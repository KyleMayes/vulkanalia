<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rendering and presentation - Vulkan Tutorial (Rust)</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A Vulkan tutorial for Rust.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../overview.html"><strong aria-hidden="true">2.</strong> Overview</a></li><li class="chapter-item expanded "><a href="../development_environment.html"><strong aria-hidden="true">3.</strong> Development environment</a></li><li class="chapter-item expanded "><a href="../faq.html"><strong aria-hidden="true">4.</strong> FAQ</a></li><li class="chapter-item expanded affix "><li class="part-title">Setup</li><li class="chapter-item expanded "><a href="../setup/base_code.html"><strong aria-hidden="true">5.</strong> Base code</a></li><li class="chapter-item expanded "><a href="../setup/instance.html"><strong aria-hidden="true">6.</strong> Instance</a></li><li class="chapter-item expanded "><a href="../setup/validation_layers.html"><strong aria-hidden="true">7.</strong> Validation layers</a></li><li class="chapter-item expanded "><a href="../setup/physical_devices_and_queue_families.html"><strong aria-hidden="true">8.</strong> Physical devices and queue families</a></li><li class="chapter-item expanded "><a href="../setup/logical_device_and_queues.html"><strong aria-hidden="true">9.</strong> Logical device and queues</a></li><li class="chapter-item expanded affix "><li class="part-title">Presentation</li><li class="chapter-item expanded "><a href="../presentation/window_surface.html"><strong aria-hidden="true">10.</strong> Window surface</a></li><li class="chapter-item expanded "><a href="../presentation/swapchain.html"><strong aria-hidden="true">11.</strong> Swapchain</a></li><li class="chapter-item expanded "><a href="../presentation/image_views.html"><strong aria-hidden="true">12.</strong> Image views</a></li><li class="chapter-item expanded affix "><li class="part-title">Pipeline</li><li class="chapter-item expanded "><a href="../pipeline/introduction.html"><strong aria-hidden="true">13.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../pipeline/shader_modules.html"><strong aria-hidden="true">14.</strong> Shader modules</a></li><li class="chapter-item expanded "><a href="../pipeline/fixed_functions.html"><strong aria-hidden="true">15.</strong> Fixed functions</a></li><li class="chapter-item expanded "><a href="../pipeline/render_passes.html"><strong aria-hidden="true">16.</strong> Render passes</a></li><li class="chapter-item expanded "><a href="../pipeline/conclusion.html"><strong aria-hidden="true">17.</strong> Conclusion</a></li><li class="chapter-item expanded affix "><li class="part-title">Drawing</li><li class="chapter-item expanded "><a href="../drawing/framebuffers.html"><strong aria-hidden="true">18.</strong> Framebuffers</a></li><li class="chapter-item expanded "><a href="../drawing/command_buffers.html"><strong aria-hidden="true">19.</strong> Command buffers</a></li><li class="chapter-item expanded "><a href="../drawing/rendering_and_presentation.html" class="active"><strong aria-hidden="true">20.</strong> Rendering and presentation</a></li><li class="chapter-item expanded affix "><li class="part-title">Swapchain</li><li class="chapter-item expanded "><a href="../swapchain/recreation.html"><strong aria-hidden="true">21.</strong> Recreation</a></li><li class="chapter-item expanded affix "><li class="part-title">Vertex buffers</li><li class="chapter-item expanded "><a href="../vertex/vertex_input_description.html"><strong aria-hidden="true">22.</strong> Vertex input description</a></li><li class="chapter-item expanded "><a href="../vertex/vertex_buffer_creation.html"><strong aria-hidden="true">23.</strong> Vertex buffer creation</a></li><li class="chapter-item expanded "><a href="../vertex/staging_buffer.html"><strong aria-hidden="true">24.</strong> Staging buffer</a></li><li class="chapter-item expanded "><a href="../vertex/index_buffer.html"><strong aria-hidden="true">25.</strong> Index buffer</a></li><li class="chapter-item expanded affix "><li class="part-title">Uniform buffers</li><li class="chapter-item expanded "><a href="../uniform/descriptor_set_layout_and_buffer.html"><strong aria-hidden="true">26.</strong> Descriptor set layout and buffer</a></li><li class="chapter-item expanded "><a href="../uniform/descriptor_pool_and_sets.html"><strong aria-hidden="true">27.</strong> Descriptor pool and sets</a></li><li class="chapter-item expanded affix "><li class="part-title">Texture mapping</li><li class="chapter-item expanded "><a href="../texture/images.html"><strong aria-hidden="true">28.</strong> Images</a></li><li class="chapter-item expanded "><a href="../texture/image_view_and_sampler.html"><strong aria-hidden="true">29.</strong> Image view and sampler</a></li><li class="chapter-item expanded "><a href="../texture/combined_image_sampler.html"><strong aria-hidden="true">30.</strong> Combined image sampler</a></li><li class="chapter-item expanded affix "><li class="part-title">Model</li><li class="chapter-item expanded "><a href="../model/depth_buffering.html"><strong aria-hidden="true">31.</strong> Depth buffering</a></li><li class="chapter-item expanded "><a href="../model/loading_models.html"><strong aria-hidden="true">32.</strong> Loading models</a></li><li class="chapter-item expanded affix "><li class="part-title">Rendering quality</li><li class="chapter-item expanded "><a href="../quality/generating_mipmaps.html"><strong aria-hidden="true">33.</strong> Generating mipmaps</a></li><li class="chapter-item expanded "><a href="../quality/multisampling.html"><strong aria-hidden="true">34.</strong> Multisampling</a></li><li class="chapter-item expanded affix "><li class="part-title">Dynamic scenes</li><li class="chapter-item expanded "><a href="../dynamic/push_constants.html"><strong aria-hidden="true">35.</strong> Push constants</a></li><li class="chapter-item expanded "><a href="../dynamic/recycling_command_buffers.html"><strong aria-hidden="true">36.</strong> Recycling command buffers</a></li><li class="chapter-item expanded "><a href="../dynamic/secondary_command_buffers.html"><strong aria-hidden="true">37.</strong> Secondary command buffers</a></li><li class="chapter-item expanded affix "><li class="part-title">Conclusion</li><li class="chapter-item expanded "><a href="../conclusion.html"><strong aria-hidden="true">38.</strong> Conclusion</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Vulkan Tutorial (Rust)</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/KyleMayes/vulkanalia" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rendering-and-presentation"><a class="header" href="#rendering-and-presentation">Rendering and presentation</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/15_hello_triangle.rs">main.rs</a></p>
<p>This is the chapter where everything is going to come together. We're going to implement the <code>App::render</code> function that will be called from the main loop to put the triangle on the screen.</p>
<h2 id="synchronization"><a class="header" href="#synchronization">Synchronization</a></h2>
<p>The <code>App::render</code> function will perform the following operations:</p>
<ul>
<li>Acquire an image from the swapchain</li>
<li>Execute the command buffer with that image as attachment in the framebuffer</li>
<li>Return the image to the swapchain for presentation</li>
</ul>
<p>Each of these events is set in motion using a single function call, but they are executed asynchronously. The function calls will return before the operations are actually finished and the order of execution is also undefined. That is unfortunate, because each of the operations depends on the previous one finishing.</p>
<p>There are two ways of synchronizing swapchain events: fences and semaphores. They're both objects that can be used for coordinating operations by having one operation signal and another operation wait for a fence or semaphore to go from the unsignaled to signaled state.</p>
<p>The difference is that the state of fences can be accessed from your program using calls like <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.wait_for_fences"><code class="hljs">wait_for_fences</code></a> and semaphores cannot be. Fences are mainly designed to synchronize your application itself with rendering operation, whereas semaphores are used to synchronize operations within or across command queues. We want to synchronize the queue operations of draw commands and presentation, which makes semaphores the best fit.</p>
<h2 id="semaphores"><a class="header" href="#semaphores">Semaphores</a></h2>
<p>We'll need one semaphore to signal that an image has been acquired and is ready for rendering, and another one to signal that rendering has finished and presentation can happen. Create two <code>AppData</code> fields to store these semaphore objects:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    image_available_semaphore: vk::Semaphore,
    render_finished_semaphore: vk::Semaphore,
}
</code></pre>
<p>To create the semaphores, we'll add the last <code>create</code> function for this part of the tutorial, <code>create_sync_objects</code>:</p>
<pre><code class="language-rust noplaypen">impl App {
    unsafe fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        // ...
        create_command_buffers(&amp;device, &amp;mut data)?;
        create_sync_objects(&amp;device, &amp;mut data)?;
        // ...
    }
}

unsafe fn create_sync_objects(device: &amp;Device, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    Ok(())
}
</code></pre>
<p>Creating semaphores requires filling in the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SemaphoreCreateInfo.html"><code class="hljs">vk::SemaphoreCreateInfo</code></a>, but in the current version of the API it doesn't actually have any required fields.</p>
<pre><code class="language-rust noplaypen">unsafe fn create_sync_objects(device: &amp;Device, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    let semaphore_info = vk::SemaphoreCreateInfo::builder();

    Ok(())
}
</code></pre>
<p>Future versions of the Vulkan API or extensions may add functionality for the <code>flags</code> and <code>p_next</code> parameters like it does for the other structures. Creating the semaphores follows the familiar pattern:</p>
<pre><code class="language-rust noplaypen">data.image_available_semaphore = device.create_semaphore(&amp;semaphore_info, None)?;
data.render_finished_semaphore = device.create_semaphore(&amp;semaphore_info, None)?;
</code></pre>
<p>The semaphores should be cleaned up at the end of the program, when all commands have finished and no more synchronization is necessary:</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy(&amp;mut self) {
    self.device.destroy_semaphore(self.data.render_finished_semaphore, None);
    self.device.destroy_semaphore(self.data.image_available_semaphore, None);
    // ...
}
</code></pre>
<h2 id="acquiring-an-image-from-the-swapchain"><a class="header" href="#acquiring-an-image-from-the-swapchain">Acquiring an image from the swapchain</a></h2>
<p>As mentioned before, the first thing we need to do in the <code>App::render</code> function is acquire an image from the swapchain. Recall that the swapchain is an extension feature, so we must use a function with the <code>*_khr</code> naming convention:</p>
<pre><code class="language-rust noplaypen">unsafe fn render(&amp;mut self, window: &amp;Window) -&gt; Result&lt;()&gt; {
    let image_index = self
        .device
        .acquire_next_image_khr(
            self.data.swapchain,
            u64::MAX,
            self.data.image_available_semaphore,
            vk::Fence::null(),
        )?
        .0 as usize;

    Ok(())
}
</code></pre>
<p>The first parameter of <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.KhrSwapchainExtension.html#method.acquire_next_image_khr"><code class="hljs">acquire_next_image_khr</code></a> is the swapchain from which we wish to acquire an image. The second parameter specifies a timeout in nanoseconds for an image to become available. Using the maximum value of a 64 bit unsigned integer disables the timeout.</p>
<p>The next two parameters specify synchronization objects that are to be signaled when the presentation engine is finished using the image. That's the point in time where we can start drawing to it. It is possible to specify a semaphore, fence or both. We're going to use our <code>image_available_semaphore</code> for that purpose here.</p>
<p>This function returns the index of the swapchain image that has become available. The index refers to the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Image.html"><code class="hljs">vk::Image</code></a> in our <code>swapchain_images</code> array. We're going to use that index to pick the right command buffer.</p>
<h2 id="submitting-the-command-buffer"><a class="header" href="#submitting-the-command-buffer">Submitting the command buffer</a></h2>
<p>Queue submission and synchronization is configured through parameters in the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SubmitInfo.html"><code class="hljs">vk::SubmitInfo</code></a> structure.</p>
<pre><code class="language-rust noplaypen">let wait_semaphores = &amp;[self.data.image_available_semaphore];
let wait_stages = &amp;[vk::PipelineStageFlags::COLOR_ATTACHMENT_OUTPUT];
let command_buffers = &amp;[self.data.command_buffers[image_index as usize]];
let signal_semaphores = &amp;[self.data.render_finished_semaphore];
let submit_info = vk::SubmitInfo::builder()
    .wait_semaphores(wait_semaphores)
    .wait_dst_stage_mask(wait_stages)
    .command_buffers(command_buffers)
    .signal_semaphores(signal_semaphores);
</code></pre>
<p>The first two parameters, <code>wait_semaphores</code> and <code>wait_dst_stage_mask</code>, specify which semaphores to wait on before execution begins and in which stage(s) of the pipeline to wait. We want to wait with writing colors to the image until it's available, so we're specifying the stage of the graphics pipeline that writes to the color attachment. That means that theoretically the implementation can already start executing our vertex shader and such while the image is not yet available. Each entry in the <code>wait_stages</code> array corresponds to the semaphore with the same index in <code>wait_semaphores</code>.</p>
<p>The next parameter, <code>command_buffers</code>, specifies which command buffers to actually submit for execution. As mentioned earlier, we should submit the command buffer that binds the swapchain image we just acquired as color attachment.</p>
<p>Lastly <code>signal_semaphores</code> specifies which semaphores to signal once the command buffer(s) have finished execution. In our case we're using the <code>render_finished_semaphore</code> for that purpose.</p>
<pre><code class="language-rust noplaypen">self.device.queue_submit(
    self.data.graphics_queue, &amp;[submit_info], vk::Fence::null())?;
</code></pre>
<p>We can now submit the command buffer to the graphics queue using <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.queue_submit"><code class="hljs">queue_submit</code></a>. The function takes an array of <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SubmitInfo.html"><code class="hljs">vk::SubmitInfo</code></a> structures as argument for efficiency when the workload is much larger. The last parameter references an optional fence that will be signaled when the command buffers finish execution. We're using semaphores for synchronization, so we'll just pass a <code>vk::Fence::null()</code>.</p>
<h2 id="subpass-dependencies"><a class="header" href="#subpass-dependencies">Subpass dependencies</a></h2>
<p>Remember that the subpasses in a render pass automatically take care of image layout transitions. These transitions are controlled by <em>subpass dependencies</em>, which specify memory and execution dependencies between subpasses. We have only a single subpass right now, but the operations right before and right after this subpass also count as implicit &quot;subpasses&quot;.</p>
<p>There are two built-in dependencies that take care of the transition at the start of the render pass and at the end of the render pass, but the former does not occur at the right time. It assumes that the transition occurs at the start of the pipeline, but we haven't acquired the image yet at that point! There are two ways to deal with this problem. We could change the <code>wait_stages</code> for the <code>image_available_semaphore</code> to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PipelineStageFlags.html#associatedconstant.TOP_OF_PIPE"><code class="hljs">vk::PipelineStageFlags::TOP_OF_PIPE</code></a> to ensure that the render passes don't begin until the image is available, or we can make the render pass wait for the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PipelineStageFlags.html#associatedconstant.COLOR_ATTACHMENT_OUTPUT"><code class="hljs">vk::PipelineStageFlags::COLOR_ATTACHMENT_OUTPUT</code></a> stage. I've decided to go with the second option here, because it's a good excuse to have a look at subpass dependencies and how they work.</p>
<p>Subpass dependencies are specified in <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SubpassDependency.html"><code class="hljs">vk::SubpassDependency</code></a> structs. Go to our <code>create_render_pass</code> function and add one:</p>
<pre><code class="language-rust noplaypen">let dependency = vk::SubpassDependency::builder()
    .src_subpass(vk::SUBPASS_EXTERNAL)
    .dst_subpass(0)
    // continued...
</code></pre>
<p>The first two fields specify the indices of the dependency and the dependent subpass. The special value <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/constant.SUBPASS_EXTERNAL.html"><code class="hljs">vk::SUBPASS_EXTERNAL</code></a> refers to the implicit subpass before or after the render pass depending on whether it is specified in <code>src_subpass</code> or <code>dst_subpass</code>. The index <code>0</code> refers to our subpass, which is the first and only one. The <code>dst_subpass</code> must always be higher than <code>src_subpass</code> to prevent cycles in the dependency graph (unless one of the subpasses is <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/constant.SUBPASS_EXTERNAL.html"><code class="hljs">vk::SUBPASS_EXTERNAL</code></a>).</p>
<pre><code class="language-rust noplaypen">    .src_stage_mask(vk::PipelineStageFlags::COLOR_ATTACHMENT_OUTPUT)
    .src_access_mask(vk::AccessFlags::empty())
</code></pre>
<p>The next two fields specify the operations to wait on and the stages in which these operations occur. We need to wait for the swapchain to finish reading from the image before we can access it. This can be accomplished by waiting on the color attachment output stage itself.</p>
<pre><code class="language-rust noplaypen">    .dst_stage_mask(vk::PipelineStageFlags::COLOR_ATTACHMENT_OUTPUT)
    .dst_access_mask(vk::AccessFlags::COLOR_ATTACHMENT_WRITE);
</code></pre>
<p>The operations that should wait on this are in the color attachment stage and involve the writing of the color attachment. These settings will prevent the transition from happening until it's actually necessary (and allowed): when we want to start writing colors to it.</p>
<pre><code class="language-rust noplaypen">let attachments = &amp;[color_attachment];
let subpasses = &amp;[subpass];
let dependencies = &amp;[dependency];
let info = vk::RenderPassCreateInfo::builder()
    .attachments(attachments)
    .subpasses(subpasses)
    .dependencies(dependencies);
</code></pre>
<p>The <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.RenderPassCreateInfo.html"><code class="hljs">vk::RenderPassCreateInfo</code></a> struct has a field to specify an array of dependencies.</p>
<h2 id="presentation"><a class="header" href="#presentation">Presentation</a></h2>
<p>The last step of drawing a frame is submitting the result back to the swapchain to have it eventually show up on the screen. Presentation is configured through a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PresentInfoKHR.html"><code class="hljs">vk::PresentInfoKHR</code></a> structure at the end of the <code>App::render</code> function.</p>
<pre><code class="language-rust noplaypen">let swapchains = &amp;[self.data.swapchain];
let image_indices = &amp;[image_index as u32];
let present_info = vk::PresentInfoKHR::builder()
    .wait_semaphores(signal_semaphores)
    .swapchains(swapchains)
    .image_indices(image_indices);
</code></pre>
<p>The first parameter specifies which semaphores to wait on before presentation can happen, just like <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SubmitInfo.html"><code class="hljs">vk::SubmitInfo</code></a>.</p>
<p>The next two parameters specify the swapchains to present images to and the index of the image for each swapchain. This will almost always be a single one.</p>
<p>There is one last optional parameter called <code>results</code>. It allows you to specify an array of <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Result.html"><code class="hljs">vk::Result</code></a> values to check for every individual swapchain if presentation was successful. It's not necessary if you're only using a single swapchain, because you can simply use the return value of the present function.</p>
<pre><code class="language-rust noplaypen">self.device.queue_present_khr(self.data.present_queue, &amp;present_info)?;
</code></pre>
<p>The <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.KhrSwapchainExtension.html#method.queue_present_khr"><code class="hljs">queue_present_khr</code></a> function submits the request to present an image to the swapchain. We'll modify the error handling for both <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.KhrSwapchainExtension.html#method.acquire_next_image_khr"><code class="hljs">acquire_next_image_khr</code></a> and <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.KhrSwapchainExtension.html#method.queue_present_khr"><code class="hljs">queue_present_khr</code></a> in the next chapter, because their failure does not necessarily mean that the program should terminate, unlike the functions we've seen so far.</p>
<p>If you did everything correctly up to this point, then you should now see something resembling the following when you run your program:</p>
<p><img src="../images/triangle.png" alt="" /></p>
<blockquote>
<p>This colored triangle may look a bit different from the one you're used to seeing in graphics tutorials. That's because this tutorial lets the shader interpolate in linear color space and converts to sRGB color space afterwards. See <a href="https://medium.com/@heypete/hello-triangle-meet-swift-and-wide-color-6f9e246616d9">this blog post</a> for a discussion of the difference.</p>
</blockquote>
<p>Yay! Unfortunately, you'll see that when validation layers are enabled, the program crashes as soon as you close it. The messages printed to the terminal from <code>debug_callback</code> tell us why:</p>
<p><img src="../images/semaphore_in_use.png" alt="" /></p>
<p>Remember that all of the operations in <code>App::render</code> are asynchronous. That means that when we call <code>App::destroy</code> before exiting the loop in <code>main</code>, drawing and presentation operations may still be going on. Cleaning up resources while that is happening is a bad idea.</p>
<p>To fix that problem, we should wait for the logical device to finish operations using <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.device_wait_idle"><code class="hljs">device_wait_idle</code></a> before calling <code>App::destroy</code>:</p>
<pre><code class="language-rust noplaypen">Event::WindowEvent { event: WindowEvent::CloseRequested, .. } =&gt; {
    destroying = true;
    *control_flow = ControlFlow::Exit;
    unsafe { app.device.device_wait_idle().unwrap(); }
    unsafe { app.destroy(); }
}
</code></pre>
<p>You can also wait for operations in a specific command queue to be finished with <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.queue_wait_idle"><code class="hljs">queue_wait_idle</code></a>. These functions can be used as a very rudimentary way to perform synchronization. You'll see that the program no longer crashes when closing the window (though you will see some errors related to synchronization if you have the validation layers enabled).</p>
<h2 id="frames-in-flight"><a class="header" href="#frames-in-flight">Frames in flight</a></h2>
<p>If you run your application with validation layers enabled now you may either get errors or notice that the memory usage slowly grows. The reason for this is that the application is rapidly submitting work in the <code>App::render</code> function, but doesn't actually check if any of it finishes. If the CPU is submitting work faster than the GPU can keep up with then the queue will slowly fill up with work. Worse, even, is that we are reusing the <code>image_available_semaphore</code> and <code>render_finished_semaphore</code> semaphores, along with the command buffers, for multiple frames at the same time!</p>
<p>The easy way to solve this is to wait for work to finish right after submitting it, for example by using <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.queue_wait_idle"><code class="hljs">queue_wait_idle</code></a> (note: don't actually make this change):</p>
<pre><code class="language-rust noplaypen">unsafe fn render(&amp;mut self, window: &amp;Window) -&gt; Result&lt;()&gt; {
    // ...

    self.device.queue_present_khr(self.data.present_queue, &amp;present_info)?;
    self.device.queue_wait_idle(self.data.present_queue)?;

    Ok(())
}
</code></pre>
<p>However, we are likely not optimally using the GPU in this way, because the whole graphics pipeline is only used for one frame at a time right now. The stages that the current frame has already progressed through are idle and could already be used for a next frame. We will now extend our application to allow for multiple frames to be <em>in-flight</em> while still bounding the amount of work that piles up.</p>
<p>Start by adding a constant at the top of the program that defines how many frames should be processed concurrently:</p>
<pre><code class="language-rust noplaypen">const MAX_FRAMES_IN_FLIGHT: usize = 2;
</code></pre>
<p>Each frame should have its own set of semaphores in <code>AppData</code>:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    image_available_semaphores: Vec&lt;vk::Semaphore&gt;,
    render_finished_semaphores: Vec&lt;vk::Semaphore&gt;,
}
</code></pre>
<p>The <code>create_sync_objects</code> function should be changed to create all of these:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_sync_objects(device: &amp;Device, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    let semaphore_info = vk::SemaphoreCreateInfo::builder();

    for _ in 0..MAX_FRAMES_IN_FLIGHT {
        data.image_available_semaphores
            .push(device.create_semaphore(&amp;semaphore_info, None)?);
        data.render_finished_semaphores
            .push(device.create_semaphore(&amp;semaphore_info, None)?);
    }

    Ok(())
}
</code></pre>
<p>Similarly, they should also all be cleaned up:</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy(&amp;mut self) {
    self.data.render_finished_semaphores
        .iter()
        .for_each(|s| self.device.destroy_semaphore(*s, None));
    self.data.image_available_semaphores
        .iter()
        .for_each(|s| self.device.destroy_semaphore(*s, None));
    // ...
}
</code></pre>
<p>To use the right pair of semaphores every time, we need to keep track of the current frame. We will use a frame index for that purpose which we'll add to <code>App</code> (initialize it to <code>0</code> in <code>App::create</code>):</p>
<pre><code class="language-rust noplaypen">struct App {
    // ...
    frame: usize,
}
</code></pre>
<p>The <code>App::render</code> function can now be modified to use the right objects:</p>
<pre><code class="language-rust noplaypen">unsafe fn render(&amp;mut self, window: &amp;Window) -&gt; Result&lt;()&gt; {
    let image_index = self
        .device
        .acquire_next_image_khr(
            self.data.swapchain,
            u64::MAX,
            self.data.image_available_semaphores[self.frame],
            vk::Fence::null(),
        )?
        .0 as usize;

    // ...

    let wait_semaphores = &amp;[self.data.image_available_semaphores[self.frame]];

    // ...

    let signal_semaphores = &amp;[self.data.render_finished_semaphores[self.frame]];

    // ...

    Ok(())
}
</code></pre>
<p>Of course, we shouldn't forget to advance to the next frame every time:</p>
<pre><code class="language-rust noplaypen">unsafe fn render(&amp;mut self, window: &amp;Window) -&gt; Result&lt;()&gt; {
    // ...

    self.frame = (self.frame + 1) % MAX_FRAMES_IN_FLIGHT;

    Ok(())
}
</code></pre>
<p>By using the modulo (%) operator, we ensure that the frame index loops around after every <code>MAX_FRAMES_IN_FLIGHT</code> enqueued frames.</p>
<p>Although we've now set up the required objects to facilitate processing of multiple frames simultaneously, we still don't actually prevent more than <code>MAX_FRAMES_IN_FLIGHT</code> from being submitted. Right now there is only GPU-GPU synchronization and no CPU-GPU synchronization going on to keep track of how the work is going. We may be using the frame #0 objects while frame #0 is still in-flight!</p>
<p>To perform CPU-GPU synchronization, Vulkan offers a second type of synchronization primitive called <em>fences</em>. Fences are similar to semaphores in the sense that they can be signaled and waited for, but this time we actually wait for them in our own code. We'll first create a fence for each frame in <code>AppData</code>:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    in_flight_fences: Vec&lt;vk::Fence&gt;,
}
</code></pre>
<p>We'll create the fences together with the semaphores in the <code>create_sync_objects</code> function:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_sync_objects(device: &amp;Device, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    let semaphore_info = vk::SemaphoreCreateInfo::builder();
    let fence_info = vk::FenceCreateInfo::builder();

    for _ in 0..MAX_FRAMES_IN_FLIGHT {
        data.image_available_semaphores
            .push(device.create_semaphore(&amp;semaphore_info, None)?);
        data.render_finished_semaphores
            .push(device.create_semaphore(&amp;semaphore_info, None)?);

        data.in_flight_fences.push(device.create_fence(&amp;fence_info, None)?);
    }

    Ok(())
}
</code></pre>
<p>The creation of fences (<a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Fence.html"><code class="hljs">vk::Fence</code></a>) is very similar to the creation of semaphores. Also make sure to clean up the fences in <code>App::destroy</code>:</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy(&amp;mut self) {
    self.data.in_flight_fences
        .iter()
        .for_each(|f| self.device.destroy_fence(*f, None));
    // ...
}
</code></pre>
<p>We will now change <code>App::render</code> to use the fences for synchronization. The <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.queue_submit"><code class="hljs">queue_submit</code></a> call includes an optional parameter to pass a fence that should be signaled when the command buffer finishes executing. We can use this to signal that a frame has finished.</p>
<pre><code class="language-rust noplaypen">unsafe fn render(&amp;mut self, window: &amp;Window) -&gt; Result&lt;()&gt; {
    // ...

    self.device.queue_submit(
        self.data.graphics_queue,
        &amp;[submit_info],
        self.data.in_flight_fences[self.frame],
    )?;

    // ...
}
</code></pre>
<p>Now the only thing remaining is to change the beginning of <code>App::render</code> to wait for the frame to be finished:</p>
<pre><code class="language-rust noplaypen">unsafe fn render(&amp;mut self, window: &amp;Window) -&gt; Result&lt;()&gt; {
    self.device.wait_for_fences(
        &amp;[self.data.in_flight_fences[self.frame]],
        true,
        u64::MAX,
    )?;

    self.device.reset_fences(&amp;[self.data.in_flight_fences[self.frame]])?;

    // ...
}
</code></pre>
<p>The <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.wait_for_fences"><code class="hljs">wait_for_fences</code></a> function takes an array of fences and waits for either any or all of them to be signaled before returning. The <code>true</code> we pass here indicates that we want to wait for all fences, but in the case of a single one it obviously doesn't matter. Just like <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.KhrSwapchainExtension.html#method.acquire_next_image_khr"><code class="hljs">acquire_next_image_khr</code></a> this function also takes a timeout. Unlike the semaphores, we manually need to restore the fence to the unsignaled state by resetting it with the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.reset_fences"><code class="hljs">reset_fences</code></a> call.</p>
<p>If you run the program now, you'll notice something something strange. The application no longer seems to be rendering anything and might even be frozen.</p>
<p>That means that we're waiting for a fence that has not been submitted. The problem here is that, by default, fences are created in the unsignaled state. That means that <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.wait_for_fences"><code class="hljs">wait_for_fences</code></a> will wait forever if we haven't used the fence before. To solve that, we can change the fence creation to initialize it in the signaled state as if we had rendered an initial frame that finished:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_sync_objects(device: &amp;Device, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    // ...

    let fence_info = vk::FenceCreateInfo::builder()
        .flags(vk::FenceCreateFlags::SIGNALED);

    // ...
}
</code></pre>
<p>The memory leak is gone now, but the program is not quite working correctly yet. If <code>MAX_FRAMES_IN_FLIGHT</code> is higher than the number of swapchain images or <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.KhrSwapchainExtension.html#method.acquire_next_image_khr"><code class="hljs">acquire_next_image_khr</code></a> returns images out-of-order then it's possible that we may start rendering to a swapchain image that is already <em>in flight</em>. To avoid this, we need to track for each swapchain image if a frame in flight is currently using it. This mapping will refer to frames in flight by their fences so we'll immediately have a synchronization object to wait on before a new frame can use that image.</p>
<p>First add a new list called <code>images_in_flight</code> to <code>AppData</code> to track this:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    in_flight_fences: Vec&lt;vk::Fence&gt;,
    images_in_flight: Vec&lt;vk::Fence&gt;,
}
</code></pre>
<p>Prepare it in <code>create_sync_objects</code>:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_sync_objects(device: &amp;Device, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    // ...

    data.images_in_flight = data.swapchain_images
        .iter()
        .map(|_| vk::Fence::null())
        .collect();

    Ok(())
}
</code></pre>
<p>Initially not a single frame is using an image so we explicitly initialize it to <em>no fence</em>. Now we'll modify <code>App::render</code> to wait on any previous frame that is using the image that we've just been assigned for the new frame:</p>
<pre><code class="language-rust noplaypen">unsafe fn render(&amp;mut self, window: &amp;Window) -&gt; Result&lt;()&gt; {
    // ...

    let image_index = self
        .device
        .acquire_next_image_khr(
            self.data.swapchain,
            u64::MAX,
            self.data.image_available_semaphores[self.frame],
            vk::Fence::null(),
        )?
        .0 as usize;

    if !self.data.images_in_flight[image_index as usize].is_null() {
        self.device.wait_for_fences(
            &amp;[self.data.images_in_flight[image_index as usize]],
            true,
            u64::MAX,
        )?;
    }

    self.data.images_in_flight[image_index as usize] =
        self.data.in_flight_fences[self.frame];

    // ...
}
</code></pre>
<p>Because we now have more calls to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.wait_for_fences"><code class="hljs">wait_for_fences</code></a>, the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.reset_fences"><code class="hljs">reset_fences</code></a> call should be <strong>moved</strong>. It's best to simply call it right before actually using the fence:</p>
<pre><code class="language-rust noplaypen">unsafe fn render(&amp;mut self, window: &amp;Window) -&gt; Result&lt;()&gt; {
    // ...

    self.device.reset_fences(&amp;[self.data.in_flight_fences[self.frame]])?;

    self.device.queue_submit(
        self.data.graphics_queue,
        &amp;[submit_info],
        self.data.in_flight_fences[self.frame],
    )?;

    // ...
}
</code></pre>
<p>We've now implemented all the needed synchronization to ensure that there are no more than two frames of work enqueued and that these frames are not accidentally using the same image. Note that it is fine for other parts of the code, like the final cleanup, to rely on more rough synchronization like <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.device_wait_idle"><code class="hljs">device_wait_idle</code></a>. You should decide on which approach to use based on performance requirements.</p>
<p>To learn more about synchronization through examples, have a look at <a href="https://github.com/KhronosGroup/Vulkan-Docs/wiki/Synchronization-Examples#swapchain-image-acquire-and-present">this extensive overview</a> by Khronos.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>A little over 600 (non-empty) lines of code later, we've finally gotten to the stage of seeing something pop up on the screen! Bootstrapping a Vulkan program is definitely a lot of work, but the take-away message is that Vulkan gives you an immense amount of control through its explicitness. I recommend you to take some time now to reread the code and build a mental model of the purpose of all of the Vulkan objects in the program and how they relate to each other. We'll be building on top of that knowledge to extend the functionality of the program from this point on.</p>
<p>In the next chapter we'll deal with one more small thing that is required for a well-behaved Vulkan program.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../drawing/command_buffers.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../swapchain/recreation.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../drawing/command_buffers.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../swapchain/recreation.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>



        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
