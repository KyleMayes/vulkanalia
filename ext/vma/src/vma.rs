/* automatically generated by rust-bindgen 0.71.1 */

#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(rustdoc::broken_intra_doc_links)]
use vulkanalia::vk::*;

#[repr(i32)]
#[doc = "Flags for created #VmaAllocator."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VmaAllocatorCreateFlagBits {
    #[doc = "Allocator and all objects created from it will not be synchronized internally, so you must guarantee they are used from only one thread at a time or synchronized externally by you.\n\nUsing this flag may increase performance because internal mutexes are not used."]
    EXTERNALLY_SYNCHRONIZED_BIT = 1,
    #[doc = "Enables usage of VK_KHR_dedicated_allocation extension.\n\nThe flag works only if VmaAllocatorCreateInfo::vulkanApiVersion `== VK_API_VERSION_1_0`.\nWhen it is `VK_API_VERSION_1_1`, the flag is ignored because the extension has been promoted to Vulkan 1.1.\n\nUsing this extension will automatically allocate dedicated blocks of memory for\nsome buffers and images instead of suballocating place for them out of bigger\nmemory blocks (as if you explicitly used #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT\nflag) when it is recommended by the driver. It may improve performance on some\nGPUs.\n\nYou may set this flag only if you found out that following device extensions are\nsupported, you enabled them while creating Vulkan device passed as\nVmaAllocatorCreateInfo::device, and you want them to be used internally by this\nlibrary:\n\n- VK_KHR_get_memory_requirements2 (device extension)\n- VK_KHR_dedicated_allocation (device extension)\n\nWhen this flag is set, you can experience following warnings reported by Vulkan\nvalidation layer. You can ignore them.\n\n> vkBindBufferMemory(): Binding memory to buffer 0x2d but vkGetBufferMemoryRequirements() has not been called on that buffer."]
    KHR_DEDICATED_ALLOCATION_BIT = 2,
    #[doc = "Enables usage of VK_KHR_bind_memory2 extension.\n\nThe flag works only if VmaAllocatorCreateInfo::vulkanApiVersion `== VK_API_VERSION_1_0`.\nWhen it is `VK_API_VERSION_1_1`, the flag is ignored because the extension has been promoted to Vulkan 1.1.\n\nYou may set this flag only if you found out that this device extension is supported,\nyou enabled it while creating Vulkan device passed as VmaAllocatorCreateInfo::device,\nand you want it to be used internally by this library.\n\nThe extension provides functions `vkBindBufferMemory2KHR` and `vkBindImageMemory2KHR`,\nwhich allow to pass a chain of `pNext` structures while binding.\nThis flag is required if you use `pNext` parameter in vmaBindBufferMemory2() or vmaBindImageMemory2()."]
    KHR_BIND_MEMORY2_BIT = 4,
    #[doc = "Enables usage of VK_EXT_memory_budget extension.\n\nYou may set this flag only if you found out that this device extension is supported,\nyou enabled it while creating Vulkan device passed as VmaAllocatorCreateInfo::device,\nand you want it to be used internally by this library, along with another instance extension\nVK_KHR_get_physical_device_properties2, which is required by it (or Vulkan 1.1, where this extension is promoted).\n\nThe extension provides query for current memory usage and budget, which will probably\nbe more accurate than an estimation used by the library otherwise."]
    EXT_MEMORY_BUDGET_BIT = 8,
    #[doc = "Enables usage of VK_AMD_device_coherent_memory extension.\n\nYou may set this flag only if you:\n\n- found out that this device extension is supported and enabled it while creating Vulkan device passed as VmaAllocatorCreateInfo::device,\n- checked that `VkPhysicalDeviceCoherentMemoryFeaturesAMD::deviceCoherentMemory` is true and set it while creating the Vulkan device,\n- want it to be used internally by this library.\n\nThe extension and accompanying device feature provide access to memory types with\n`VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD` and `VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD` flags.\nThey are useful mostly for writing breadcrumb markers - a common method for debugging GPU crash/hang/TDR.\n\nWhen the extension is not enabled, such memory types are still enumerated, but their usage is illegal.\nTo protect from this error, if you don't create the allocator with this flag, it will refuse to allocate any memory or create a custom pool in such memory type,\nreturning `VK_ERROR_FEATURE_NOT_PRESENT`."]
    AMD_DEVICE_COHERENT_MEMORY_BIT = 16,
    #[doc = "Enables usage of \"buffer device address\" feature, which allows you to use function\n`vkGetBufferDeviceAddress*` to get raw GPU pointer to a buffer and pass it for usage inside a shader.\n\nYou may set this flag only if you:\n\n1. (For Vulkan version < 1.2) Found as available and enabled device extension\nVK_KHR_buffer_device_address.\nThis extension is promoted to core Vulkan 1.2.\n2. Found as available and enabled device feature `VkPhysicalDeviceBufferDeviceAddressFeatures::bufferDeviceAddress`.\n\nWhen this flag is set, you can create buffers with `VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT` using VMA.\nThe library automatically adds `VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT` to\nallocated memory blocks wherever it might be needed.\n\nFor more information, see documentation chapter enabling_buffer_device_address."]
    BUFFER_DEVICE_ADDRESS_BIT = 32,
    #[doc = "Enables usage of VK_EXT_memory_priority extension in the library.\n\nYou may set this flag only if you found available and enabled this device extension,\nalong with `VkPhysicalDeviceMemoryPriorityFeaturesEXT::memoryPriority == VK_TRUE`,\nwhile creating Vulkan device passed as VmaAllocatorCreateInfo::device.\n\nWhen this flag is used, VmaAllocationCreateInfo::priority and VmaPoolCreateInfo::priority\nare used to set priorities of allocated Vulkan memory. Without it, these variables are ignored.\n\nA priority must be a floating-point value between 0 and 1, indicating the priority of the allocation relative to other memory allocations.\nLarger values are higher priority. The granularity of the priorities is implementation-dependent.\nIt is automatically passed to every call to `vkAllocateMemory` done by the library using structure `VkMemoryPriorityAllocateInfoEXT`.\nThe value to be used for default priority is 0.5.\nFor more details, see the documentation of the VK_EXT_memory_priority extension."]
    EXT_MEMORY_PRIORITY_BIT = 64,
    #[doc = "Enables usage of VK_KHR_maintenance4 extension in the library.\n\nYou may set this flag only if you found available and enabled this device extension,\nwhile creating Vulkan device passed as VmaAllocatorCreateInfo::device."]
    KHR_MAINTENANCE4_BIT = 128,
    #[doc = "Enables usage of VK_KHR_maintenance5 extension in the library.\n\nYou should set this flag if you found available and enabled this device extension,\nwhile creating Vulkan device passed as VmaAllocatorCreateInfo::device."]
    KHR_MAINTENANCE5_BIT = 256,
    #[doc = "Enables usage of VK_KHR_maintenance5 extension in the library.\n\nYou should set this flag if you found available and enabled this device extension,\nwhile creating Vulkan device passed as VmaAllocatorCreateInfo::device."]
    MAX_ENUM = 2147483647,
}
#[doc = "See #VmaAllocatorCreateFlagBits."]
pub type VmaAllocatorCreateFlags = Flags;
#[repr(i32)]
#[doc = "Intended usage of the allocated memory."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VmaMemoryUsage {
    #[doc = "No intended memory usage specified.\nUse other members of VmaAllocationCreateInfo to specify your requirements."]
    UNKNOWN = 0,
    #[doc = "> **Deprecated** Obsolete, preserved for backward compatibility.\nPrefers `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`."]
    GPU_ONLY = 1,
    #[doc = "> **Deprecated** Obsolete, preserved for backward compatibility.\nGuarantees `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` and `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT`."]
    CPU_ONLY = 2,
    #[doc = "> **Deprecated** Obsolete, preserved for backward compatibility.\nGuarantees `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT`, prefers `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`."]
    CPU_TO_GPU = 3,
    #[doc = "> **Deprecated** Obsolete, preserved for backward compatibility.\nGuarantees `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT`, prefers `VK_MEMORY_PROPERTY_HOST_CACHED_BIT`."]
    GPU_TO_CPU = 4,
    #[doc = "> **Deprecated** Obsolete, preserved for backward compatibility.\nPrefers not `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`."]
    CPU_COPY = 5,
    #[doc = "Lazily allocated GPU memory having `VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT`.\nExists mostly on mobile platforms. Using it on desktop PC or other GPUs with no such memory type present will fail the allocation.\n\nUsage: Memory for transient attachment images (color attachments, depth attachments etc.), created with `VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT`.\n\nAllocations with this usage are always created as dedicated - it implies #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT."]
    GPU_LAZILY_ALLOCATED = 6,
    #[doc = "Selects best memory type automatically.\nThis flag is recommended for most common use cases.\n\nWhen using this flag, if you want to map the allocation (using vmaMapMemory() or #VMA_ALLOCATION_CREATE_MAPPED_BIT),\nyou must pass one of the flags: #VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT or #VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT\nin VmaAllocationCreateInfo::flags.\n\nIt can be used only with functions that let the library know `VkBufferCreateInfo` or `VkImageCreateInfo`, e.g.\nvmaCreateBuffer(), vmaCreateImage(), vmaFindMemoryTypeIndexForBufferInfo(), vmaFindMemoryTypeIndexForImageInfo()\nand not with generic memory allocation functions."]
    AUTO = 7,
    #[doc = "Selects best memory type automatically with preference for GPU (device) memory.\n\nWhen using this flag, if you want to map the allocation (using vmaMapMemory() or #VMA_ALLOCATION_CREATE_MAPPED_BIT),\nyou must pass one of the flags: #VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT or #VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT\nin VmaAllocationCreateInfo::flags.\n\nIt can be used only with functions that let the library know `VkBufferCreateInfo` or `VkImageCreateInfo`, e.g.\nvmaCreateBuffer(), vmaCreateImage(), vmaFindMemoryTypeIndexForBufferInfo(), vmaFindMemoryTypeIndexForImageInfo()\nand not with generic memory allocation functions."]
    AUTO_PREFER_DEVICE = 8,
    #[doc = "Selects best memory type automatically with preference for CPU (host) memory.\n\nWhen using this flag, if you want to map the allocation (using vmaMapMemory() or #VMA_ALLOCATION_CREATE_MAPPED_BIT),\nyou must pass one of the flags: #VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT or #VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT\nin VmaAllocationCreateInfo::flags.\n\nIt can be used only with functions that let the library know `VkBufferCreateInfo` or `VkImageCreateInfo`, e.g.\nvmaCreateBuffer(), vmaCreateImage(), vmaFindMemoryTypeIndexForBufferInfo(), vmaFindMemoryTypeIndexForImageInfo()\nand not with generic memory allocation functions."]
    AUTO_PREFER_HOST = 9,
    #[doc = "Selects best memory type automatically with preference for CPU (host) memory.\n\nWhen using this flag, if you want to map the allocation (using vmaMapMemory() or #VMA_ALLOCATION_CREATE_MAPPED_BIT),\nyou must pass one of the flags: #VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT or #VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT\nin VmaAllocationCreateInfo::flags.\n\nIt can be used only with functions that let the library know `VkBufferCreateInfo` or `VkImageCreateInfo`, e.g.\nvmaCreateBuffer(), vmaCreateImage(), vmaFindMemoryTypeIndexForBufferInfo(), vmaFindMemoryTypeIndexForImageInfo()\nand not with generic memory allocation functions."]
    MAX_ENUM = 2147483647,
}
impl VmaAllocationCreateFlagBits {
    pub const STRATEGY_BEST_FIT_BIT: VmaAllocationCreateFlagBits =
        VmaAllocationCreateFlagBits::STRATEGY_MIN_MEMORY_BIT;
}
impl VmaAllocationCreateFlagBits {
    pub const STRATEGY_FIRST_FIT_BIT: VmaAllocationCreateFlagBits =
        VmaAllocationCreateFlagBits::STRATEGY_MIN_TIME_BIT;
}
#[repr(i32)]
#[doc = "Flags to be passed as VmaAllocationCreateInfo::flags."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VmaAllocationCreateFlagBits {
    #[doc = "Set this flag if the allocation should have its own memory block.\n\nUse it for special, big resources, like fullscreen images used as attachments.\n\nIf you use this flag while creating a buffer or an image, `VkMemoryDedicatedAllocateInfo`\nstructure is applied if possible."]
    DEDICATED_MEMORY_BIT = 1,
    #[doc = "Set this flag to only try to allocate from existing `VkDeviceMemory` blocks and never create new such block.\n\nIf new allocation cannot be placed in any of the existing blocks, allocation\nfails with `VK_ERROR_OUT_OF_DEVICE_MEMORY` error.\n\nYou should not use #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT and\n#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT at the same time. It makes no sense."]
    NEVER_ALLOCATE_BIT = 2,
    #[doc = "Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.\n\nPointer to mapped memory will be returned through VmaAllocationInfo::pMappedData.\n\nIt is valid to use this flag for allocation made from memory type that is not\n`HOST_VISIBLE`. This flag is then ignored and memory is not mapped. This is\nuseful if you need an allocation that is efficient to use on GPU\n(`DEVICE_LOCAL`) and still want to map it directly if possible on platforms that\nsupport it (e.g. Intel GPU)."]
    MAPPED_BIT = 4,
    #[doc = "> **Deprecated** Preserved for backward compatibility. Consider using vmaSetAllocationName() instead.\n\nSet this flag to treat VmaAllocationCreateInfo::pUserData as pointer to a\nnull-terminated string. Instead of copying pointer value, a local copy of the\nstring is made and stored in allocation's `pName`. The string is automatically\nfreed together with the allocation. It is also used in vmaBuildStatsString()."]
    USER_DATA_COPY_STRING_BIT = 32,
    #[doc = "Allocation will be created from upper stack in a double stack pool.\n\nThis flag is only allowed for custom pools created with #VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT flag."]
    UPPER_ADDRESS_BIT = 64,
    #[doc = "Create both buffer/image and allocation, but don't bind them together.\nIt is useful when you want to bind yourself to do some more advanced binding, e.g. using some extensions.\nThe flag is meaningful only with functions that bind by default: vmaCreateBuffer(), vmaCreateImage().\nOtherwise it is ignored.\n\nIf you want to make sure the new buffer/image is not tied to the new memory allocation\nthrough `VkMemoryDedicatedAllocateInfoKHR` structure in case the allocation ends up in its own memory block,\nuse also flag #VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT."]
    DONT_BIND_BIT = 128,
    #[doc = "Create allocation only if additional device memory required for it, if any, won't exceed\nmemory budget. Otherwise return `VK_ERROR_OUT_OF_DEVICE_MEMORY`."]
    WITHIN_BUDGET_BIT = 256,
    #[doc = "Set this flag if the allocated memory will have aliasing resources.\n\nUsage of this flag prevents supplying `VkMemoryDedicatedAllocateInfoKHR` when #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT is specified.\nOtherwise created dedicated memory will not be suitable for aliasing resources, resulting in Vulkan Validation Layer errors."]
    CAN_ALIAS_BIT = 512,
    #[doc = "Requests possibility to map the allocation (using vmaMapMemory() or #VMA_ALLOCATION_CREATE_MAPPED_BIT).\n\n- If you use #VMA_MEMORY_USAGE_AUTO or other `VMA_MEMORY_USAGE_AUTO*` value,\nyou must use this flag to be able to map the allocation. Otherwise, mapping is incorrect.\n- If you use other value of #VmaMemoryUsage, this flag is ignored and mapping is always possible in memory types that are `HOST_VISIBLE`.\nThis includes allocations created in custom_memory_pools.\n\nDeclares that mapped memory will only be written sequentially, e.g. using `memcpy()` or a loop writing number-by-number,\nnever read or accessed randomly, so a memory type can be selected that is uncached and write-combined.\n\nViolating this declaration may work correctly, but will likely be very slow.\nWatch out for implicit reads introduced by doing e.g. `pMappedData[i] += x;`\nBetter prepare your data in a local variable and `memcpy()` it to the mapped pointer all at once."]
    HOST_ACCESS_SEQUENTIAL_WRITE_BIT = 1024,
    #[doc = "Requests possibility to map the allocation (using vmaMapMemory() or #VMA_ALLOCATION_CREATE_MAPPED_BIT).\n\n- If you use #VMA_MEMORY_USAGE_AUTO or other `VMA_MEMORY_USAGE_AUTO*` value,\nyou must use this flag to be able to map the allocation. Otherwise, mapping is incorrect.\n- If you use other value of #VmaMemoryUsage, this flag is ignored and mapping is always possible in memory types that are `HOST_VISIBLE`.\nThis includes allocations created in custom_memory_pools.\n\nDeclares that mapped memory can be read, written, and accessed in random order,\nso a `HOST_CACHED` memory type is preferred."]
    HOST_ACCESS_RANDOM_BIT = 2048,
    #[doc = "Together with #VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT or #VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT,\nit says that despite request for host access, a not-`HOST_VISIBLE` memory type can be selected\nif it may improve performance.\n\nBy using this flag, you declare that you will check if the allocation ended up in a `HOST_VISIBLE` memory type\n(e.g. using vmaGetAllocationMemoryProperties()) and if not, you will create some \"staging\" buffer and\nissue an explicit transfer to write/read your data.\nTo prepare for this possibility, don't forget to add appropriate flags like\n`VK_BUFFER_USAGE_TRANSFER_DST_BIT`, `VK_BUFFER_USAGE_TRANSFER_SRC_BIT` to the parameters of created buffer or image."]
    HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT = 4096,
    #[doc = "Allocation strategy that chooses smallest possible free range for the allocation\nto minimize memory usage and fragmentation, possibly at the expense of allocation time."]
    STRATEGY_MIN_MEMORY_BIT = 65536,
    #[doc = "Allocation strategy that chooses first suitable free range for the allocation -\nnot necessarily in terms of the smallest offset but the one that is easiest and fastest to find\nto minimize allocation time, possibly at the expense of allocation quality."]
    STRATEGY_MIN_TIME_BIT = 131072,
    #[doc = "Allocation strategy that chooses always the lowest offset in available space.\nThis is not the most efficient strategy but achieves highly packed data.\nUsed internally by defragmentation, not recommended in typical usage."]
    STRATEGY_MIN_OFFSET_BIT = 262144,
    #[doc = "A bit mask to extract only `STRATEGY` bits from entire set of flags."]
    STRATEGY_MASK = 458752,
    #[doc = "A bit mask to extract only `STRATEGY` bits from entire set of flags."]
    MAX_ENUM = 2147483647,
}
#[doc = "See #VmaAllocationCreateFlagBits."]
pub type VmaAllocationCreateFlags = Flags;
impl VmaPoolCreateFlagBits {
    pub const ALGORITHM_MASK: VmaPoolCreateFlagBits = VmaPoolCreateFlagBits::LINEAR_ALGORITHM_BIT;
}
#[repr(i32)]
#[doc = "Flags to be passed as VmaPoolCreateInfo::flags."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VmaPoolCreateFlagBits {
    #[doc = "Use this flag if you always allocate only buffers and linear images or only optimal images out of this pool and so Buffer-Image Granularity can be ignored.\n\nThis is an optional optimization flag.\n\nIf you always allocate using vmaCreateBuffer(), vmaCreateImage(),\nvmaAllocateMemoryForBuffer(), then you don't need to use it because allocator\nknows exact type of your allocations so it can handle Buffer-Image Granularity\nin the optimal way.\n\nIf you also allocate using vmaAllocateMemoryForImage() or vmaAllocateMemory(),\nexact type of such allocations is not known, so allocator must be conservative\nin handling Buffer-Image Granularity, which can lead to suboptimal allocation\n(wasted memory). In that case, if you can make sure you always allocate only\nbuffers and linear images or only optimal images out of this pool, use this flag\nto make allocator disregard Buffer-Image Granularity and so make allocations\nfaster and more optimal."]
    IGNORE_BUFFER_IMAGE_GRANULARITY_BIT = 2,
    #[doc = "Enables alternative, linear allocation algorithm in this pool.\n\nSpecify this flag to enable linear allocation algorithm, which always creates\nnew allocations after last one and doesn't reuse space from allocations freed in\nbetween. It trades memory consumption for simplified algorithm and data\nstructure, which has better performance and uses less memory for metadata.\n\nBy using this flag, you can achieve behavior of free-at-once, stack,\nring buffer, and double stack.\nFor details, see documentation chapter linear_algorithm."]
    LINEAR_ALGORITHM_BIT = 4,
    #[doc = "Bit mask to extract only `ALGORITHM` bits from entire set of flags."]
    MAX_ENUM = 2147483647,
}
#[doc = "Flags to be passed as VmaPoolCreateInfo::flags. See #VmaPoolCreateFlagBits."]
pub type VmaPoolCreateFlags = Flags;
#[repr(i32)]
#[doc = "Flags to be passed as VmaDefragmentationInfo::flags."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VmaDefragmentationFlagBits {
    ALGORITHM_FAST_BIT = 1,
    ALGORITHM_BALANCED_BIT = 2,
    ALGORITHM_FULL_BIT = 4,
    #[doc = "Use the most roboust algorithm at the cost of time to compute and number of copies to make.\nOnly available when bufferImageGranularity is greater than 1, since it aims to reduce\nalignment issues between different types of resources.\nOtherwise falls back to same behavior as #VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT."]
    ALGORITHM_EXTENSIVE_BIT = 8,
    #[doc = "A bit mask to extract only `ALGORITHM` bits from entire set of flags."]
    ALGORITHM_MASK = 15,
    #[doc = "A bit mask to extract only `ALGORITHM` bits from entire set of flags."]
    MAX_ENUM = 2147483647,
}
#[doc = "See #VmaDefragmentationFlagBits."]
pub type VmaDefragmentationFlags = Flags;
#[repr(i32)]
#[doc = "Operation performed on single defragmentation move. See structure #VmaDefragmentationMove."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VmaDefragmentationMoveOperation {
    #[doc = "Buffer/image has been recreated at `dstTmpAllocation`, data has been copied, old buffer/image has been destroyed. `srcAllocation` should be changed to point to the new place. This is the default value set by vmaBeginDefragmentationPass()."]
    COPY = 0,
    #[doc = "Set this value if you cannot move the allocation. New place reserved at `dstTmpAllocation` will be freed. `srcAllocation` will remain unchanged."]
    IGNORE = 1,
    #[doc = "Set this value if you decide to abandon the allocation and you destroyed the buffer/image. New place reserved at `dstTmpAllocation` will be freed, along with `srcAllocation`, which will be destroyed."]
    DESTROY = 2,
}
impl VmaVirtualBlockCreateFlagBits {
    pub const ALGORITHM_MASK: VmaVirtualBlockCreateFlagBits =
        VmaVirtualBlockCreateFlagBits::LINEAR_ALGORITHM_BIT;
}
#[repr(i32)]
#[doc = "Flags to be passed as VmaVirtualBlockCreateInfo::flags."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VmaVirtualBlockCreateFlagBits {
    #[doc = "Enables alternative, linear allocation algorithm in this virtual block.\n\nSpecify this flag to enable linear allocation algorithm, which always creates\nnew allocations after last one and doesn't reuse space from allocations freed in\nbetween. It trades memory consumption for simplified algorithm and data\nstructure, which has better performance and uses less memory for metadata.\n\nBy using this flag, you can achieve behavior of free-at-once, stack,\nring buffer, and double stack.\nFor details, see documentation chapter linear_algorithm."]
    LINEAR_ALGORITHM_BIT = 1,
    #[doc = "Bit mask to extract only `ALGORITHM` bits from entire set of flags."]
    MAX_ENUM = 2147483647,
}
#[doc = "Flags to be passed as VmaVirtualBlockCreateInfo::flags. See #VmaVirtualBlockCreateFlagBits."]
pub type VmaVirtualBlockCreateFlags = Flags;
#[repr(i32)]
#[doc = "Flags to be passed as VmaVirtualAllocationCreateInfo::flags."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VmaVirtualAllocationCreateFlagBits {
    #[doc = "Allocation will be created from upper stack in a double stack pool.\n\nThis flag is only allowed for virtual blocks created with #VMA_VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT flag."]
    UPPER_ADDRESS_BIT = 64,
    #[doc = "Allocation strategy that tries to minimize memory usage."]
    STRATEGY_MIN_MEMORY_BIT = 65536,
    #[doc = "Allocation strategy that tries to minimize allocation time."]
    STRATEGY_MIN_TIME_BIT = 131072,
    #[doc = "Allocation strategy that chooses always the lowest offset in available space.\nThis is not the most efficient strategy but achieves highly packed data."]
    STRATEGY_MIN_OFFSET_BIT = 262144,
    #[doc = "A bit mask to extract only `STRATEGY` bits from entire set of flags.\n\nThese strategy flags are binary compatible with equivalent flags in #VmaAllocationCreateFlagBits."]
    STRATEGY_MASK = 458752,
    #[doc = "A bit mask to extract only `STRATEGY` bits from entire set of flags.\n\nThese strategy flags are binary compatible with equivalent flags in #VmaAllocationCreateFlagBits."]
    MAX_ENUM = 2147483647,
}
#[doc = "Flags to be passed as VmaVirtualAllocationCreateInfo::flags. See #VmaVirtualAllocationCreateFlagBits."]
pub type VmaVirtualAllocationCreateFlags = Flags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaAllocator_T {
    _unused: [u8; 0],
}
pub type VmaAllocator = *mut VmaAllocator_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaPool_T {
    _unused: [u8; 0],
}
pub type VmaPool = *mut VmaPool_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaAllocation_T {
    _unused: [u8; 0],
}
pub type VmaAllocation = *mut VmaAllocation_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaDefragmentationContext_T {
    _unused: [u8; 0],
}
pub type VmaDefragmentationContext = *mut VmaDefragmentationContext_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaVirtualAllocation_T {
    _unused: [u8; 0],
}
pub type VmaVirtualAllocation = *mut VmaVirtualAllocation_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaVirtualBlock_T {
    _unused: [u8; 0],
}
pub type VmaVirtualBlock = *mut VmaVirtualBlock_T;
#[doc = "Callback function called after successful vkAllocateMemory."]
pub type PFN_vmaAllocateDeviceMemoryFunction = ::core::option::Option<
    unsafe extern "C" fn(
        allocator: VmaAllocator,
        memoryType: u32,
        memory: DeviceMemory,
        size: DeviceSize,
        pUserData: *mut ::core::ffi::c_void,
    ),
>;
#[doc = "Callback function called before vkFreeMemory."]
pub type PFN_vmaFreeDeviceMemoryFunction = ::core::option::Option<
    unsafe extern "C" fn(
        allocator: VmaAllocator,
        memoryType: u32,
        memory: DeviceMemory,
        size: DeviceSize,
        pUserData: *mut ::core::ffi::c_void,
    ),
>;
#[doc = "Set of callbacks that the library will call for `vkAllocateMemory` and `vkFreeMemory`.\n\nProvided for informative purpose, e.g. to gather statistics about number of\nallocations or total amount of memory allocated in Vulkan.\n\nUsed in VmaAllocatorCreateInfo::pDeviceMemoryCallbacks."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaDeviceMemoryCallbacks {
    #[doc = "Optional, can be null."]
    pub pfnAllocate: PFN_vmaAllocateDeviceMemoryFunction,
    #[doc = "Optional, can be null."]
    pub pfnFree: PFN_vmaFreeDeviceMemoryFunction,
    #[doc = "Optional, can be null."]
    pub pUserData: *mut ::core::ffi::c_void,
}
#[doc = "Pointers to some Vulkan functions - a subset used by the library.\n\nUsed in VmaAllocatorCreateInfo::pVulkanFunctions."]
#[repr(C)]
pub struct VmaVulkanFunctions {
    #[doc = "Required when using VMA_DYNAMIC_VULKAN_FUNCTIONS."]
    pub vkGetInstanceProcAddr: PFN_vkGetInstanceProcAddr,
    #[doc = "Required when using VMA_DYNAMIC_VULKAN_FUNCTIONS."]
    pub vkGetDeviceProcAddr: PFN_vkGetDeviceProcAddr,
    pub vkGetPhysicalDeviceProperties: PFN_vkGetPhysicalDeviceProperties,
    pub vkGetPhysicalDeviceMemoryProperties: PFN_vkGetPhysicalDeviceMemoryProperties,
    pub vkAllocateMemory: PFN_vkAllocateMemory,
    pub vkFreeMemory: PFN_vkFreeMemory,
    pub vkMapMemory: PFN_vkMapMemory,
    pub vkUnmapMemory: PFN_vkUnmapMemory,
    pub vkFlushMappedMemoryRanges: PFN_vkFlushMappedMemoryRanges,
    pub vkInvalidateMappedMemoryRanges: PFN_vkInvalidateMappedMemoryRanges,
    pub vkBindBufferMemory: PFN_vkBindBufferMemory,
    pub vkBindImageMemory: PFN_vkBindImageMemory,
    pub vkGetBufferMemoryRequirements: PFN_vkGetBufferMemoryRequirements,
    pub vkGetImageMemoryRequirements: PFN_vkGetImageMemoryRequirements,
    pub vkCreateBuffer: PFN_vkCreateBuffer,
    pub vkDestroyBuffer: PFN_vkDestroyBuffer,
    pub vkCreateImage: PFN_vkCreateImage,
    pub vkDestroyImage: PFN_vkDestroyImage,
    pub vkCmdCopyBuffer: PFN_vkCmdCopyBuffer,
    #[doc = "Fetch \"vkGetBufferMemoryRequirements2\" on Vulkan >= 1.1, fetch \"vkGetBufferMemoryRequirements2KHR\" when using VK_KHR_dedicated_allocation extension."]
    pub vkGetBufferMemoryRequirements2KHR: PFN_vkGetBufferMemoryRequirements2KHR,
    #[doc = "Fetch \"vkGetImageMemoryRequirements2\" on Vulkan >= 1.1, fetch \"vkGetImageMemoryRequirements2KHR\" when using VK_KHR_dedicated_allocation extension."]
    pub vkGetImageMemoryRequirements2KHR: PFN_vkGetImageMemoryRequirements2KHR,
    #[doc = "Fetch \"vkBindBufferMemory2\" on Vulkan >= 1.1, fetch \"vkBindBufferMemory2KHR\" when using VK_KHR_bind_memory2 extension."]
    pub vkBindBufferMemory2KHR: PFN_vkBindBufferMemory2KHR,
    #[doc = "Fetch \"vkBindImageMemory2\" on Vulkan >= 1.1, fetch \"vkBindImageMemory2KHR\" when using VK_KHR_bind_memory2 extension."]
    pub vkBindImageMemory2KHR: PFN_vkBindImageMemory2KHR,
    #[doc = "Fetch from \"vkGetPhysicalDeviceMemoryProperties2\" on Vulkan >= 1.1, but you can also fetch it from \"vkGetPhysicalDeviceMemoryProperties2KHR\" if you enabled extension VK_KHR_get_physical_device_properties2."]
    pub vkGetPhysicalDeviceMemoryProperties2KHR: PFN_vkGetPhysicalDeviceMemoryProperties2KHR,
    #[doc = "Fetch from \"vkGetDeviceBufferMemoryRequirements\" on Vulkan >= 1.3, but you can also fetch it from \"vkGetDeviceBufferMemoryRequirementsKHR\" if you enabled extension VK_KHR_maintenance4."]
    pub vkGetDeviceBufferMemoryRequirements: PFN_vkGetDeviceBufferMemoryRequirementsKHR,
    #[doc = "Fetch from \"vkGetDeviceImageMemoryRequirements\" on Vulkan >= 1.3, but you can also fetch it from \"vkGetDeviceImageMemoryRequirementsKHR\" if you enabled extension VK_KHR_maintenance4."]
    pub vkGetDeviceImageMemoryRequirements: PFN_vkGetDeviceImageMemoryRequirementsKHR,
}
#[doc = "Description of a Allocator to be created."]
#[repr(C)]
pub struct VmaAllocatorCreateInfo {
    #[doc = "Flags for created allocator. Use #VmaAllocatorCreateFlagBits enum."]
    pub flags: VmaAllocatorCreateFlags,
    #[doc = "Vulkan physical device.\n** It must be valid throughout whole lifetime of created allocator. */"]
    pub physicalDevice: PhysicalDevice,
    #[doc = "Vulkan device.\n** It must be valid throughout whole lifetime of created allocator. */"]
    pub device: Device,
    #[doc = "Preferred size of a single `VkDeviceMemory` block to be allocated from large heaps > 1 GiB. Optional.\n** Set to 0 to use default, which is currently 256 MiB. */"]
    pub preferredLargeHeapBlockSize: DeviceSize,
    #[doc = "Custom CPU memory allocation callbacks. Optional.\n** Optional, can be null. When specified, will also be used for all CPU-side memory allocations. */"]
    pub pAllocationCallbacks: *const AllocationCallbacks,
    #[doc = "Informative callbacks for `vkAllocateMemory`, `vkFreeMemory`. Optional.\n** Optional, can be null. */"]
    pub pDeviceMemoryCallbacks: *const VmaDeviceMemoryCallbacks,
    #[doc = "Either null or a pointer to an array of limits on maximum number of bytes that can be allocated out of particular Vulkan memory heap.\n\nIf not NULL, it must be a pointer to an array of\n`VkPhysicalDeviceMemoryProperties::memoryHeapCount` elements, defining limit on\nmaximum number of bytes that can be allocated out of particular Vulkan memory\nheap.\n\nAny of the elements may be equal to `VK_WHOLE_SIZE`, which means no limit on that\nheap. This is also the default in case of `pHeapSizeLimit` = NULL.\n\nIf there is a limit defined for a heap:\n\n- If user tries to allocate more memory from that heap using this allocator,\nthe allocation fails with `VK_ERROR_OUT_OF_DEVICE_MEMORY`.\n- If the limit is smaller than heap size reported in `VkMemoryHeap::size`, the\nvalue of this limit will be reported instead when using vmaGetMemoryProperties().\n\nWarning! Using this feature may not be equivalent to installing a GPU with\nsmaller amount of memory, because graphics driver doesn't necessary fail new\nallocations with `VK_ERROR_OUT_OF_DEVICE_MEMORY` result when memory capacity is\nexceeded. It may return success and just silently migrate some device memory\nblocks to system RAM. This driver behavior can also be controlled using\nVK_AMD_memory_overallocation_behavior extension."]
    pub pHeapSizeLimit: *const DeviceSize,
    #[doc = "Pointers to Vulkan functions. Can be null.\n\nFor details see [Pointers to Vulkan functions](config_Vulkan_functions)."]
    pub pVulkanFunctions: *const VmaVulkanFunctions,
    #[doc = "Handle to Vulkan instance object.\n\nStarting from version 3.0.0 this member is no longer optional, it must be set!"]
    pub instance: Instance,
    #[doc = "Optional. Vulkan version that the application uses.\n\nIt must be a value in the format as created by macro `VK_MAKE_VERSION` or a constant like: `VK_API_VERSION_1_1`, `VK_API_VERSION_1_0`.\nThe patch version number specified is ignored. Only the major and minor versions are considered.\nOnly versions 1.0, 1.1, 1.2, 1.3 are supported by the current implementation.\nLeaving it initialized to zero is equivalent to `VK_API_VERSION_1_0`.\nIt must match the Vulkan version used by the application and supported on the selected physical device,\nso it must be no higher than `VkApplicationInfo::apiVersion` passed to `vkCreateInstance`\nand no higher than `VkPhysicalDeviceProperties::apiVersion` found on the physical device used."]
    pub vulkanApiVersion: u32,
    #[doc = "Either null or a pointer to an array of external memory handle types for each Vulkan memory type.\n\nIf not NULL, it must be a pointer to an array of `VkPhysicalDeviceMemoryProperties::memoryTypeCount`\nelements, defining external memory handle types of particular Vulkan memory type,\nto be passed using `VkExportMemoryAllocateInfoKHR`.\n\nAny of the elements may be equal to 0, which means not to use `VkExportMemoryAllocateInfoKHR` on this memory type.\nThis is also the default in case of `pTypeExternalMemoryHandleTypes` = NULL."]
    pub pTypeExternalMemoryHandleTypes: *const ExternalMemoryHandleTypeFlagsKHR,
}
#[doc = "Information about existing #VmaAllocator object."]
#[repr(C)]
pub struct VmaAllocatorInfo {
    #[doc = "Handle to Vulkan instance object.\n\nThis is the same value as has been passed through VmaAllocatorCreateInfo::instance."]
    pub instance: Instance,
    #[doc = "Handle to Vulkan physical device object.\n\nThis is the same value as has been passed through VmaAllocatorCreateInfo::physicalDevice."]
    pub physicalDevice: PhysicalDevice,
    #[doc = "Handle to Vulkan device object.\n\nThis is the same value as has been passed through VmaAllocatorCreateInfo::device."]
    pub device: Device,
}
#[doc = "Calculated statistics of memory usage e.g. in a specific memory type, heap, custom pool, or total.\n\nThese are fast to calculate.\nSee functions: vmaGetHeapBudgets(), vmaGetPoolStatistics()."]
#[repr(C)]
#[derive(Debug)]
pub struct VmaStatistics {
    #[doc = "Number of `VkDeviceMemory` objects - Vulkan memory blocks allocated."]
    pub blockCount: u32,
    #[doc = "Number of #VmaAllocation objects allocated.\n\nDedicated allocations have their own blocks, so each one adds 1 to `allocationCount` as well as `blockCount`."]
    pub allocationCount: u32,
    #[doc = "Number of bytes allocated in `VkDeviceMemory` blocks.\n\n> **Note:** To avoid confusion, please be aware that what Vulkan calls an \"allocation\" - a whole `VkDeviceMemory` object\n(e.g. as in `VkPhysicalDeviceLimits::maxMemoryAllocationCount`) is called a \"block\" in VMA, while VMA calls\n\"allocation\" a #VmaAllocation object that represents a memory region sub-allocated from such block, usually for a single buffer or image."]
    pub blockBytes: DeviceSize,
    #[doc = "Total number of bytes occupied by all #VmaAllocation objects.\n\nAlways less or equal than `blockBytes`.\nDifference `(blockBytes - allocationBytes)` is the amount of memory allocated from Vulkan\nbut unused by any #VmaAllocation."]
    pub allocationBytes: DeviceSize,
}
#[doc = "More detailed statistics than #VmaStatistics.\n\nThese are slower to calculate. Use for debugging purposes.\nSee functions: vmaCalculateStatistics(), vmaCalculatePoolStatistics().\n\nPrevious version of the statistics API provided averages, but they have been removed\nbecause they can be easily calculated as:\n\nVkDeviceSize allocationSizeAvg = detailedStats.statistics.allocationBytes / detailedStats.statistics.allocationCount;\nVkDeviceSize unusedBytes = detailedStats.statistics.blockBytes - detailedStats.statistics.allocationBytes;\nVkDeviceSize unusedRangeSizeAvg = unusedBytes / detailedStats.unusedRangeCount;\n"]
#[repr(C)]
#[derive(Debug)]
pub struct VmaDetailedStatistics {
    #[doc = "Basic statistics."]
    pub statistics: VmaStatistics,
    #[doc = "Number of free ranges of memory between allocations."]
    pub unusedRangeCount: u32,
    #[doc = "Smallest allocation size. `VK_WHOLE_SIZE` if there are 0 allocations."]
    pub allocationSizeMin: DeviceSize,
    #[doc = "Largest allocation size. 0 if there are 0 allocations."]
    pub allocationSizeMax: DeviceSize,
    #[doc = "Smallest empty range size. `VK_WHOLE_SIZE` if there are 0 empty ranges."]
    pub unusedRangeSizeMin: DeviceSize,
    #[doc = "Largest empty range size. 0 if there are 0 empty ranges."]
    pub unusedRangeSizeMax: DeviceSize,
}
#[doc = "General statistics from current state of the Allocator -\ntotal memory usage across all memory heaps and types.\n\nThese are slower to calculate. Use for debugging purposes.\nSee function vmaCalculateStatistics()."]
#[repr(C)]
#[derive(Debug)]
pub struct VmaTotalStatistics {
    pub memoryType: [VmaDetailedStatistics; 32usize],
    pub memoryHeap: [VmaDetailedStatistics; 16usize],
    pub total: VmaDetailedStatistics,
}
#[doc = "Statistics of current memory usage and available budget for a specific memory heap.\n\nThese are fast to calculate.\nSee function vmaGetHeapBudgets()."]
#[repr(C)]
#[derive(Debug)]
pub struct VmaBudget {
    #[doc = "Statistics fetched from the library."]
    pub statistics: VmaStatistics,
    #[doc = "Estimated current memory usage of the program, in bytes.\n\nFetched from system using VK_EXT_memory_budget extension if enabled.\n\nIt might be different than `statistics.blockBytes` (usually higher) due to additional implicit objects\nalso occupying the memory, like swapchain, pipelines, descriptor heaps, command buffers, or\n`VkDeviceMemory` blocks allocated outside of this library, if any."]
    pub usage: DeviceSize,
    #[doc = "Estimated amount of memory available to the program, in bytes.\n\nFetched from system using VK_EXT_memory_budget extension if enabled.\n\nIt might be different (most probably smaller) than `VkMemoryHeap::size[heapIndex]` due to factors\nexternal to the program, decided by the operating system.\nDifference `budget - usage` is the amount of additional memory that can probably\nbe allocated without problems. Exceeding the budget may result in various problems."]
    pub budget: DeviceSize,
}
#[doc = "Parameters of new #VmaAllocation.\n\nTo be used with functions like vmaCreateBuffer(), vmaCreateImage(), and many others."]
#[repr(C)]
pub struct VmaAllocationCreateInfo {
    #[doc = "Use #VmaAllocationCreateFlagBits enum."]
    pub flags: VmaAllocationCreateFlags,
    #[doc = "Intended usage of memory.\n\nYou can leave #VMA_MEMORY_USAGE_UNKNOWN if you specify memory requirements in other way. If `pool` is not null, this member is ignored."]
    pub usage: VmaMemoryUsage,
    #[doc = "Flags that must be set in a Memory Type chosen for an allocation.\n\nLeave 0 if you specify memory requirements in other way. If `pool` is not null, this member is ignored."]
    pub requiredFlags: MemoryPropertyFlags,
    #[doc = "Flags that preferably should be set in a memory type chosen for an allocation.\n\nSet to 0 if no additional flags are preferred. If `pool` is not null, this member is ignored."]
    pub preferredFlags: MemoryPropertyFlags,
    #[doc = "Bitmask containing one bit set for every memory type acceptable for this allocation.\n\nValue 0 is equivalent to `UINT32_MAX` - it means any memory type is accepted if\nit meets other requirements specified by this structure, with no further\nrestrictions on memory type index. If `pool` is not null, this member is ignored."]
    pub memoryTypeBits: u32,
    #[doc = "Pool that this allocation should be created in.\n\nLeave `VK_NULL_HANDLE` to allocate from default pool. If not null, members:\n`usage`, `requiredFlags`, `preferredFlags`, `memoryTypeBits` are ignored."]
    pub pool: VmaPool,
    #[doc = "Custom general-purpose pointer that will be stored in #VmaAllocation, can be read as VmaAllocationInfo::pUserData and changed using vmaSetAllocationUserData().\n\nIf #VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT is used, it must be either\nnull or pointer to a null-terminated string. The string will be then copied to\ninternal buffer, so it doesn't need to be valid after allocation call."]
    pub pUserData: *mut ::core::ffi::c_void,
    #[doc = "A floating-point value between 0 and 1, indicating the priority of the allocation relative to other memory allocations.\n\nIt is used only when #VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT flag was used during creation of the #VmaAllocator object\nand this allocation ends up as dedicated or is explicitly forced as dedicated using #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.\nOtherwise, it has the priority of a memory block where it is placed and this variable is ignored."]
    pub priority: f32,
}
#[doc = "Describes parameter of created #VmaPool."]
#[repr(C)]
pub struct VmaPoolCreateInfo {
    #[doc = "Vulkan memory type index to allocate this pool from."]
    pub memoryTypeIndex: u32,
    #[doc = "Use combination of #VmaPoolCreateFlagBits."]
    pub flags: VmaPoolCreateFlags,
    #[doc = "Size of a single `VkDeviceMemory` block to be allocated as part of this pool, in bytes. Optional.\n\nSpecify nonzero to set explicit, constant size of memory blocks used by this\npool.\n\nLeave 0 to use default and let the library manage block sizes automatically.\nSizes of particular blocks may vary.\nIn this case, the pool will also support dedicated allocations."]
    pub blockSize: DeviceSize,
    #[doc = "Minimum number of blocks to be always allocated in this pool, even if they stay empty.\n\nSet to 0 to have no preallocated blocks and allow the pool be completely empty."]
    pub minBlockCount: usize,
    #[doc = "Maximum number of blocks that can be allocated in this pool. Optional.\n\nSet to 0 to use default, which is `SIZE_MAX`, which means no limit.\n\nSet to same value as VmaPoolCreateInfo::minBlockCount to have fixed amount of memory allocated\nthroughout whole lifetime of this pool."]
    pub maxBlockCount: usize,
    #[doc = "A floating-point value between 0 and 1, indicating the priority of the allocations in this pool relative to other memory allocations.\n\nIt is used only when #VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT flag was used during creation of the #VmaAllocator object.\nOtherwise, this variable is ignored."]
    pub priority: f32,
    #[doc = "Additional minimum alignment to be used for all allocations created from this pool. Can be 0.\n\nLeave 0 (default) not to impose any additional alignment. If not 0, it must be a power of two.\nIt can be useful in cases where alignment returned by Vulkan by functions like `vkGetBufferMemoryRequirements` is not enough,\ne.g. when doing interop with OpenGL."]
    pub minAllocationAlignment: DeviceSize,
    #[doc = "Additional `pNext` chain to be attached to `VkMemoryAllocateInfo` used for every allocation made by this pool. Optional.\n\nOptional, can be null. If not null, it must point to a `pNext` chain of structures that can be attached to `VkMemoryAllocateInfo`.\nIt can be useful for special needs such as adding `VkExportMemoryAllocateInfoKHR`.\nStructures pointed by this member must remain alive and unchanged for the whole lifetime of the custom pool.\n\nPlease note that some structures, e.g. `VkMemoryPriorityAllocateInfoEXT`, `VkMemoryDedicatedAllocateInfoKHR`,\ncan be attached automatically by this library when using other, more convenient of its features."]
    pub pMemoryAllocateNext: *mut ::core::ffi::c_void,
}
#[doc = "Parameters of #VmaAllocation objects, that can be retrieved using function vmaGetAllocationInfo().\n\nThere is also an extended version of this structure that carries additional parameters: #VmaAllocationInfo2."]
#[repr(C)]
pub struct VmaAllocationInfo {
    #[doc = "Memory type index that this allocation was allocated from.\n\nIt never changes."]
    pub memoryType: u32,
    #[doc = "Handle to Vulkan memory object.\n\nSame memory object can be shared by multiple allocations.\n\nIt can change after the allocation is moved during defragmentation."]
    pub deviceMemory: DeviceMemory,
    #[doc = "Offset in `VkDeviceMemory` object to the beginning of this allocation, in bytes. `(deviceMemory, offset)` pair is unique to this allocation.\n\nYou usually don't need to use this offset. If you create a buffer or an image together with the allocation using e.g. function\nvmaCreateBuffer(), vmaCreateImage(), functions that operate on these resources refer to the beginning of the buffer or image,\nnot entire device memory block. Functions like vmaMapMemory(), vmaBindBufferMemory() also refer to the beginning of the allocation\nand apply this offset automatically.\n\nIt can change after the allocation is moved during defragmentation."]
    pub offset: DeviceSize,
    #[doc = "Size of this allocation, in bytes.\n\nIt never changes.\n\n> **Note:** Allocation size returned in this variable may be greater than the size\nrequested for the resource e.g. as `VkBufferCreateInfo::size`. Whole size of the\nallocation is accessible for operations on memory e.g. using a pointer after\nmapping with vmaMapMemory(), but operations on the resource e.g. using\n`vkCmdCopyBuffer` must be limited to the size of the resource."]
    pub size: DeviceSize,
    #[doc = "Pointer to the beginning of this allocation as mapped data.\n\nIf the allocation hasn't been mapped using vmaMapMemory() and hasn't been\ncreated with #VMA_ALLOCATION_CREATE_MAPPED_BIT flag, this value is null.\n\nIt can change after call to vmaMapMemory(), vmaUnmapMemory().\nIt can also change after the allocation is moved during defragmentation."]
    pub pMappedData: *mut ::core::ffi::c_void,
    #[doc = "Custom general-purpose pointer that was passed as VmaAllocationCreateInfo::pUserData or set using vmaSetAllocationUserData().\n\nIt can change after call to vmaSetAllocationUserData() for this allocation."]
    pub pUserData: *mut ::core::ffi::c_void,
    #[doc = "Custom allocation name that was set with vmaSetAllocationName().\n\nIt can change after call to vmaSetAllocationName() for this allocation.\n\nAnother way to set custom name is to pass it in VmaAllocationCreateInfo::pUserData with\nadditional flag #VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT set [DEPRECATED]."]
    pub pName: *const ::core::ffi::c_char,
}
#[doc = "Extended parameters of a #VmaAllocation object that can be retrieved using function vmaGetAllocationInfo2()."]
#[repr(C)]
pub struct VmaAllocationInfo2 {
    #[doc = "Basic parameters of the allocation.\n\nIf you need only these, you can use function vmaGetAllocationInfo() and structure #VmaAllocationInfo instead."]
    pub allocationInfo: VmaAllocationInfo,
    #[doc = "Size of the `VkDeviceMemory` block that the allocation belongs to.\n\nIn case of an allocation with dedicated memory, it will be equal to `allocationInfo.size`."]
    pub blockSize: DeviceSize,
    #[doc = "`VK_TRUE` if the allocation has dedicated memory, `VK_FALSE` if it was placed as part of a larger memory block.\n\nWhen `VK_TRUE`, it also means `VkMemoryDedicatedAllocateInfo` was used when creating the allocation\n(if VK_KHR_dedicated_allocation extension or Vulkan version >= 1.1 is enabled)."]
    pub dedicatedMemory: Bool32,
}
#[doc = "Callback function called during vmaBeginDefragmentation() to check custom criterion about ending current defragmentation pass.\n\nShould return true if the defragmentation needs to stop current pass."]
pub type PFN_vmaCheckDefragmentationBreakFunction =
    ::core::option::Option<unsafe extern "C" fn(pUserData: *mut ::core::ffi::c_void) -> Bool32>;
#[doc = "Parameters for defragmentation.\n\nTo be used with function vmaBeginDefragmentation()."]
#[repr(C)]
pub struct VmaDefragmentationInfo {
    #[doc = "Use combination of #VmaDefragmentationFlagBits."]
    pub flags: VmaDefragmentationFlags,
    #[doc = "Custom pool to be defragmented.\n\nIf null then default pools will undergo defragmentation process."]
    pub pool: VmaPool,
    #[doc = "Maximum numbers of bytes that can be copied during single pass, while moving allocations to different places.\n\n`0` means no limit."]
    pub maxBytesPerPass: DeviceSize,
    #[doc = "Maximum number of allocations that can be moved during single pass to a different place.\n\n`0` means no limit."]
    pub maxAllocationsPerPass: u32,
    #[doc = "Optional custom callback for stopping vmaBeginDefragmentation().\n\nHave to return true for breaking current defragmentation pass."]
    pub pfnBreakCallback: PFN_vmaCheckDefragmentationBreakFunction,
    #[doc = "Optional data to pass to custom callback for stopping pass of defragmentation."]
    pub pBreakCallbackUserData: *mut ::core::ffi::c_void,
}
#[doc = "Single move of an allocation to be done for defragmentation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaDefragmentationMove {
    #[doc = "Operation to be performed on the allocation by vmaEndDefragmentationPass(). Default value is #VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY. You can modify it."]
    pub operation: VmaDefragmentationMoveOperation,
    #[doc = "Allocation that should be moved."]
    pub srcAllocation: VmaAllocation,
    #[doc = "Temporary allocation pointing to destination memory that will replace `srcAllocation`.\n\nDo not store this allocation in your data structures! It exists only temporarily, for the duration of the defragmentation pass,\nto be used for binding new buffer/image to the destination memory using e.g. vmaBindBufferMemory().\nvmaEndDefragmentationPass() will destroy it and make `srcAllocation` point to this memory."]
    pub dstTmpAllocation: VmaAllocation,
}
#[doc = "Parameters for incremental defragmentation steps.\n\nTo be used with function vmaBeginDefragmentationPass()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaDefragmentationPassMoveInfo {
    #[doc = "Number of elements in the `pMoves` array."]
    pub moveCount: u32,
    #[doc = "Array of moves to be performed by the user in the current defragmentation pass.\n\nPointer to an array of `moveCount` elements, owned by VMA, created in vmaBeginDefragmentationPass(), destroyed in vmaEndDefragmentationPass().\n\nFor each element, you should:\n\n1. Create a new buffer/image in the place pointed by VmaDefragmentationMove::dstMemory + VmaDefragmentationMove::dstOffset.\n2. Copy data from the VmaDefragmentationMove::srcAllocation e.g. using `vkCmdCopyBuffer`, `vkCmdCopyImage`.\n3. Make sure these commands finished executing on the GPU.\n4. Destroy the old buffer/image.\n\nOnly then you can finish defragmentation pass by calling vmaEndDefragmentationPass().\nAfter this call, the allocation will point to the new place in memory.\n\nAlternatively, if you cannot move specific allocation, you can set VmaDefragmentationMove::operation to #VMA_DEFRAGMENTATION_MOVE_OPERATION_IGNORE.\n\nAlternatively, if you decide you want to completely remove the allocation:\n\n1. Destroy its buffer/image.\n2. Set VmaDefragmentationMove::operation to #VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY.\n\nThen, after vmaEndDefragmentationPass() the allocation will be freed."]
    pub pMoves: *mut VmaDefragmentationMove,
}
#[doc = "Statistics returned for defragmentation process in function vmaEndDefragmentation()."]
#[repr(C)]
pub struct VmaDefragmentationStats {
    #[doc = "Total number of bytes that have been copied while moving allocations to different places."]
    pub bytesMoved: DeviceSize,
    #[doc = "Total number of bytes that have been released to the system by freeing empty `VkDeviceMemory` objects."]
    pub bytesFreed: DeviceSize,
    #[doc = "Number of allocations that have been moved to different places."]
    pub allocationsMoved: u32,
    #[doc = "Number of empty `VkDeviceMemory` objects that have been released to the system."]
    pub deviceMemoryBlocksFreed: u32,
}
#[doc = "Parameters of created #VmaVirtualBlock object to be passed to vmaCreateVirtualBlock()."]
#[repr(C)]
pub struct VmaVirtualBlockCreateInfo {
    #[doc = "Total size of the virtual block.\n\nSizes can be expressed in bytes or any units you want as long as you are consistent in using them.\nFor example, if you allocate from some array of structures, 1 can mean single instance of entire structure."]
    pub size: DeviceSize,
    #[doc = "Use combination of #VmaVirtualBlockCreateFlagBits."]
    pub flags: VmaVirtualBlockCreateFlags,
    #[doc = "Custom CPU memory allocation callbacks. Optional.\n\nOptional, can be null. When specified, they will be used for all CPU-side memory allocations."]
    pub pAllocationCallbacks: *const AllocationCallbacks,
}
#[doc = "Parameters of created virtual allocation to be passed to vmaVirtualAllocate()."]
#[repr(C)]
pub struct VmaVirtualAllocationCreateInfo {
    #[doc = "Size of the allocation.\n\nCannot be zero."]
    pub size: DeviceSize,
    #[doc = "Required alignment of the allocation. Optional.\n\nMust be power of two. Special value 0 has the same meaning as 1 - means no special alignment is required, so allocation can start at any offset."]
    pub alignment: DeviceSize,
    #[doc = "Use combination of #VmaVirtualAllocationCreateFlagBits."]
    pub flags: VmaVirtualAllocationCreateFlags,
    #[doc = "Custom pointer to be associated with the allocation. Optional.\n\nIt can be any value and can be used for user-defined purposes. It can be fetched or changed later."]
    pub pUserData: *mut ::core::ffi::c_void,
}
#[doc = "Parameters of an existing virtual allocation, returned by vmaGetVirtualAllocationInfo()."]
#[repr(C)]
pub struct VmaVirtualAllocationInfo {
    #[doc = "Offset of the allocation.\n\nOffset at which the allocation was made."]
    pub offset: DeviceSize,
    #[doc = "Size of the allocation.\n\nSame value as passed in VmaVirtualAllocationCreateInfo::size."]
    pub size: DeviceSize,
    #[doc = "Custom pointer associated with the allocation.\n\nSame value as passed in VmaVirtualAllocationCreateInfo::pUserData or to vmaSetVirtualAllocationUserData()."]
    pub pUserData: *mut ::core::ffi::c_void,
}
unsafe extern "C" {
    #[doc = "Creates #VmaAllocator object."]
    pub fn vmaCreateAllocator(
        pCreateInfo: *const VmaAllocatorCreateInfo,
        pAllocator: *mut VmaAllocator,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Destroys allocator object."]
    pub fn vmaDestroyAllocator(allocator: VmaAllocator);
}
unsafe extern "C" {
    #[doc = "Returns information about existing #VmaAllocator object - handle to Vulkan device etc.\n\nIt might be useful if you want to keep just the #VmaAllocator handle and fetch other required handles to\n`VkPhysicalDevice`, `VkDevice` etc. every time using this function."]
    pub fn vmaGetAllocatorInfo(allocator: VmaAllocator, pAllocatorInfo: *mut VmaAllocatorInfo);
}
unsafe extern "C" {
    #[doc = "PhysicalDeviceProperties are fetched from physicalDevice by the allocator.\nYou can access it here, without fetching it again on your own."]
    pub fn vmaGetPhysicalDeviceProperties(
        allocator: VmaAllocator,
        ppPhysicalDeviceProperties: *mut *const PhysicalDeviceProperties,
    );
}
unsafe extern "C" {
    #[doc = "PhysicalDeviceMemoryProperties are fetched from physicalDevice by the allocator.\nYou can access it here, without fetching it again on your own."]
    pub fn vmaGetMemoryProperties(
        allocator: VmaAllocator,
        ppPhysicalDeviceMemoryProperties: *mut *const PhysicalDeviceMemoryProperties,
    );
}
unsafe extern "C" {
    #[doc = "Given Memory Type Index, returns Property Flags of this memory type.\n\nThis is just a convenience function. Same information can be obtained using\nvmaGetMemoryProperties()."]
    pub fn vmaGetMemoryTypeProperties(
        allocator: VmaAllocator,
        memoryTypeIndex: u32,
        pFlags: *mut MemoryPropertyFlags,
    );
}
unsafe extern "C" {
    #[doc = "Sets index of the current frame."]
    pub fn vmaSetCurrentFrameIndex(allocator: VmaAllocator, frameIndex: u32);
}
unsafe extern "C" {
    #[doc = "Retrieves statistics from current state of the Allocator.\n\nThis function is called \"calculate\" not \"get\" because it has to traverse all\ninternal data structures, so it may be quite slow. Use it for debugging purposes.\nFor faster but more brief statistics suitable to be called every frame or every allocation,\nuse vmaGetHeapBudgets().\n\nNote that when using allocator from multiple threads, returned information may immediately\nbecome outdated."]
    pub fn vmaCalculateStatistics(allocator: VmaAllocator, pStats: *mut VmaTotalStatistics);
}
unsafe extern "C" {
    #[doc = "Retrieves information about current memory usage and budget for all memory heaps.\n\n# Arguments\n\n* `allocator` -\n* `pBudgets` (direction out) - Must point to array with number of elements at least equal to number of memory heaps in physical device used.\n\nThis function is called \"get\" not \"calculate\" because it is very fast, suitable to be called\nevery frame or every allocation. For more detailed statistics use vmaCalculateStatistics().\n\nNote that when using allocator from multiple threads, returned information may immediately\nbecome outdated."]
    pub fn vmaGetHeapBudgets(allocator: VmaAllocator, pBudgets: *mut VmaBudget);
}
unsafe extern "C" {
    #[doc = "Helps to find memoryTypeIndex, given memoryTypeBits and VmaAllocationCreateInfo.\n\nThis algorithm tries to find a memory type that:\n\n- Is allowed by memoryTypeBits.\n- Contains all the flags from pAllocationCreateInfo->requiredFlags.\n- Matches intended usage.\n- Has as many flags from pAllocationCreateInfo->preferredFlags as possible.\n\n# Returns\n\nReturns VK_ERROR_FEATURE_NOT_PRESENT if not found. Receiving such result\nfrom this function or any other allocating function probably means that your\ndevice doesn't support any memory type with requested features for the specific\ntype of resource you want to use it for. Please check parameters of your\nresource, like image layout (OPTIMAL versus LINEAR) or mip level count."]
    pub fn vmaFindMemoryTypeIndex(
        allocator: VmaAllocator,
        memoryTypeBits: u32,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        pMemoryTypeIndex: *mut u32,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Helps to find memoryTypeIndex, given VkBufferCreateInfo and VmaAllocationCreateInfo.\n\nIt can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.\nIt internally creates a temporary, dummy buffer that never has memory bound."]
    pub fn vmaFindMemoryTypeIndexForBufferInfo(
        allocator: VmaAllocator,
        pBufferCreateInfo: *const BufferCreateInfo,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        pMemoryTypeIndex: *mut u32,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Helps to find memoryTypeIndex, given VkImageCreateInfo and VmaAllocationCreateInfo.\n\nIt can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.\nIt internally creates a temporary, dummy image that never has memory bound."]
    pub fn vmaFindMemoryTypeIndexForImageInfo(
        allocator: VmaAllocator,
        pImageCreateInfo: *const ImageCreateInfo,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        pMemoryTypeIndex: *mut u32,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Allocates Vulkan device memory and creates #VmaPool object.\n\n# Arguments\n\n* `allocator` - Allocator object.\n* `pCreateInfo` - Parameters of pool to create.\n* `pPool` (direction out) - Handle to created pool."]
    pub fn vmaCreatePool(
        allocator: VmaAllocator,
        pCreateInfo: *const VmaPoolCreateInfo,
        pPool: *mut VmaPool,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Destroys #VmaPool object and frees Vulkan device memory."]
    pub fn vmaDestroyPool(allocator: VmaAllocator, pool: VmaPool);
}
unsafe extern "C" {
    #[doc = "Retrieves statistics of existing #VmaPool object.\n\n# Arguments\n\n* `allocator` - Allocator object.\n* `pool` - Pool object.\n* `pPoolStats` (direction out) - Statistics of specified pool."]
    pub fn vmaGetPoolStatistics(
        allocator: VmaAllocator,
        pool: VmaPool,
        pPoolStats: *mut VmaStatistics,
    );
}
unsafe extern "C" {
    #[doc = "Retrieves detailed statistics of existing #VmaPool object.\n\n# Arguments\n\n* `allocator` - Allocator object.\n* `pool` - Pool object.\n* `pPoolStats` (direction out) - Statistics of specified pool."]
    pub fn vmaCalculatePoolStatistics(
        allocator: VmaAllocator,
        pool: VmaPool,
        pPoolStats: *mut VmaDetailedStatistics,
    );
}
unsafe extern "C" {
    #[doc = "Checks magic number in margins around all allocations in given memory pool in search for corruptions.\n\nCorruption detection is enabled only when `VMA_DEBUG_DETECT_CORRUPTION` macro is defined to nonzero,\n`VMA_DEBUG_MARGIN` is defined to nonzero and the pool is created in memory type that is\n`HOST_VISIBLE` and `HOST_COHERENT`. For more information, see [Corruption detection](debugging_memory_usage_corruption_detection).\n\nPossible return values:\n\n- `VK_ERROR_FEATURE_NOT_PRESENT` - corruption detection is not enabled for specified pool.\n- `VK_SUCCESS` - corruption detection has been performed and succeeded.\n- `VK_ERROR_UNKNOWN` - corruption detection has been performed and found memory corruptions around one of the allocations.\n`VMA_ASSERT` is also fired in that case.\n- Other value: Error returned by Vulkan, e.g. memory mapping failure."]
    pub fn vmaCheckPoolCorruption(allocator: VmaAllocator, pool: VmaPool) -> Result;
}
unsafe extern "C" {
    #[doc = "Retrieves name of a custom pool.\n\nAfter the call `ppName` is either null or points to an internally-owned null-terminated string\ncontaining name of the pool that was previously set. The pointer becomes invalid when the pool is\ndestroyed or its name is changed using vmaSetPoolName()."]
    pub fn vmaGetPoolName(
        allocator: VmaAllocator,
        pool: VmaPool,
        ppName: *mut *const ::core::ffi::c_char,
    );
}
unsafe extern "C" {
    #[doc = "Sets name of a custom pool.\n\n`pName` can be either null or pointer to a null-terminated string with new name for the pool.\nFunction makes internal copy of the string, so it can be changed or freed immediately after this call."]
    pub fn vmaSetPoolName(
        allocator: VmaAllocator,
        pool: VmaPool,
        pName: *const ::core::ffi::c_char,
    );
}
unsafe extern "C" {
    #[doc = "General purpose memory allocation.\n\n# Arguments\n\n* `allocator` -\n* `pVkMemoryRequirements` -\n* `pCreateInfo` -\n* `pAllocation` (direction out) - Handle to allocated memory.\n* `pAllocationInfo` (direction out) - Optional. Information about allocated memory. It can be later fetched using function vmaGetAllocationInfo().\n\nYou should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().\n\nIt is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),\nvmaCreateBuffer(), vmaCreateImage() instead whenever possible."]
    pub fn vmaAllocateMemory(
        allocator: VmaAllocator,
        pVkMemoryRequirements: *const MemoryRequirements,
        pCreateInfo: *const VmaAllocationCreateInfo,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "General purpose memory allocation for multiple allocation objects at once.\n\n# Arguments\n\n* `allocator` - Allocator object.\n* `pVkMemoryRequirements` - Memory requirements for each allocation.\n* `pCreateInfo` - Creation parameters for each allocation.\n* `allocationCount` - Number of allocations to make.\n* `pAllocations` (direction out) - Pointer to array that will be filled with handles to created allocations.\n* `pAllocationInfo` (direction out) - Optional. Pointer to array that will be filled with parameters of created allocations.\n\nYou should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().\n\nWord \"pages\" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.\nIt is just a general purpose allocation function able to make multiple allocations at once.\nIt may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.\n\nAll allocations are made using same parameters. All of them are created out of the same memory pool and type.\nIf any allocation fails, all allocations already made within this function call are also freed, so that when\nreturned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`."]
    pub fn vmaAllocateMemoryPages(
        allocator: VmaAllocator,
        pVkMemoryRequirements: *const MemoryRequirements,
        pCreateInfo: *const VmaAllocationCreateInfo,
        allocationCount: usize,
        pAllocations: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Allocates memory suitable for given `VkBuffer`.\n\n# Arguments\n\n* `allocator` -\n* `buffer` -\n* `pCreateInfo` -\n* `pAllocation` (direction out) - Handle to allocated memory.\n* `pAllocationInfo` (direction out) - Optional. Information about allocated memory. It can be later fetched using function vmaGetAllocationInfo().\n\nIt only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindBufferMemory().\n\nThis is a special-purpose function. In most cases you should use vmaCreateBuffer().\n\nYou must free the allocation using vmaFreeMemory() when no longer needed."]
    pub fn vmaAllocateMemoryForBuffer(
        allocator: VmaAllocator,
        buffer: Buffer,
        pCreateInfo: *const VmaAllocationCreateInfo,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Allocates memory suitable for given `VkImage`.\n\n# Arguments\n\n* `allocator` -\n* `image` -\n* `pCreateInfo` -\n* `pAllocation` (direction out) - Handle to allocated memory.\n* `pAllocationInfo` (direction out) - Optional. Information about allocated memory. It can be later fetched using function vmaGetAllocationInfo().\n\nIt only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindImageMemory().\n\nThis is a special-purpose function. In most cases you should use vmaCreateImage().\n\nYou must free the allocation using vmaFreeMemory() when no longer needed."]
    pub fn vmaAllocateMemoryForImage(
        allocator: VmaAllocator,
        image: Image,
        pCreateInfo: *const VmaAllocationCreateInfo,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Frees memory previously allocated using vmaAllocateMemory(), vmaAllocateMemoryForBuffer(), or vmaAllocateMemoryForImage().\n\nPassing `VK_NULL_HANDLE` as `allocation` is valid. Such function call is just skipped."]
    pub fn vmaFreeMemory(allocator: VmaAllocator, allocation: VmaAllocation);
}
unsafe extern "C" {
    #[doc = "Frees memory and destroys multiple allocations.\n\nWord \"pages\" is just a suggestion to use this function to free pieces of memory used for sparse binding.\nIt is just a general purpose function to free memory and destroy allocations made using e.g. vmaAllocateMemory(),\nvmaAllocateMemoryPages() and other functions.\nIt may be internally optimized to be more efficient than calling vmaFreeMemory() `allocationCount` times.\n\nAllocations in `pAllocations` array can come from any memory pools and types.\nPassing `VK_NULL_HANDLE` as elements of `pAllocations` array is valid. Such entries are just skipped."]
    pub fn vmaFreeMemoryPages(
        allocator: VmaAllocator,
        allocationCount: usize,
        pAllocations: *const *mut VmaAllocation_T,
    );
}
unsafe extern "C" {
    #[doc = "Returns current information about specified allocation.\n\nCurrent parameters of given allocation are returned in `pAllocationInfo`.\n\nAlthough this function doesn't lock any mutex, so it should be quite efficient,\nyou should avoid calling it too often.\nYou can retrieve same VmaAllocationInfo structure while creating your resource, from function\nvmaCreateBuffer(), vmaCreateImage(). You can remember it if you are sure parameters don't change\n(e.g. due to defragmentation).\n\nThere is also a new function vmaGetAllocationInfo2() that offers extended information\nabout the allocation, returned using new structure #VmaAllocationInfo2."]
    pub fn vmaGetAllocationInfo(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    );
}
unsafe extern "C" {
    #[doc = "Returns extended information about specified allocation.\n\nCurrent parameters of given allocation are returned in `pAllocationInfo`.\nExtended parameters in structure #VmaAllocationInfo2 include memory block size\nand a flag telling whether the allocation has dedicated memory.\nIt can be useful e.g. for interop with OpenGL."]
    pub fn vmaGetAllocationInfo2(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo2,
    );
}
unsafe extern "C" {
    #[doc = "Sets pUserData in given allocation to new value.\n\nThe value of pointer `pUserData` is copied to allocation's `pUserData`.\nIt is opaque, so you can use it however you want - e.g.\nas a pointer, ordinal number or some handle to you own data."]
    pub fn vmaSetAllocationUserData(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        pUserData: *mut ::core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Sets pName in given allocation to new value.\n\n`pName` must be either null, or pointer to a null-terminated string. The function\nmakes local copy of the string and sets it as allocation's `pName`. String\npassed as pName doesn't need to be valid for whole lifetime of the allocation -\nyou can free it after this call. String previously pointed by allocation's\n`pName` is freed from memory."]
    pub fn vmaSetAllocationName(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        pName: *const ::core::ffi::c_char,
    );
}
unsafe extern "C" {
    #[doc = "Given an allocation, returns Property Flags of its memory type.\n\nThis is just a convenience function. Same information can be obtained using\nvmaGetAllocationInfo() + vmaGetMemoryProperties()."]
    pub fn vmaGetAllocationMemoryProperties(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        pFlags: *mut MemoryPropertyFlags,
    );
}
unsafe extern "C" {
    #[doc = "Maps memory represented by given allocation and returns pointer to it.\n\nMaps memory represented by given allocation to make it accessible to CPU code.\nWhen succeeded, `*ppData` contains pointer to first byte of this memory.\n\nIf the allocation is part of a bigger `VkDeviceMemory` block, returned pointer is\ncorrectly offsetted to the beginning of region assigned to this particular allocation.\nUnlike the result of `vkMapMemory`, it points to the allocation, not to the beginning of the whole block.\nYou should not add VmaAllocationInfo::offset to it!\n\nMapping is internally reference-counted and synchronized, so despite raw Vulkan\nfunction `vkMapMemory()` cannot be used to map same block of `VkDeviceMemory`\nmultiple times simultaneously, it is safe to call this function on allocations\nassigned to the same memory block. Actual Vulkan memory will be mapped on first\nmapping and unmapped on last unmapping.\n\nIf the function succeeded, you must call vmaUnmapMemory() to unmap the\nallocation when mapping is no longer needed or before freeing the allocation, at\nthe latest.\n\nIt also safe to call this function multiple times on the same allocation. You\nmust call vmaUnmapMemory() same number of times as you called vmaMapMemory().\n\nIt is also safe to call this function on allocation created with\n#VMA_ALLOCATION_CREATE_MAPPED_BIT flag. Its memory stays mapped all the time.\nYou must still call vmaUnmapMemory() same number of times as you called\nvmaMapMemory(). You must not call vmaUnmapMemory() additional time to free the\n\"0-th\" mapping made automatically due to #VMA_ALLOCATION_CREATE_MAPPED_BIT flag.\n\nThis function fails when used on allocation made in memory type that is not\n`HOST_VISIBLE`.\n\nThis function doesn't automatically flush or invalidate caches.\nIf the allocation is made from a memory types that is not `HOST_COHERENT`,\nyou also need to use vmaInvalidateAllocation() / vmaFlushAllocation(), as required by Vulkan specification."]
    pub fn vmaMapMemory(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        ppData: *mut *mut ::core::ffi::c_void,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Unmaps memory represented by given allocation, mapped previously using vmaMapMemory().\n\nFor details, see description of vmaMapMemory().\n\nThis function doesn't automatically flush or invalidate caches.\nIf the allocation is made from a memory types that is not `HOST_COHERENT`,\nyou also need to use vmaInvalidateAllocation() / vmaFlushAllocation(), as required by Vulkan specification."]
    pub fn vmaUnmapMemory(allocator: VmaAllocator, allocation: VmaAllocation);
}
unsafe extern "C" {
    #[doc = "Flushes memory of given allocation.\n\nCalls `vkFlushMappedMemoryRanges()` for memory associated with given range of given allocation.\nIt needs to be called after writing to a mapped memory for memory types that are not `HOST_COHERENT`.\nUnmap operation doesn't do that automatically.\n\n- `offset` must be relative to the beginning of allocation.\n- `size` can be `VK_WHOLE_SIZE`. It means all memory from `offset` the the end of given allocation.\n- `offset` and `size` don't have to be aligned.\nThey are internally rounded down/up to multiply of `nonCoherentAtomSize`.\n- If `size` is 0, this call is ignored.\n- If memory type that the `allocation` belongs to is not `HOST_VISIBLE` or it is `HOST_COHERENT`,\nthis call is ignored.\n\nWarning! `offset` and `size` are relative to the contents of given `allocation`.\nIf you mean whole allocation, you can pass 0 and `VK_WHOLE_SIZE`, respectively.\nDo not pass allocation's offset as `offset`!!!\n\nThis function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is\ncalled, otherwise `VK_SUCCESS`."]
    pub fn vmaFlushAllocation(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        offset: DeviceSize,
        size: DeviceSize,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Invalidates memory of given allocation.\n\nCalls `vkInvalidateMappedMemoryRanges()` for memory associated with given range of given allocation.\nIt needs to be called before reading from a mapped memory for memory types that are not `HOST_COHERENT`.\nMap operation doesn't do that automatically.\n\n- `offset` must be relative to the beginning of allocation.\n- `size` can be `VK_WHOLE_SIZE`. It means all memory from `offset` the the end of given allocation.\n- `offset` and `size` don't have to be aligned.\nThey are internally rounded down/up to multiply of `nonCoherentAtomSize`.\n- If `size` is 0, this call is ignored.\n- If memory type that the `allocation` belongs to is not `HOST_VISIBLE` or it is `HOST_COHERENT`,\nthis call is ignored.\n\nWarning! `offset` and `size` are relative to the contents of given `allocation`.\nIf you mean whole allocation, you can pass 0 and `VK_WHOLE_SIZE`, respectively.\nDo not pass allocation's offset as `offset`!!!\n\nThis function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if\nit is called, otherwise `VK_SUCCESS`."]
    pub fn vmaInvalidateAllocation(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        offset: DeviceSize,
        size: DeviceSize,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Flushes memory of given set of allocations.\n\nCalls `vkFlushMappedMemoryRanges()` for memory associated with given ranges of given allocations.\nFor more information, see documentation of vmaFlushAllocation().\n\n# Arguments\n\n* `allocator` -\n* `allocationCount` -\n* `allocations` -\n* `offsets` - If not null, it must point to an array of offsets of regions to flush, relative to the beginning of respective allocations. Null means all offsets are zero.\n* `sizes` - If not null, it must point to an array of sizes of regions to flush in respective allocations. Null means `VK_WHOLE_SIZE` for all allocations.\n\nThis function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is\ncalled, otherwise `VK_SUCCESS`."]
    pub fn vmaFlushAllocations(
        allocator: VmaAllocator,
        allocationCount: u32,
        allocations: *const *mut VmaAllocation_T,
        offsets: *const DeviceSize,
        sizes: *const DeviceSize,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Invalidates memory of given set of allocations.\n\nCalls `vkInvalidateMappedMemoryRanges()` for memory associated with given ranges of given allocations.\nFor more information, see documentation of vmaInvalidateAllocation().\n\n# Arguments\n\n* `allocator` -\n* `allocationCount` -\n* `allocations` -\n* `offsets` - If not null, it must point to an array of offsets of regions to flush, relative to the beginning of respective allocations. Null means all offsets are zero.\n* `sizes` - If not null, it must point to an array of sizes of regions to flush in respective allocations. Null means `VK_WHOLE_SIZE` for all allocations.\n\nThis function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is\ncalled, otherwise `VK_SUCCESS`."]
    pub fn vmaInvalidateAllocations(
        allocator: VmaAllocator,
        allocationCount: u32,
        allocations: *const *mut VmaAllocation_T,
        offsets: *const DeviceSize,
        sizes: *const DeviceSize,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Maps the allocation temporarily if needed, copies data from specified host pointer to it, and flushes the memory from the host caches if needed.\n\n# Arguments\n\n* `allocator` -\n* `pSrcHostPointer` - Pointer to the host data that become source of the copy.\n* `dstAllocation` - Handle to the allocation that becomes destination of the copy.\n* `dstAllocationLocalOffset` - Offset within `dstAllocation` where to write copied data, in bytes.\n* `size` - Number of bytes to copy.\n\nThis is a convenience function that allows to copy data from a host pointer to an allocation easily.\nSame behavior can be achieved by calling vmaMapMemory(), `memcpy()`, vmaUnmapMemory(), vmaFlushAllocation().\n\nThis function can be called only for allocations created in a memory type that has `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` flag.\nIt can be ensured e.g. by using #VMA_MEMORY_USAGE_AUTO and #VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT or\n#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT.\nOtherwise, the function will fail and generate a Validation Layers error.\n\n`dstAllocationLocalOffset` is relative to the contents of given `dstAllocation`.\nIf you mean whole allocation, you should pass 0.\nDo not pass allocation's offset within device memory block this parameter!"]
    pub fn vmaCopyMemoryToAllocation(
        allocator: VmaAllocator,
        pSrcHostPointer: *const ::core::ffi::c_void,
        dstAllocation: VmaAllocation,
        dstAllocationLocalOffset: DeviceSize,
        size: DeviceSize,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Invalidates memory in the host caches if needed, maps the allocation temporarily if needed, and copies data from it to a specified host pointer.\n\n# Arguments\n\n* `allocator` -\n* `srcAllocation` - Handle to the allocation that becomes source of the copy.\n* `srcAllocationLocalOffset` - Offset within `srcAllocation` where to read copied data, in bytes.\n* `pDstHostPointer` - Pointer to the host memory that become destination of the copy.\n* `size` - Number of bytes to copy.\n\nThis is a convenience function that allows to copy data from an allocation to a host pointer easily.\nSame behavior can be achieved by calling vmaInvalidateAllocation(), vmaMapMemory(), `memcpy()`, vmaUnmapMemory().\n\nThis function should be called only for allocations created in a memory type that has `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT`\nand `VK_MEMORY_PROPERTY_HOST_CACHED_BIT` flag.\nIt can be ensured e.g. by using #VMA_MEMORY_USAGE_AUTO and #VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT.\nOtherwise, the function may fail and generate a Validation Layers error.\nIt may also work very slowly when reading from an uncached memory.\n\n`srcAllocationLocalOffset` is relative to the contents of given `srcAllocation`.\nIf you mean whole allocation, you should pass 0.\nDo not pass allocation's offset within device memory block as this parameter!"]
    pub fn vmaCopyAllocationToMemory(
        allocator: VmaAllocator,
        srcAllocation: VmaAllocation,
        srcAllocationLocalOffset: DeviceSize,
        pDstHostPointer: *mut ::core::ffi::c_void,
        size: DeviceSize,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Checks magic number in margins around all allocations in given memory types (in both default and custom pools) in search for corruptions.\n\n# Arguments\n\n* `allocator` -\n* `memoryTypeBits` - Bit mask, where each bit set means that a memory type with that index should be checked.\n\nCorruption detection is enabled only when `VMA_DEBUG_DETECT_CORRUPTION` macro is defined to nonzero,\n`VMA_DEBUG_MARGIN` is defined to nonzero and only for memory types that are\n`HOST_VISIBLE` and `HOST_COHERENT`. For more information, see [Corruption detection](debugging_memory_usage_corruption_detection).\n\nPossible return values:\n\n- `VK_ERROR_FEATURE_NOT_PRESENT` - corruption detection is not enabled for any of specified memory types.\n- `VK_SUCCESS` - corruption detection has been performed and succeeded.\n- `VK_ERROR_UNKNOWN` - corruption detection has been performed and found memory corruptions around one of the allocations.\n`VMA_ASSERT` is also fired in that case.\n- Other value: Error returned by Vulkan, e.g. memory mapping failure."]
    pub fn vmaCheckCorruption(allocator: VmaAllocator, memoryTypeBits: u32) -> Result;
}
unsafe extern "C" {
    #[doc = "Begins defragmentation process.\n\n# Arguments\n\n* `allocator` - Allocator object.\n* `pInfo` - Structure filled with parameters of defragmentation.\n* `pContext` (direction out) - Context object that must be passed to vmaEndDefragmentation() to finish defragmentation.\n# Returns\n\n- `VK_SUCCESS` if defragmentation can begin.\n- `VK_ERROR_FEATURE_NOT_PRESENT` if defragmentation is not supported.\n\nFor more information about defragmentation, see documentation chapter:\n[Defragmentation](defragmentation)."]
    pub fn vmaBeginDefragmentation(
        allocator: VmaAllocator,
        pInfo: *const VmaDefragmentationInfo,
        pContext: *mut VmaDefragmentationContext,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Ends defragmentation process.\n\n# Arguments\n\n* `allocator` - Allocator object.\n* `context` - Context object that has been created by vmaBeginDefragmentation().\n* `pStats` (direction out) - Optional stats for the defragmentation. Can be null.\n\nUse this function to finish defragmentation started by vmaBeginDefragmentation()."]
    pub fn vmaEndDefragmentation(
        allocator: VmaAllocator,
        context: VmaDefragmentationContext,
        pStats: *mut VmaDefragmentationStats,
    );
}
unsafe extern "C" {
    #[doc = "Starts single defragmentation pass.\n\n# Arguments\n\n* `allocator` - Allocator object.\n* `context` - Context object that has been created by vmaBeginDefragmentation().\n* `pPassInfo` (direction out) - Computed information for current pass.\n# Returns\n\n- `VK_SUCCESS` if no more moves are possible. Then you can omit call to vmaEndDefragmentationPass() and simply end whole defragmentation.\n- `VK_INCOMPLETE` if there are pending moves returned in `pPassInfo`. You need to perform them, call vmaEndDefragmentationPass(),\nand then preferably try another pass with vmaBeginDefragmentationPass()."]
    pub fn vmaBeginDefragmentationPass(
        allocator: VmaAllocator,
        context: VmaDefragmentationContext,
        pPassInfo: *mut VmaDefragmentationPassMoveInfo,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Ends single defragmentation pass.\n\n# Arguments\n\n* `allocator` - Allocator object.\n* `context` - Context object that has been created by vmaBeginDefragmentation().\n* `pPassInfo` - Computed information for current pass filled by vmaBeginDefragmentationPass() and possibly modified by you.\n\nReturns `VK_SUCCESS` if no more moves are possible or `VK_INCOMPLETE` if more defragmentations are possible.\n\nEnds incremental defragmentation pass and commits all defragmentation moves from `pPassInfo`.\nAfter this call:\n\n- Allocations at `pPassInfo[i].srcAllocation` that had `pPassInfo[i].operation ==` #VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY\n(which is the default) will be pointing to the new destination place.\n- Allocation at `pPassInfo[i].srcAllocation` that had `pPassInfo[i].operation ==` #VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY\nwill be freed.\n\nIf no more moves are possible you can end whole defragmentation."]
    pub fn vmaEndDefragmentationPass(
        allocator: VmaAllocator,
        context: VmaDefragmentationContext,
        pPassInfo: *mut VmaDefragmentationPassMoveInfo,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Binds buffer to allocation.\n\nBinds specified buffer to region of memory represented by specified allocation.\nGets `VkDeviceMemory` handle and offset from the allocation.\nIf you want to create a buffer, allocate memory for it and bind them together separately,\nyou should use this function for binding instead of standard `vkBindBufferMemory()`,\nbecause it ensures proper synchronization so that when a `VkDeviceMemory` object is used by multiple\nallocations, calls to `vkBind*Memory()` or `vkMapMemory()` won't happen from multiple threads simultaneously\n(which is illegal in Vulkan).\n\nIt is recommended to use function vmaCreateBuffer() instead of this one."]
    pub fn vmaBindBufferMemory(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        buffer: Buffer,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Binds buffer to allocation with additional parameters.\n\n# Arguments\n\n* `allocator` -\n* `allocation` -\n* `allocationLocalOffset` - Additional offset to be added while binding, relative to the beginning of the `allocation`. Normally it should be 0.\n* `buffer` -\n* `pNext` - A chain of structures to be attached to `VkBindBufferMemoryInfoKHR` structure used internally. Normally it should be null.\n\nThis function is similar to vmaBindBufferMemory(), but it provides additional parameters.\n\nIf `pNext` is not null, #VmaAllocator object must have been created with #VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT flag\nor with VmaAllocatorCreateInfo::vulkanApiVersion `>= VK_API_VERSION_1_1`. Otherwise the call fails."]
    pub fn vmaBindBufferMemory2(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        allocationLocalOffset: DeviceSize,
        buffer: Buffer,
        pNext: *const ::core::ffi::c_void,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Binds image to allocation.\n\nBinds specified image to region of memory represented by specified allocation.\nGets `VkDeviceMemory` handle and offset from the allocation.\nIf you want to create an image, allocate memory for it and bind them together separately,\nyou should use this function for binding instead of standard `vkBindImageMemory()`,\nbecause it ensures proper synchronization so that when a `VkDeviceMemory` object is used by multiple\nallocations, calls to `vkBind*Memory()` or `vkMapMemory()` won't happen from multiple threads simultaneously\n(which is illegal in Vulkan).\n\nIt is recommended to use function vmaCreateImage() instead of this one."]
    pub fn vmaBindImageMemory(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        image: Image,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Binds image to allocation with additional parameters.\n\n# Arguments\n\n* `allocator` -\n* `allocation` -\n* `allocationLocalOffset` - Additional offset to be added while binding, relative to the beginning of the `allocation`. Normally it should be 0.\n* `image` -\n* `pNext` - A chain of structures to be attached to `VkBindImageMemoryInfoKHR` structure used internally. Normally it should be null.\n\nThis function is similar to vmaBindImageMemory(), but it provides additional parameters.\n\nIf `pNext` is not null, #VmaAllocator object must have been created with #VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT flag\nor with VmaAllocatorCreateInfo::vulkanApiVersion `>= VK_API_VERSION_1_1`. Otherwise the call fails."]
    pub fn vmaBindImageMemory2(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        allocationLocalOffset: DeviceSize,
        image: Image,
        pNext: *const ::core::ffi::c_void,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Creates a new `VkBuffer`, allocates and binds memory for it.\n\n# Arguments\n\n* `allocator` -\n* `pBufferCreateInfo` -\n* `pAllocationCreateInfo` -\n* `pBuffer` (direction out) - Buffer that was created.\n* `pAllocation` (direction out) - Allocation that was created.\n* `pAllocationInfo` (direction out) - Optional. Information about allocated memory. It can be later fetched using function vmaGetAllocationInfo().\n\nThis function automatically:\n\n-# Creates buffer.\n-# Allocates appropriate memory for it.\n-# Binds the buffer with the memory.\n\nIf any of these operations fail, buffer and allocation are not created,\nreturned value is negative error code, `*pBuffer` and `*pAllocation` are null.\n\nIf the function succeeded, you must destroy both buffer and allocation when you\nno longer need them using either convenience function vmaDestroyBuffer() or\nseparately, using `vkDestroyBuffer()` and vmaFreeMemory().\n\nIf #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,\nVK_KHR_dedicated_allocation extension is used internally to query driver whether\nit requires or prefers the new buffer to have dedicated allocation. If yes,\nand if dedicated allocation is possible\n(#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated\nallocation for this buffer, just like when using\n#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.\n\n> **Note:** This function creates a new `VkBuffer`. Sub-allocation of parts of one large buffer,\nalthough recommended as a good practice, is out of scope of this library and could be implemented\nby the user as a higher-level logic on top of VMA."]
    pub fn vmaCreateBuffer(
        allocator: VmaAllocator,
        pBufferCreateInfo: *const BufferCreateInfo,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        pBuffer: *mut Buffer,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Creates a buffer with additional minimum alignment.\n\nSimilar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,\nminimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.\nfor interop with OpenGL."]
    pub fn vmaCreateBufferWithAlignment(
        allocator: VmaAllocator,
        pBufferCreateInfo: *const BufferCreateInfo,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        minAlignment: DeviceSize,
        pBuffer: *mut Buffer,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Creates a new `VkBuffer`, binds already created memory for it.\n\n# Arguments\n\n* `allocator` -\n* `allocation` - Allocation that provides memory to be used for binding new buffer to it.\n* `pBufferCreateInfo` -\n* `pBuffer` (direction out) - Buffer that was created.\n\nThis function automatically:\n\n-# Creates buffer.\n-# Binds the buffer with the supplied memory.\n\nIf any of these operations fail, buffer is not created,\nreturned value is negative error code and `*pBuffer` is null.\n\nIf the function succeeded, you must destroy the buffer when you\nno longer need it using `vkDestroyBuffer()`. If you want to also destroy the corresponding\nallocation you can use convenience function vmaDestroyBuffer().\n\n> **Note:** There is a new version of this function augmented with parameter `allocationLocalOffset` - see vmaCreateAliasingBuffer2()."]
    pub fn vmaCreateAliasingBuffer(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        pBufferCreateInfo: *const BufferCreateInfo,
        pBuffer: *mut Buffer,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Creates a new `VkBuffer`, binds already created memory for it.\n\n# Arguments\n\n* `allocator` -\n* `allocation` - Allocation that provides memory to be used for binding new buffer to it.\n* `allocationLocalOffset` - Additional offset to be added while binding, relative to the beginning of the allocation. Normally it should be 0.\n* `pBufferCreateInfo` -\n* `pBuffer` (direction out) - Buffer that was created.\n\nThis function automatically:\n\n-# Creates buffer.\n-# Binds the buffer with the supplied memory.\n\nIf any of these operations fail, buffer is not created,\nreturned value is negative error code and `*pBuffer` is null.\n\nIf the function succeeded, you must destroy the buffer when you\nno longer need it using `vkDestroyBuffer()`. If you want to also destroy the corresponding\nallocation you can use convenience function vmaDestroyBuffer().\n\n> **Note:** This is a new version of the function augmented with parameter `allocationLocalOffset`."]
    pub fn vmaCreateAliasingBuffer2(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        allocationLocalOffset: DeviceSize,
        pBufferCreateInfo: *const BufferCreateInfo,
        pBuffer: *mut Buffer,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Destroys Vulkan buffer and frees allocated memory.\n\nThis is just a convenience function equivalent to:\n\nvkDestroyBuffer(device, buffer, allocationCallbacks);\nvmaFreeMemory(allocator, allocation);\nIt is safe to pass null as buffer and/or allocation."]
    pub fn vmaDestroyBuffer(allocator: VmaAllocator, buffer: Buffer, allocation: VmaAllocation);
}
unsafe extern "C" {
    #[doc = "Function similar to vmaCreateBuffer()."]
    pub fn vmaCreateImage(
        allocator: VmaAllocator,
        pImageCreateInfo: *const ImageCreateInfo,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        pImage: *mut Image,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Function similar to vmaCreateAliasingBuffer() but for images."]
    pub fn vmaCreateAliasingImage(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        pImageCreateInfo: *const ImageCreateInfo,
        pImage: *mut Image,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Function similar to vmaCreateAliasingBuffer2() but for images."]
    pub fn vmaCreateAliasingImage2(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        allocationLocalOffset: DeviceSize,
        pImageCreateInfo: *const ImageCreateInfo,
        pImage: *mut Image,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Destroys Vulkan image and frees allocated memory.\n\nThis is just a convenience function equivalent to:\n\nvkDestroyImage(device, image, allocationCallbacks);\nvmaFreeMemory(allocator, allocation);\nIt is safe to pass null as image and/or allocation."]
    pub fn vmaDestroyImage(allocator: VmaAllocator, image: Image, allocation: VmaAllocation);
}
unsafe extern "C" {
    #[doc = "Creates new #VmaVirtualBlock object.\n\n# Arguments\n\n* `pCreateInfo` - Parameters for creation.\n* `pVirtualBlock` (direction out) - Returned virtual block object or `VMA_NULL` if creation failed."]
    pub fn vmaCreateVirtualBlock(
        pCreateInfo: *const VmaVirtualBlockCreateInfo,
        pVirtualBlock: *mut VmaVirtualBlock,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Destroys #VmaVirtualBlock object.\n\nPlease note that you should consciously handle virtual allocations that could remain unfreed in the block.\nYou should either free them individually using vmaVirtualFree() or call vmaClearVirtualBlock()\nif you are sure this is what you want. If you do neither, an assert is called.\n\nIf you keep pointers to some additional metadata associated with your virtual allocations in their `pUserData`,\ndon't forget to free them."]
    pub fn vmaDestroyVirtualBlock(virtualBlock: VmaVirtualBlock);
}
unsafe extern "C" {
    #[doc = "Returns true of the #VmaVirtualBlock is empty - contains 0 virtual allocations and has all its space available for new allocations."]
    pub fn vmaIsVirtualBlockEmpty(virtualBlock: VmaVirtualBlock) -> Bool32;
}
unsafe extern "C" {
    #[doc = "Returns information about a specific virtual allocation within a virtual block, like its size and `pUserData` pointer."]
    pub fn vmaGetVirtualAllocationInfo(
        virtualBlock: VmaVirtualBlock,
        allocation: VmaVirtualAllocation,
        pVirtualAllocInfo: *mut VmaVirtualAllocationInfo,
    );
}
unsafe extern "C" {
    #[doc = "Allocates new virtual allocation inside given #VmaVirtualBlock.\n\nIf the allocation fails due to not enough free space available, `VK_ERROR_OUT_OF_DEVICE_MEMORY` is returned\n(despite the function doesn't ever allocate actual GPU memory).\n`pAllocation` is then set to `VK_NULL_HANDLE` and `pOffset`, if not null, it set to `UINT64_MAX`.\n\n# Arguments\n\n* `virtualBlock` - Virtual block\n* `pCreateInfo` - Parameters for the allocation\n* `pAllocation` (direction out) - Returned handle of the new allocation\n* `pOffset` (direction out) - Returned offset of the new allocation. Optional, can be null."]
    pub fn vmaVirtualAllocate(
        virtualBlock: VmaVirtualBlock,
        pCreateInfo: *const VmaVirtualAllocationCreateInfo,
        pAllocation: *mut VmaVirtualAllocation,
        pOffset: *mut DeviceSize,
    ) -> Result;
}
unsafe extern "C" {
    #[doc = "Frees virtual allocation inside given #VmaVirtualBlock.\n\nIt is correct to call this function with `allocation == VK_NULL_HANDLE` - it does nothing."]
    pub fn vmaVirtualFree(virtualBlock: VmaVirtualBlock, allocation: VmaVirtualAllocation);
}
unsafe extern "C" {
    #[doc = "Frees all virtual allocations inside given #VmaVirtualBlock.\n\nYou must either call this function or free each virtual allocation individually with vmaVirtualFree()\nbefore destroying a virtual block. Otherwise, an assert is called.\n\nIf you keep pointer to some additional metadata associated with your virtual allocation in its `pUserData`,\ndon't forget to free it as well."]
    pub fn vmaClearVirtualBlock(virtualBlock: VmaVirtualBlock);
}
unsafe extern "C" {
    #[doc = "Changes custom pointer associated with given virtual allocation."]
    pub fn vmaSetVirtualAllocationUserData(
        virtualBlock: VmaVirtualBlock,
        allocation: VmaVirtualAllocation,
        pUserData: *mut ::core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Calculates and returns statistics about virtual allocations and memory usage in given #VmaVirtualBlock.\n\nThis function is fast to call. For more detailed statistics, see vmaCalculateVirtualBlockStatistics()."]
    pub fn vmaGetVirtualBlockStatistics(virtualBlock: VmaVirtualBlock, pStats: *mut VmaStatistics);
}
unsafe extern "C" {
    #[doc = "Calculates and returns detailed statistics about virtual allocations and memory usage in given #VmaVirtualBlock.\n\nThis function is slow to call. Use for debugging purposes.\nFor less detailed statistics, see vmaGetVirtualBlockStatistics()."]
    pub fn vmaCalculateVirtualBlockStatistics(
        virtualBlock: VmaVirtualBlock,
        pStats: *mut VmaDetailedStatistics,
    );
}
unsafe extern "C" {
    #[doc = "Builds and returns a null-terminated string in JSON format with information about given #VmaVirtualBlock.\n# Arguments\n\n* `virtualBlock` - Virtual block.\n* `ppStatsString` (direction out) - Returned string.\n* `detailedMap` - Pass `VK_FALSE` to only obtain statistics as returned by vmaCalculateVirtualBlockStatistics(). Pass `VK_TRUE` to also obtain full list of allocations and free spaces.\n\nReturned string must be freed using vmaFreeVirtualBlockStatsString()."]
    pub fn vmaBuildVirtualBlockStatsString(
        virtualBlock: VmaVirtualBlock,
        ppStatsString: *mut *mut ::core::ffi::c_char,
        detailedMap: Bool32,
    );
}
unsafe extern "C" {
    #[doc = "Frees a string returned by vmaBuildVirtualBlockStatsString()."]
    pub fn vmaFreeVirtualBlockStatsString(
        virtualBlock: VmaVirtualBlock,
        pStatsString: *mut ::core::ffi::c_char,
    );
}
unsafe extern "C" {
    #[doc = "Builds and returns statistics as a null-terminated string in JSON format.\n# Arguments\n\n* `allocator` -\n* `ppStatsString` (direction out) - Must be freed using vmaFreeStatsString() function.\n* `detailedMap` -"]
    pub fn vmaBuildStatsString(
        allocator: VmaAllocator,
        ppStatsString: *mut *mut ::core::ffi::c_char,
        detailedMap: Bool32,
    );
}
unsafe extern "C" {
    pub fn vmaFreeStatsString(allocator: VmaAllocator, pStatsString: *mut ::core::ffi::c_char);
}
