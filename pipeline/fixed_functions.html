<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Fixed functions - Vulkan Tutorial (Rust)</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A Vulkan tutorial for Rust.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../overview.html"><strong aria-hidden="true">2.</strong> Overview</a></li><li class="chapter-item expanded "><a href="../development_environment.html"><strong aria-hidden="true">3.</strong> Development environment</a></li><li class="chapter-item expanded "><a href="../faq.html"><strong aria-hidden="true">4.</strong> FAQ</a></li><li class="chapter-item expanded affix "><li class="part-title">Setup</li><li class="chapter-item expanded "><a href="../setup/base_code.html"><strong aria-hidden="true">5.</strong> Base code</a></li><li class="chapter-item expanded "><a href="../setup/instance.html"><strong aria-hidden="true">6.</strong> Instance</a></li><li class="chapter-item expanded "><a href="../setup/validation_layers.html"><strong aria-hidden="true">7.</strong> Validation layers</a></li><li class="chapter-item expanded "><a href="../setup/physical_devices_and_queue_families.html"><strong aria-hidden="true">8.</strong> Physical devices and queue families</a></li><li class="chapter-item expanded "><a href="../setup/logical_device_and_queues.html"><strong aria-hidden="true">9.</strong> Logical device and queues</a></li><li class="chapter-item expanded affix "><li class="part-title">Presentation</li><li class="chapter-item expanded "><a href="../presentation/window_surface.html"><strong aria-hidden="true">10.</strong> Window surface</a></li><li class="chapter-item expanded "><a href="../presentation/swapchain.html"><strong aria-hidden="true">11.</strong> Swapchain</a></li><li class="chapter-item expanded "><a href="../presentation/image_views.html"><strong aria-hidden="true">12.</strong> Image views</a></li><li class="chapter-item expanded affix "><li class="part-title">Pipeline</li><li class="chapter-item expanded "><a href="../pipeline/introduction.html"><strong aria-hidden="true">13.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../pipeline/shader_modules.html"><strong aria-hidden="true">14.</strong> Shader modules</a></li><li class="chapter-item expanded "><a href="../pipeline/fixed_functions.html" class="active"><strong aria-hidden="true">15.</strong> Fixed functions</a></li><li class="chapter-item expanded "><a href="../pipeline/render_passes.html"><strong aria-hidden="true">16.</strong> Render passes</a></li><li class="chapter-item expanded "><a href="../pipeline/conclusion.html"><strong aria-hidden="true">17.</strong> Conclusion</a></li><li class="chapter-item expanded affix "><li class="part-title">Drawing</li><li class="chapter-item expanded "><a href="../drawing/framebuffers.html"><strong aria-hidden="true">18.</strong> Framebuffers</a></li><li class="chapter-item expanded "><a href="../drawing/command_buffers.html"><strong aria-hidden="true">19.</strong> Command buffers</a></li><li class="chapter-item expanded "><a href="../drawing/rendering_and_presentation.html"><strong aria-hidden="true">20.</strong> Rendering and presentation</a></li><li class="chapter-item expanded affix "><li class="part-title">Swapchain</li><li class="chapter-item expanded "><a href="../swapchain/recreation.html"><strong aria-hidden="true">21.</strong> Recreation</a></li><li class="chapter-item expanded affix "><li class="part-title">Vertex buffers</li><li class="chapter-item expanded "><a href="../vertex/vertex_input_description.html"><strong aria-hidden="true">22.</strong> Vertex input description</a></li><li class="chapter-item expanded "><a href="../vertex/vertex_buffer_creation.html"><strong aria-hidden="true">23.</strong> Vertex buffer creation</a></li><li class="chapter-item expanded "><a href="../vertex/staging_buffer.html"><strong aria-hidden="true">24.</strong> Staging buffer</a></li><li class="chapter-item expanded "><a href="../vertex/index_buffer.html"><strong aria-hidden="true">25.</strong> Index buffer</a></li><li class="chapter-item expanded affix "><li class="part-title">Uniform buffers</li><li class="chapter-item expanded "><a href="../uniform/descriptor_set_layout_and_buffer.html"><strong aria-hidden="true">26.</strong> Descriptor set layout and buffer</a></li><li class="chapter-item expanded "><a href="../uniform/descriptor_pool_and_sets.html"><strong aria-hidden="true">27.</strong> Descriptor pool and sets</a></li><li class="chapter-item expanded affix "><li class="part-title">Texture mapping</li><li class="chapter-item expanded "><a href="../texture/images.html"><strong aria-hidden="true">28.</strong> Images</a></li><li class="chapter-item expanded "><a href="../texture/image_view_and_sampler.html"><strong aria-hidden="true">29.</strong> Image view and sampler</a></li><li class="chapter-item expanded "><a href="../texture/combined_image_sampler.html"><strong aria-hidden="true">30.</strong> Combined image sampler</a></li><li class="chapter-item expanded affix "><li class="part-title">Model</li><li class="chapter-item expanded "><a href="../model/depth_buffering.html"><strong aria-hidden="true">31.</strong> Depth buffering</a></li><li class="chapter-item expanded "><a href="../model/loading_models.html"><strong aria-hidden="true">32.</strong> Loading models</a></li><li class="chapter-item expanded affix "><li class="part-title">Rendering quality</li><li class="chapter-item expanded "><a href="../quality/generating_mipmaps.html"><strong aria-hidden="true">33.</strong> Generating mipmaps</a></li><li class="chapter-item expanded "><a href="../quality/multisampling.html"><strong aria-hidden="true">34.</strong> Multisampling</a></li><li class="chapter-item expanded affix "><li class="part-title">Dynamic scenes</li><li class="chapter-item expanded "><a href="../dynamic/push_constants.html"><strong aria-hidden="true">35.</strong> Push constants</a></li><li class="chapter-item expanded "><a href="../dynamic/recycling_command_buffers.html"><strong aria-hidden="true">36.</strong> Recycling command buffers</a></li><li class="chapter-item expanded "><a href="../dynamic/secondary_command_buffers.html"><strong aria-hidden="true">37.</strong> Secondary command buffers</a></li><li class="chapter-item expanded affix "><li class="part-title">Conclusion</li><li class="chapter-item expanded "><a href="../conclusion.html"><strong aria-hidden="true">38.</strong> Conclusion</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Vulkan Tutorial (Rust)</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/KyleMayes/vulkanalia" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="fixed-functions"><a class="header" href="#fixed-functions">Fixed functions</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/10_fixed_functions.rs">main.rs</a></p>
<p>The older graphics APIs provided default state for most of the stages of the graphics pipeline. In Vulkan you have to be explicit about everything, from viewport size to color blending function. In this chapter we'll fill in all of the structures to configure these fixed-function operations.</p>
<h2 id="vertex-input"><a class="header" href="#vertex-input">Vertex input</a></h2>
<p>The <a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.PipelineVertexInputStateCreateInfo.html"><code class="hljs">vk::PipelineVertexInputStateCreateInfo</code></a> structure describes the format of the vertex data that will be passed to the vertex shader. It describes this in roughly two ways:</p>
<ul>
<li>Bindings – spacing between data and whether the data is per-vertex or per-instance (see <a href="https://en.wikipedia.org/wiki/Geometry_instancing">instancing</a>)</li>
<li>Attribute descriptions – type of the attributes passed to the vertex shader, which binding to load them from and at which offset</li>
</ul>
<p>Because we're hard coding the vertex data directly in the vertex shader, we'll leave this structure with the defaults to specify that there is no vertex data to load for now. We'll get back to it in the vertex buffer chapter. Add this to the <code>create_pipeline</code> function right after the <a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.PipelineShaderStageCreateInfo.html"><code class="hljs">vk::PipelineShaderStageCreateInfo</code></a> structs:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_pipeline(device: &amp;Device, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    // ...

    let vertex_input_state = vk::PipelineVertexInputStateCreateInfo::builder();
</code></pre>
<p>The <code>vertex_binding_descriptions</code> and <code>vertex_attribute_descriptions</code> fields for this struct that could have been set here would be slices of structs that describe the aforementioned details for loading vertex data.</p>
<h2 id="input-assembly"><a class="header" href="#input-assembly">Input assembly</a></h2>
<p>The <a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.PipelineInputAssemblyStateCreateInfo.html"><code class="hljs">vk::PipelineInputAssemblyStateCreateInfo</code></a> struct describes two things: what kind of geometry will be drawn from the vertices and if primitive restart should be enabled. The former is specified in the <code>topology</code> member and can have values like:</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.PrimitiveTopology.html#associatedconstant.POINT_LIST"><code class="hljs">vk::PrimitiveTopology::POINT_LIST</code></a> – points from vertices</li>
<li><a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.PrimitiveTopology.html#associatedconstant.LINE_LIST"><code class="hljs">vk::PrimitiveTopology::LINE_LIST</code></a> – line from every 2 vertices without reuse</li>
<li><a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.PrimitiveTopology.html#associatedconstant.LINE_STRIP"><code class="hljs">vk::PrimitiveTopology::LINE_STRIP</code></a> – the end vertex of every line is used as start vertex for the next line</li>
<li><a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.PrimitiveTopology.html#associatedconstant.TRIANGLE_LIST"><code class="hljs">vk::PrimitiveTopology::TRIANGLE_LIST</code></a> – triangle from every 3 vertices without reuse</li>
<li><a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.PrimitiveTopology.html#associatedconstant.TRIANGLE_STRIP"><code class="hljs">vk::PrimitiveTopology::TRIANGLE_STRIP</code></a> – the second and third vertex of every triangle are used as first two vertices of the next triangle</li>
</ul>
<p>Normally, the vertices are loaded from the vertex buffer by index in sequential order, but with an <em>element buffer</em> you can specify the indices to use yourself. This allows you to perform optimizations like reusing vertices. If you set the <code>primitive_restart_enable</code> member to <code>true</code>, then it's possible to break up lines and triangles in the <code>_STRIP</code> topology modes by using a special index of <code>0xFFFF</code> or <code>0xFFFFFFFF</code>.</p>
<p>We intend to draw triangles throughout this tutorial, so we'll stick to the following data for the structure:</p>
<pre><code class="language-rust noplaypen">let input_assembly_state = vk::PipelineInputAssemblyStateCreateInfo::builder()
    .topology(vk::PrimitiveTopology::TRIANGLE_LIST)
    .primitive_restart_enable(false);
</code></pre>
<h2 id="viewports-and-scissors"><a class="header" href="#viewports-and-scissors">Viewports and scissors</a></h2>
<p>A viewport basically describes the region of the framebuffer that the output will be rendered to. This will almost always be <code>(0, 0)</code> to <code>(width, height)</code> and in this tutorial that will also be the case.</p>
<pre><code class="language-rust noplaypen">let viewport = vk::Viewport::builder()
    .x(0.0)
    .y(0.0)
    .width(data.swapchain_extent.width as f32)
    .height(data.swapchain_extent.height as f32)
    .min_depth(0.0)
    .max_depth(1.0);
</code></pre>
<p>Remember that the size of the swapchain and its images may differ from the <code>WIDTH</code> and <code>HEIGHT</code> of the window. The swapchain images will be used as framebuffers later on, so we should stick to their size.</p>
<p>The <code>min_depth</code> and <code>max_depth</code> values specify the range of depth values to use for the framebuffer. These values must be within the <code>[0.0, 1.0]</code> range, but <code>min_depth</code> may be higher than <code>max_depth</code>. If you aren't doing anything special, then you should stick to the standard values of <code>0.0</code> and <code>1.0</code>.</p>
<p>While viewports define the transformation from the image to the framebuffer, scissor rectangles define in which regions pixels will actually be stored. Any pixels outside the scissor rectangles will be discarded by the rasterizer. They function like a filter rather than a transformation. The difference is illustrated below. Note that the left scissor rectangle is just one of the many possibilities that would result in that image, as long as it's larger than the viewport.</p>
<p><img src="../images/viewports_scissors.png" alt="" /></p>
<p>In this tutorial we simply want to draw to the entire framebuffer, so we'll specify a scissor rectangle that covers it entirely:</p>
<pre><code class="language-rust noplaypen">let scissor = vk::Rect2D::builder()
    .offset(vk::Offset2D { x: 0, y: 0 })
    .extent(data.swapchain_extent);
</code></pre>
<p>Now this viewport and scissor rectangle need to be combined into a viewport state using the <a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.PipelineViewportStateCreateInfo.html"><code class="hljs">vk::PipelineViewportStateCreateInfo</code></a> struct. It is possible to use multiple viewports and scissor rectangles on some graphics cards, so its members reference an array of them. Using multiple requires enabling a GPU feature (see logical device creation).</p>
<pre><code class="language-rust noplaypen">let viewports = &amp;[viewport];
let scissors = &amp;[scissor];
let viewport_state = vk::PipelineViewportStateCreateInfo::builder()
    .viewports(viewports)
    .scissors(scissors);
</code></pre>
<h2 id="rasterizer"><a class="header" href="#rasterizer">Rasterizer</a></h2>
<p>The rasterizer takes the geometry that is shaped by the vertices from the vertex shader and turns it into fragments to be colored by the fragment shader. It also performs <a href="https://en.wikipedia.org/wiki/Z-buffering">depth testing</a>, <a href="https://en.wikipedia.org/wiki/Back-face_culling">face culling</a> and the scissor test, and it can be configured to output fragments that fill entire polygons or just the edges (wireframe rendering). All this is configured using the <a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.PipelineRasterizationStateCreateInfo.html"><code class="hljs">vk::PipelineRasterizationStateCreateInfo</code></a> structure.</p>
<pre><code class="language-rust noplaypen">let rasterization_state = vk::PipelineRasterizationStateCreateInfo::builder()
    .depth_clamp_enable(false)
    // continued...
</code></pre>
<p>If <code>depth_clamp_enable</code> is set to <code>true</code>, then fragments that are beyond the near and far planes are clamped to them as opposed to discarding them. This is useful in some special cases like shadow maps. Using this requires enabling a GPU feature.</p>
<pre><code class="language-rust noplaypen">    .rasterizer_discard_enable(false)
</code></pre>
<p>If <code>rasterizer_discard_enable</code> is set to <code>true</code>, then geometry never passes through the rasterizer stage. This basically disables any output to the framebuffer.</p>
<pre><code class="language-rust noplaypen">    .polygon_mode(vk::PolygonMode::FILL)
</code></pre>
<p>The <code>polygon_mode</code> determines how fragments are generated for geometry. The following modes are available:</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.PolygonMode.html#associatedconstant.FILL"><code class="hljs">vk::PolygonMode::FILL</code></a> – fill the area of the polygon with fragments</li>
<li><a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.PolygonMode.html#associatedconstant.LINE"><code class="hljs">vk::PolygonMode::LINE</code></a> – polygon edges are drawn as lines</li>
<li><a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.PolygonMode.html#associatedconstant.POINT"><code class="hljs">vk::PolygonMode::POINT</code></a> – polygon vertices are drawn as points</li>
</ul>
<p>Using any mode other than fill requires enabling a GPU feature.</p>
<pre><code class="language-rust noplaypen">    .line_width(1.0)
</code></pre>
<p>The <code>line_width</code> member is straightforward, it describes the thickness of lines in terms of number of fragments. The maximum line width that is supported depends on the hardware and any line thicker than <code>1.0</code> requires you to enable the <code>wide_lines</code> GPU feature.</p>
<pre><code class="language-rust noplaypen">    .cull_mode(vk::CullModeFlags::BACK)
    .front_face(vk::FrontFace::CLOCKWISE)
</code></pre>
<p>The <code>cull_mode</code> variable determines the type of face culling to use. You can disable culling, cull the front faces, cull the back faces or both. The <code>front_face</code> variable specifies the vertex order for faces to be considered front-facing and can be clockwise or counterclockwise.</p>
<pre><code class="language-rust noplaypen">    .depth_bias_enable(false);
</code></pre>
<p>The rasterizer can alter the depth values by adding a constant value or biasing them based on a fragment's slope. This is sometimes used for shadow mapping, but we won't be using it. Just set <code>depth_bias_enable</code> to <code>false</code>.</p>
<h2 id="multisampling"><a class="header" href="#multisampling">Multisampling</a></h2>
<p>The <a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.PipelineMultisampleStateCreateInfo.html"><code class="hljs">vk::PipelineMultisampleStateCreateInfo</code></a> struct configures multisampling, which is one of the ways to perform <a href="https://en.wikipedia.org/wiki/Multisample_anti-aliasing">anti-aliasing</a>. It works by combining the fragment shader results of multiple polygons that rasterize to the same pixel. This mainly occurs along edges, which is also where the most noticeable aliasing artifacts occur. Because it doesn't need to run the fragment shader multiple times if only one polygon maps to a pixel, it is significantly less expensive than simply rendering to a higher resolution and then downscaling. Enabling it requires enabling a GPU feature.</p>
<pre><code class="language-rust noplaypen">let multisample_state = vk::PipelineMultisampleStateCreateInfo::builder()
    .sample_shading_enable(false)
    .rasterization_samples(vk::SampleCountFlags::_1);
</code></pre>
<p>We'll revisit multisampling in a later chapter, for now let's keep it disabled.</p>
<h2 id="depth-and-stencil-testing"><a class="header" href="#depth-and-stencil-testing">Depth and stencil testing</a></h2>
<p>If you are using a depth and/or stencil buffer, then you also need to configure the depth and stencil tests using <a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.PipelineDepthStencilStateCreateInfo.html"><code class="hljs">vk::PipelineDepthStencilStateCreateInfo</code></a>. We don't have one right now, so we can simply ignore it for now. We'll get back to it in the depth buffering chapter.</p>
<h2 id="color-blending"><a class="header" href="#color-blending">Color blending</a></h2>
<p>After a fragment shader has returned a color, it needs to be combined with the color that is already in the framebuffer. This transformation is known as color blending and there are two ways to do it:</p>
<ul>
<li>Mix the old and new value to produce a final color</li>
<li>Combine the old and new value using a bitwise operation</li>
</ul>
<p>There are two types of structs to configure color blending. The first struct, <a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.PipelineColorBlendAttachmentState.html"><code class="hljs">vk::PipelineColorBlendAttachmentState</code></a> contains the configuration per attached framebuffer and the second struct, <a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.PipelineColorBlendStateCreateInfo.html"><code class="hljs">vk::PipelineColorBlendStateCreateInfo</code></a> contains the <em>global</em> color blending settings. In our case we only have one framebuffer:</p>
<pre><code class="language-rust noplaypen">let attachment = vk::PipelineColorBlendAttachmentState::builder()
    .color_write_mask(vk::ColorComponentFlags::all())
    .blend_enable(false)
    .src_color_blend_factor(vk::BlendFactor::ONE)  // Optional
    .dst_color_blend_factor(vk::BlendFactor::ZERO) // Optional
    .color_blend_op(vk::BlendOp::ADD)              // Optional
    .src_alpha_blend_factor(vk::BlendFactor::ONE)  // Optional
    .dst_alpha_blend_factor(vk::BlendFactor::ZERO) // Optional
    .alpha_blend_op(vk::BlendOp::ADD);             // Optional
</code></pre>
<p>This per-framebuffer struct allows you to configure the first way of color blending. The operations that will be performed are best demonstrated using the following pseudocode:</p>
<pre><code class="language-rust noplaypen">if blend_enable {
    final_color.rgb = (src_color_blend_factor * new_color.rgb)
        &lt;color_blend_op&gt; (dst_color_blend_factor * old_color.rgb);
    final_color.a = (src_alpha_blend_factor * new_color.a)
        &lt;alpha_blend_op&gt; (dst_alpha_blend_factor * old_color.a);
} else {
    final_color = new_color;
}

final_color = final_color &amp; color_write_mask;
</code></pre>
<p>If <code>blend_enable</code> is set to <code>false</code>, then the new color from the fragment shader is passed through unmodified. Otherwise, the two mixing operations are performed to compute a new color. The resulting color is AND'd with the <code>color_write_mask</code> to determine which channels are actually passed through.</p>
<p>The most common way to use color blending is to implement alpha blending, where we want the new color to be blended with the old color based on its opacity. The <code>final_color</code> should then be computed as follows:</p>
<pre><code class="language-c++">final_color.rgb = new_alpha * new_color + (1 - new_alpha) * old_color;
final_color.a = new_alpha.a;
</code></pre>
<p>This can be accomplished with the following parameters:</p>
<pre><code class="language-rust noplaypen">let attachment = vk::PipelineColorBlendAttachmentState::builder()
    .color_write_mask(vk::ColorComponentFlags::all())
    .blend_enable(true)
    .src_color_blend_factor(vk::BlendFactor::SRC_ALPHA)
    .dst_color_blend_factor(vk::BlendFactor::ONE_MINUS_SRC_ALPHA)
    .color_blend_op(vk::BlendOp::ADD)
    .src_alpha_blend_factor(vk::BlendFactor::ONE)
    .dst_alpha_blend_factor(vk::BlendFactor::ZERO)
    .alpha_blend_op(vk::BlendOp::ADD);
</code></pre>
<p>You can find all of the possible operations in the <a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.BlendFactor.html"><code class="hljs">vk::BlendFactor</code></a> and <a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.BlendOp.html"><code class="hljs">vk::BlendOp</code></a> enumerations in the specification (or <code>vulkanalia</code>'s documentation).</p>
<p>The second structure references the array of structures for all of the framebuffers and allows you to set blend constants that you can use as blend factors in the aforementioned calculations.</p>
<pre><code class="language-rust noplaypen">let attachments = &amp;[attachment];
let color_blend_state = vk::PipelineColorBlendStateCreateInfo::builder()
    .logic_op_enable(false)
    .logic_op(vk::LogicOp::COPY)
    .attachments(attachments)
    .blend_constants([0.0, 0.0, 0.0, 0.0]);
</code></pre>
<p>If you want to use the second method of blending (bitwise combination), then you should set <code>logic_op_enable</code> to <code>true</code>. The bitwise operation can then be specified in the <code>logic_op</code> field. Note that this will automatically disable the first method, as if you had set <code>blend_enable</code> to <code>false</code> for every attached framebuffer! The <code>color_write_mask</code> will also be used in this mode to determine which channels in the framebuffer will actually be affected. It is also possible to disable both modes, as we've done here, in which case the fragment colors will be written to the framebuffer unmodified.</p>
<h2 id="dynamic-state-example-dont-add"><a class="header" href="#dynamic-state-example-dont-add">Dynamic state (example, don't add)</a></h2>
<p>A limited amount of the state that we've specified in the previous structs <em>can</em> actually be changed without recreating the pipeline. Examples are the size of the viewport, line width and blend constants. If you want to do that, then you'll have to fill in a <a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.PipelineDynamicStateCreateInfo.html"><code class="hljs">vk::PipelineDynamicStateCreateInfo</code></a> structure like this:</p>
<pre><code class="language-rust noplaypen">let dynamic_states = &amp;[
    vk::DynamicState::VIEWPORT,
    vk::DynamicState::LINE_WIDTH,
];

let dynamic_state = vk::PipelineDynamicStateCreateInfo::builder()
    .dynamic_states(dynamic_states);
</code></pre>
<p>This will cause the configuration of these values to be ignored and you will be required to specify the data at drawing time. We'll get back to this in a future chapter. This struct can be omitted if you don't have any dynamic state.</p>
<h2 id="pipeline-layout"><a class="header" href="#pipeline-layout">Pipeline layout</a></h2>
<p>You can use <code>uniform</code> values in shaders, which are globals similar to dynamic state variables that can be changed at drawing time to alter the behavior of your shaders without having to recreate them. They are commonly used to pass the transformation matrix to the vertex shader, or to create texture samplers in the fragment shader.</p>
<p>These uniform values need to be specified during pipeline creation by creating a <a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.PipelineLayout.html"><code class="hljs">vk::PipelineLayout</code></a> object. Even though we won't be using them until a future chapter, we are still required to create an empty pipeline layout.</p>
<p>Create an <code>AppData</code> field to hold this object, because we'll refer to it from other functions at a later point in time:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    pipeline_layout: vk::PipelineLayout,
}
</code></pre>
<p>And then create the object in the <code>create_pipeline</code> function just above the calls to <a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/trait.DeviceV1_0.html#method.destroy_shader_module"><code class="hljs">destroy_shader_module</code></a>:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_pipeline(device: &amp;Device, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    // ...

    let layout_info = vk::PipelineLayoutCreateInfo::builder();

    data.pipeline_layout = device.create_pipeline_layout(&amp;layout_info, None)?;

    device.destroy_shader_module(vert_shader_module, None);
    device.destroy_shader_module(frag_shader_module, None);

    Ok(())
}
</code></pre>
<p>The structure also specifies <em>push constants</em>, which are another way of passing dynamic values to shaders that we may get into in a future chapter. The pipeline layout will be referenced throughout the program's lifetime, so it should be destroyed in <code>App::destroy</code>:</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy(&amp;mut self) {
    self.device.destroy_pipeline_layout(self.data.pipeline_layout, None);
    // ...
}
</code></pre>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>That's it for all of the fixed-function state! It's a lot of work to set all of this up from scratch, but the advantage is that we're now nearly fully aware of everything that is going on in the graphics pipeline! This reduces the chance of running into unexpected behavior because the default state of certain components is not what you expect.</p>
<p>There is however one more object to create before we can finally create the graphics pipeline and that is a render pass.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../pipeline/shader_modules.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../pipeline/render_passes.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../pipeline/shader_modules.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../pipeline/render_passes.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>



        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
