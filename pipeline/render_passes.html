<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Render passes - Vulkan Tutorial (Rust)</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A Vulkan tutorial for Rust.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../overview.html"><strong aria-hidden="true">2.</strong> Overview</a></li><li class="chapter-item expanded "><a href="../development_environment.html"><strong aria-hidden="true">3.</strong> Development environment</a></li><li class="chapter-item expanded "><a href="../faq.html"><strong aria-hidden="true">4.</strong> FAQ</a></li><li class="chapter-item expanded affix "><li class="part-title">Setup</li><li class="chapter-item expanded "><a href="../setup/base_code.html"><strong aria-hidden="true">5.</strong> Base code</a></li><li class="chapter-item expanded "><a href="../setup/instance.html"><strong aria-hidden="true">6.</strong> Instance</a></li><li class="chapter-item expanded "><a href="../setup/validation_layers.html"><strong aria-hidden="true">7.</strong> Validation layers</a></li><li class="chapter-item expanded "><a href="../setup/physical_devices_and_queue_families.html"><strong aria-hidden="true">8.</strong> Physical devices and queue families</a></li><li class="chapter-item expanded "><a href="../setup/logical_device_and_queues.html"><strong aria-hidden="true">9.</strong> Logical device and queues</a></li><li class="chapter-item expanded affix "><li class="part-title">Presentation</li><li class="chapter-item expanded "><a href="../presentation/window_surface.html"><strong aria-hidden="true">10.</strong> Window surface</a></li><li class="chapter-item expanded "><a href="../presentation/swapchain.html"><strong aria-hidden="true">11.</strong> Swapchain</a></li><li class="chapter-item expanded "><a href="../presentation/image_views.html"><strong aria-hidden="true">12.</strong> Image views</a></li><li class="chapter-item expanded affix "><li class="part-title">Pipeline</li><li class="chapter-item expanded "><a href="../pipeline/introduction.html"><strong aria-hidden="true">13.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../pipeline/shader_modules.html"><strong aria-hidden="true">14.</strong> Shader modules</a></li><li class="chapter-item expanded "><a href="../pipeline/fixed_functions.html"><strong aria-hidden="true">15.</strong> Fixed functions</a></li><li class="chapter-item expanded "><a href="../pipeline/render_passes.html" class="active"><strong aria-hidden="true">16.</strong> Render passes</a></li><li class="chapter-item expanded "><a href="../pipeline/conclusion.html"><strong aria-hidden="true">17.</strong> Conclusion</a></li><li class="chapter-item expanded affix "><li class="part-title">Drawing</li><li class="chapter-item expanded "><a href="../drawing/framebuffers.html"><strong aria-hidden="true">18.</strong> Framebuffers</a></li><li class="chapter-item expanded "><a href="../drawing/command_buffers.html"><strong aria-hidden="true">19.</strong> Command buffers</a></li><li class="chapter-item expanded "><a href="../drawing/rendering_and_presentation.html"><strong aria-hidden="true">20.</strong> Rendering and presentation</a></li><li class="chapter-item expanded affix "><li class="part-title">Swapchain</li><li class="chapter-item expanded "><a href="../swapchain/recreation.html"><strong aria-hidden="true">21.</strong> Recreation</a></li><li class="chapter-item expanded affix "><li class="part-title">Vertex buffers</li><li class="chapter-item expanded "><a href="../vertex/vertex_input_description.html"><strong aria-hidden="true">22.</strong> Vertex input description</a></li><li class="chapter-item expanded "><a href="../vertex/vertex_buffer_creation.html"><strong aria-hidden="true">23.</strong> Vertex buffer creation</a></li><li class="chapter-item expanded "><a href="../vertex/staging_buffer.html"><strong aria-hidden="true">24.</strong> Staging buffer</a></li><li class="chapter-item expanded "><a href="../vertex/index_buffer.html"><strong aria-hidden="true">25.</strong> Index buffer</a></li><li class="chapter-item expanded affix "><li class="part-title">Uniform buffers</li><li class="chapter-item expanded "><a href="../uniform/descriptor_set_layout_and_buffer.html"><strong aria-hidden="true">26.</strong> Descriptor set layout and buffer</a></li><li class="chapter-item expanded "><a href="../uniform/descriptor_pool_and_sets.html"><strong aria-hidden="true">27.</strong> Descriptor pool and sets</a></li><li class="chapter-item expanded affix "><li class="part-title">Texture mapping</li><li class="chapter-item expanded "><a href="../texture/images.html"><strong aria-hidden="true">28.</strong> Images</a></li><li class="chapter-item expanded "><a href="../texture/image_view_and_sampler.html"><strong aria-hidden="true">29.</strong> Image view and sampler</a></li><li class="chapter-item expanded "><a href="../texture/combined_image_sampler.html"><strong aria-hidden="true">30.</strong> Combined image sampler</a></li><li class="chapter-item expanded affix "><li class="part-title">Model</li><li class="chapter-item expanded "><a href="../model/depth_buffering.html"><strong aria-hidden="true">31.</strong> Depth buffering</a></li><li class="chapter-item expanded "><a href="../model/loading_models.html"><strong aria-hidden="true">32.</strong> Loading models</a></li><li class="chapter-item expanded affix "><li class="part-title">Rendering quality</li><li class="chapter-item expanded "><a href="../quality/generating_mipmaps.html"><strong aria-hidden="true">33.</strong> Generating mipmaps</a></li><li class="chapter-item expanded "><a href="../quality/multisampling.html"><strong aria-hidden="true">34.</strong> Multisampling</a></li><li class="chapter-item expanded affix "><li class="part-title">Dynamic scenes</li><li class="chapter-item expanded "><a href="../dynamic/push_constants.html"><strong aria-hidden="true">35.</strong> Push constants</a></li><li class="chapter-item expanded "><a href="../dynamic/recycling_command_buffers.html"><strong aria-hidden="true">36.</strong> Recycling command buffers</a></li><li class="chapter-item expanded "><a href="../dynamic/secondary_command_buffers.html"><strong aria-hidden="true">37.</strong> Secondary command buffers</a></li><li class="chapter-item expanded affix "><li class="part-title">Conclusion</li><li class="chapter-item expanded "><a href="../conclusion.html"><strong aria-hidden="true">38.</strong> Conclusion</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Vulkan Tutorial (Rust)</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/KyleMayes/vulkanalia" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="render-passes"><a class="header" href="#render-passes">Render passes</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/11_render_passes.rs">main.rs</a></p>
<p>Before we can finish creating the pipeline, we need to tell Vulkan about the framebuffer attachments that will be used while rendering. We need to specify how many color and depth buffers there will be, how many samples to use for each of them and how their contents should be handled throughout the rendering operations. All of this information is wrapped in a <em>render pass</em> object, for which we'll create a new <code>create_render_pass</code> function. Call this function from <code>App::create</code> before <code>create_pipeline</code>.</p>
<pre><code class="language-rust noplaypen">impl App {
    unsafe fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        // ...
        create_render_pass(&amp;instance, &amp;device, &amp;mut data)?;
        create_pipeline(&amp;device, &amp;mut data)?;
        // ...
    }
}

unsafe fn create_render_pass(
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;mut AppData,
) -&gt; Result&lt;()&gt; {
    Ok(())
}
</code></pre>
<h2 id="attachment-description"><a class="header" href="#attachment-description">Attachment description</a></h2>
<p>In our case we'll have just a single color buffer attachment represented by one of the images from the swapchain. This will be represented by a <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.AttachmentDescription.html"><code class="hljs">vk::AttachmentDescription</code></a> which we will build in <code>create_render_pass</code>.</p>
<pre><code class="language-rust noplaypen">let color_attachment = vk::AttachmentDescription::builder()
    .format(data.swapchain_format)
    .samples(vk::SampleCountFlags::_1)
    // continued...
</code></pre>
<p>The <code>format</code> of the color attachment should match the format of the swapchain images, and we're not doing anything with multisampling yet, so we'll stick to 1 sample.</p>
<pre><code class="language-rust noplaypen">    .load_op(vk::AttachmentLoadOp::CLEAR)
    .store_op(vk::AttachmentStoreOp::STORE)
</code></pre>
<p>The <code>load_op</code> and <code>store_op</code> determine what to do with the data in the attachment before rendering and after rendering. We have the following choices for <code>load_op</code>:</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.AttachmentLoadOp.html#associatedconstant.LOAD"><code class="hljs">vk::AttachmentLoadOp::LOAD</code></a> – Preserve the existing contents of the attachment</li>
<li><a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.AttachmentLoadOp.html#associatedconstant.CLEAR"><code class="hljs">vk::AttachmentLoadOp::CLEAR</code></a> – Clear the values to a constant at the start</li>
<li><a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.AttachmentLoadOp.html#associatedconstant.DONT_CARE"><code class="hljs">vk::AttachmentLoadOp::DONT_CARE</code></a> – Existing contents are undefined; we don't care about them</li>
</ul>
<p>In our case we're going to use the clear operation to clear the framebuffer to black before drawing a new frame. There are only two possibilities for the <code>store_op</code>:</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.AttachmentStoreOp.html#associatedconstant.STORE"><code class="hljs">vk::AttachmentStoreOp::STORE</code></a> – Rendered contents will be stored in memory and can be read later</li>
<li><a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.AttachmentStoreOp.html#associatedconstant.DONT_CARE"><code class="hljs">vk::AttachmentStoreOp::DONT_CARE</code></a> – Contents of the framebuffer will be undefined after the rendering operation</li>
</ul>
<p>We're interested in seeing the rendered triangle on the screen, so we're going with the store operation here.</p>
<pre><code class="language-rust noplaypen">    .stencil_load_op(vk::AttachmentLoadOp::DONT_CARE)
    .stencil_store_op(vk::AttachmentStoreOp::DONT_CARE)
</code></pre>
<p>The <code>load_op</code> and <code>store_op</code> apply to color and depth data, and <code>stencil_load_op</code> / <code>stencil_store_op</code> apply to stencil data. Our application won't do anything with the stencil buffer, so the results of loading and storing are irrelevant.</p>
<pre><code class="language-rust noplaypen">    .initial_layout(vk::ImageLayout::UNDEFINED)
    .final_layout(vk::ImageLayout::PRESENT_SRC_KHR);
</code></pre>
<p>Textures and framebuffers in Vulkan are represented by <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.Image.html"><code class="hljs">vk::Image</code></a> objects with a certain pixel format, however the layout of the pixels in memory can change based on what you're trying to do with an image.</p>
<p>Some of the most common layouts are:</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.COLOR_ATTACHMENT_OPTIMAL"><code class="hljs">vk::ImageLayout::COLOR_ATTACHMENT_OPTIMAL</code></a> – Images used as color attachment</li>
<li><a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.PRESENT_SRC_KHR"><code class="hljs">vk::ImageLayout::PRESENT_SRC_KHR</code></a> – Images to be presented in the swapchain</li>
<li><a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.TRANSFER_DST_OPTIMAL"><code class="hljs">vk::ImageLayout::TRANSFER_DST_OPTIMAL</code></a> – Images to be used as destination for a memory copy operation</li>
</ul>
<p>We'll discuss this topic in more depth in the texturing chapter, but what's important to know right now is that images need to be transitioned to specific layouts that are suitable for the operation that they're going to be involved in next.</p>
<p>The <code>initial_layout</code> specifies which layout the image will have before the render pass begins. The <code>final_layout</code> specifies the layout to automatically transition to when the render pass finishes. Using <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.UNDEFINED"><code class="hljs">vk::ImageLayout::UNDEFINED</code></a> for <code>initial_layout</code> means that we don't care what previous layout the image was in. The caveat of this special value is that the contents of the image are not guaranteed to be preserved, but that doesn't matter since we're going to clear it anyway. We want the image to be ready for presentation using the swapchain after rendering, which is why we use <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.PRESENT_SRC_KHR"><code class="hljs">vk::ImageLayout::PRESENT_SRC_KHR</code></a> as <code>final_layout</code>.</p>
<h2 id="subpasses-and-attachment-references"><a class="header" href="#subpasses-and-attachment-references">Subpasses and attachment references</a></h2>
<p>A single render pass can consist of multiple subpasses. Subpasses are subsequent rendering operations that depend on the contents of framebuffers in previous passes, for example a sequence of post-processing effects that are applied one after another. If you group these rendering operations into one render pass, then Vulkan is able to reorder the operations and conserve memory bandwidth for possibly better performance. For our very first triangle, however, we'll stick to a single subpass.</p>
<p>Every subpass references one or more of the attachments that we've described using the structure in the previous sections. These references are themselves <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.AttachmentReference.html"><code class="hljs">vk::AttachmentReference</code></a> structs that look like this:</p>
<pre><code class="language-rust noplaypen">let color_attachment_ref = vk::AttachmentReference::builder()
    .attachment(0)
    .layout(vk::ImageLayout::COLOR_ATTACHMENT_OPTIMAL);
</code></pre>
<p>The <code>attachment</code> parameter specifies which attachment to reference by its index in the attachment descriptions array. Our array consists of a single <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.AttachmentDescription.html"><code class="hljs">vk::AttachmentDescription</code></a>, so its index is <code>0</code>. The <code>layout</code> specifies which layout we would like the attachment to have during a subpass that uses this reference. Vulkan will automatically transition the attachment to this layout when the subpass is started. We intend to use the attachment to function as a color buffer and the <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.COLOR_ATTACHMENT_OPTIMAL"><code class="hljs">vk::ImageLayout::COLOR_ATTACHMENT_OPTIMAL</code></a> layout will give us the best performance, as its name implies.</p>
<p>The subpass is described using a <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.SubpassDescription.html"><code class="hljs">vk::SubpassDescription</code></a> structure:</p>
<pre><code class="language-rust noplaypen">let color_attachments = &amp;[color_attachment_ref];
let subpass = vk::SubpassDescription::builder()
    .pipeline_bind_point(vk::PipelineBindPoint::GRAPHICS)
    .color_attachments(color_attachments);
</code></pre>
<p>Vulkan may also support compute subpasses in the future, so we have to be explicit about this being a graphics subpass. Then we specify the reference to the color attachment.</p>
<p>The index of the attachment in this array is directly referenced from the fragment shader with the <code>layout(location = 0) out vec4 outColor</code> directive!</p>
<p>The following other types of attachments can be referenced by a subpass:</p>
<ul>
<li><code>input_attachments</code> – Attachments that are read from a shader</li>
<li><code>resolve_attachments</code> – Attachments used for multisampling color attachments</li>
<li><code>depth_stencil_attachment</code> – Attachment for depth and stencil data</li>
<li><code>preserve_attachments</code> – Attachments that are not used by this subpass, but for which the data must be preserved</li>
</ul>
<h2 id="render-pass"><a class="header" href="#render-pass">Render pass</a></h2>
<p>Now that the attachment and a basic subpass referencing it have been described, we can create the render pass itself. Create a new class member variable to hold the <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.RenderPass.html"><code class="hljs">vk::RenderPass</code></a> object right above the <code>pipeline_layout</code> field in <code>AppData</code>:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    render_pass: vk::RenderPass,
    pipeline_layout: vk::PipelineLayout,
}
</code></pre>
<p>The render pass object can then be created by filling in the <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.RenderPassCreateInfo.html"><code class="hljs">vk::RenderPassCreateInfo</code></a> structure with an array of attachments and subpasses. The <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.AttachmentReference.html"><code class="hljs">vk::AttachmentReference</code></a> objects reference attachments using the indices of this array.</p>
<pre><code class="language-rust noplaypen">let attachments = &amp;[color_attachment];
let subpasses = &amp;[subpass];
let info = vk::RenderPassCreateInfo::builder()
    .attachments(attachments)
    .subpasses(subpasses);

data.render_pass = device.create_render_pass(&amp;info, None)?;
</code></pre>
<p>Just like the pipeline layout, the render pass will be referenced throughout the program, so it should only be cleaned up at the end in <code>App::destroy</code>:</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy(&amp;mut self) {
    self.device.destroy_pipeline_layout(self.data.pipeline_layout, None);
    self.device.destroy_render_pass(self.data.render_pass, None);
    // ...
}
</code></pre>
<p>That was a lot of work, but in the next chapter it all comes together to finally create the graphics pipeline object!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../pipeline/fixed_functions.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../pipeline/conclusion.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../pipeline/fixed_functions.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../pipeline/conclusion.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>



        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
