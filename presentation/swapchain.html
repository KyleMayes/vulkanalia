<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Swapchain - Vulkan Tutorial (Rust)</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A Vulkan tutorial for Rust.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../overview.html"><strong aria-hidden="true">2.</strong> Overview</a></li><li class="chapter-item expanded "><a href="../development_environment.html"><strong aria-hidden="true">3.</strong> Development environment</a></li><li class="chapter-item expanded "><a href="../faq.html"><strong aria-hidden="true">4.</strong> FAQ</a></li><li class="chapter-item expanded affix "><li class="part-title">Setup</li><li class="chapter-item expanded "><a href="../setup/base_code.html"><strong aria-hidden="true">5.</strong> Base code</a></li><li class="chapter-item expanded "><a href="../setup/instance.html"><strong aria-hidden="true">6.</strong> Instance</a></li><li class="chapter-item expanded "><a href="../setup/validation_layers.html"><strong aria-hidden="true">7.</strong> Validation layers</a></li><li class="chapter-item expanded "><a href="../setup/physical_devices_and_queue_families.html"><strong aria-hidden="true">8.</strong> Physical devices and queue families</a></li><li class="chapter-item expanded "><a href="../setup/logical_device_and_queues.html"><strong aria-hidden="true">9.</strong> Logical device and queues</a></li><li class="chapter-item expanded affix "><li class="part-title">Presentation</li><li class="chapter-item expanded "><a href="../presentation/window_surface.html"><strong aria-hidden="true">10.</strong> Window surface</a></li><li class="chapter-item expanded "><a href="../presentation/swapchain.html" class="active"><strong aria-hidden="true">11.</strong> Swapchain</a></li><li class="chapter-item expanded "><a href="../presentation/image_views.html"><strong aria-hidden="true">12.</strong> Image views</a></li><li class="chapter-item expanded affix "><li class="part-title">Pipeline</li><li class="chapter-item expanded "><a href="../pipeline/introduction.html"><strong aria-hidden="true">13.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../pipeline/shader_modules.html"><strong aria-hidden="true">14.</strong> Shader modules</a></li><li class="chapter-item expanded "><a href="../pipeline/fixed_functions.html"><strong aria-hidden="true">15.</strong> Fixed functions</a></li><li class="chapter-item expanded "><a href="../pipeline/render_passes.html"><strong aria-hidden="true">16.</strong> Render passes</a></li><li class="chapter-item expanded "><a href="../pipeline/conclusion.html"><strong aria-hidden="true">17.</strong> Conclusion</a></li><li class="chapter-item expanded affix "><li class="part-title">Drawing</li><li class="chapter-item expanded "><a href="../drawing/framebuffers.html"><strong aria-hidden="true">18.</strong> Framebuffers</a></li><li class="chapter-item expanded "><a href="../drawing/command_buffers.html"><strong aria-hidden="true">19.</strong> Command buffers</a></li><li class="chapter-item expanded "><a href="../drawing/rendering_and_presentation.html"><strong aria-hidden="true">20.</strong> Rendering and presentation</a></li><li class="chapter-item expanded affix "><li class="part-title">Swapchain</li><li class="chapter-item expanded "><a href="../swapchain/recreation.html"><strong aria-hidden="true">21.</strong> Recreation</a></li><li class="chapter-item expanded affix "><li class="part-title">Vertex buffers</li><li class="chapter-item expanded "><a href="../vertex/vertex_input_description.html"><strong aria-hidden="true">22.</strong> Vertex input description</a></li><li class="chapter-item expanded "><a href="../vertex/vertex_buffer_creation.html"><strong aria-hidden="true">23.</strong> Vertex buffer creation</a></li><li class="chapter-item expanded "><a href="../vertex/staging_buffer.html"><strong aria-hidden="true">24.</strong> Staging buffer</a></li><li class="chapter-item expanded "><a href="../vertex/index_buffer.html"><strong aria-hidden="true">25.</strong> Index buffer</a></li><li class="chapter-item expanded affix "><li class="part-title">Uniform buffers</li><li class="chapter-item expanded "><a href="../uniform/descriptor_set_layout_and_buffer.html"><strong aria-hidden="true">26.</strong> Descriptor set layout and buffer</a></li><li class="chapter-item expanded "><a href="../uniform/descriptor_pool_and_sets.html"><strong aria-hidden="true">27.</strong> Descriptor pool and sets</a></li><li class="chapter-item expanded affix "><li class="part-title">Texture mapping</li><li class="chapter-item expanded "><a href="../texture/images.html"><strong aria-hidden="true">28.</strong> Images</a></li><li class="chapter-item expanded "><a href="../texture/image_view_and_sampler.html"><strong aria-hidden="true">29.</strong> Image view and sampler</a></li><li class="chapter-item expanded "><a href="../texture/combined_image_sampler.html"><strong aria-hidden="true">30.</strong> Combined image sampler</a></li><li class="chapter-item expanded affix "><li class="part-title">Model</li><li class="chapter-item expanded "><a href="../model/depth_buffering.html"><strong aria-hidden="true">31.</strong> Depth buffering</a></li><li class="chapter-item expanded "><a href="../model/loading_models.html"><strong aria-hidden="true">32.</strong> Loading models</a></li><li class="chapter-item expanded affix "><li class="part-title">Rendering quality</li><li class="chapter-item expanded "><a href="../quality/generating_mipmaps.html"><strong aria-hidden="true">33.</strong> Generating mipmaps</a></li><li class="chapter-item expanded "><a href="../quality/multisampling.html"><strong aria-hidden="true">34.</strong> Multisampling</a></li><li class="chapter-item expanded affix "><li class="part-title">Dynamic scenes</li><li class="chapter-item expanded "><a href="../dynamic/push_constants.html"><strong aria-hidden="true">35.</strong> Push constants</a></li><li class="chapter-item expanded "><a href="../dynamic/recycling_command_buffers.html"><strong aria-hidden="true">36.</strong> Recycling command buffers</a></li><li class="chapter-item expanded "><a href="../dynamic/secondary_command_buffers.html"><strong aria-hidden="true">37.</strong> Secondary command buffers</a></li><li class="chapter-item expanded affix "><li class="part-title">Conclusion</li><li class="chapter-item expanded "><a href="../conclusion.html"><strong aria-hidden="true">38.</strong> Conclusion</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Vulkan Tutorial (Rust)</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/KyleMayes/vulkanalia" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="swapchain"><a class="header" href="#swapchain">Swapchain</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/06_swapchain_creation.rs">main.rs</a></p>
<p>Vulkan does not have the concept of a &quot;default framebuffer&quot;, hence it requires an infrastructure that will own the buffers we will render to before we visualize them on the screen. This infrastructure is known as the <em>swapchain</em> and must be created explicitly in Vulkan. The swapchain is essentially a queue of images that are waiting to be presented to the screen. Our application will acquire such an image to draw to it, and then return it to the queue. How exactly the queue works and the conditions for presenting an image from the queue depend on how the swapchain is set up, but the general purpose of the swapchain is to synchronize the presentation of images with the refresh rate of the screen.</p>
<h2 id="checking-for-swapchain-support"><a class="header" href="#checking-for-swapchain-support">Checking for swapchain support</a></h2>
<p>Not all graphics cards are capable of presenting images directly to a screen for various reasons, for example because they are designed for servers and don't have any display outputs. Secondly, since image presentation is heavily tied into the window system and the surfaces associated with windows, it is not actually part of the Vulkan core. You have to enable the <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VK_KHR_swapchain.html"><code class="hljs">VK_KHR_swapchain</code></a> device extension after querying for its support. Also, like before, you need to import the <code>vulkanalia</code> extension trait for <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VK_KHR_swapchain.html"><code class="hljs">VK_KHR_swapchain</code></a>:</p>
<pre><code class="language-rust noplaypen">// Note: This trait was called `KhrSwapchainExtension` in versions of `vulkanalia` prior to `v0.31.0`.
use vulkanalia::vk::KhrSwapchainExtensionDeviceCommands;
</code></pre>
<p>Then we'll first extend the <code>check_physical_device</code> function to check if this extension is supported. We've previously seen how to list the extensions that are supported by a <a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.PhysicalDevice.html"><code class="hljs">vk::PhysicalDevice</code></a>, so doing that should be fairly straightforward.</p>
<p>First declare a list of required device extensions, similar to the list of validation layers to enable.</p>
<pre><code class="language-rust noplaypen">const DEVICE_EXTENSIONS: &amp;[vk::ExtensionName] = &amp;[vk::KHR_SWAPCHAIN_EXTENSION.name];
</code></pre>
<p>Next, create a new function <code>check_physical_device_extensions</code> that is called from <code>check_physical_device</code> as an additional check:</p>
<pre><code class="language-rust noplaypen">unsafe fn check_physical_device(
    instance: &amp;Instance,
    data: &amp;AppData,
    physical_device: vk::PhysicalDevice,
) -&gt; Result&lt;()&gt; {
    QueueFamilyIndices::get(instance, data, physical_device)?;
    check_physical_device_extensions(instance, physical_device)?;
    Ok(())
}

unsafe fn check_physical_device_extensions(
    instance: &amp;Instance,
    physical_device: vk::PhysicalDevice,
) -&gt; Result&lt;()&gt; {
    Ok(())
}
</code></pre>
<p>Modify the body of the function to enumerate the extensions and check if all of the required extensions are amongst them.</p>
<pre><code class="language-rust noplaypen">unsafe fn check_physical_device_extensions(
    instance: &amp;Instance,
    physical_device: vk::PhysicalDevice,
) -&gt; Result&lt;()&gt; {
    let extensions = instance
        .enumerate_device_extension_properties(physical_device, None)?
        .iter()
        .map(|e| e.extension_name)
        .collect::&lt;HashSet&lt;_&gt;&gt;();
    if DEVICE_EXTENSIONS.iter().all(|e| extensions.contains(e)) {
        Ok(())
    } else {
        Err(anyhow!(SuitabilityError(&quot;Missing required device extensions.&quot;)))
    }
}
</code></pre>
<p>Now run the code and verify that your graphics card is indeed capable of creating a swapchain. It should be noted that the availability of a presentation queue, as we checked in the previous chapter, implies that the swapchain extension must be supported. However, it's still good to be explicit about things, and the extension does have to be explicitly enabled.</p>
<h2 id="enabling-device-extensions"><a class="header" href="#enabling-device-extensions">Enabling device extensions</a></h2>
<p>Using a swapchain requires enabling the <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VK_KHR_swapchain.html"><code class="hljs">VK_KHR_swapchain</code></a> extension first. Enabling the extension just requires a small change to our list of device extensions in the <code>create_logical_device</code> function. Initialize our list of device extensions with a list of null-terminated strings constructed from <code>DEVICE_EXTENSIONS</code>:</p>
<pre><code class="language-rust noplaypen">let mut extensions = DEVICE_EXTENSIONS
    .iter()
    .map(|n| n.as_ptr())
    .collect::&lt;Vec&lt;_&gt;&gt;();
</code></pre>
<h2 id="querying-details-of-swapchain-support"><a class="header" href="#querying-details-of-swapchain-support">Querying details of swapchain support</a></h2>
<p>Just checking if a swapchain is available is not sufficient, because it may not actually be compatible with our window surface. Creating a swapchain also involves a lot more settings than instance and device creation, so we need to query for some more details before we're able to proceed.</p>
<p>There are basically three kinds of properties we need to check:</p>
<ul>
<li>Basic surface capabilities (min/max number of images in swapchain, min/max width and height of images)</li>
<li>Surface formats (pixel format, color space)</li>
<li>Available presentation modes</li>
</ul>
<p>Similar to <code>QueueFamilyIndices</code>, we'll use a struct to pass these details around once they've been queried. The three aforementioned types of properties come in the form of the following structs and lists of structs:</p>
<pre><code class="language-rust noplaypen">#[derive(Clone, Debug)]
struct SwapchainSupport {
    capabilities: vk::SurfaceCapabilitiesKHR,
    formats: Vec&lt;vk::SurfaceFormatKHR&gt;,
    present_modes: Vec&lt;vk::PresentModeKHR&gt;,
}
</code></pre>
<p>We'll now create a new method <code>SwapchainSupport::get</code> that will initialize this struct with all of the structs we need.</p>
<pre><code class="language-rust noplaypen">impl SwapchainSupport {
    unsafe fn get(
        instance: &amp;Instance,
        data: &amp;AppData,
        physical_device: vk::PhysicalDevice,
    ) -&gt; Result&lt;Self&gt; {
        Ok(Self {
            capabilities: instance
                .get_physical_device_surface_capabilities_khr(
                    physical_device, data.surface)?,
            formats: instance
                .get_physical_device_surface_formats_khr(
                    physical_device, data.surface)?,
            present_modes: instance
                .get_physical_device_surface_present_modes_khr(
                    physical_device, data.surface)?,
        })
    }
}
</code></pre>
<p>The meaning of these structs and exactly which data they contain is discussed in the next section.</p>
<p>All of the details are in the struct now, so let's extend <code>check_physical_device</code> once more to utilize this method to verify that swapchain support is adequate. swapchain support is sufficient for this tutorial if there is at least one supported image format and one supported presentation mode given the window surface we have.</p>
<pre><code class="language-rust noplaypen">unsafe fn check_physical_device(
    instance: &amp;Instance,
    data: &amp;AppData,
    physical_device: vk::PhysicalDevice,
) -&gt; Result&lt;()&gt; {
    // ...

    let support = SwapchainSupport::get(instance, data, physical_device)?;
    if support.formats.is_empty() || support.present_modes.is_empty() {
        return Err(anyhow!(SuitabilityError(&quot;Insufficient swapchain support.&quot;)));
    }

    Ok(())
}
</code></pre>
<p>It is important that we only try to query for swapchain support after verifying that the extension is available.</p>
<h2 id="choosing-the-right-settings-for-the-swapchain"><a class="header" href="#choosing-the-right-settings-for-the-swapchain">Choosing the right settings for the swapchain</a></h2>
<p>If the conditions we just added were met then the support is definitely sufficient, but there may still be many different modes of varying optimality. We'll now write a couple of functions to find the right settings for the best possible swapchain. There are three types of settings to determine:</p>
<ul>
<li>Surface format (color depth)</li>
<li>Presentation mode (conditions for &quot;swapping&quot; images to the screen)</li>
<li>Swap extent (resolution of images in swapchain)</li>
</ul>
<p>For each of these settings we'll have an ideal value in mind that we'll go with if it's available and otherwise we'll create some logic to find the next best thing.</p>
<h3 id="surface-format"><a class="header" href="#surface-format">Surface format</a></h3>
<p>The function for this setting starts out like this. We'll later pass the <code>formats</code> field of the <code>SwapchainSupport</code> struct as argument.</p>
<pre><code class="language-rust noplaypen">fn get_swapchain_surface_format(
    formats: &amp;[vk::SurfaceFormatKHR],
) -&gt; vk::SurfaceFormatKHR {
}
</code></pre>
<p>Each <a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.SurfaceFormatKHR.html"><code class="hljs">vk::SurfaceFormatKHR</code></a> entry contains a <code>format</code> and a <code>color_space</code> member. The <code>format</code> member specifies the color channels and types. For example, <a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.Format.html#associatedconstant.B8G8R8A8_SRGB"><code class="hljs">vk::Format::B8G8R8A8_SRGB</code></a> means that we store the B, G, R and alpha channels in that order with an 8 bit unsigned integer for a total of 32 bits per pixel. The <code>color_space</code> member indicates if the sRGB color space is supported or not using the <a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.ColorSpaceKHR.html#associatedconstant.SRGB_NONLINEAR"><code class="hljs">vk::ColorSpaceKHR::SRGB_NONLINEAR</code></a> flag.</p>
<p>For the color space we'll use sRGB if it is available, because it <a href="http://stackoverflow.com/questions/12524623/">results in more accurate perceived colors</a>. It is also pretty much the standard color space for images, like the textures we'll use later on. Because of that we should also use an sRGB color format, of which one of the most common ones is <a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.Format.html#associatedconstant.B8G8R8A8_SRGB"><code class="hljs">vk::Format::B8G8R8A8_SRGB</code></a>.</p>
<p>Let's go through the list and see if the preferred combination is available:</p>
<pre><code class="language-rust noplaypen">fn get_swapchain_surface_format(
    formats: &amp;[vk::SurfaceFormatKHR],
) -&gt; vk::SurfaceFormatKHR {
    formats
        .iter()
        .cloned()
        .find(|f| {
            f.format == vk::Format::B8G8R8A8_SRGB
                &amp;&amp; f.color_space == vk::ColorSpaceKHR::SRGB_NONLINEAR
        })
        .unwrap_or_else(|| formats[0])
}
</code></pre>
<p>If that also fails then we could rank the available formats based on how &quot;good&quot; they are, but in most cases it's okay to just settle with the first format that is specified hence <code>.unwrap_or_else(|| formats[0])</code>.</p>
<h3 id="presentation-mode"><a class="header" href="#presentation-mode">Presentation mode</a></h3>
<p>The presentation mode is arguably the most important setting for the swapchain, because it represents the actual conditions for showing images to the screen. There are four possible modes available in Vulkan:</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.PresentModeKHR.html#associatedconstant.IMMEDIATE"><code class="hljs">vk::PresentModeKHR::IMMEDIATE</code></a> – Images submitted by your application are transferred to the screen right away, which may result in tearing.</li>
<li><a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.PresentModeKHR.html#associatedconstant.FIFO"><code class="hljs">vk::PresentModeKHR::FIFO</code></a> – The swapchain is a queue where the display takes an image from the front of the queue when the display is refreshed and the program inserts rendered images at the back of the queue. If the queue is full then the program has to wait. This is most similar to vertical sync as found in modern games. The moment that the display is refreshed is known as &quot;vertical blank&quot;.</li>
<li><a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.PresentModeKHR.html#associatedconstant.FIFO_RELAXED"><code class="hljs">vk::PresentModeKHR::FIFO_RELAXED</code></a> – This mode only differs from the previous one if the application is late and the queue was empty at the last vertical blank. Instead of waiting for the next vertical blank, the image is transferred right away when it finally arrives. This may result in visible tearing.</li>
<li><a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.PresentModeKHR.html#associatedconstant.MAILBOX"><code class="hljs">vk::PresentModeKHR::MAILBOX</code></a> – This is another variation of the second mode. Instead of blocking the application when the queue is full, the images that are already queued are simply replaced with the newer ones. This mode can be used to render frames as fast as possible while still avoiding tearing, resulting in fewer latency issues than standard vertical sync. This is commonly known as &quot;triple buffering&quot;, although the existence of three buffers alone does not necessarily mean that the framerate is unlocked.</li>
</ul>
<p>Only the <a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.PresentModeKHR.html#associatedconstant.FIFO"><code class="hljs">vk::PresentModeKHR::FIFO</code></a> mode is guaranteed to be available, so we'll again have to write a function that looks for the best mode that is available:</p>
<pre><code class="language-rust noplaypen">fn get_swapchain_present_mode(
    present_modes: &amp;[vk::PresentModeKHR],
) -&gt; vk::PresentModeKHR {
}
</code></pre>
<p>I personally think that <a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.PresentModeKHR.html#associatedconstant.MAILBOX"><code class="hljs">vk::PresentModeKHR::MAILBOX</code></a> is a very nice trade-off if energy usage is not a concern. It allows us to avoid tearing while still maintaining a fairly low latency by rendering new images that are as up-to-date as possible right until the vertical blank. On mobile devices, where energy usage is more important, you will probably want to use <a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.PresentModeKHR.html#associatedconstant.FIFO"><code class="hljs">vk::PresentModeKHR::FIFO</code></a> instead. Now, let's look through the list to see if <a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.PresentModeKHR.html#associatedconstant.MAILBOX"><code class="hljs">vk::PresentModeKHR::MAILBOX</code></a> is available:</p>
<pre><code class="language-rust noplaypen">fn get_swapchain_present_mode(
    present_modes: &amp;[vk::PresentModeKHR],
) -&gt; vk::PresentModeKHR {
    present_modes
        .iter()
        .cloned()
        .find(|m| *m == vk::PresentModeKHR::MAILBOX)
        .unwrap_or(vk::PresentModeKHR::FIFO)
}
</code></pre>
<h3 id="swap-extent"><a class="header" href="#swap-extent">Swap extent</a></h3>
<p>That leaves only one major property, for which we'll add one last function:</p>
<pre><code class="language-rust noplaypen">fn get_swapchain_extent(
    window: &amp;Window,
    capabilities: vk::SurfaceCapabilitiesKHR,
) -&gt; vk::Extent2D {
}
</code></pre>
<p>The swap extent is the resolution of the swapchain images and it's almost always exactly equal to the resolution of the window that we're drawing to. The range of the possible resolutions is defined in the <a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.SurfaceCapabilitiesKHR.html"><code class="hljs">vk::SurfaceCapabilitiesKHR</code></a> structure. Vulkan tells us to match the resolution of the window by setting the width and height in the <code>current_extent</code> member. However, some window managers do allow us to differ here and this is indicated by setting the width and height in <code>current_extent</code> to a special value: the maximum value of <code>u32</code>. In that case we'll pick the resolution that best matches the window within the <code>min_image_extent</code> and <code>max_image_extent</code> bounds.</p>
<pre><code class="language-rust noplaypen">fn get_swapchain_extent(
    window: &amp;Window,
    capabilities: vk::SurfaceCapabilitiesKHR,
) -&gt; vk::Extent2D {
    if capabilities.current_extent.width != u32::MAX {
        capabilities.current_extent
    } else {
        vk::Extent2D::builder()
            .width(window.inner_size().width.clamp(
                capabilities.min_image_extent.width,
                capabilities.max_image_extent.width,
            ))
            .height(window.inner_size().height.clamp(
                capabilities.min_image_extent.height,
                capabilities.max_image_extent.height,
            ))
            .build()
    }
}
</code></pre>
<p>We use the <a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html#method.clamp"><code>clamp</code> function</a> to restrict the actual size of the window within the supported range supported by the Vulkan device.</p>
<h2 id="creating-the-swapchain"><a class="header" href="#creating-the-swapchain">Creating the swapchain</a></h2>
<p>Now that we have all of these helper functions assisting us with the choices we have to make at runtime, we finally have all the information that is needed to create a working swapchain.</p>
<p>Create a <code>create_swapchain</code> function that starts out with the results of these calls and make sure to call it from <code>App::create</code> after logical device creation.</p>
<pre><code class="language-rust noplaypen">impl App {
    unsafe fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        // ...
        let device = create_logical_device(&amp;instance, &amp;mut data)?;
        create_swapchain(window, &amp;instance, &amp;device, &amp;mut data)?;
        // ...
    }
}

unsafe fn create_swapchain(
    window: &amp;Window,
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;mut AppData,
) -&gt; Result&lt;()&gt; {
    let indices = QueueFamilyIndices::get(instance, data, data.physical_device)?;
    let support = SwapchainSupport::get(instance, data, data.physical_device)?;

    let surface_format = get_swapchain_surface_format(&amp;support.formats);
    let present_mode = get_swapchain_present_mode(&amp;support.present_modes);
    let extent = get_swapchain_extent(window, support.capabilities);

    Ok(())
}
</code></pre>
<p>Aside from these properties we also have to decide how many images we would like to have in the swapchain. The implementation specifies the minimum number that it requires to function:</p>
<pre><code class="language-rust noplaypen">let image_count = support.capabilities.min_image_count;
</code></pre>
<p>However, simply sticking to this minimum means that we may sometimes have to wait on the driver to complete internal operations before we can acquire another image to render to. Therefore it is recommended to request at least one more image than the minimum:</p>
<pre><code class="language-rust noplaypen">let image_count = support.capabilities.min_image_count + 1;
</code></pre>
<p>We should also make sure to not exceed the maximum number of images while doing this, where <code>0</code> is a special value that means that there is no maximum:</p>
<pre><code class="language-rust noplaypen">let mut image_count = support.capabilities.min_image_count + 1;
if support.capabilities.max_image_count != 0
    &amp;&amp; image_count &gt; support.capabilities.max_image_count
{
    image_count = support.capabilities.max_image_count;
}
</code></pre>
<p>Next, we need to specify how to handle swapchain images that will be used across multiple queue families. That will be the case in our application if the graphics queue family is different from the presentation queue. We'll be drawing on the images in the swapchain from the graphics queue and then submitting them on the presentation queue. There are two ways to handle images that are accessed from multiple queues:</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.SharingMode.html#associatedconstant.EXCLUSIVE"><code class="hljs">vk::SharingMode::EXCLUSIVE</code></a> – An image is owned by one queue family at a time and ownership must be explicitly transferred before using it in another queue family. This option offers the best performance.</li>
<li><a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.SharingMode.html#associatedconstant.CONCURRENT"><code class="hljs">vk::SharingMode::CONCURRENT</code></a> – Images can be used across multiple queue families without explicit ownership transfers.</li>
</ul>
<p>If the queue families differ, then we'll be using the concurrent mode in this tutorial to avoid having to do the ownership chapters, because these involve some concepts that are better explained at a later time. Concurrent mode requires you to specify in advance between which queue families ownership will be shared using the <code>queue_family_indices</code> builder method. If the graphics queue family and presentation queue family are the same, which will be the case on most hardware, then we should stick to exclusive mode, because concurrent mode requires you to specify at least two distinct queue families.</p>
<pre><code class="language-rust noplaypen">let mut queue_family_indices = vec![];
let image_sharing_mode = if indices.graphics != indices.present {
    queue_family_indices.push(indices.graphics);
    queue_family_indices.push(indices.present);
    vk::SharingMode::CONCURRENT
} else {
    vk::SharingMode::EXCLUSIVE
};
</code></pre>
<p>As is tradition with Vulkan objects, creating the swapchain object requires filling in a large structure. It starts out very familiarly:</p>
<pre><code class="language-rust noplaypen">let info = vk::SwapchainCreateInfoKHR::builder()
    .surface(data.surface)
    // continued...
</code></pre>
<p>After specifying which surface the swapchain should be tied to, the details of the swapchain images are specified:</p>
<pre><code class="language-rust noplaypen">    .min_image_count(image_count)
    .image_format(surface_format.format)
    .image_color_space(surface_format.color_space)
    .image_extent(extent)
    .image_array_layers(1)
    .image_usage(vk::ImageUsageFlags::COLOR_ATTACHMENT)
</code></pre>
<p>The <code>image_array_layers</code> specifies the amount of layers each image consists of. This is always <code>1</code> unless you are developing a stereoscopic 3D application. The <code>image_usage</code> bitmask specifies what kind of operations we'll use the images in the swapchain for. In this tutorial we're going to render directly to them, which means that they're used as color attachment. It is also possible that you'll render images to a separate image first to perform operations like post-processing. In that case you may use a value like <a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.ImageUsageFlags.html#associatedconstant.TRANSFER_DST"><code class="hljs">vk::ImageUsageFlags::TRANSFER_DST</code></a> instead and use a memory operation to transfer the rendered image to a swapchain image.</p>
<pre><code class="language-rust noplaypen">    .image_sharing_mode(image_sharing_mode)
    .queue_family_indices(&amp;queue_family_indices)
</code></pre>
<p>Next we'll provide the image sharing mode and indices of the queue families permitted to share the swapchain images.</p>
<pre><code class="language-rust noplaypen">    .pre_transform(support.capabilities.current_transform)
</code></pre>
<p>We can specify that a certain transform should be applied to images in the swapchain if it is supported (<code>supported_transforms</code> in <code>capabilities</code>), like a 90 degree clockwise rotation or horizontal flip. To specify that you do not want any transformation, simply specify the current transformation.</p>
<pre><code class="language-rust noplaypen">    .composite_alpha(vk::CompositeAlphaFlagsKHR::OPAQUE)
</code></pre>
<p>The <code>composite_alpha</code> method specifies if the alpha channel should be used for blending with other windows in the window system. You'll almost always want to simply ignore the alpha channel, hence <a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.CompositeAlphaFlagsKHR.html#associatedconstant.OPAQUE"><code class="hljs">vk::CompositeAlphaFlagsKHR::OPAQUE</code></a>.</p>
<pre><code class="language-rust noplaypen">    .present_mode(present_mode)
    .clipped(true)
</code></pre>
<p>The <code>present_mode</code> member speaks for itself. If the <code>clipped</code> member is set to <code>true</code> then that means that we don't care about the color of pixels that are obscured, for example because another window is in front of them. Unless you really need to be able to read these pixels back and get predictable results, you'll get the best performance by enabling clipping.</p>
<pre><code class="language-rust noplaypen">    .old_swapchain(vk::SwapchainKHR::null());
</code></pre>
<p>That leaves one last method, <code>old_swapchain</code>. With Vulkan it's possible that your swapchain becomes invalid or unoptimized while your application is running, for example because the window was resized. In that case the swapchain actually needs to be recreated from scratch and a reference to the old one must be specified in this method. This is a complex topic that we'll learn more about in a future chapter. For now we'll assume that we'll only ever create one swapchain. We could omit this method since the underlying field will default to a null handle, but we'll leave it in for completeness.</p>
<p>Now add an <code>AppData</code> field to store the <a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.SwapchainKHR.html"><code class="hljs">vk::SwapchainKHR</code></a> object:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    swapchain: vk::SwapchainKHR,
}
</code></pre>
<p>Creating the swapchain is now as simple as calling <a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/trait.KhrSwapchainExtension.html#method.create_swapchain_khr"><code class="hljs">create_swapchain_khr</code></a>:</p>
<pre><code class="language-rust noplaypen">data.swapchain = device.create_swapchain_khr(&amp;info, None)?;
</code></pre>
<p>The parameters are the swapchain creation info and optional custom allocators. No surprises there. It should be cleaned up in <code>App::destroy</code> before the device:</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy(&amp;mut self) {
    self.device.destroy_swapchain_khr(self.data.swapchain, None);
    // ...
}
</code></pre>
<p>Now run the application to ensure that the swapchain is created successfully! If at this point you get an access violation error in <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/vkCreateSwapchainKHR.html"><code class="hljs">vkCreateSwapchainKHR</code></a> or see a message like <code>Failed to find 'vkGetInstanceProcAddress' in layer SteamOverlayVulkanLayer.dll</code>, then see the <a href="../faq.html">FAQ entry</a> about the Steam overlay layer.</p>
<p>Try removing the <code>.image_extent(extent)</code> line from where you are building the <a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.SwapchainCreateInfoKHR.html"><code class="hljs">vk::SwapchainCreateInfoKHR</code></a> struct with validation layers enabled. You'll see that one of the validation layers immediately catches the mistake and some helpful messages are printed which call out the illegal value provided for <code>image_extent</code>:</p>
<p><img src="../images/swapchain_validation_layer.png" alt="" /></p>
<h2 id="retrieving-the-swapchain-images"><a class="header" href="#retrieving-the-swapchain-images">Retrieving the swapchain images</a></h2>
<p>The swapchain has been created now, so all that remains is retrieving the handles of the <a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/struct.Image.html"><code class="hljs">vk::Image</code></a>s in it. We'll reference these during rendering operations in later chapters. Add an <code>AppData</code> field to store the handles:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    swapchain_images: Vec&lt;vk::Image&gt;,
}
</code></pre>
<p>The images were created by the implementation for the swapchain and they will be automatically cleaned up once the swapchain has been destroyed, therefore we don't need to add any cleanup code.</p>
<p>I'm adding the code to retrieve the handles to the end of the <code>create_swapchain</code> function, right after the <a href="https://docs.rs/vulkanalia/0.32.0/vulkanalia/vk/trait.KhrSwapchainExtension.html#method.create_swapchain_khr"><code class="hljs">create_swapchain_khr</code></a> call.</p>
<pre><code class="language-rust noplaypen">data.swapchain_images = device.get_swapchain_images_khr(data.swapchain)?;
</code></pre>
<p>One last thing, store the format and extent we've chosen for the swapchain images in <code>AppData</code> fields. We'll need them in future chapters.</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    swapchain_format: vk::Format,
    swapchain_extent: vk::Extent2D,
    swapchain: vk::SwapchainKHR,
    swapchain_images: Vec&lt;vk::Image&gt;,
}
</code></pre>
<p>And then in <code>create_swapchain</code>:</p>
<pre><code class="language-rust noplaypen">data.swapchain_format = surface_format.format;
data.swapchain_extent = extent;
</code></pre>
<p>We now have a set of images that can be drawn onto and can be presented to the window. The next chapter will begin to cover how we can set up the images as render targets and then we start looking into the actual graphics pipeline and drawing commands!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../presentation/window_surface.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../presentation/image_views.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../presentation/window_surface.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../presentation/image_views.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>



        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
