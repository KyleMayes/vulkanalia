<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Vulkan Tutorial (Rust)</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A Vulkan tutorial for Rust.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">2.</strong> Overview</a></li><li class="chapter-item expanded "><a href="development_environment.html"><strong aria-hidden="true">3.</strong> Development environment</a></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">4.</strong> FAQ</a></li><li class="chapter-item expanded affix "><li class="part-title">Setup</li><li class="chapter-item expanded "><a href="setup/base_code.html"><strong aria-hidden="true">5.</strong> Base code</a></li><li class="chapter-item expanded "><a href="setup/instance.html"><strong aria-hidden="true">6.</strong> Instance</a></li><li class="chapter-item expanded "><a href="setup/validation_layers.html"><strong aria-hidden="true">7.</strong> Validation layers</a></li><li class="chapter-item expanded "><a href="setup/physical_devices_and_queue_families.html"><strong aria-hidden="true">8.</strong> Physical devices and queue families</a></li><li class="chapter-item expanded "><a href="setup/logical_device_and_queues.html"><strong aria-hidden="true">9.</strong> Logical device and queues</a></li><li class="chapter-item expanded affix "><li class="part-title">Presentation</li><li class="chapter-item expanded "><a href="presentation/window_surface.html"><strong aria-hidden="true">10.</strong> Window surface</a></li><li class="chapter-item expanded "><a href="presentation/swapchain.html"><strong aria-hidden="true">11.</strong> Swapchain</a></li><li class="chapter-item expanded "><a href="presentation/image_views.html"><strong aria-hidden="true">12.</strong> Image views</a></li><li class="chapter-item expanded affix "><li class="part-title">Pipeline</li><li class="chapter-item expanded "><a href="pipeline/introduction.html"><strong aria-hidden="true">13.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="pipeline/shader_modules.html"><strong aria-hidden="true">14.</strong> Shader modules</a></li><li class="chapter-item expanded "><a href="pipeline/fixed_functions.html"><strong aria-hidden="true">15.</strong> Fixed functions</a></li><li class="chapter-item expanded "><a href="pipeline/render_passes.html"><strong aria-hidden="true">16.</strong> Render passes</a></li><li class="chapter-item expanded "><a href="pipeline/conclusion.html"><strong aria-hidden="true">17.</strong> Conclusion</a></li><li class="chapter-item expanded affix "><li class="part-title">Drawing</li><li class="chapter-item expanded "><a href="drawing/framebuffers.html"><strong aria-hidden="true">18.</strong> Framebuffers</a></li><li class="chapter-item expanded "><a href="drawing/command_buffers.html"><strong aria-hidden="true">19.</strong> Command buffers</a></li><li class="chapter-item expanded "><a href="drawing/rendering_and_presentation.html"><strong aria-hidden="true">20.</strong> Rendering and presentation</a></li><li class="chapter-item expanded affix "><li class="part-title">Swapchain</li><li class="chapter-item expanded "><a href="swapchain/recreation.html"><strong aria-hidden="true">21.</strong> Recreation</a></li><li class="chapter-item expanded affix "><li class="part-title">Vertex buffers</li><li class="chapter-item expanded "><a href="vertex/vertex_input_description.html"><strong aria-hidden="true">22.</strong> Vertex input description</a></li><li class="chapter-item expanded "><a href="vertex/vertex_buffer_creation.html"><strong aria-hidden="true">23.</strong> Vertex buffer creation</a></li><li class="chapter-item expanded "><a href="vertex/staging_buffer.html"><strong aria-hidden="true">24.</strong> Staging buffer</a></li><li class="chapter-item expanded "><a href="vertex/index_buffer.html"><strong aria-hidden="true">25.</strong> Index buffer</a></li><li class="chapter-item expanded affix "><li class="part-title">Uniform buffers</li><li class="chapter-item expanded "><a href="uniform/descriptor_set_layout_and_buffer.html"><strong aria-hidden="true">26.</strong> Descriptor set layout and buffer</a></li><li class="chapter-item expanded "><a href="uniform/descriptor_pool_and_sets.html"><strong aria-hidden="true">27.</strong> Descriptor pool and sets</a></li><li class="chapter-item expanded affix "><li class="part-title">Texture mapping</li><li class="chapter-item expanded "><a href="texture/images.html"><strong aria-hidden="true">28.</strong> Images</a></li><li class="chapter-item expanded "><a href="texture/image_view_and_sampler.html"><strong aria-hidden="true">29.</strong> Image view and sampler</a></li><li class="chapter-item expanded "><a href="texture/combined_image_sampler.html"><strong aria-hidden="true">30.</strong> Combined image sampler</a></li><li class="chapter-item expanded affix "><li class="part-title">Model</li><li class="chapter-item expanded "><a href="model/depth_buffering.html"><strong aria-hidden="true">31.</strong> Depth buffering</a></li><li class="chapter-item expanded "><a href="model/loading_models.html"><strong aria-hidden="true">32.</strong> Loading models</a></li><li class="chapter-item expanded affix "><li class="part-title">Rendering quality</li><li class="chapter-item expanded "><a href="quality/generating_mipmaps.html"><strong aria-hidden="true">33.</strong> Generating mipmaps</a></li><li class="chapter-item expanded "><a href="quality/multisampling.html"><strong aria-hidden="true">34.</strong> Multisampling</a></li><li class="chapter-item expanded affix "><li class="part-title">Dynamic scenes</li><li class="chapter-item expanded "><a href="dynamic/push_constants.html"><strong aria-hidden="true">35.</strong> Push constants</a></li><li class="chapter-item expanded "><a href="dynamic/recycling_command_buffers.html"><strong aria-hidden="true">36.</strong> Recycling command buffers</a></li><li class="chapter-item expanded "><a href="dynamic/secondary_command_buffers.html"><strong aria-hidden="true">37.</strong> Secondary command buffers</a></li><li class="chapter-item expanded affix "><li class="part-title">Conclusion</li><li class="chapter-item expanded "><a href="conclusion.html"><strong aria-hidden="true">38.</strong> Conclusion</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Vulkan Tutorial (Rust)</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/KyleMayes/vulkanalia" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This tutorial is an adaptation of <a href="https://vulkan-tutorial.com">https://vulkan-tutorial.com</a> to use Rust instead of C++. The majority of the credit for this tutorial should go the author of the original tutorial (<a href="https://github.com/Overv">Alexander Overvoorde</a>) and the <a href="https://github.com/Overv/VulkanTutorial/graphs/contributors">other contributors</a>.</p>
<p>This tutorial also includes several additional chapters that are original creations of the author of this adapted tutorial (starting with the <code>Push Constants</code> chapter). These chapters introduce important Vulkan concepts and features that will be useful in almost any Vulkan application. However, as noted in the disclaimer for those chapters, they should be considered experimental.</p>
<h2 id="about"><a class="header" href="#about">About</a></h2>
<p>This tutorial will teach you the basics of using the <a href="https://www.khronos.org/vulkan/">Vulkan</a> graphics and compute API. Vulkan is a new API by the <a href="https://www.khronos.org/">Khronos group</a> (known for OpenGL) that provides a much better abstraction of modern graphics cards. This new interface allows you to better describe what your application intends to do, which can lead to better performance and less surprising driver behavior compared to existing APIs like <a href="https://en.wikipedia.org/wiki/OpenGL">OpenGL</a> and <a href="https://en.wikipedia.org/wiki/Direct3D">Direct3D</a>. The ideas behind Vulkan are similar to those of <a href="https://en.wikipedia.org/wiki/Direct3D#Direct3D_12">Direct3D 12</a> and <a href="https://en.wikipedia.org/wiki/Metal_(API)">Metal</a>, but Vulkan has the advantage of being cross-platform and allows you to develop for Windows, Linux and Android at the same time (and iOS and macOS via <a href="https://github.com/KhronosGroup/MoltenVK">MoltenVK</a>).</p>
<p>However, the price you pay for these benefits is that you have to work with a significantly more verbose API. Every detail related to the graphics API needs to be set up from scratch by your application, including initial frame buffer creation and memory management for objects like buffers and texture images. The graphics driver will do a lot less hand holding, which means that you will have to do more work in your application to ensure correct behavior.</p>
<p>The takeaway message here is that Vulkan is not for everyone. It is targeted at programmers who are enthusiastic about high performance computer graphics, and are willing to put some work in. If you are more interested in game development, rather than computer graphics, then you may wish to stick to OpenGL or Direct3D, which will not be deprecated in favor of Vulkan anytime soon. Another alternative is to use an engine like <a href="https://en.wikipedia.org/wiki/Unreal_Engine#Unreal_Engine_4">Unreal Engine</a> or <a href="https://en.wikipedia.org/wiki/Unity_(game_engine)">Unity</a>, which will be able to use Vulkan while exposing a much higher level API to you.</p>
<p>With that out of the way, let's cover some prerequisites for following this tutorial:</p>
<ul>
<li>A graphics card and driver compatible with Vulkan (<a href="https://developer.nvidia.com/vulkan-driver">NVIDIA</a>, <a href="http://www.amd.com/en-us/innovations/software-technologies/technologies-gaming/vulkan">AMD</a>, <a href="https://software.intel.com/en-us/blogs/2016/03/14/new-intel-vulkan-beta-1540204404-graphics-driver-for-windows-78110-1540">Intel</a>)</li>
<li>Experience with Rust</li>
<li>Rust 1.88 or later</li>
<li>Some existing experience with 3D computer graphics</li>
</ul>
<p>This tutorial will not assume knowledge of OpenGL or Direct3D concepts, but it does require you to know the basics of 3D computer graphics. It will not explain the math behind perspective projection, for example. See <a href="https://paroj.github.io/gltut/">this online book</a> for a great introduction of computer graphics concepts. Some other great computer graphics resources are:</p>
<ul>
<li><a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">Ray tracing in one weekend</a></li>
<li><a href="http://www.pbr-book.org/">Physically Based Rendering book</a></li>
<li>Vulkan being used in a real engine in the open-source <a href="https://github.com/Novum/vkQuake">Quake</a> and <a href="https://github.com/DustinHLand/vkDOOM3">DOOM 3</a></li>
</ul>
<p>If you want a C++ tutorial instead, see the original tutorial:<br/>
<a href="https://vulkan-tutorial.com">https://vulkan-tutorial.com</a></p>
<p>This tutorial uses the <a href="https://github.com/KyleMayes/vulkanalia"><code>vulkanalia</code></a> crate to provide access to the Vulkan API from Rust. <code>vulkanalia</code> provides raw bindings to the Vulkan API as well as a thin wrapper over said bindings to make them easier and more idiomatic to use from Rust (more on this in the next chapter). This means that while you should never have any difficulty in determining exactly how your Rust programs are interacting with the Vulkan API, you will be shielded from little of the danger and verbosity of the Vulkan API.</p>
<p>If you want a Rust Vulkan tutorial that uses a crate which provides a safe and relatively concise wrapper around the Vulkan API (<a href="https://vulkano.rs"><code>vulkano</code></a>), see this tutorial:<br/>
<a href="https://github.com/bwasty/vulkan-tutorial-rs">https://github.com/bwasty/vulkan-tutorial-rs</a></p>
<h2 id="tutorial-structure"><a class="header" href="#tutorial-structure">Tutorial structure</a></h2>
<p>We'll start with an overview of how Vulkan works and the work we'll have to do to get the first triangle on the screen. The purpose of all the smaller steps will make more sense after you've understood their basic role in the whole picture. Next, we'll set up the development environment with the <a href="https://lunarg.com/vulkan-sdk/">Vulkan SDK</a>.</p>
<p>After that we'll implement all of the basic components of a Vulkan program that are necessary to render your first triangle. Each chapter will follow roughly the following structure:</p>
<ul>
<li>Introduce a new concept and its purpose</li>
<li>Use all of the relevant API calls to integrate it into your program</li>
<li>Abstract parts of it into helper functions</li>
</ul>
<p>Although each chapter is written as a follow-up on the previous one, it is also possible to read the chapters as standalone articles introducing a certain Vulkan feature. That means that the site is also useful as a reference. All of the Vulkan functions and types are linked to the either the Vulkan specification or to the <code>vulkanalia</code> documentation, so you can click them to learn more. Vulkan is still a fairly young API, so there may be some shortcomings in the specification itself. You are encouraged to submit feedback to <a href="https://github.com/KhronosGroup/Vulkan-Docs">this Khronos repository</a>.</p>
<p>As mentioned before, the Vulkan API has a rather verbose API with many parameters to give you maximum control over the graphics hardware. This causes basic operations like creating a texture to take a lot of steps that have to be repeated every time. Therefore we'll be creating our own collection of helper functions throughout the tutorial.</p>
<p>Every chapter will also start with a link to the final code for that chapter. You can refer to it if you have any doubts about the structure of the code, or if you're dealing with a bug and want to compare.</p>
<p>This tutorial is intended to be a community effort. Vulkan is still a fairly new API and best practices haven't been fully established. If you have any type of feedback on the tutorial and site itself, then please don't hesitate to submit an issue or pull request to the <a href="https://github.com/KyleMayes/vulkanalia">GitHub repository</a>.</p>
<p>After you've gone through the ritual of drawing your very first Vulkan powered triangle onscreen, we'll start expanding the program to include linear transformations, textures and 3D models.</p>
<p>If you've played with graphics APIs before, then you'll know that there can be a lot of steps until the first geometry shows up on the screen. There are many of these initial steps in Vulkan, but you'll see that each of the individual steps is easy to understand and does not feel redundant. It's also important to keep in mind that once you have that boring looking triangle, drawing fully textured 3D models does not take that much extra work, and each step beyond that point is much more rewarding.</p>
<p>If you encounter any problems while following the tutorial, check the FAQ to see if your problem and its solution is already listed there. Next, you might find someone who had the same problem (if it is not Rust-specific) in the comment section for the corresponding chapter in the <a href="https://vulkan-tutorial.com/">original tutorial</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>This chapter will start off with an introduction of Vulkan and the problems it addresses. After that we're going to look at the ingredients that are required for the first triangle. This will give you a big picture to place each of the subsequent chapters in. We will conclude by covering the structure of the Vulkan API as implemented by <code>vulkanalia</code>.</p>
<h2 id="origin-of-vulkan"><a class="header" href="#origin-of-vulkan">Origin of Vulkan</a></h2>
<p>Just like the previous graphics APIs, Vulkan is designed as a cross-platform abstraction over <a href="https://en.wikipedia.org/wiki/Graphics_processing_unit">GPUs</a>. The problem with most of these APIs is that the era in which they were designed featured graphics hardware that was mostly limited to configurable fixed functionality. Programmers had to provide the vertex data in a standard format and were at the mercy of the GPU manufacturers with regards to lighting and shading options.</p>
<p>As graphics card architectures matured, they started offering more and more programmable functionality. All this new functionality had to be integrated with the existing APIs somehow. This resulted in less than ideal abstractions and a lot of guesswork on the graphics driver side to map the programmer's intent to the modern graphics architectures. That's why there are so many driver updates for improving the performance in games, sometimes by significant margins. Because of the complexity of these drivers, application developers also need to deal with inconsistencies between vendors, like the syntax that is accepted for <a href="https://en.wikipedia.org/wiki/Shader">shaders</a>. Aside from these new features, the past decade also saw an influx of mobile devices with powerful graphics hardware. These mobile GPUs have different architectures based on their energy and space requirements. One such example is <a href="https://en.wikipedia.org/wiki/Tiled_rendering">tiled rendering</a>, which would benefit from improved performance by offering the programmer more control over this functionality. Another limitation originating from the age of these APIs is limited multi-threading support, which can result in a bottleneck on the CPU side.</p>
<p>Vulkan solves these problems by being designed from scratch for modern graphics architectures. It reduces driver overhead by allowing programmers to clearly specify their intent using a more verbose API, and allows multiple threads to create and submit commands in parallel. It reduces inconsistencies in shader compilation by switching to a standardized byte code format with a single compiler. Lastly, it acknowledges the general purpose processing capabilities of modern graphics cards by unifying the graphics and compute functionality into a single API.</p>
<h2 id="what-it-takes-to-draw-a-triangle"><a class="header" href="#what-it-takes-to-draw-a-triangle">What it takes to draw a triangle</a></h2>
<p>We'll now look at an overview of all the steps it takes to render a triangle in a well-behaved Vulkan program. All of the concepts introduced here will be elaborated on in the next chapters. This is just to give you a big picture to relate all of the individual components to.</p>
<h3 id="step-1---instance-and-physical-device-selection"><a class="header" href="#step-1---instance-and-physical-device-selection">Step 1 - Instance and physical device selection</a></h3>
<p>A Vulkan application starts by setting up the Vulkan API through a <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VkInstance.html"><code class="hljs">VkInstance</code></a>. An instance is created by describing your application and any API extensions you will be using. After creating the instance, you can query for Vulkan supported hardware and select one or more <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VkPhysicalDevice.html"><code class="hljs">VkPhysicalDevice</code></a>s to use for operations. You can query for properties like VRAM size and device capabilities to select desired devices, for example to prefer using dedicated graphics cards.</p>
<h3 id="step-2---logical-device-and-queue-families"><a class="header" href="#step-2---logical-device-and-queue-families">Step 2 - Logical device and queue families</a></h3>
<p>After selecting the right hardware device to use, you need to create a <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VkDevice.html"><code class="hljs">VkDevice</code></a> (logical device), where you describe more specifically which <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VkPhysicalDeviceFeatures.html"><code class="hljs">VkPhysicalDeviceFeatures</code></a> you will be using, like multi-viewport rendering and 64-bit floats. You also need to specify which queue families you would like to use. Most operations performed with Vulkan, like draw commands and memory operations, are asynchronously executed by submitting them to a <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VkQueue.html"><code class="hljs">VkQueue</code></a>. Queues are allocated from queue families, where each queue family supports a specific set of operations in its queues. For example, there could be separate queue families for graphics, compute and memory transfer operations. The availability of queue families could also be used as a distinguishing factor in physical device selection. It is possible for a device with Vulkan support to not offer any graphics functionality, however all graphics cards with Vulkan support today will generally support all queue operations that we're interested in.</p>
<h3 id="step-3---window-surface-and-swapchain"><a class="header" href="#step-3---window-surface-and-swapchain">Step 3 - Window surface and swapchain</a></h3>
<p>Unless you're only interested in offscreen rendering, you will need to create a window to present rendered images to. Windows can be created with the native platform APIs or libraries like <a href="http://www.glfw.org/">GLFW</a>, <a href="https://www.libsdl.org/">SDL</a>, or the <a href="https://github.com/rust-windowing/winit"><code>winit</code></a> crate. We will be using the <code>winit</code> crate in this tutorial, but more about that in the next chapter.</p>
<p>We need two more components to actually render to a window: a window surface (<a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VkSurfaceKHR.html"><code class="hljs">VkSurfaceKHR</code></a>) and a swapchain (<a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VkSwapchainKHR.html"><code class="hljs">VkSwapchainKHR</code></a>). Note the <code>KHR</code> postfix, which means that these objects are part of a Vulkan extension. The Vulkan API itself is completely platform agnostic, which is why we need to use the standardized WSI (Window System Interface) extension to interact with the window manager. The surface is a cross-platform abstraction over windows to render to and is generally instantiated by providing a reference to the native window handle, for example <code>HWND</code> on Windows. However, <code>vulkanalia</code> has optional integration with the <code>winit</code> crate which we will be leveraging to handle the platform-specific details of creating a window and associated surface for us.</p>
<p>The swapchain is a collection of render targets. Its basic purpose is to ensure that the image that we're currently rendering to is different from the one that is currently on the screen. This is important to make sure that only complete images are shown. Every time we want to draw a frame we have to ask the swapchain to provide us with an image to render to. When we've finished drawing a frame, the image is returned to the swapchain for it to be presented to the screen at some point. The number of render targets and conditions for presenting finished images to the screen depends on the present mode. Common present modes are  double buffering (vsync) and triple buffering. We'll look into these in the swapchain creation chapter.</p>
<p>Some platforms allow you to render directly to a display without interacting with any window manager through the <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VK_KHR_display.html"><code class="hljs">VK_KHR_display</code></a> and <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VK_KHR_display_swapchain.html"><code class="hljs">VK_KHR_display_swapchain</code></a> extensions. These allow you to create a surface that represents the entire screen and could be used to implement your own window manager, for example.</p>
<h3 id="step-4---image-views-and-framebuffers"><a class="header" href="#step-4---image-views-and-framebuffers">Step 4 - Image views and framebuffers</a></h3>
<p>To draw to an image acquired from the swapchain, we have to wrap it into a <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VkImageView.html"><code class="hljs">VkImageView</code></a> and <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VkFramebuffer.html"><code class="hljs">VkFramebuffer</code></a>. An image view references a specific part of an image to be used, and a framebuffer references image views that are to be used for color, depth and stencil targets. Because there could be many different images in the swapchain, we'll preemptively create an image view and framebuffer for each of them and select the right one at draw time.</p>
<h3 id="step-5---render-passes"><a class="header" href="#step-5---render-passes">Step 5 - Render passes</a></h3>
<p>Render passes in Vulkan describe the type of images that are used during rendering operations, how they will be used, and how their contents should be treated. In our initial triangle rendering application, we'll tell Vulkan that we will use a single image as color target and that we want it to be cleared to a solid color right before the drawing operation. Whereas a render pass only describes the type of images, a <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VkFramebuffer.html"><code class="hljs">VkFramebuffer</code></a> actually binds specific images to these slots.</p>
<h3 id="step-6---graphics-pipeline"><a class="header" href="#step-6---graphics-pipeline">Step 6 - Graphics pipeline</a></h3>
<p>The graphics pipeline in Vulkan is set up by creating a <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VkPipeline.html"><code class="hljs">VkPipeline</code></a> object. It describes the configurable state of the graphics card, like the viewport size and depth buffer operation and the programmable state using <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VkShaderModule.html"><code class="hljs">VkShaderModule</code></a> objects. The <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VkShaderModule.html"><code class="hljs">VkShaderModule</code></a> objects are created from shader byte code. The driver also needs to know which render targets will be used in the pipeline, which we specify by referencing the render pass.</p>
<p>One of the most distinctive features of Vulkan compared to existing APIs, is that almost all configuration of the graphics pipeline needs to be set in advance. That means that if you want to switch to a different shader or slightly change your vertex layout, then you need to entirely recreate the graphics pipeline. That means that you will have to create many <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VkPipeline.html"><code class="hljs">VkPipeline</code></a> objects in advance for all the different combinations you need for your rendering operations. Only some basic configuration, like viewport size and clear color, can be changed dynamically. All of the state also needs to be described explicitly, there is no default color blend state, for example.</p>
<p>The good news is that because you're doing the equivalent of ahead-of-time compilation versus just-in-time compilation, there are more optimization opportunities for the driver and runtime performance is more predictable, because large state changes like switching to a different graphics pipeline are made very explicit.</p>
<h3 id="step-7---command-pools-and-command-buffers"><a class="header" href="#step-7---command-pools-and-command-buffers">Step 7 - Command pools and command buffers</a></h3>
<p>As mentioned earlier, many of the operations in Vulkan that we want to execute, like drawing operations, need to be submitted to a queue. These operations first need to be recorded into a <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VkCommandBuffer.html"><code class="hljs">VkCommandBuffer</code></a> before they can be submitted. These command buffers are allocated from a <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VkCommandPool.html"><code class="hljs">VkCommandPool</code></a> that is associated with a specific queue family. To draw a simple triangle, we need to record a command buffer with the following operations:</p>
<ul>
<li>Begin the render pass</li>
<li>Bind the graphics pipeline</li>
<li>Draw 3 vertices</li>
<li>End the render pass</li>
</ul>
<p>Because the image in the framebuffer depends on which specific image the swapchain will give us, we need to record a command buffer for each possible image and select the right one at draw time. The alternative would be to record the command buffer again every frame, which is not as efficient.</p>
<h3 id="step-8---main-loop"><a class="header" href="#step-8---main-loop">Step 8 - Main loop</a></h3>
<p>Now that the drawing commands have been wrapped into a command buffer, the main loop is quite straightforward. We first acquire an image from the swapchain with <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/vkAcquireNextImageKHR.html"><code class="hljs">vkAcquireNextImageKHR</code></a>. We can then select the appropriate command buffer for that image and execute it with <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/vkQueueSubmit.html"><code class="hljs">vkQueueSubmit</code></a>. Finally, we return the image to the swapchain for presentation to the screen with <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/vkQueuePresentKHR.html"><code class="hljs">vkQueuePresentKHR</code></a>.</p>
<p>Operations that are submitted to queues are executed asynchronously. Therefore we have to use synchronization objects like semaphores to ensure a correct order of execution. Execution of the draw command buffer must be set up to wait on image acquisition to finish, otherwise it may occur that we start rendering to an image that is still being read for presentation on the screen. The <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/vkQueuePresentKHR.html"><code class="hljs">vkQueuePresentKHR</code></a> call in turn needs to wait for rendering to be finished, for which we'll use a second semaphore that is signaled after rendering completes.</p>
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<p>This whirlwind tour should give you a basic understanding of the work ahead for drawing the first triangle. A real-world program contains more steps, like allocating vertex buffers, creating uniform buffers and uploading texture images that will be covered in subsequent chapters, but we'll start simple because Vulkan has enough of a steep learning curve as it is. Note that we'll cheat a bit by initially embedding the vertex coordinates in the vertex shader instead of using a vertex buffer. That's because managing vertex buffers requires some familiarity with command buffers first.</p>
<p>So in short, to draw the first triangle we need to:</p>
<ul>
<li>Create a <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VkInstance.html"><code class="hljs">VkInstance</code></a></li>
<li>Select a supported graphics card (<a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VkPhysicalDevice.html"><code class="hljs">VkPhysicalDevice</code></a>)</li>
<li>Create a <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VkDevice.html"><code class="hljs">VkDevice</code></a> and <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VkQueue.html"><code class="hljs">VkQueue</code></a> for drawing and presentation</li>
<li>Create a window, window surface and swapchain</li>
<li>Wrap the swapchain images into <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VkImageView.html"><code class="hljs">VkImageView</code></a></li>
<li>Create a render pass that specifies the render targets and usage</li>
<li>Create framebuffers for the render pass</li>
<li>Set up the graphics pipeline</li>
<li>Allocate and record a command buffer with the draw commands for every possible swapchain image</li>
<li>Draw frames by acquiring images, submitting the right draw command buffer and returning the images back to the swapchain</li>
</ul>
<p>It's a lot of steps, but the purpose of each individual step will be made very simple and clear in the upcoming chapters. If you're confused about the relation of a single step compared to the whole program, you should refer back to this chapter.</p>
<h2 id="api-concepts"><a class="header" href="#api-concepts">API concepts</a></h2>
<p>The Vulkan API is defined in terms of the C programming language. The canonical version of the Vulkan API is defined in the Vulkan API Registry which is <a href="https://github.com/KhronosGroup/Vulkan-Docs/blob/main/xml/vk.xml">an XML file</a> which serves as a machine readable definition of the Vulkan API.</p>
<p>The <a href="https://github.com/KhronosGroup/Vulkan-Headers">Vulkan headers</a> that are part of the Vulkan SDK you will be installing in the next chapter are generated from this Vulkan API Registry. However, we will not be using these headers, directly or indirectly, because <code>vulkanalia</code> includes a Rust interface to the Vulkan API generated from the Vulkan API registry that is independent of the C interface provided by the Vulkan SDK.</p>
<p>The foundation of <code>vulkanalia</code> is the <a href="https://docs.rs/vulkanalia-sys"><code>vulkanalia-sys</code></a> crate which defines the raw types (commands, enums, bitmasks, structs, etc.) defined by the Vulkan API Registry. These raw types are re-exported from the <code>vulkanalia</code> crate in the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/index.html"><code>vk</code></a> module along with some other items generated from the Vulkan API Registry which serve as the thin wrapper around the Vulkan API previously mentioned in the introduction.</p>
<h3 id="type-names"><a class="header" href="#type-names">Type Names</a></h3>
<p>Because Rust has support for namespaces unlike C, the <code>vulkanalia</code> API omits the parts of Vulkan type names that are used for namespacing purposes in C. More specifically, Vulkan types such as structs, unions, and enums lose their <code>Vk</code> prefix. For example, the <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VkInstanceCreateInfo.html"><code class="hljs">VkInstanceCreateInfo</code></a> struct becomes the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.InstanceCreateInfo.html"><code>InstanceCreateInfo</code></a> struct in <code>vulkanalia</code> and can be found in the previously mentioned <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/index.html"><code>vk</code></a> module.</p>
<p>Going forward, this tutorial will refer to the Vulkan types defined by <code>vulkanalia</code> using the <code>vk::</code> module prefix to make it clear the type represents something generated from the Vulkan API Registry.</p>
<p>These type names will each be links to the <code>vulkanalia</code> documentation for the referenced type. The <code>vulkanalia</code> documentation for Vulkan types will also contain a link to the Vulkan specification for the type which you can use to learn more about the purpose and usage of the type.</p>
<p>A few type name examples:</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Instance.html"><code class="hljs">vk::Instance</code></a> </li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.InstanceCreateInfo.html"><code class="hljs">vk::InstanceCreateInfo</code></a> </li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.InstanceCreateFlags.html"><code class="hljs">vk::InstanceCreateFlags</code></a> </li>
</ul>
<h3 id="enums"><a class="header" href="#enums">Enums</a></h3>
<p><code>vulkanalia</code> models Vulkan enums as structs and models variants as associated constants for these structs. Rust enums are not used for Vulkan enums because the use of Rust enums in FFI can lead to <a href="https://github.com/rust-lang/rust/issues/36927">undefined behavior</a>.</p>
<p>Since associated constants are namespaced to the struct they are for, we don't need to worry about name conflicts between the values of different Vulkan enums (or enums from other libraries) like we would in C. So like with type names, <code>vulkanalia</code> omits the parts of variant names used for namespacing purposes.</p>
<p>For example, the <code>VK_OBJECT_TYPE_INSTANCE</code> variant is the <code>INSTANCE</code> value for the <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VkObjectType.html"><code class="hljs">VkObjectType</code></a> enum. In <code>vulkanalia</code>, this variant becomes <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ObjectType.html#associatedconstant.INSTANCE"><code class="hljs">vk::ObjectType::INSTANCE</code></a>.</p>
<h3 id="bitmasks"><a class="header" href="#bitmasks">Bitmasks</a></h3>
<p><code>vulkanalia</code> models Vulkan bitmasks as structs and models bitflags as associated constants for these structs. These structs and associated constants are generated by the <code>bitflags!</code> macro from the <a href="https://github.com/bitflags/bitflags"><code>bitflags</code></a> crate.</p>
<p>Like with variants, the parts of bitmask names used for namespacing purposes are omitted.</p>
<p>For example, the <code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code> bitflag is the <code>TRANSFER_SRC</code> bitflag for the <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VkBufferUsageFlags.html"><code class="hljs">VkBufferUsageFlags</code></a> bitmask. In <code>vulkanalia</code>, this becomes <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.BufferUsageFlags.html#associatedconstant.TRANSFER_SRC"><code class="hljs">vk::BufferUsageFlags::TRANSFER_SRC</code></a>.</p>
<h3 id="commands"><a class="header" href="#commands">Commands</a></h3>
<p>The types for raw Vulkan commands like <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/vkCreateInstance.html"><code class="hljs">vkCreateInstance</code></a> are defined in <code>vulkanalia</code> as function pointer type aliases with the <code>PFN_</code> (pointer to function) prefix. So the <code>vulkanalia</code> type alias for <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/vkCreateInstance.html"><code class="hljs">vkCreateInstance</code></a> is <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/type.PFN_vkCreateInstance.html"><code class="hljs">vk::PFN_vkCreateInstance</code></a>.</p>
<p>These function pointer types are not enough on their own to call Vulkan commands, we first need to load the commands described by these types. The Vulkan specification has a <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#initialization-functionpointers">detailed description</a> of how this is done, but I will present a simplified version here.</p>
<p>The first Vulkan command to load is <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/vkGetInstanceProcAddr.html"><code class="hljs">vkGetInstanceProcAddr</code></a>. This command is loaded in a platform-specific manner, but <code>vulkanalia</code> provides an optional integration with <a href="https://crates.io/crates/libloading"><code>libloading</code></a> that we will be using in this tutorial to load this command from a Vulkan shared library. <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/vkGetInstanceProcAddr.html"><code class="hljs">vkGetInstanceProcAddr</code></a> can be then used to load the other Vulkan commands we want to call.</p>
<p>However, there may be multiple versions of Vulkan commands available depending on the Vulkan implementations on your system. For example, if your system has both a dedicated NVIDIA GPU and an integrated Intel GPU, there may be separate implementations of device-specific Vulkan commands like <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.allocate_memory"><code class="hljs">allocate_memory</code></a> for each device. In cases like this, <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/vkGetInstanceProcAddr.html"><code class="hljs">vkGetInstanceProcAddr</code></a> will return a command that will dispatch calls to the appropriate device-specific command depending on the device in use.</p>
<p>To avoid the runtime overhead of this dispatch, the <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/vkGetDeviceProcAddr.html"><code class="hljs">vkGetDeviceProcAddr</code></a> command can be used to directly load these device-specific Vulkan commands. This command is loaded in the same manner as <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/vkGetInstanceProcAddr.html"><code class="hljs">vkGetInstanceProcAddr</code></a>.</p>
<p>We will be calling dozens of Vulkan commands in this tutorial. Fortunately we won't have to load them manually, <code>vulkanalia</code> provides structs which can be used to easily load all the Vulkan commands in one of four categories:</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.StaticCommands.html"><code class="hljs">vk::StaticCommands</code></a> – The Vulkan commands loaded in a platform-specific manner that can then used to load the other commands (i.e., <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/vkGetInstanceProcAddr.html"><code class="hljs">vkGetInstanceProcAddr</code></a> and <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/vkGetDeviceProcAddr.html"><code class="hljs">vkGetDeviceProcAddr</code></a>)</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.EntryCommands.html"><code class="hljs">vk::EntryCommands</code></a> – The Vulkan commands loaded using <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/vkGetInstanceProcAddr.html"><code class="hljs">vkGetInstanceProcAddr</code></a> and a null Vulkan instance. These commands are not tied to a specific Vulkan instance and are used to query instance support and create instances</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.InstanceCommands.html"><code class="hljs">vk::InstanceCommands</code></a> – The Vulkan commands loaded using <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/vkGetInstanceProcAddr.html"><code class="hljs">vkGetInstanceProcAddr</code></a> and a valid Vulkan instance. These commands are tied to a specific Vulkan instance and, among other things, are used to query device support and create devices</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DeviceCommands.html"><code class="hljs">vk::DeviceCommands</code></a> – The Vulkan commands loaded using <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/vkGetDeviceProcAddr.html"><code class="hljs">vkGetDeviceProcAddr</code></a> and a valid Vulkan device. These commands are tied to a specific Vulkan device and expose most of the functionality you would expect from a graphics API</li>
</ul>
<p>These structs allow you to easily load and call raw Vulkan commands from Rust, but <code>vulkanalia</code> offers wrappers around the raw Vulkan commands which make calling them from Rust easier and less error-prone.</p>
<h3 id="command-wrappers"><a class="header" href="#command-wrappers">Command wrappers</a></h3>
<p>An example of a typical Vulkan command signature looks like this in C:</p>
<pre><code class="language-c">VkResult vkEnumerateInstanceExtensionProperties(
    const char* pLayerName,
    uint32_t* pPropertyCount,
    VkExtensionProperties* pProperties
);
</code></pre>
<p>Someone who is familiar with the conventions of the Vulkan API could quickly see how this command is supposed to be used from this signature alone despite it not including some key information.</p>
<p>For those new to the Vulkan API, a look at the <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/vkEnumerateInstanceExtensionProperties.html">documentation</a> for this command will likely be more illuminating. The description of the behavior of this command in the documentation suggests that using this command to list the available extensions for the Vulkan instance will be a multi-step process:</p>
<ol>
<li>Call the command to get the number of extensions</li>
<li>Allocate a buffer that can contain the outputted number of extensions</li>
<li>Call the command again to populate the buffer with the extensions</li>
</ol>
<p>So in C++, this might look like this (ignoring the result of the command for simplicity):</p>
<pre><code class="language-c++">// 1.
uint32_t pPropertyCount;
vkEnumerateInstanceExtensionProperties(NULL, &amp;pPropertyCount, NULL);

// 2.
std::vector&lt;VkExtensionProperties&gt; pProperties{pPropertyCount};

// 3.
vkEnumerateInstanceExtensionProperties(NULL, &amp;pPropertyCount, pProperties.data());
</code></pre>
<p>The Rust signature of the wrapper for <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/vkEnumerateInstanceExtensionProperties.html"><code class="hljs">vkEnumerateInstanceExtensionProperties</code></a> looks like this:</p>
<pre><code class="language-rust noplaypen">unsafe fn enumerate_instance_extension_properties(
    &amp;self,
    layer_name: Option&lt;&amp;CStr&gt;,
) -&gt; VkResult&lt;Vec&lt;ExtensionProperties&gt;&gt;;
</code></pre>
<p>This command wrapper makes the usage of <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/vkEnumerateInstanceExtensionProperties.html"><code class="hljs">vkEnumerateInstanceExtensionProperties</code></a> from Rust easier, less error-prone, and more idiomatic in several ways:</p>
<ul>
<li>The optionality of the <code>layer_name</code> parameter is encoded in the function signature. That this parameter is optional is not captured in the C function signature, one would need to check the Vulkan specification for this information</li>
<li>The fallibility of the command is modelled by returning a <code>Result</code> (<a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/type.VkResult.html"><code>VkResult&lt;T&gt;</code></a> is a type alias for <code>Result&lt;T, vk::ErrorCode&gt;</code>). This allows us to take advantage of Rust's strong error handling capabilities as well as be warned by the compiler if we neglect to check the result of a fallible command</li>
<li>The command wrapper handles the three step process described above internally and returns a <code>Vec</code> containing the extension properties</li>
</ul>
<p>Note that command wrappers are still <code>unsafe</code> because while <code>vulkanalia</code> can eliminate certain classes of errors (e.g., passing a null layer name to this command), there are still plenty of things that can go horribly wrong and cause fun things like segfaults. You can always check the <code>Valid Usage</code> section of the Vulkan documentation for a command to see the invariants that need to upheld to call that command validly.</p>
<p>You likely noticed the <code>&amp;self</code> parameter in the above command wrapper. These command wrappers are defined in traits which are implemented for types exposed by <code>vulkanalia</code>. These traits can be separated into two categories: version traits and extension traits. The version traits offer command wrappers for the commands which are a standard part of Vulkan whereas the extension traits offer command wrappers for the commands which are defined as part of Vulkan extensions.</p>
<p>For example, <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.EntryV1_0.html#method.enumerate_instance_extension_properties"><code class="hljs">enumerate_instance_extension_properties</code></a> is in the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.EntryV1_0.html"><code class="hljs">vk::EntryV1_0</code></a> trait since it is a non-extension Vulkan command that is part of Vulkan 1.0 and not dependent on a Vulkan instance or device. A Vulkan command like <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_2.html#method.cmd_draw_indirect_count"><code class="hljs">cmd_draw_indirect_count</code></a> that was added in Vulkan 1.2 and is dependent on a Vulkan device would be in the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_2.html"><code class="hljs">vk::DeviceV1_2</code></a> trait.</p>
<p><code>vk::KhrSurfaceExtensionInstanceCommands</code> is an example of an extension trait that we will be using in future chapters to call Vulkan commands like <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.KhrSurfaceExtension.html#method.destroy_surface_khr"><code class="hljs">destroy_surface_khr</code></a> that are defined in the <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VK_KHR_surface.html"><code class="hljs">VK_KHR_surface</code></a> extension. Note <code>InstanceCommands</code> at the end of the name of this extension trait. This suffix indicates that this extension trait provides the instance-level commands added by the <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VK_KHR_surface.html"><code class="hljs">VK_KHR_surface</code></a> extension. Most Vulkan extensions only add commands at the instance-level or device-level, not both. However, <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VK_KHR_swapchain.html"><code class="hljs">VK_KHR_swapchain</code></a> is an example of an extension that does add commands at both the instance-level and device-level, so it has two extension traits in <code>vulkanalia</code>: <code>vk::KhrSwapchainExtensionInstanceCommands</code> and <code>vk::KhrSwapchainExtensionDeviceCommands</code>.</p>
<p>These version and extension traits are defined for types which contain both the loaded commands and the required Vulkan instance or device (if any). These types have been lovingly hand-crafted and are not part of the generated Vulkan bindings in the <code>vk</code> module of <code>vulkanalia</code>. They will be used in future chapters and are the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/struct.Entry.html"><code class="hljs">Entry</code></a>, <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/struct.Instance.html"><code class="hljs">Instance</code></a>, and <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/struct.Device.html"><code class="hljs">Device</code></a> structs.</p>
<p>Going forward, this tutorial will continue to refer to these command wrappers directly by name as in this section (e.g., <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.EntryV1_0.html#method.create_instance"><code class="hljs">create_instance</code></a>). You can visit the <code>vulkanalia</code> documentation for the command wrapper for more information like which trait the command wrapper is defined in.</p>
<h3 id="builders"><a class="header" href="#builders">Builders</a></h3>
<p>The Vulkan API heavily utilizes structs as parameters for Vulkan commands. The Vulkan structs used as command parameters have a field which indicates the type of the struct. In the C API, this field (<code>sType</code>) would need to be set explicitly. For example, here we are populating an instance of <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VkInstanceCreateInfo.html"><code class="hljs">VkInstanceCreateInfo</code></a> and then using it to call <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/vkCreateInstance.html"><code class="hljs">vkCreateInstance</code></a> in C++:</p>
<pre><code class="language-c++">std::vector&lt;const char*&gt; extensions{/* 3 extension names */};

VkInstanceCreateInfo info;
info.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
info.enabledExtensionCount = static_cast&lt;uint32_t&gt;(extensions.size());
info.ppEnabledExtensionNames = extensions.data();

VkInstance instance;
vkCreateInstance(&amp;info, NULL, &amp;instance);
</code></pre>
<p>You can still populate parameter structs in this manner when using <code>vulkanalia</code>, but <code>vulkanalia</code> provides builders which simplify the construction of these parameter structs. The <code>vulkanalia</code> builder for <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.InstanceCreateInfo.html"><code class="hljs">vk::InstanceCreateInfo</code></a> is <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.InstanceCreateInfoBuilder.html"><code class="hljs">vk::InstanceCreateInfoBuilder</code></a>. Using this builder the above code would become:</p>
<pre><code class="language-rust noplaypen">let extensions = &amp;[/* 3 extension names */];

let info = vk::InstanceCreateInfo::builder()
    .enabled_extension_names(extensions)
    .build();

let instance = entry.create_instance(&amp;info, None).unwrap();
</code></pre>
<p>Note the following differences:</p>
<ul>
<li>A value is not provided for the <code>s_type</code> field. This is because the builder provides the correct value for this field (<a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.StructureType.html#associatedconstant.INSTANCE_CREATE_INFO"><code class="hljs">vk::StructureType::INSTANCE_CREATE_INFO</code></a>) automatically</li>
<li>A value is not provided for the <code>enabled_extension_count</code> field. This is because the <code>enabled_extension_names</code> builder method uses the length of the provided slice to set this field automatically</li>
</ul>
<p>However, the above Rust code involves a certain degree of danger. The builders have lifetimes which enforce that the references stored in them live at least as long as the builders themselves. In the above example, this means that the Rust compiler will make sure that the slice passed to the <code>enabled_extension_names</code> method lives at least as long as the builder. However, as soon as we call <code>.build()</code> to get the underlying <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.InstanceCreateInfo.html"><code class="hljs">vk::InstanceCreateInfo</code></a> struct the builder lifetimes are discarded. This means that the Rust compiler can no longer prevent us from shooting ourselves in the foot if we try to dereference a pointer to a slice that no longer exists.</p>
<p>The following code will (hopefully) crash since the temporary <code>Vec</code> passed to <code>enabled_extension_names</code> will have been dropped by the time we call <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.EntryV1_0.html#method.create_instance"><code class="hljs">create_instance</code></a> with our <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.InstanceCreateInfo.html"><code class="hljs">vk::InstanceCreateInfo</code></a> struct:</p>
<pre><code class="language-rust noplaypen">let info = vk::InstanceCreateInfo::builder()
    .enabled_extension_names(&amp;vec![/* 3 extension names */])
    .build();

let instance = entry.create_instance(&amp;info, None).unwrap();
</code></pre>
<p>Fortunately, <code>vulkanalia</code> has a solution for this. Simply don't call <code>build()</code> and instead pass the builder to the command wrapper instead! Anywhere a Vulkan struct is expected in a command wrapper you can instead provide the associated builder. If you remove the <code>build()</code> call from the above code the Rust compiler will be able to use the lifetimes on the builder to reject this bad code with <code>error[E0716]: temporary value dropped while borrowed</code>.</p>
<h3 id="preludes"><a class="header" href="#preludes">Preludes</a></h3>
<p><code>vulkanalia</code> offers <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/prelude/index.html">prelude modules</a> that expose the basic types needed to use the crate. One prelude module is available per Vulkan version and each will expose the relevant command traits along with other very frequently used types:</p>
<pre><code class="language-rust noplaypen">// Vulkan 1.0
use vulkanalia::prelude::v1_0::*;

// Vulkan 1.1
use vulkanalia::prelude::v1_1::*;

// Vulkan 1.2
use vulkanalia::prelude::v1_2::*;
</code></pre>
<h2 id="validation-layers"><a class="header" href="#validation-layers">Validation layers</a></h2>
<p>As mentioned earlier, Vulkan is designed for high performance and low driver overhead. Therefore it will include very limited error checking and debugging capabilities by default. The driver will often crash instead of returning an error code if you do something wrong, or worse, it will appear to work on your graphics card and completely fail on others.</p>
<p>Vulkan allows you to enable extensive checks through a feature known as <em>validation layers</em>. Validation layers are pieces of code that can be inserted between the API and the graphics driver to do things like running extra checks on function parameters and tracking memory management problems. The nice thing is that you can enable them during development and then completely disable them when releasing your application for zero overhead. Anyone can write their own validation layers, but the Vulkan SDK by LunarG provides a standard set of validation layers that we'll be using in this tutorial. You also need to register a callback function to receive debug messages from the layers.</p>
<p>Because Vulkan is so explicit about every operation and the validation layers are so extensive, it can actually be a lot easier to find out why your screen is black compared to OpenGL and Direct3D!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development-environment"><a class="header" href="#development-environment">Development environment</a></h1>
<p>In this chapter we'll set up your environment for developing Vulkan applications by installing the Vulkan SDK for your operating system. This tutorial assumes you already have a working Rust (1.88+) development environment.</p>
<h2 id="cargo-project"><a class="header" href="#cargo-project">Cargo project</a></h2>
<p>First let's create our Cargo project:</p>
<p><code>cargo new vulkan-tutorial</code></p>
<p>After this command has executed, you'll have a folder called <code>vulkan-tutorial</code> containing a minimal Cargo project which produces a Rust executable.</p>
<p>Open the <code>Cargo.toml</code> file in the folder and add these dependencies in the pre-existing <code>[dependencies]</code> section:</p>
<pre><code class="language-toml">anyhow = &quot;1&quot;
log = &quot;0.4&quot;
cgmath = &quot;0.18&quot;
png = &quot;0.17&quot;
pretty_env_logger = &quot;0.5&quot;
thiserror = &quot;1&quot;
tobj = { version = &quot;3&quot;, features = [&quot;log&quot;] }
vulkanalia = { version = &quot;=0.34.0&quot;, features = [&quot;libloading&quot;, &quot;provisional&quot;, &quot;window&quot;] }
winit = &quot;0.29&quot;
</code></pre>
<ul>
<li><code>anyhow</code> – used for simple error handling</li>
<li><code>log</code> – used for logging statements</li>
<li><code>cgmath</code> – used as a Rust replacement for <a href="https://glm.g-truc.net/0.9.9/index.html">GLM</a> (graphics math library)</li>
<li><code>png</code> – used to load PNGs to use as textures</li>
<li><code>pretty_env_logger</code> – used to print our logs to the console</li>
<li><code>thiserror</code> – used to define custom errors types without boilerplate</li>
<li><code>tobj</code> – used to load 3D models in the <a href="https://en.wikipedia.org/wiki/Wavefront_.obj_file">Wavefront .obj format</a></li>
<li><code>vulkanalia</code> – used to call the Vulkan API</li>
<li><code>winit</code> – used to create a window to render to</li>
</ul>
<h2 id="vulkan-sdk"><a class="header" href="#vulkan-sdk">Vulkan SDK</a></h2>
<p>The most important component you'll need for developing Vulkan applications is the SDK. It includes the headers, standard validation layers, debugging tools and a loader for the Vulkan functions. The loader looks up the functions in the driver at runtime, similarly to GLEW for OpenGL - if you're familiar with that.</p>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>The SDK can be downloaded from the <a href="https://vulkan.lunarg.com/">LunarG website</a> using the buttons at the bottom of the page. You don't have to create an account, but it will give you access to some additional documentation that may be useful to you.</p>
<p><img src="./images/vulkan_sdk_download_buttons.png" alt="" /></p>
<p>Proceed through the installation and pay attention to the install location of the SDK. The first thing we'll do is verify that your graphics card and driver properly support Vulkan. Go to the directory where you installed the SDK, open the <code>Bin</code> directory and run the <code>vkcube.exe</code> demo. You should see the following:</p>
<p><img src="./images/cube_demo.png" alt="" /></p>
<p>If you receive an error message then ensure that your drivers are up-to-date, include the Vulkan runtime and that your graphics card is supported. See the <a href="introduction.html">introduction chapter</a> for links to drivers from the major vendors.</p>
<p>There is another program in this directory that will be useful for development. The <code>glslangValidator.exe</code> and <code>glslc.exe</code> programs will be used to compile shaders from the human-readable <a href="https://en.wikipedia.org/wiki/OpenGL_Shading_Language">GLSL</a> to bytecode. We'll cover this in depth in the <a href="pipeline/shader_modules.html">shader modules chapter</a>. The <code>Bin</code> directory also contains the binaries of the Vulkan loader and the validation layers, while the <code>Lib</code> directory contains the libraries.</p>
<p>Feel free to explore the other files, but we won't need them for this tutorial.</p>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<p>These instructions will be aimed at Ubuntu users, but you may be able to follow along by changing the <code>apt</code> commands to the package manager commands that are appropriate for you.</p>
<p>The most important components you'll need for developing Vulkan applications on Linux are the Vulkan loader, validation layers, and a couple of command-line utilities to test whether your machine is Vulkan-capable:</p>
<ul>
<li><code>sudo apt install vulkan-tools</code> – Command-line utilities, most importantly <code>vulkaninfo</code> and <code>vkcube</code>. Run these to confirm your machine supports Vulkan.</li>
<li><code>sudo apt install libvulkan-dev</code> – Installs Vulkan loader. The loader looks up the functions in the driver at runtime, similarly to GLEW for OpenGL - if you're familiar with that.</li>
<li><code>sudo apt install vulkan-validationlayers-dev</code> – Installs the standard validation layers. These are crucial when debugging Vulkan applications, and we'll discuss them in an upcoming chapter.</li>
</ul>
<p>If installation was successful, you should be all set with the Vulkan portion. Remember to run <code>vkcube</code> and ensure you see the following pop up in a window:</p>
<p><img src="./images/cube_demo_nowindow.png" alt="" /></p>
<p>If you receive an error message then ensure that your drivers are up-to-date, include the Vulkan runtime and that your graphics card is supported. See the <a href="introduction.html">introduction chapter</a> for links to drivers from the major vendors.</p>
<h3 id="macos"><a class="header" href="#macos">macOS</a></h3>
<p>The SDK can be downloaded from the <a href="https://vulkan.lunarg.com/">LunarG website</a> using the buttons at the bottom of the page. You don't have to create an account, but it will give you access to some additional documentation that may be useful to you.</p>
<p><img src="./images/vulkan_sdk_download_buttons.png" alt="" /></p>
<p>The SDK version for MacOS internally uses <a href="https://moltengl.com/">MoltenVK</a>. There is no native support for Vulkan on MacOS, so what MoltenVK does is act as a layer that translates Vulkan API calls to Apple's Metal graphics framework. With this you can take advantage of debugging and performance benefits of Apple's Metal framework.</p>
<p>After downloading it, simply extract the contents to a folder of your choice. Inside the extracted folder, in the <code>Applications</code> folder you should have some executable files that will run a few demos using the SDK. Run the <code>vkcube</code> executable and you will see the following:</p>
<p><img src="./images/cube_demo_mac.png" alt="" /></p>
<h4 id="setup-environment"><a class="header" href="#setup-environment">Setup Environment</a></h4>
<p>When running a Vulkan application outside of the Vulkan SDK directory, you will likely also need to run the <code>setup-env.sh</code> script from the Vulkan SDK to avoid errors about the inability to find Vulkan libraries (e.g., <code>libvulkan.dylib</code>). If you installed the Vulkan SDK in the default location, this script should be located in a path like this: <code>~/VulkanSDK/1.3.280.1/setup-env.sh</code> (replace the version number to match your Vulkan SDK installation).</p>
<p>You can also add this script to be executed by default by adding it to your shell's setup script. For example you could add a statement like this to <code>~/.zshrc</code>:</p>
<pre><code>source ~/VulkanSDK/1.3.280.1/setup-env.sh
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<p>This page lists solutions to common problems that you may encounter while developing Vulkan applications.</p>
<ul>
<li>
<p><strong><em>(macOS)</em> I installed the Vulkan SDK, but I get an error about <code>libvulkan.dylib</code> not being found when I run a Vulkan application</strong> - see the <a href="./development_environment.html#setup-environment"><code>Setup Environment</code> section of the Vulkan SDK setup instructions for macOS</a></p>
</li>
<li>
<p><strong>I get an access violation error in the core validation layer</strong> – Make sure that MSI Afterburner / RivaTuner Statistics Server is not running, because it has some compatibility problems with Vulkan.</p>
</li>
<li>
<p><strong>I don't see any messages from the validation layers / Validation layers are not available</strong> – First make sure that the validation layers get a chance to print errors by keeping the terminal open after your program exits. You can do this from Visual Studio by running your program with Ctrl-F5 instead of F5, and on Linux by executing your program from a terminal window. If there are still no messages and you are sure that validation layers are turned on, then you should ensure that your Vulkan SDK is correctly installed by following the &quot;Verify the Installation&quot; instructions <a href="https://vulkan.lunarg.com/doc/view/1.2.135.0/windows/getting_started.html">on this page</a>. Also ensure that your SDK version is at least 1.1.106.0 to support the <code>VK_LAYER_KHRONOS_validation</code> layer.</p>
</li>
<li>
<p><strong>vkCreateSwapchainKHR triggers an error in SteamOverlayVulkanLayer64.dll</strong> – This appears to be a compatibility problem in the Steam client beta. There are a few possible workarounds:</p>
<ul>
<li>Opt out of the Steam beta program.</li>
<li>Set the <code>DISABLE_VK_LAYER_VALVE_steam_overlay_1</code> environment variable to <code>1</code></li>
<li>Delete the Steam overlay Vulkan layer entry in the registry under <code>HKEY_LOCAL_MACHINE\SOFTWARE\Khronos\Vulkan\ImplicitLayers</code></li>
</ul>
</li>
</ul>
<p>Example:</p>
<p><img src="./images/steam_layers_env.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="base-code"><a class="header" href="#base-code">Base code</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/00_base_code.rs">main.rs</a></p>
<p>In the <code>Development environment</code> chapter we created a Cargo project and added the necessary dependencies. In this chapter we will be replacing the code in the <code>src/main.rs</code> file with the following code:</p>
<pre><pre class="playground"><code class="language-rust">#![allow(
    dead_code,
    unsafe_op_in_unsafe_fn,
    unused_variables,
    clippy::too_many_arguments,
    clippy::unnecessary_wraps
)]

use anyhow::Result;
use winit::dpi::LogicalSize;
use winit::event::{Event, WindowEvent};
use winit::event_loop::EventLoop;
use winit::window::{Window, WindowBuilder};

fn main() -&gt; Result&lt;()&gt; {
    pretty_env_logger::init();

    // Window

    let event_loop = EventLoop::new()?;
    let window = WindowBuilder::new()
        .with_title(&quot;Vulkan Tutorial (Rust)&quot;)
        .with_inner_size(LogicalSize::new(1024, 768))
        .build(&amp;event_loop)?;

    // App

    let mut app = unsafe { App::create(&amp;window)? };
    event_loop.run(move |event, elwt| {
        match event {
            // Request a redraw when all events were processed.
            Event::AboutToWait =&gt; window.request_redraw(),
            Event::WindowEvent { event, .. } =&gt; match event {
                // Render a frame if our Vulkan app is not being destroyed.
                WindowEvent::RedrawRequested if !elwt.exiting() =&gt; unsafe { app.render(&amp;window) }.unwrap(),
                // Destroy our Vulkan app.
                WindowEvent::CloseRequested =&gt; {
                    elwt.exit();
                    unsafe { app.destroy(); }
                }
                _ =&gt; {}
            }
            _ =&gt; {}
        }
    })?;

    Ok(())
}

/// Our Vulkan app.
#[derive(Clone, Debug)]
struct App {}

impl App {
    /// Creates our Vulkan app.
    unsafe fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        Ok(Self {})
    }

    /// Renders a frame for our Vulkan app.
    unsafe fn render(&amp;mut self, window: &amp;Window) -&gt; Result&lt;()&gt; {
        Ok(())
    }

    /// Destroys our Vulkan app.
    unsafe fn destroy(&amp;mut self) {}
}

/// The Vulkan handles and associated properties used by our Vulkan app.
#[derive(Clone, Debug, Default)]
struct AppData {}
</code></pre></pre>
<p>We first import <code>anyhow::Result</code> so we can use <code>anyhow</code>'s <a href="https://docs.rs/anyhow/latest/anyhow/type.Result.html"><code>Result</code></a> type for all of the fallible functions in our program. Next we import all of the <code>winit</code> types we need to create a window and start an event loop for that window.</p>
<p>Next comes our <code>main</code> function (which returns an <code>anyhow::Result</code> type). This function starts by initializing <code>pretty_env_logger</code> which will print our logs to the console (as shown later).</p>
<p>Then we create an event loop and window to render to using <code>winit</code> using <code>LogicalSize</code> which will scale the window according to the DPI of your display. If you want to know more about UI scaling you can read the <a href="https://docs.rs/winit/latest/winit/dpi/index.html">relevant <code>winit</code> documentation</a>.</p>
<p>Next we create an instance of our Vulkan app (<code>App</code>) and enter into our rendering loop. This loop will continually render our scene to the window until you request the window to be closed at which point the app will be destroyed and the program will exit. The <code>destroying</code> flag is necessary to not keep attempting to render the scene while the app is being destroyed which would most likely result in the program crashing after attempting to access Vulkan resources that have been destroyed.</p>
<p>Lastly comes <code>App</code> and <code>AppData</code>. <code>App</code> will be used to implement the setup, rendering, and destruction logic required for the Vulkan program we will be building over the course of the following chapters. <code>AppData</code> will serve simply as a container for the large number of Vulkan resources we will need to create and initialize which will allow for them to be easily passed to functions to be read and/or modified. <code>AppData</code> implements the <a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code> trait</a> so we can easily construct an instance of this struct with empty/default values.</p>
<p>This will come in handy because many of the following chapters consist of adding a function which takes a <code>&amp;mut AppData</code> and creates and initializes Vulkan resources. These functions will then be called from our <code>App::create</code> constructor method to set up our Vulkan app. Then, before our program exits, these Vulkan resources will be released by our <code>App::destroy</code> method.</p>
<h2 id="a-note-on-safety"><a class="header" href="#a-note-on-safety">A Note on Safety</a></h2>
<p>All Vulkan commands, both the raw commands and their command wrappers, are marked <code>unsafe</code> in <code>vulkanalia</code>. This is because most Vulkan commands have restrictions on how they can be called that cannot be enforced by Rust (unless a higher-level interface that hides the Vulkan API is provided like in <a href="https://vulkano.rs"><code>vulkano</code></a>).</p>
<p>This tutorial will be addressing this fact by simply marking every function and method in which a Vulkan command is called as <code>unsafe</code>. This helps keep syntactical noise to a minimum, but in a more realistic program you may want to expose your own safe interface that enforces the invariants required for the Vulkan commands you are calling.</p>
<h2 id="resource-management"><a class="header" href="#resource-management">Resource management</a></h2>
<p>Just like each chunk of memory allocated in C with <code>malloc</code> requires a corresponding call to <code>free</code>, every Vulkan object that we create needs to be explicitly destroyed when we no longer need it. In Rust it is possible to perform automatic resource management using <a href="https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII</a> possibly combined with smart pointers like <code>Rc</code> or <code>Arc</code>. However, the author of <a href="https://vulkan-tutorial.com">https://vulkan-tutorial.com</a> chose to be explicit about allocation and deallocation of Vulkan objects in this tutorial and I have decided to take the same approach. After all, Vulkan's niche is to be explicit about every operation to avoid mistakes, so it's good to be explicit about the lifetime of objects to learn how the API works.</p>
<p>After following this tutorial, you could implement automatic resource management by writing Rust structs that wrap Vulkan objects and release them in their <code>Drop</code> implementation. RAII is the recommended model for larger Vulkan programs, but for learning purposes it's always good to know what's going on behind the scenes.</p>
<p>Vulkan objects are either created directly with commands like <code>create_xxx</code>, or allocated through another object with commands like <code>allocate_xxx</code>. After making sure that an object is no longer used anywhere, you need to destroy it with the counterparts <code>destroy_xxx</code> and <code>free_xxx</code>. The parameters for these commands generally vary for different types of objects, but there is one parameter that they all share: <code>allocator</code>. This is an optional parameter that allows you to specify callbacks for a custom memory allocator. We will ignore this parameter in the tutorial and always pass <code>None</code> as argument.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="instance"><a class="header" href="#instance">Instance</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/01_instance_creation.rs">main.rs</a></p>
<p>The very first thing you will want to do is initialize the Vulkan library by creating an <em>instance</em>. The instance is the connection between your application and the Vulkan library and creating it involves specifying some details about your application to the driver. To get started, add the following imports:</p>
<pre><code class="language-rust noplaypen">use anyhow::{anyhow, Result};
use log::*;
use vulkanalia::loader::{LibloadingLoader, LIBRARY};
use vulkanalia::window as vk_window;
use vulkanalia::prelude::v1_0::*;
</code></pre>
<p>Here we first add the <a href="https://docs.rs/anyhow/latest/anyhow/macro.anyhow.html"><code>anyhow!</code></a> macro to our imports from <code>anyhow</code>. This macro will be used to easily construct instances of <code>anyhow</code> errors. Then, we import <code>log::*</code> so we can use the logging macros from the <code>log</code> crate. Next, we import <code>LibloadingLoader</code> which serves as <code>vulkanalia</code>'s <code>libloading</code> integration which we will use to load the initial Vulkan commands from the Vulkan shared library. The standard name of the Vulkan shared library on your operating system (e.g., <code>vulkan-1.dll</code> on Windows) is then imported as <code>LIBRARY</code>.</p>
<p>Next we import <code>vulkanalia</code>'s window integration as <code>vk_window</code> which in this chapter we will use to enumerate the global Vulkan extensions required to render to a window. In a future chapter we will also use <code>vk_window</code> to link our Vulkan instance with our <code>winit</code> window.</p>
<p>Lastly we import the Vulkan 1.0 prelude from <code>vulkanalia</code> which will provide all of the other Vulkan-related imports we will need for this and future chapters.</p>
<p>Now, to create an instance we'll next have to fill in a struct with some information about our application. This data is technically optional, but it may provide some useful information to the driver in order to optimize our specific application (e.g., because it uses a well-known graphics engine with certain special behavior). This struct is called <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ApplicationInfo.html"><code class="hljs">vk::ApplicationInfo</code></a> and we'll create it in a new function called <code>create_instance</code> that takes our window and a Vulkan entry point (which we will create later) and returns a Vulkan instance:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_instance(window: &amp;Window, entry: &amp;Entry) -&gt; Result&lt;Instance&gt; {
    let application_info = vk::ApplicationInfo::builder()
        .application_name(b&quot;Vulkan Tutorial\0&quot;)
        .application_version(vk::make_version(1, 0, 0))
        .engine_name(b&quot;No Engine\0&quot;)
        .engine_version(vk::make_version(1, 0, 0))
        .api_version(vk::make_version(1, 0, 0));
}
</code></pre>
<p>A lot of information in Vulkan is passed through structs instead of function parameters and we'll have to fill in one more struct to provide sufficient information for creating an instance. This next struct is not optional and tells the Vulkan driver which global extensions and validation layers we want to use. Global here means that they apply to the entire program and not a specific device, which will become clear in the next few chapters. First we'll need to use <code>vulkanalia</code>'s window integration to enumerate the required global extensions and convert them into null-terminated C strings (<code>*const c_char</code>):</p>
<pre><code class="language-rust noplaypen">let extensions = vk_window::get_required_instance_extensions(window)
    .iter()
    .map(|e| e.as_ptr())
    .collect::&lt;Vec&lt;_&gt;&gt;();
</code></pre>
<p>With our list of required global extensions in hand we can create and return a Vulkan instance using the Vulkan entry point passed into this function:</p>
<pre><code class="language-rust noplaypen">let info = vk::InstanceCreateInfo::builder()
    .application_info(&amp;application_info)
    .enabled_extension_names(&amp;extensions);

Ok(entry.create_instance(&amp;info, None)?)
</code></pre>
<p>As you'll see, the general pattern that object creation function parameters in Vulkan follow is:</p>
<ul>
<li>Reference to struct with creation info</li>
<li>Optional reference to custom allocator callbacks, always <code>None</code> in this tutorial</li>
</ul>
<p>Now that we have a function to create Vulkan instances from entry points, we next need to create a Vulkan entry point. This entry point will load the Vulkan commands used to query instance support and create instances. But before we do that, let's add some fields to our <code>App</code> struct to store the Vulkan entry point and instance we will be creating:</p>
<pre><code class="language-rust noplaypen">struct App {
    entry: Entry,
    instance: Instance,
}
</code></pre>
<p>To populate these fields, update the <code>App::create</code> method to the following:</p>
<pre><code class="language-rust noplaypen">unsafe fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
    let loader = LibloadingLoader::new(LIBRARY)?;
    let entry = Entry::new(loader).map_err(|b| anyhow!(&quot;{}&quot;, b))?;
    let instance = create_instance(window, &amp;entry)?;
    Ok(Self { entry, instance })
}
</code></pre>
<p>Here we first create a Vulkan function loader which will be used to load the initial Vulkan commands from the Vulkan shared library. Next we create the Vulkan entry point using the function loader which will load all of the commands we need to manage Vulkan instances. Lastly we are now able to call our <code>create_instance</code> function with the Vulkan entry point.</p>
<h2 id="cleaning-up"><a class="header" href="#cleaning-up">Cleaning up</a></h2>
<p>The <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/struct.Instance.html"><code class="hljs">Instance</code></a> should only be destroyed right before the program exits. It can be destroyed in the <code>App::destroy</code> method using <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.InstanceV1_0.html#method.destroy_instance"><code class="hljs">destroy_instance</code></a>:</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy(&amp;mut self) {
    self.instance.destroy_instance(None);
}
</code></pre>
<p>Like the Vulkan commands used to create objects, the commands used to destroy objects also take an optional reference to custom allocator callbacks. So like before, we pass <code>None</code> to indicate we are content with the default allocation behavior.</p>
<h2 id="non-conformant-vulkan-implementations"><a class="header" href="#non-conformant-vulkan-implementations">Non-conformant Vulkan implementations</a></h2>
<p>Not every platform is so fortunate to have an implementation of the Vulkan API that fully conforms to the Vulkan specification. On such a platform, there may be standard Vulkan features that are not available and/or there may be significant differences between the actual behavior of a Vulkan application using that non-conformant implementation and what the Vulkan specification says that application should behave.</p>
<p>Since version 1.3.216 of the Vulkan SDK, applications that use a non-conformant Vulkan implementation must enable some additional Vulkan extensions. These compatibility extensions have the primary purpose of forcing the developer to acknowledge that their application is using a non-conformant implementation of Vulkan and that they should not expect everything to be as the Vulkan specification says it should be.</p>
<p>This tutorial will be utilizing these compatibility Vulkan extensions so that your application can run even on platforms that lack a fully conforming Vulkan implementation.</p>
<p>However, you might ask &quot;Why are we doing this? Do we really need to worry about supporting niche platforms in an introductory Vulkan tutorial?&quot; As it turns out, the not-so-niche macOS is among those platforms that lack a fully-conformant Vulkan implementation.</p>
<p>As was mentioned in the introduction, Apple has their own low-level graphics API, <a href="https://en.wikipedia.org/wiki/Metal_(API)">Metal</a>. The Vulkan implementation that is provided as part of the Vulkan SDK for macOS (<a href="https://moltengl.com/">MoltenVK</a>) is a layer that sits in-between your application and Metal and translates the Vulkan API calls your application makes into Metal API calls. Because MoltenVK is <a href="https://www.lunarg.com/wp-content/uploads/2022/05/The-State-of-Vulkan-on-Apple-15APR2022.pdf">not fully conformant with the Vulkan specification</a>, you will need to enable the compatibility Vulkan extensions we've been talking about to support macOS. </p>
<p>As an aside, while MoltenVK is not fully-conformant, you shouldn't encounter any issues caused by deviations from the Vulkan specification while following this tutorial on macOS.</p>
<h2 id="enabling-compatibility-extensions"><a class="header" href="#enabling-compatibility-extensions">Enabling compatibility extensions</a></h2>
<blockquote>
<p><strong>Note:</strong> Even if you are not following this tutorial on a macOS, some of the code added in this section is referenced in the remainder of this tutorial so you can't just skip it!</p>
</blockquote>
<p>We'll want to check if the version of Vulkan we are using is equal to or greather than the version of Vulkan that introduced the compatibility extension requirement. With this goal in mind, we'll first add an additional import:</p>
<pre><code class="language-rust noplaypen">use vulkanalia::Version;
</code></pre>
<p>With this new import in place, we'll define a constant for the minimum version:</p>
<pre><code class="language-rust noplaypen">const PORTABILITY_MACOS_VERSION: Version = Version::new(1, 3, 216);
</code></pre>
<p>Replace the extension enumeration and instance creation code with the following:</p>
<pre><code class="language-rust noplaypen">let mut extensions = vk_window::get_required_instance_extensions(window)
    .iter()
    .map(|e| e.as_ptr())
    .collect::&lt;Vec&lt;_&gt;&gt;();

// Required by Vulkan SDK on macOS since 1.3.216.
let flags = if 
    cfg!(target_os = &quot;macos&quot;) &amp;&amp; 
    entry.version()? &gt;= PORTABILITY_MACOS_VERSION
{
    info!(&quot;Enabling extensions for macOS portability.&quot;);
    extensions.push(vk::KHR_GET_PHYSICAL_DEVICE_PROPERTIES2_EXTENSION.name.as_ptr());
    extensions.push(vk::KHR_PORTABILITY_ENUMERATION_EXTENSION.name.as_ptr());
    vk::InstanceCreateFlags::ENUMERATE_PORTABILITY_KHR
} else {
    vk::InstanceCreateFlags::empty()
};

let info = vk::InstanceCreateInfo::builder()
    .application_info(&amp;application_info)
    .enabled_extension_names(&amp;extensions)
    .flags(flags);
</code></pre>
<p>This code enables <code>KHR_PORTABILITY_ENUMERATION_EXTENSION</code> if your application is being compiled for a platform that lacks a conformant Vulkan implementation (just checking for macOS here) and the Vulkan version meets or exceeds the minimum version we just defined.</p>
<p>This code also enables <code>KHR_GET_PHYSICAL_DEVICE_PROPERTIES2_EXTENSION</code> under the same conditions. This extension is needed to enable the <code>KHR_PORTABILITY_SUBSET_EXTENSION</code> device extension which will be added later in the tutorial when we set up a logical device.</p>
<h2 id="instance-vs-vkinstance"><a class="header" href="#instance-vs-vkinstance"><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/struct.Instance.html"><code class="hljs">Instance</code></a> vs <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Instance.html"><code class="hljs">vk::Instance</code></a></a></h2>
<p>When we call our <code>create_instance</code> function, what we get back is not a raw Vulkan instance as would be returned by the Vulkan command <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/vkCreateInstance.html"><code class="hljs">vkCreateInstance</code></a> (<a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Instance.html"><code class="hljs">vk::Instance</code></a>). Instead what we got back is a custom type defined by <code>vulkanalia</code> which combines both a raw Vulkan instance and the commands loaded for that specific instance.</p>
<p>This is the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/struct.Instance.html"><code class="hljs">Instance</code></a> type we have been using (imported from the <code>vulkanalia</code> prelude) which should not be confused with the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Instance.html"><code class="hljs">vk::Instance</code></a> type which represents a raw Vulkan instance. In future chapters we will also use the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/struct.Device.html"><code class="hljs">Device</code></a> type which, like <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/struct.Instance.html"><code class="hljs">Instance</code></a>, is a pairing of a raw Vulkan device (<a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Device.html"><code class="hljs">vk::Device</code></a>) and the commands loaded for that specific device. Fortunately we will not be using <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Instance.html"><code class="hljs">vk::Instance</code></a> or <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Device.html"><code class="hljs">vk::Device</code></a> directly in this tutorial so you don't need to worry about getting them mixed up.</p>
<p>Because an <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/struct.Instance.html"><code class="hljs">Instance</code></a> contains both a Vulkan instance and the associated commands, the command wrappers implemented for an <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/struct.Instance.html"><code class="hljs">Instance</code></a> are able to provide the Vulkan instance when it is required by the underlying Vulkan command.</p>
<p>If you look at the documentation for the <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/vkDestroyInstance.html"><code class="hljs">vkDestroyInstance</code></a> command, you will see that it takes two parameters: the instance to destroy and the optional custom allocator callbacks. However, <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.InstanceV1_0.html#method.destroy_instance"><code class="hljs">destroy_instance</code></a> only takes the optional custom allocator callbacks because it is able to provide the raw Vulkan handle as the first parameter itself as described above.</p>
<p>Before continuing with the more complex steps after instance creation, it's time to evaluate our debugging options by checking out validation layers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="validation-layers-1"><a class="header" href="#validation-layers-1">Validation layers</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/02_validation_layers.rs">main.rs</a></p>
<p>The Vulkan API is designed around the idea of minimal driver overhead and one of the manifestations of that goal is that there is very limited error checking in the API by default. Even mistakes as simple as setting enumerations to incorrect values are generally not explicitly handled and will simply result in crashes or undefined behavior. Because Vulkan requires you to be very explicit about everything you're doing, it's easy to make many small mistakes like using a new GPU feature and forgetting to request it at logical device creation time.</p>
<p>However, that doesn't mean that these checks can't be added to the API. Vulkan introduces an elegant system for this known as validation layers. Validation layers are optional components that hook into Vulkan function calls to apply additional operations. Common operations in validation layers are:</p>
<ul>
<li>Checking the values of parameters against the specification to detect misuse</li>
<li>Tracking creation and destruction of objects to find resource leaks</li>
<li>Checking thread safety by tracking the threads that calls originate from</li>
<li>Logging every call and its parameters to the standard output</li>
<li>Tracing Vulkan calls for profiling and replaying</li>
</ul>
<p>Here's an example of what the implementation of a function in a diagnostics validation layer could look like (in C):</p>
<pre><code class="language-c">VkResult vkCreateInstance(
    const VkInstanceCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkInstance* instance
) {
    if (pCreateInfo == nullptr || instance == nullptr) {
        log(&quot;Null pointer passed to required parameter!&quot;);
        return VK_ERROR_INITIALIZATION_FAILED;
    }

    return real_vkCreateInstance(pCreateInfo, pAllocator, instance);
}
</code></pre>
<p>These validation layers can be freely stacked to include all the debugging functionality that you're interested in. You can simply enable validation layers for debug builds and completely disable them for release builds, which gives you the best of both worlds!</p>
<p>Vulkan does not come with any validation layers built-in, but the LunarG Vulkan SDK provides a nice set of layers that check for common errors. They're also completely <a href="https://github.com/KhronosGroup/Vulkan-ValidationLayers">open source</a>, so you can check which kind of mistakes they check for and contribute. Using the validation layers is the best way to avoid your application breaking on different drivers by accidentally relying on undefined behavior.</p>
<p>Validation layers can only be used if they have been installed onto the system. For example, the LunarG validation layers are only available on PCs with the Vulkan SDK installed.</p>
<p>There were formerly two different types of validation layers in Vulkan: instance and device specific. The idea was that instance layers would only check calls related to global Vulkan objects like instances, and device specific layers would only check calls related to a specific GPU. Device specific layers have now been deprecated, which means that instance validation layers apply to all Vulkan calls. The specification document still recommends that you enable validation layers at device level as well for compatibility, which is required by some implementations. We'll simply specify the same layers as the instance at logical device level, which we'll see later on.</p>
<p>Before we get started, we'll need some new imports for this chapter:</p>
<pre><code class="language-rust noplaypen">use std::collections::HashSet;
use std::ffi::CStr;
use std::os::raw::c_void;

// Note: This trait was called `ExtDebugUtilsExtension` in versions of `vulkanalia` prior to `v0.31.0`.
use vulkanalia::vk::ExtDebugUtilsExtensionInstanceCommands;
</code></pre>
<p><code>HashSet</code> will be used for storing and querying supported layers and the other imports will be used in the function we will be writing to log messages from the validation layer with the exception of <code>vk::ExtDebugUtilsExtensionInstanceCommands</code> which provides the command wrappers for managing debugging functionality.</p>
<h2 id="using-validation-layers"><a class="header" href="#using-validation-layers">Using validation layers</a></h2>
<p>In this section we'll see how to enable the standard diagnostics layers provided by the Vulkan SDK. Just like extensions, validation layers need to be enabled by specifying their name. All of the useful standard validation is bundled into a layer included in the SDK that is known as <code>VK_LAYER_KHRONOS_validation</code>.</p>
<p>Let's first add two configuration variables to the program to specify the layers to enable and whether to enable them or not. I've chosen to base that value on whether the program is being compiled in debug mode or not.</p>
<pre><code class="language-rust noplaypen">const VALIDATION_ENABLED: bool =
    cfg!(debug_assertions);

const VALIDATION_LAYER: vk::ExtensionName =
    vk::ExtensionName::from_bytes(b&quot;VK_LAYER_KHRONOS_validation&quot;);
</code></pre>
<p>We'll add some new code to our <code>create_instance</code> function that collects the supported instance layers into a <code>HashSet</code>, checks that the validation layer is available, and creates a list of layer names containing the validation layer. This code should go right below where the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ApplicationInfo.html"><code class="hljs">vk::ApplicationInfo</code></a> struct is built:</p>
<pre><code class="language-rust noplaypen">let available_layers = entry
    .enumerate_instance_layer_properties()?
    .iter()
    .map(|l| l.layer_name)
    .collect::&lt;HashSet&lt;_&gt;&gt;();

if VALIDATION_ENABLED &amp;&amp; !available_layers.contains(&amp;VALIDATION_LAYER) {
    return Err(anyhow!(&quot;Validation layer requested but not supported.&quot;));
}

let layers = if VALIDATION_ENABLED {
    vec![VALIDATION_LAYER.as_ptr()]
} else {
    Vec::new()
};
</code></pre>
<p>Then you'll need to specify the requested layers in <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.InstanceCreateInfo.html"><code class="hljs">vk::InstanceCreateInfo</code></a> by adding a call to the <code>enabled_layer_names</code> builder method:</p>
<pre><code class="language-rust noplaypen">let info = vk::InstanceCreateInfo::builder()
    .application_info(&amp;application_info)
    .enabled_layer_names(&amp;layers)
    .enabled_extension_names(&amp;extensions)
    .flags(flags);
</code></pre>
<p>Now run the program in debug mode and ensure that the <code>Validation layer requested but not supported.</code> error does not occur. If it does, then have a look at the FAQ. If you get past that check, then <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.EntryV1_0.html#method.create_instance"><code class="hljs">create_instance</code></a> should never return a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ErrorCode.html#associatedconstant.LAYER_NOT_PRESENT"><code class="hljs">vk::ErrorCode::LAYER_NOT_PRESENT</code></a> error code but you should still run the program to be sure.</p>
<h2 id="message-callback"><a class="header" href="#message-callback">Message callback</a></h2>
<p>The validation layers will print debug messages to the standard output by default, but we can also handle them ourselves by providing an explicit callback in our program. This will also allow you to decide which kind of messages you would like to see, because not all are necessarily (fatal) errors. If you don't want to do that right now then you may skip to the last section in this chapter.</p>
<p>To set up a callback in the program to handle messages and the associated details, we have to set up a debug messenger with a callback using the <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VK_EXT_debug_utils.html"><code class="hljs">VK_EXT_debug_utils</code></a> extension.</p>
<p>We'll add some more code to our <code>create_instance</code> function. This time we'll modify the <code>extensions</code> list to be mutable and then add the debug utilities extension to the list when the validation layer is enabled:</p>
<pre><code class="language-rust noplaypen">let mut extensions = vk_window::get_required_instance_extensions(window)
    .iter()
    .map(|e| e.as_ptr())
    .collect::&lt;Vec&lt;_&gt;&gt;();

if VALIDATION_ENABLED {
    extensions.push(vk::EXT_DEBUG_UTILS_EXTENSION.name.as_ptr());
}
</code></pre>
<p><code>vulkanalia</code> provides a collection of metadata for each Vulkan extension. In this case we just need the name of the extension to load, so we add the value of the <code>name</code> field of the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/constant.EXT_DEBUG_UTILS_EXTENSION.html"><code class="hljs">vk::EXT_DEBUG_UTILS_EXTENSION</code></a> struct constant to our list of desired extension names.</p>
<p>Run the program to make sure you don't receive a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ErrorCode.html#associatedconstant.EXTENSION_NOT_PRESENT"><code class="hljs">vk::ErrorCode::EXTENSION_NOT_PRESENT</code></a> error code. We don't really need to check for the existence of this extension, because it should be implied by the availability of the validation layers.</p>
<p>Now let's see what a debug callback function looks like. Add a new <code>extern &quot;system&quot;</code> function called <code>debug_callback</code> that matches the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/type.PFN_vkDebugUtilsMessengerCallbackEXT.html"><code class="hljs">vk::PFN_vkDebugUtilsMessengerCallbackEXT</code></a> prototype. The <code>extern &quot;system&quot;</code> is necessary to allow Vulkan to call our Rust function.</p>
<pre><code class="language-rust noplaypen">extern &quot;system&quot; fn debug_callback(
    severity: vk::DebugUtilsMessageSeverityFlagsEXT,
    type_: vk::DebugUtilsMessageTypeFlagsEXT,
    data: *const vk::DebugUtilsMessengerCallbackDataEXT,
    _: *mut c_void,
) -&gt; vk::Bool32 {
    let data = unsafe { *data };
    let message = unsafe { CStr::from_ptr(data.message) }.to_string_lossy();

    if severity &gt;= vk::DebugUtilsMessageSeverityFlagsEXT::ERROR {
        error!(&quot;({:?}) {}&quot;, type_, message);
    } else if severity &gt;= vk::DebugUtilsMessageSeverityFlagsEXT::WARNING {
        warn!(&quot;({:?}) {}&quot;, type_, message);
    } else if severity &gt;= vk::DebugUtilsMessageSeverityFlagsEXT::INFO {
        debug!(&quot;({:?}) {}&quot;, type_, message);
    } else {
        trace!(&quot;({:?}) {}&quot;, type_, message);
    }

    vk::FALSE
}
</code></pre>
<p>The first parameter specifies the severity of the message, which is one of the following flags:</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DebugUtilsMessageSeverityFlagsEXT.html#associatedconstant.VERBOSE"><code class="hljs">vk::DebugUtilsMessageSeverityFlagsEXT::VERBOSE</code></a> – Diagnostic message</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DebugUtilsMessageSeverityFlagsEXT.html#associatedconstant.INFO"><code class="hljs">vk::DebugUtilsMessageSeverityFlagsEXT::INFO</code></a> – Informational message like the creation of a resource</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DebugUtilsMessageSeverityFlagsEXT.html#associatedconstant.WARNING"><code class="hljs">vk::DebugUtilsMessageSeverityFlagsEXT::WARNING</code></a> – Message about behavior that is not necessarily an error, but very likely a bug in your application</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DebugUtilsMessageSeverityFlagsEXT.html#associatedconstant.ERROR"><code class="hljs">vk::DebugUtilsMessageSeverityFlagsEXT::ERROR</code></a> – Message about behavior that is invalid and may cause crashes</li>
</ul>
<p>The values of this enumeration are set up in such a way that you can use a comparison operation to check if a message is equal or worse compared to some level of severity which we use here to decide on which <code>log</code> macro is appropriate to use when logging the message.</p>
<p>The <code>type_</code> parameter can have the following values:</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DebugUtilsMessageTypeFlagsEXT.html#associatedconstant.GENERAL"><code class="hljs">vk::DebugUtilsMessageTypeFlagsEXT::GENERAL</code></a> – Some event has happened that is unrelated to the specification or performance</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DebugUtilsMessageTypeFlagsEXT.html#associatedconstant.VALIDATION"><code class="hljs">vk::DebugUtilsMessageTypeFlagsEXT::VALIDATION</code></a> – Something has happened that violates the specification or indicates a possible mistake</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DebugUtilsMessageTypeFlagsEXT.html#associatedconstant.PERFORMANCE"><code class="hljs">vk::DebugUtilsMessageTypeFlagsEXT::PERFORMANCE</code></a> – Potential non-optimal use of Vulkan</li>
</ul>
<p>The <code>data</code> parameter refers to a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DebugUtilsMessengerCallbackDataEXT.html"><code class="hljs">vk::DebugUtilsMessengerCallbackDataEXT</code></a> struct containing the details of the message itself, with the most important members being:</p>
<ul>
<li><code>message</code> – The debug message as a null-terminated string (<code>*const c_char</code>)</li>
<li><code>objects</code> – Array of Vulkan object handles related to the message</li>
<li><code>object_count</code> – Number of objects in array</li>
</ul>
<p>Finally, the last parameter, here ignored as <code>_</code>, contains a pointer that was specified during the setup of the callback and allows you to pass your own data to it.</p>
<p>The callback returns a (Vulkan) boolean that indicates if the Vulkan call that triggered the validation layer message should be aborted. If the callback returns true, then the call is aborted with the <code>vk::ErrorCode::VALIDATION_FAILED_EXT</code> error code. This is normally only used to test the validation layers themselves, so you should always return <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/constant.FALSE.html"><code class="hljs">vk::FALSE</code></a>.</p>
<p>All that remains now is telling Vulkan about the callback function. Perhaps somewhat surprisingly, even the debug callback in Vulkan is managed with a handle that needs to be explicitly created and destroyed. Such a callback is part of a debug messenger and you can have as many of them as you want. Add a field to the <code>AppData</code> struct:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    messenger: vk::DebugUtilsMessengerEXT,
}
</code></pre>
<p>Now modify the signature and end of the <code>create_instance</code> function to look like this:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_instance(
    window: &amp;Window,
    entry: &amp;Entry,
    data: &amp;mut AppData
) -&gt; Result&lt;Instance&gt; {
    // ...

    let instance = entry.create_instance(&amp;info, None)?;

    if VALIDATION_ENABLED {
        let debug_info = vk::DebugUtilsMessengerCreateInfoEXT::builder()
            .message_severity(vk::DebugUtilsMessageSeverityFlagsEXT::all())
            .message_type(
                vk::DebugUtilsMessageTypeFlagsEXT::GENERAL
                    | vk::DebugUtilsMessageTypeFlagsEXT::VALIDATION
                    | vk::DebugUtilsMessageTypeFlagsEXT::PERFORMANCE,
            )
            .user_callback(Some(debug_callback));

        data.messenger = instance.create_debug_utils_messenger_ext(&amp;debug_info, None)?;
    }

    Ok(instance)
}
</code></pre>
<blockquote>
<p><strong>Note:</strong> Calling the <code>all</code> static method on a set of Vulkan flags (e.g., <code>vk::DebugUtilsMessageSeverityFlagsEXT::all()</code> as in the above code) will, as the name implies, return a set of flags containing all of the flags of that type known by <code>vulkanalia</code>. A complete set of flags may contain flags that are only valid when certain extensions are enabled or flags added by a newer version of Vulkan than the one you are using/targeting.</p>
<p>In the above code we've explicitly listed the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DebugUtilsMessageTypeFlagsEXT.html"><code class="hljs">vk::DebugUtilsMessageTypeFlagsEXT</code></a> flags we want because that set of flags contains a flag (<a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DebugUtilsMessageTypeFlagsEXT.html#associatedconstant.DEVICE_ADDRESS_BINDING"><code class="hljs">vk::DebugUtilsMessageTypeFlagsEXT::DEVICE_ADDRESS_BINDING</code></a>) that is only valid when <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_device_address_binding_report.html">a certain extension is enabled</a>.</p>
<p>In most cases using unsupported flags shouldn't cause any errors or changes in the behavior of your application, but it definitely will result in validation errors if you have the validation layers enabled (as we are aiming to do in this chapter).</p>
</blockquote>
<p>We have first extracted our Vulkan instance out of the return expression so we can use it to add our debug callback.</p>
<p>Then we construct a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DebugUtilsMessengerCreateInfoEXT.html"><code class="hljs">vk::DebugUtilsMessengerCreateInfoEXT</code></a> struct which provides information about our debug callback and how it will be called.</p>
<p>The <code>message_severity</code> field allows you to specify all the types of severities you would like your callback to be called for. I've requested that messages of all severity be included. This would normally produce a lot of verbose general debug info but we can filter that out using a log level when we are not interested in it.</p>
<p>Similarly the <code>message_type</code> field lets you filter which types of messages your callback is notified about. I've simply enabled all types here. You can always disable some if they're not useful to you.</p>
<p>Finally, the <code>user_callback</code> field specifies the callback function. You can optionally pass a mutable reference to the <code>user_data</code> field which will be passed along to the callback function via the final parameter. You could use this to pass a pointer to the <code>AppData</code> struct, for example.</p>
<p>Lastly we call <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.ExtDebugUtilsExtension.html#method.create_debug_utils_messenger_ext"><code class="hljs">create_debug_utils_messenger_ext</code></a> to register our debug callback with the Vulkan instance.</p>
<p>Since our <code>create_instance</code> function takes an <code>AppData</code> reference now, we'll also need to update <code>App</code> and <code>App::create</code>:</p>
<blockquote>
<p><strong>Note:</strong> <code>AppData::default()</code> will use the implementation of the <a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code> trait</a> generated by the presence of <code>#[derive(Default)]</code> on the <code>AppData</code> struct. This will result in containers like <code>Vec</code> being initialized to empty lists and Vulkan handles like <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DebugUtilsMessengerEXT.html"><code class="hljs">vk::DebugUtilsMessengerEXT</code></a> being initialized to null handles. If Vulkan handles are not initialized properly before they are used, the validation layers we are enabling in this chapter should let us know exactly what we missed.</p>
</blockquote>
<pre><code class="language-rust noplaypen">struct App {
    entry: Entry,
    instance: Instance,
    data: AppData,
}

impl App {
    unsafe fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        // ...
        let mut data = AppData::default();
        let instance = create_instance(window, &amp;entry, &amp;mut data)?;
        Ok(Self { entry, instance, data })
    }
}
</code></pre>
<p>The <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DebugUtilsMessengerEXT.html"><code class="hljs">vk::DebugUtilsMessengerEXT</code></a> object we created needs to cleaned up before our app exits. We'll do this in <code>App::destroy</code> before we destroy the instance:</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy(&amp;mut self) {
    if VALIDATION_ENABLED {
        self.instance.destroy_debug_utils_messenger_ext(self.data.messenger, None);
    }

    self.instance.destroy_instance(None);
}
</code></pre>
<h2 id="debugging-instance-creation-and-destruction"><a class="header" href="#debugging-instance-creation-and-destruction">Debugging instance creation and destruction</a></h2>
<p>Although we've now added debugging with validation layers to the program we're not covering everything quite yet. The <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.ExtDebugUtilsExtension.html#method.create_debug_utils_messenger_ext"><code class="hljs">create_debug_utils_messenger_ext</code></a> call requires a valid instance to have been created and <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.ExtDebugUtilsExtension.html#method.destroy_debug_utils_messenger_ext"><code class="hljs">destroy_debug_utils_messenger_ext</code></a> must be called before the instance is destroyed. This currently leaves us unable to debug any issues in the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.EntryV1_0.html#method.create_instance"><code class="hljs">create_instance</code></a> and <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.InstanceV1_0.html#method.destroy_instance"><code class="hljs">destroy_instance</code></a> calls.</p>
<p>However, if you closely read the <a href="https://github.com/KhronosGroup/Vulkan-Docs/blob/77d9f42e075e6a483a37351c14c5e9e3122f9113/appendices/VK_EXT_debug_utils.txt#L84-L91">extension documentation</a>, you'll see that there is a way to create a separate debug utils messenger specifically for those two function calls. It requires you to simply pass a pointer to a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DebugUtilsMessengerCreateInfoEXT.html"><code class="hljs">vk::DebugUtilsMessengerCreateInfoEXT</code></a> struct in the <code>next</code> extension field of <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.InstanceCreateInfo.html"><code class="hljs">vk::InstanceCreateInfo</code></a>. Before we do this, let's first discuss how extending structs works in Vulkan.</p>
<p>The <code>s_type</code> field that is present on many Vulkan structs was briefly mentioned in the <a href="setup/../overview.html#builders">Builders section</a> of the Overview chapter. It was said that this field must be set to the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.StructureType.html"><code class="hljs">vk::StructureType</code></a> variant indicating the type of the struct (e.g., <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.StructureType.html#associatedconstant.APPLICATION_INFO"><code class="hljs">vk::StructureType::APPLICATION_INFO</code></a> for a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ApplicationInfo.html"><code class="hljs">vk::ApplicationInfo</code></a> struct).</p>
<p>You may have wondered what the purpose of this field is: doesn't Vulkan already know the type of structs passed to its commands? The purpose of this field is wrapped up with the purpose of the <code>next</code> field that always accompanies the <code>s_type</code> field in Vulkan structs: the ability to <em>extend</em> a Vulkan struct with other Vulkan structs.</p>
<p>The <code>next</code> field in a Vulkan struct may be used to specify a <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#fundamentals-validusage-pNext">structure pointer chain</a>. <code>next</code> can be either be null or a pointer to a Vulkan struct that is permitted by Vulkan to extend the struct. Each struct in this chain of structs is used to provide additional information to the Vulkan command the root structure is passed to. This feature of Vulkan allows for extending the functionality of Vulkan commands without breaking backwards compabilitity.</p>
<p>When you pass such a chain of structs to a Vulkan command, it must iterate through the structs to collect all of the information from the structs. Because of this, Vulkan can't know the type of each structure in the chain, hence the need for the <code>s_type</code> field.</p>
<p>The builders provided by <code>vulkanalia</code> allow for easily building these pointer chains in a type-safe manner. For example, take a look at the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.InstanceCreateInfoBuilder.html"><code class="hljs">vk::InstanceCreateInfoBuilder</code></a> builder, specifically the <code>push_next</code> method. This method allows adding any Vulkan struct for which the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.ExtendsInstanceCreateInfo.html"><code class="hljs">vk::ExtendsInstanceCreateInfo</code></a> trait is implemented for to the pointer chain for a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.InstanceCreateInfo.html"><code class="hljs">vk::InstanceCreateInfo</code></a>.</p>
<p>One such struct is <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DebugUtilsMessengerCreateInfoEXT.html"><code class="hljs">vk::DebugUtilsMessengerCreateInfoEXT</code></a>, which we will now use to extend our <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.InstanceCreateInfo.html"><code class="hljs">vk::InstanceCreateInfo</code></a> struct to set up our debug callback. To do this we'll continue to modify our <code>create_instance</code> function. This time we'll make the <code>info</code> struct mutable so we can modify its pointer chain before moving the <code>debug_info</code> struct, now also mutable, below it so we can push it onto <code>info</code>'s pointer chain:</p>
<pre><code class="language-rust noplaypen">let mut info = vk::InstanceCreateInfo::builder()
    .application_info(&amp;application_info)
    .enabled_layer_names(&amp;layers)
    .enabled_extension_names(&amp;extensions)
    .flags(flags);

let mut debug_info = vk::DebugUtilsMessengerCreateInfoEXT::builder()
    .message_severity(vk::DebugUtilsMessageSeverityFlagsEXT::all())
    .message_type(
        vk::DebugUtilsMessageTypeFlagsEXT::GENERAL
            | vk::DebugUtilsMessageTypeFlagsEXT::VALIDATION
            | vk::DebugUtilsMessageTypeFlagsEXT::PERFORMANCE,
    )
    .user_callback(Some(debug_callback));

if VALIDATION_ENABLED {
    info = info.push_next(&amp;mut debug_info);
}
</code></pre>
<blockquote>
<p><strong>Note:</strong> It might seem redundant to use the same debug info with the same severity, type, and callback to both call <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.ExtDebugUtilsExtension.html#method.create_debug_utils_messenger_ext"><code class="hljs">create_debug_utils_messenger_ext</code></a> <em>and</em> add as an extension to the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.InstanceCreateInfo.html"><code class="hljs">vk::InstanceCreateInfo</code></a> instance. However, these two usages serve different purposes. The usage here (adding the debug info to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.InstanceCreateInfo.html"><code class="hljs">vk::InstanceCreateInfo</code></a>) sets up debugging <em>during the creation and destruction of the instance</em>. Calling <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.ExtDebugUtilsExtension.html#method.create_debug_utils_messenger_ext"><code class="hljs">create_debug_utils_messenger_ext</code></a> sets up persistent debugging for <em>everything else</em>. See the paragraph starting &quot;To capture events that occur while creating or destroying an instance&quot; in the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap4.html#VkInstanceCreateInfo">relevant chapter of the Vulkan specification</a>.</p>
</blockquote>
<p><code>debug_info</code> needs to be defined outside of the conditional since it needs to live until we are done calling <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.EntryV1_0.html#method.create_instance"><code class="hljs">create_instance</code></a>. Fortunately we can rely on the Rust compiler to protect us from pushing a struct that doesn't live long enough onto a pointer chain due to the lifetimes defined for the <code>vulkanalia</code> builders.</p>
<p>Now we should be able to run our program and see logs from our debug callback, but first we'll need to set the <code>RUST_LOG</code> environment variable so that <code>pretty_env_logger</code> will enable the log levels we are interested in. Initially set the log level to <code>debug</code> so we can be sure it is working, here is an example on Windows (PowerShell):</p>
<p><img src="setup/../images/validation_layer_test.png" alt="" /></p>
<p>If everything is working you shouldn't see any warning or error messages. Going forward you will probably want to increase the minimum log level to <code>info</code> using <code>RUST_LOG</code> to reduce the verbosity of the logs unless you are trying to debug an error.</p>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>There are a lot more settings for the behavior of validation layers than just the flags specified in the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DebugUtilsMessengerCreateInfoEXT.html"><code class="hljs">vk::DebugUtilsMessengerCreateInfoEXT</code></a> struct. Browse to the Vulkan SDK and go to the <code>Config</code> directory. There you will find a <code>vk_layer_settings.txt</code> file that explains how to configure the layers.</p>
<p>To configure the layer settings for your own application, copy the file to the working directory of your project's executable and follow the instructions to set the desired behavior. However, for the remainder of this tutorial I'll assume that you're using the default settings.</p>
<p>Throughout this tutorial I'll be making a couple of intentional mistakes to show you how helpful the validation layers are with catching them and to teach you how important it is to know exactly what you're doing with Vulkan. Now it's time to look at Vulkan devices in the system.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="physical-devices-and-queue-families"><a class="header" href="#physical-devices-and-queue-families">Physical devices and queue families</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/03_physical_device_selection.rs">main.rs</a></p>
<p>After initializing the Vulkan library through an <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/struct.Instance.html"><code class="hljs">Instance</code></a> we need to look for and select a graphics card in the system that supports the features we need. In fact we can select any number of graphics cards and use them simultaneously, but in this tutorial we'll stick to the first graphics card that suits our needs.</p>
<p>We'll add a <code>pick_physical_device</code> function which will accomplish this task and write the physical device and related information to the <code>AppData</code> instance. This function and the functions it calls will use a custom error type (<code>SuitabilityError</code>) to signal that a physical device does not satisfy the requirements of the application. This error type will use the <code>thiserror</code> crate to automatically implement all the necessary boilerplate for an error type.</p>
<pre><code class="language-rust noplaypen">use thiserror::Error;

impl App {
    unsafe fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        // ...
        pick_physical_device(&amp;instance, &amp;mut data)?;
        Ok(Self { entry, instance, data })
    }
}

#[derive(Debug, Error)]
#[error(&quot;Missing {0}.&quot;)]
pub struct SuitabilityError(pub &amp;'static str);

unsafe fn pick_physical_device(instance: &amp;Instance, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    Ok(())
}
</code></pre>
<p>The graphics card that we'll end up selecting will be stored in a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PhysicalDevice.html"><code class="hljs">vk::PhysicalDevice</code></a> handle that is added as a new field to the <code>AppData</code> struct. This object will be implicitly destroyed when the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/struct.Instance.html"><code class="hljs">Instance</code></a> is destroyed, so we won't need to do anything new in the <code>App::destroy</code> method.</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    physical_device: vk::PhysicalDevice,
}
</code></pre>
<h2 id="device-suitability"><a class="header" href="#device-suitability">Device suitability</a></h2>
<p>We'll need a way to determine whether a physical device meets our needs. We'll start by creating a function that returns a <code>SuitabilityError</code> if a supplied physical device does not support everything we require:</p>
<pre><code class="language-rust noplaypen">unsafe fn check_physical_device(
    instance: &amp;Instance,
    data: &amp;AppData,
    physical_device: vk::PhysicalDevice,
) -&gt; Result&lt;()&gt; {
    Ok(())
}
</code></pre>
<p>To evaluate whether a physical device meets our needs we can start by querying for some details. Basic device properties like the name, type, and supported Vulkan version can be queried using <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.InstanceV1_0.html#method.get_physical_device_properties"><code class="hljs">get_physical_device_properties</code></a>:</p>
<pre><code class="language-rust noplaypen">let properties = instance
    .get_physical_device_properties(physical_device);
</code></pre>
<p>The support for optional features like texture compression, 64 bit floats, and multi-viewport rendering (useful for VR) can be queried using <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.InstanceV1_0.html#method.get_physical_device_features"><code class="hljs">get_physical_device_features</code></a>:</p>
<pre><code class="language-rust noplaypen">let features = instance
    .get_physical_device_features(physical_device);
</code></pre>
<p>There are more details that can be queried from devices that we'll discuss later concerning device memory and queue families (see the next section).</p>
<p>As an example, let's say we consider our application only usable for dedicated graphics cards that support geometry shaders. Then the <code>check_physical_device</code> function might look like this:</p>
<pre><code class="language-rust noplaypen">unsafe fn check_physical_device(
    instance: &amp;Instance,
    data: &amp;AppData,
    physical_device: vk::PhysicalDevice,
) -&gt; Result&lt;()&gt; {
    let properties = instance.get_physical_device_properties(physical_device);
    if properties.device_type != vk::PhysicalDeviceType::DISCRETE_GPU {
        return Err(anyhow!(SuitabilityError(&quot;Only discrete GPUs are supported.&quot;)));
    }

    let features = instance.get_physical_device_features(physical_device);
    if features.geometry_shader != vk::TRUE {
        return Err(anyhow!(SuitabilityError(&quot;Missing geometry shader support.&quot;)));
    }

    Ok(())
}
</code></pre>
<p>Instead of just checking if a device is suitable or not and going with the first one, you could also give each device a score and pick the highest one. That way you could favor a dedicated graphics card by giving it a higher score, but fall back to an integrated GPU if that's the only available one. You could also just display the names of the choices and allow the user to select.</p>
<p>Next we'll discuss the first real required feature.</p>
<h2 id="queue-families"><a class="header" href="#queue-families">Queue families</a></h2>
<p>It has been briefly touched upon before that almost every operation in Vulkan, anything from drawing to uploading textures, requires commands to be submitted to a queue. There are different types of queues that originate from different queue families and each family of queues allows only a subset of commands. For example, there could be a queue family that only allows processing of compute commands or one that only allows memory transfer related commands.</p>
<p>We need to check which queue families are supported by the device and which one of these supports the commands that we want to use. For that purpose we'll add a new struct <code>QueueFamilyIndices</code> that stores the indices of the queue families we need.</p>
<p>Right now we are only going to look for a queue that supports graphics commands, so the struct and its implementation will look like this:</p>
<pre><code class="language-rust noplaypen">#[derive(Copy, Clone, Debug)]
struct QueueFamilyIndices {
    graphics: u32,
}

impl QueueFamilyIndices {
    unsafe fn get(
        instance: &amp;Instance,
        data: &amp;AppData,
        physical_device: vk::PhysicalDevice,
    ) -&gt; Result&lt;Self&gt; {
        let properties = instance
            .get_physical_device_queue_family_properties(physical_device);

        let graphics = properties
            .iter()
            .position(|p| p.queue_flags.contains(vk::QueueFlags::GRAPHICS))
            .map(|i| i as u32);

        if let Some(graphics) = graphics {
            Ok(Self { graphics })
        } else {
            Err(anyhow!(SuitabilityError(&quot;Missing required queue families.&quot;)))
        }
    }
}
</code></pre>
<p>The queue properties returned by <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.InstanceV1_0.html#method.get_physical_device_queue_family_properties"><code class="hljs">get_physical_device_queue_family_properties</code></a> contains various details about the queue families supported by the physical device, including the type of operations supported and the number of queues that can be created based on that family. Here we are looking for the first queue family that supports graphics operations as indicated by <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.QueueFlags.html#associatedconstant.GRAPHICS"><code class="hljs">vk::QueueFlags::GRAPHICS</code></a>.</p>
<p>Now that we have this fancy queue family lookup method, we can use it as a check in the <code>check_physical_device</code> function to ensure the device can process the commands we want to use:</p>
<pre><code class="language-rust noplaypen">unsafe fn check_physical_device(
    instance: &amp;Instance,
    data: &amp;AppData,
    physical_device: vk::PhysicalDevice,
) -&gt; Result&lt;()&gt; {
    QueueFamilyIndices::get(instance, data, physical_device)?;
    Ok(())
}
</code></pre>
<p>Lastly we can iterate over the physical devices and pick the first that satisfies our requirements as indicated by <code>check_physical_device</code>. To do this, update <code>pick_physical_device</code> to look like the following:</p>
<pre><code class="language-rust noplaypen">unsafe fn pick_physical_device(instance: &amp;Instance, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    for physical_device in instance.enumerate_physical_devices()? {
        let properties = instance.get_physical_device_properties(physical_device);

        if let Err(error) = check_physical_device(instance, data, physical_device) {
            warn!(&quot;Skipping physical device (`{}`): {}&quot;, properties.device_name, error);
        } else {
            info!(&quot;Selected physical device (`{}`).&quot;, properties.device_name);
            data.physical_device = physical_device;
            return Ok(());
        }
    }

    Err(anyhow!(&quot;Failed to find suitable physical device.&quot;))
}
</code></pre>
<p>Great, that's all we need for now to find the right physical device! The next step is to create a logical device to interface with it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logical-device-and-queues"><a class="header" href="#logical-device-and-queues">Logical device and queues</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/04_logical_device.rs">main.rs</a></p>
<p>After selecting a physical device to use we need to set up a logical device to interface with it. The logical device creation process is similar to the instance creation process and describes the features we want to use. We also need to specify which queues to create now that we've queried which queue families are available. You can even create multiple logical devices from the same physical device if you have varying requirements.</p>
<p>Start by adding a new <code>App</code> field to store the logical device in:</p>
<pre><code class="language-rust noplaypen">struct App {
    // ...
    device: Device,
}
</code></pre>
<p>Next, add a <code>create_logical_device</code> function that is called from <code>App::create</code> and add the resulting logical device to the <code>App</code> initializer:</p>
<pre><code class="language-rust noplaypen">impl App {
    unsafe fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        // ...
        let device = create_logical_device(&amp;entry, &amp;instance, &amp;mut data)?;
        Ok(Self { entry, instance, data, device })
    }
}

unsafe fn create_logical_device(
    entry: &amp;Entry,
    instance: &amp;Instance,
    data: &amp;mut AppData,
) -&gt; Result&lt;Device&gt; {
}
</code></pre>
<h2 id="specifying-the-queues-to-be-created"><a class="header" href="#specifying-the-queues-to-be-created">Specifying the queues to be created</a></h2>
<p>The creation of a logical device involves specifying a bunch of details in structs again, of which the first one will be <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DeviceQueueCreateInfo.html"><code class="hljs">vk::DeviceQueueCreateInfo</code></a>. This structure describes the number of queues we want for a single queue family. Right now we're only interested in a queue with graphics capabilities.</p>
<pre><code class="language-rust noplaypen">let indices = QueueFamilyIndices::get(instance, data, data.physical_device)?;

let queue_priorities = &amp;[1.0];
let queue_info = vk::DeviceQueueCreateInfo::builder()
    .queue_family_index(indices.graphics)
    .queue_priorities(queue_priorities);
</code></pre>
<p>The currently available drivers will only allow you to create a small number of queues for each queue family and you don't really need more than one. That's because you can create all of the command buffers on multiple threads and then submit them all at once on the main thread with a single low-overhead call.</p>
<p>Vulkan lets you assign priorities to queues to influence the scheduling of command buffer execution using floating point numbers between <code>0.0</code> and <code>1.0</code>. This is required even when only creating a single queue.</p>
<h2 id="specifying-the-layers-to-enable"><a class="header" href="#specifying-the-layers-to-enable">Specifying the layers to enable</a></h2>
<p>The next piece of information we need to provide bears a resemblance to the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.InstanceCreateInfo.html"><code class="hljs">vk::InstanceCreateInfo</code></a> struct. Once again we need to specify any layers or extensions we want to enable, but this time any specified extensions are device specific rather than global.</p>
<p>An example of a device specific extension is <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VK_KHR_swapchain.html"><code class="hljs">VK_KHR_swapchain</code></a>, which allows you to present rendered images from that device to windows. It is possible that there are Vulkan devices in the system that lack this ability, for example because they only support compute operations. We will come back to this extension in the swapchain chapter.</p>
<p>Previous implementations of Vulkan made a distinction between instance and device specific validation layers, but this is no longer the case. That means that the layer names we pass to <code>enabled_layer_names</code> later are ignored by up-to-date implementations. However, it is still a good idea to set them anyway to be compatible with older implementations.</p>
<p>We wont be enabling any device extensions yet, so we will just construct a list of layer names containing the validation layer if validation is enabled.</p>
<pre><code class="language-rust noplaypen">let layers = if VALIDATION_ENABLED {
    vec![VALIDATION_LAYER.as_ptr()]
} else {
    vec![]
};
</code></pre>
<h2 id="specifying-the-extensions-to-enable"><a class="header" href="#specifying-the-extensions-to-enable">Specifying the extensions to enable</a></h2>
<p>As discussed in the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/struct.Instance.html"><code class="hljs">Instance</code></a> chapter, certain Vulkan extensions must be enabled for applications that use Vulkan implementations that aren't fully conformant with the Vulkan specification. In that chapter, we enabled the instance extensions needed for compatibility with these non-conformant implementations. Here, we'll enable the device extension needed for the same purpose.</p>
<pre><code class="language-rust noplaypen">let mut extensions = vec![];

// Required by Vulkan SDK on macOS since 1.3.216.
if cfg!(target_os = &quot;macos&quot;) &amp;&amp; entry.version()? &gt;= PORTABILITY_MACOS_VERSION {
    extensions.push(vk::KHR_PORTABILITY_SUBSET_EXTENSION.name.as_ptr());
}
</code></pre>
<h2 id="specifying-used-device-features"><a class="header" href="#specifying-used-device-features">Specifying used device features</a></h2>
<p>The next information to specify is the set of device features that we'll be using. These are the features that we queried support for with <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.InstanceV1_0.html#method.get_physical_device_features"><code class="hljs">get_physical_device_features</code></a> in the previous chapter, like geometry shaders. Right now we don't need anything special, so we can simply define it and leave everything to the default values (<code>false</code>). We'll come back to this structure once we're about to start doing more interesting things with Vulkan.</p>
<pre><code class="language-rust noplaypen">let features = vk::PhysicalDeviceFeatures::builder();
</code></pre>
<h2 id="creating-the-logical-device"><a class="header" href="#creating-the-logical-device">Creating the logical device</a></h2>
<p>With the previous two structures, the validation layer (if enabled), and the device extensions in place, we can fill in the main <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DeviceCreateInfo.html"><code class="hljs">vk::DeviceCreateInfo</code></a> structure.</p>
<pre><code class="language-rust noplaypen">let queue_infos = &amp;[queue_info];
let info = vk::DeviceCreateInfo::builder()
    .queue_create_infos(queue_infos)
    .enabled_layer_names(&amp;layers)
    .enabled_extension_names(&amp;extensions)
    .enabled_features(&amp;features);
</code></pre>
<p>That's it, we're now ready to instantiate the logical device with a call to the appropriately named <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.InstanceV1_0.html#method.create_device"><code class="hljs">create_device</code></a> method.</p>
<pre><code class="language-rust noplaypen">let device = instance.create_device(data.physical_device, &amp;info, None)?;
</code></pre>
<p>The parameters are the physical device to interface with, the queue and usage info we just specified, and the optional allocation callbacks. Similarly to the instance creation function, this call can return errors based on enabling non-existent extensions or specifying the desired usage of unsupported features.</p>
<p>The device should be destroyed in <code>App::destroy</code>:</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy(&amp;mut self) {
    self.device.destroy_device(None);
    // ...
}
</code></pre>
<p>Logical devices don't interact directly with instances, which is why it's not included as a parameter.</p>
<h2 id="retrieving-queue-handles"><a class="header" href="#retrieving-queue-handles">Retrieving queue handles</a></h2>
<p>The queues are automatically created along with the logical device, but we don't have a handle to interface with them yet. First add a new <code>AppData</code> field to store a handle to the graphics queue:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    graphics_queue: vk::Queue,
}
</code></pre>
<p>Device queues are implicitly cleaned up when the device is destroyed, so we don't need to do anything in <code>App::destroy</code>.</p>
<p>We can use the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.get_device_queue"><code class="hljs">get_device_queue</code></a> function to retrieve queue handles for each queue family. The parameters are the logical device, queue family, and queue index. Because we're only creating a single queue from this family, we'll simply use index 0.</p>
<pre><code class="language-rust noplaypen">data.graphics_queue = device.get_device_queue(indices.graphics, 0);
</code></pre>
<p>Lastly, return the created logical device from <code>create_logical_device</code>:</p>
<pre><code class="language-rust noplaypen">Ok(device)
</code></pre>
<p>With the logical device and queue handles we can now actually start using the graphics card to do things! In the next few chapters we'll set up the resources to present results to the window system.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="window-surface"><a class="header" href="#window-surface">Window surface</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/05_window_surface.rs">main.rs</a></p>
<p>Since Vulkan is a platform agnostic API, it can't interface directly with the window system on its own. To establish the connection between Vulkan and the window system to present results to the screen, we need to use the WSI (Window System Integration) extensions. In this chapter we'll discuss the first one, which is <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VK_KHR_surface.html"><code class="hljs">VK_KHR_surface</code></a>. It exposes a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SurfaceKHR.html"><code class="hljs">vk::SurfaceKHR</code></a> object that represents an abstract type of surface to present rendered images to. The surface in our program will be backed by the window that we've already opened with <code>winit</code>.</p>
<p>The <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VK_KHR_surface.html"><code class="hljs">VK_KHR_surface</code></a> extension is an instance level extension and we've actually already enabled it, because it's included in the list returned by <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/window/fn.get_required_instance_extensions.html"><code class="hljs">vk_window::get_required_instance_extensions</code></a>. The list also includes some other WSI extensions that we'll use in the next couple of chapters.</p>
<p>The window surface needs to be created right after the instance creation, because it can actually influence the physical device selection. The reason we postponed this is because window surfaces are part of the larger topic of render targets and presentation for which the explanation would have cluttered the basic setup. It should also be noted that window surfaces are an entirely optional component in Vulkan, if you just need off-screen rendering. Vulkan allows you to do that without hacks like creating an invisible window (necessary for OpenGL).</p>
<p>While we can freely import types for extensions like the struct <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SurfaceKHR.html"><code class="hljs">vk::SurfaceKHR</code></a>, we need to import the <code>vulkanalia</code> extension trait for <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VK_KHR_surface.html"><code class="hljs">VK_KHR_surface</code></a> before we can call any of the Vulkan commands added by the extension. Add the following import for <code>vk::KhrSurfaceExtensionInstanceCommands</code>:</p>
<pre><code class="language-rust noplaypen">// Note: This trait was called `KhrSurfaceExtension` in versions of `vulkanalia` prior to `v0.31.0`.
use vulkanalia::vk::KhrSurfaceExtensionInstanceCommands;
</code></pre>
<h2 id="window-surface-creation"><a class="header" href="#window-surface-creation">Window surface creation</a></h2>
<p>Start by adding a <code>surface</code> field in <code>AppData</code> above the other fields.</p>
<pre><code class="language-rust noplaypen">struct AppData {
    surface: vk::SurfaceKHR,
    // ...
}
</code></pre>
<p>Although the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SurfaceKHR.html"><code class="hljs">vk::SurfaceKHR</code></a> object and its usage is platform agnostic, its creation isn't because it depends on window system details. For example, it needs the <code>HWND</code> and <code>HMODULE</code> handles on Windows. Therefore there is a platform-specific addition to the extension, which on Windows is called <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VK_KHR_win32_surface.html"><code class="hljs">VK_KHR_win32_surface</code></a> and is also automatically included in the list from <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/window/fn.get_required_instance_extensions.html"><code class="hljs">vk_window::get_required_instance_extensions</code></a>.</p>
<p>I will demonstrate how this platform specific extension can be used to create a surface on Windows, but we won't actually use it in this tutorial. <code>vulkanalia</code> has <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/window/fn.create_surface.html"><code class="hljs">vk_window::create_surface</code></a> that handles the platform differences for us. Still, it's good to see what it does behind the scenes before we start relying on it.</p>
<p>Because a window surface is a Vulkan object, it comes with a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Win32SurfaceCreateInfoKHR.html"><code class="hljs">vk::Win32SurfaceCreateInfoKHR</code></a> struct that needs to be filled in. It has two important parameters: <code>hinstance</code> and <code>hwnd</code>. These are the handles to the process and the window.</p>
<pre><code class="language-rust noplaypen">use winit::platform::windows::WindowExtWindows;

let info = vk::Win32SurfaceCreateInfoKHR::builder()
    .hinstance(window.hinstance())
    .hwnd(window.hwnd());
</code></pre>
<p>The <code>WindowExtWindows</code> trait is imported from <code>winit</code> because it allows us to access platform-specific methods on the <code>winit</code> <code>Window</code> struct. In this case, it permits us to get the process and window handles for the window created by <code>winit</code>.</p>
<p>After that the surface can be created with <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.KhrWin32SurfaceExtension.html#method.create_win32_surface_khr"><code class="hljs">create_win32_surface_khr</code></a>, which includes parameters for the surface creation details and custom allocators. Technically this is a WSI extension function, but it is so commonly used that the standard Vulkan loader includes it, so unlike other extensions you don't need to explicitly load it. However, we do need to import the <code>vulkanalia</code> extension trait for <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VK_KHR_win32_surface.html"><code class="hljs">VK_KHR_win32_surface</code></a> (<code>vk::KhrWin32SurfaceExtensionInstanceCommands</code>).</p>
<pre><code class="language-rust noplaypen">// Note: This trait was called `KhrWin32SurfaceExtension` in versions of `vulkanalia` prior to `v0.31.0`.
use vk::KhrWin32SurfaceExtensionInstanceCommands;

let surface = instance.create_win32_surface_khr(&amp;info, None).unwrap();
</code></pre>
<p>The process is similar for other platforms like Linux, where <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.KhrXcbSurfaceExtension.html#method.create_xcb_surface_khr"><code class="hljs">create_xcb_surface_khr</code></a> takes an XCB connection and window as creation details with X11.</p>
<p>The <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/window/fn.create_surface.html"><code class="hljs">vk_window::create_surface</code></a> function performs exactly this operation with a different implementation for each platform. We'll now integrate it into our program. Add a call to the function in <code>App::create</code> right before we pick a physical device.</p>
<pre><code class="language-rust noplaypen">unsafe fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
    // ...
    let instance = create_instance(window, &amp;entry, &amp;mut data)?;
    data.surface = vk_window::create_surface(&amp;instance, &amp;window, &amp;window)?;
    pick_physical_device(&amp;instance, &amp;mut data)?;
    // ...
}
</code></pre>
<p>The parameters are the Vulkan instance and the <code>winit</code> window. Once we have our surface, it can be destroyed in <code>App::destroy</code> using the Vulkan API:</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy(&amp;mut self) {
    // ...
    self.instance.destroy_surface_khr(self.data.surface, None);
    self.instance.destroy_instance(None);
}
</code></pre>
<p>Make sure that the surface is destroyed before the instance.</p>
<h2 id="querying-for-presentation-support"><a class="header" href="#querying-for-presentation-support">Querying for presentation support</a></h2>
<p>Although the Vulkan implementation may support window system integration, that does not mean that every device in the system supports it. Therefore we need to extend our physical device selection code to ensure that our chosen device can present images to the surface we created. Since the presentation is a queue-specific feature, the problem is actually about finding a queue family that supports presenting to the surface we created.</p>
<p>It's actually possible that the queue families supporting drawing commands and the ones supporting presentation do not overlap. Therefore we have to take into account that there could be a distinct presentation queue by modifying the <code>QueueFamilyIndices</code> struct:</p>
<pre><code class="language-rust noplaypen">struct QueueFamilyIndices {
    graphics: u32,
    present: u32,
}
</code></pre>
<p>Next, we'll modify the <code>QueueFamilyIndices::get</code> method to look for a queue family that has the capability of presenting to our window surface. The function to check for that is <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.KhrSurfaceExtension.html#method.get_physical_device_surface_support_khr"><code class="hljs">get_physical_device_surface_support_khr</code></a>, which takes the physical device, queue family index. and surface as parameters and returns whether presentation is supported for that combination of physical device, queue family, and surface.</p>
<p>Modify <code>QueueFamilyIndices::get</code> to find a presentation queue family index below where a graphics queue family index is found.</p>
<pre><code class="language-rust noplaypen">let mut present = None;
for (index, properties) in properties.iter().enumerate() {
    if instance.get_physical_device_surface_support_khr(
        physical_device,
        index as u32,
        data.surface,
    )? {
        present = Some(index as u32);
        break;
    }
}
</code></pre>
<p>We'll also need to add <code>present</code> to the final expression:</p>
<pre><code class="language-rust noplaypen">if let (Some(graphics), Some(present)) = (graphics, present) {
    Ok(Self { graphics, present })
} else {
    Err(anyhow!(SuitabilityError(&quot;Missing required queue families.&quot;)))
}
</code></pre>
<p>Note that it's very likely that these end up being the same queue family after all, but throughout the program we will treat them as if they were separate queues for a uniform approach. Nevertheless, you could add logic to explicitly prefer a physical device that supports drawing and presentation in the same queue for improved performance.</p>
<h2 id="creating-the-presentation-queue"><a class="header" href="#creating-the-presentation-queue">Creating the presentation queue</a></h2>
<p>The one thing that remains is modifying the logical device creation procedure to create the presentation queue and retrieve the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Queue.html"><code class="hljs">vk::Queue</code></a> handle. Add a field to <code>AppData</code> for the handle:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    present_queue: vk::Queue,
}
</code></pre>
<p>Next, we need to have multiple <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DeviceQueueCreateInfo.html"><code class="hljs">vk::DeviceQueueCreateInfo</code></a> structs to create a queue from both families. An easy way to do that is to create a set of all unique queue families that are necessary for the required queues. We'll do this in the <code>create_logical_device</code> function:</p>
<pre><code class="language-rust noplaypen">let indices = QueueFamilyIndices::get(instance, data, data.physical_device)?;

let mut unique_indices = HashSet::new();
unique_indices.insert(indices.graphics);
unique_indices.insert(indices.present);

let queue_priorities = &amp;[1.0];
let queue_infos = unique_indices
    .iter()
    .map(|i| {
        vk::DeviceQueueCreateInfo::builder()
            .queue_family_index(*i)
            .queue_priorities(queue_priorities)
    })
    .collect::&lt;Vec&lt;_&gt;&gt;();
</code></pre>
<p>And delete the previous <code>queue_infos</code> slice and take a reference to the <code>queue_infos</code> list for <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DeviceCreateInfo.html"><code class="hljs">vk::DeviceCreateInfo</code></a>:</p>
<pre><code class="language-rust noplaypen">let info = vk::DeviceCreateInfo::builder()
    .queue_create_infos(&amp;queue_infos)
    .enabled_layer_names(&amp;layers)
    .enabled_extension_names(&amp;extensions)
    .enabled_features(&amp;features);
</code></pre>
<p>If the queue families are the same, then we only need to pass its index once. Finally, add a call to retrieve the queue handle:</p>
<pre><code class="language-rust noplaypen">data.present_queue = device.get_device_queue(indices.present, 0);
</code></pre>
<p>In case the queue families are the same, the two handles will most likely have the same value now. In the next chapter we're going to look at swapchains and how they give us the ability to present images to the surface.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swapchain"><a class="header" href="#swapchain">Swapchain</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/06_swapchain_creation.rs">main.rs</a></p>
<p>Vulkan does not have the concept of a &quot;default framebuffer&quot;, hence it requires an infrastructure that will own the buffers we will render to before we visualize them on the screen. This infrastructure is known as the <em>swapchain</em> and must be created explicitly in Vulkan. The swapchain is essentially a queue of images that are waiting to be presented to the screen. Our application will acquire such an image to draw to it, and then return it to the queue. How exactly the queue works and the conditions for presenting an image from the queue depend on how the swapchain is set up, but the general purpose of the swapchain is to synchronize the presentation of images with the refresh rate of the screen.</p>
<h2 id="checking-for-swapchain-support"><a class="header" href="#checking-for-swapchain-support">Checking for swapchain support</a></h2>
<p>Not all graphics cards are capable of presenting images directly to a screen for various reasons, for example because they are designed for servers and don't have any display outputs. Secondly, since image presentation is heavily tied into the window system and the surfaces associated with windows, it is not actually part of the Vulkan core. You have to enable the <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VK_KHR_swapchain.html"><code class="hljs">VK_KHR_swapchain</code></a> device extension after querying for its support. Also, like before, you need to import the <code>vulkanalia</code> extension trait for <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VK_KHR_swapchain.html"><code class="hljs">VK_KHR_swapchain</code></a>:</p>
<pre><code class="language-rust noplaypen">// Note: This trait was called `KhrSwapchainExtension` in versions of `vulkanalia` prior to `v0.31.0`.
use vulkanalia::vk::KhrSwapchainExtensionDeviceCommands;
</code></pre>
<p>Then we'll first extend the <code>check_physical_device</code> function to check if this extension is supported. We've previously seen how to list the extensions that are supported by a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PhysicalDevice.html"><code class="hljs">vk::PhysicalDevice</code></a>, so doing that should be fairly straightforward.</p>
<p>First declare a list of required device extensions, similar to the list of validation layers to enable.</p>
<pre><code class="language-rust noplaypen">const DEVICE_EXTENSIONS: &amp;[vk::ExtensionName] = &amp;[vk::KHR_SWAPCHAIN_EXTENSION.name];
</code></pre>
<p>Next, create a new function <code>check_physical_device_extensions</code> that is called from <code>check_physical_device</code> as an additional check:</p>
<pre><code class="language-rust noplaypen">unsafe fn check_physical_device(
    instance: &amp;Instance,
    data: &amp;AppData,
    physical_device: vk::PhysicalDevice,
) -&gt; Result&lt;()&gt; {
    QueueFamilyIndices::get(instance, data, physical_device)?;
    check_physical_device_extensions(instance, physical_device)?;
    Ok(())
}

unsafe fn check_physical_device_extensions(
    instance: &amp;Instance,
    physical_device: vk::PhysicalDevice,
) -&gt; Result&lt;()&gt; {
    Ok(())
}
</code></pre>
<p>Modify the body of the function to enumerate the extensions and check if all of the required extensions are amongst them.</p>
<pre><code class="language-rust noplaypen">unsafe fn check_physical_device_extensions(
    instance: &amp;Instance,
    physical_device: vk::PhysicalDevice,
) -&gt; Result&lt;()&gt; {
    let extensions = instance
        .enumerate_device_extension_properties(physical_device, None)?
        .iter()
        .map(|e| e.extension_name)
        .collect::&lt;HashSet&lt;_&gt;&gt;();
    if DEVICE_EXTENSIONS.iter().all(|e| extensions.contains(e)) {
        Ok(())
    } else {
        Err(anyhow!(SuitabilityError(&quot;Missing required device extensions.&quot;)))
    }
}
</code></pre>
<p>Now run the code and verify that your graphics card is indeed capable of creating a swapchain. It should be noted that the availability of a presentation queue, as we checked in the previous chapter, implies that the swapchain extension must be supported. However, it's still good to be explicit about things, and the extension does have to be explicitly enabled.</p>
<h2 id="enabling-device-extensions"><a class="header" href="#enabling-device-extensions">Enabling device extensions</a></h2>
<p>Using a swapchain requires enabling the <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VK_KHR_swapchain.html"><code class="hljs">VK_KHR_swapchain</code></a> extension first. Enabling the extension just requires a small change to our list of device extensions in the <code>create_logical_device</code> function. Initialize our list of device extensions with a list of null-terminated strings constructed from <code>DEVICE_EXTENSIONS</code>:</p>
<pre><code class="language-rust noplaypen">let mut extensions = DEVICE_EXTENSIONS
    .iter()
    .map(|n| n.as_ptr())
    .collect::&lt;Vec&lt;_&gt;&gt;();
</code></pre>
<h2 id="querying-details-of-swapchain-support"><a class="header" href="#querying-details-of-swapchain-support">Querying details of swapchain support</a></h2>
<p>Just checking if a swapchain is available is not sufficient, because it may not actually be compatible with our window surface. Creating a swapchain also involves a lot more settings than instance and device creation, so we need to query for some more details before we're able to proceed.</p>
<p>There are basically three kinds of properties we need to check:</p>
<ul>
<li>Basic surface capabilities (min/max number of images in swapchain, min/max width and height of images)</li>
<li>Surface formats (pixel format, color space)</li>
<li>Available presentation modes</li>
</ul>
<p>Similar to <code>QueueFamilyIndices</code>, we'll use a struct to pass these details around once they've been queried. The three aforementioned types of properties come in the form of the following structs and lists of structs:</p>
<pre><code class="language-rust noplaypen">#[derive(Clone, Debug)]
struct SwapchainSupport {
    capabilities: vk::SurfaceCapabilitiesKHR,
    formats: Vec&lt;vk::SurfaceFormatKHR&gt;,
    present_modes: Vec&lt;vk::PresentModeKHR&gt;,
}
</code></pre>
<p>We'll now create a new method <code>SwapchainSupport::get</code> that will initialize this struct with all of the structs we need.</p>
<pre><code class="language-rust noplaypen">impl SwapchainSupport {
    unsafe fn get(
        instance: &amp;Instance,
        data: &amp;AppData,
        physical_device: vk::PhysicalDevice,
    ) -&gt; Result&lt;Self&gt; {
        Ok(Self {
            capabilities: instance
                .get_physical_device_surface_capabilities_khr(
                    physical_device, data.surface)?,
            formats: instance
                .get_physical_device_surface_formats_khr(
                    physical_device, data.surface)?,
            present_modes: instance
                .get_physical_device_surface_present_modes_khr(
                    physical_device, data.surface)?,
        })
    }
}
</code></pre>
<p>The meaning of these structs and exactly which data they contain is discussed in the next section.</p>
<p>All of the details are in the struct now, so let's extend <code>check_physical_device</code> once more to utilize this method to verify that swapchain support is adequate. swapchain support is sufficient for this tutorial if there is at least one supported image format and one supported presentation mode given the window surface we have.</p>
<pre><code class="language-rust noplaypen">unsafe fn check_physical_device(
    instance: &amp;Instance,
    data: &amp;AppData,
    physical_device: vk::PhysicalDevice,
) -&gt; Result&lt;()&gt; {
    // ...

    let support = SwapchainSupport::get(instance, data, physical_device)?;
    if support.formats.is_empty() || support.present_modes.is_empty() {
        return Err(anyhow!(SuitabilityError(&quot;Insufficient swapchain support.&quot;)));
    }

    Ok(())
}
</code></pre>
<p>It is important that we only try to query for swapchain support after verifying that the extension is available.</p>
<h2 id="choosing-the-right-settings-for-the-swapchain"><a class="header" href="#choosing-the-right-settings-for-the-swapchain">Choosing the right settings for the swapchain</a></h2>
<p>If the conditions we just added were met then the support is definitely sufficient, but there may still be many different modes of varying optimality. We'll now write a couple of functions to find the right settings for the best possible swapchain. There are three types of settings to determine:</p>
<ul>
<li>Surface format (color depth)</li>
<li>Presentation mode (conditions for &quot;swapping&quot; images to the screen)</li>
<li>Swap extent (resolution of images in swapchain)</li>
</ul>
<p>For each of these settings we'll have an ideal value in mind that we'll go with if it's available and otherwise we'll create some logic to find the next best thing.</p>
<h3 id="surface-format"><a class="header" href="#surface-format">Surface format</a></h3>
<p>The function for this setting starts out like this. We'll later pass the <code>formats</code> field of the <code>SwapchainSupport</code> struct as argument.</p>
<pre><code class="language-rust noplaypen">fn get_swapchain_surface_format(
    formats: &amp;[vk::SurfaceFormatKHR],
) -&gt; vk::SurfaceFormatKHR {
}
</code></pre>
<p>Each <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SurfaceFormatKHR.html"><code class="hljs">vk::SurfaceFormatKHR</code></a> entry contains a <code>format</code> and a <code>color_space</code> member. The <code>format</code> member specifies the color channels and types. For example, <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Format.html#associatedconstant.B8G8R8A8_SRGB"><code class="hljs">vk::Format::B8G8R8A8_SRGB</code></a> means that we store the B, G, R and alpha channels in that order with an 8 bit unsigned integer for a total of 32 bits per pixel. The <code>color_space</code> member indicates if the sRGB color space is supported or not using the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ColorSpaceKHR.html#associatedconstant.SRGB_NONLINEAR"><code class="hljs">vk::ColorSpaceKHR::SRGB_NONLINEAR</code></a> flag.</p>
<p>For the color space we'll use sRGB if it is available, because it <a href="http://stackoverflow.com/questions/12524623/">results in more accurate perceived colors</a>. It is also pretty much the standard color space for images, like the textures we'll use later on. Because of that we should also use an sRGB color format, of which one of the most common ones is <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Format.html#associatedconstant.B8G8R8A8_SRGB"><code class="hljs">vk::Format::B8G8R8A8_SRGB</code></a>.</p>
<p>Let's go through the list and see if the preferred combination is available:</p>
<pre><code class="language-rust noplaypen">fn get_swapchain_surface_format(
    formats: &amp;[vk::SurfaceFormatKHR],
) -&gt; vk::SurfaceFormatKHR {
    formats
        .iter()
        .cloned()
        .find(|f| {
            f.format == vk::Format::B8G8R8A8_SRGB
                &amp;&amp; f.color_space == vk::ColorSpaceKHR::SRGB_NONLINEAR
        })
        .unwrap_or_else(|| formats[0])
}
</code></pre>
<p>If that also fails then we could rank the available formats based on how &quot;good&quot; they are, but in most cases it's okay to just settle with the first format that is specified hence <code>.unwrap_or_else(|| formats[0])</code>.</p>
<h3 id="presentation-mode"><a class="header" href="#presentation-mode">Presentation mode</a></h3>
<p>The presentation mode is arguably the most important setting for the swapchain, because it represents the actual conditions for showing images to the screen. There are four possible modes available in Vulkan:</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PresentModeKHR.html#associatedconstant.IMMEDIATE"><code class="hljs">vk::PresentModeKHR::IMMEDIATE</code></a> – Images submitted by your application are transferred to the screen right away, which may result in tearing.</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PresentModeKHR.html#associatedconstant.FIFO"><code class="hljs">vk::PresentModeKHR::FIFO</code></a> – The swapchain is a queue where the display takes an image from the front of the queue when the display is refreshed and the program inserts rendered images at the back of the queue. If the queue is full then the program has to wait. This is most similar to vertical sync as found in modern games. The moment that the display is refreshed is known as &quot;vertical blank&quot;.</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PresentModeKHR.html#associatedconstant.FIFO_RELAXED"><code class="hljs">vk::PresentModeKHR::FIFO_RELAXED</code></a> – This mode only differs from the previous one if the application is late and the queue was empty at the last vertical blank. Instead of waiting for the next vertical blank, the image is transferred right away when it finally arrives. This may result in visible tearing.</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PresentModeKHR.html#associatedconstant.MAILBOX"><code class="hljs">vk::PresentModeKHR::MAILBOX</code></a> – This is another variation of the second mode. Instead of blocking the application when the queue is full, the images that are already queued are simply replaced with the newer ones. This mode can be used to render frames as fast as possible while still avoiding tearing, resulting in fewer latency issues than standard vertical sync. This is commonly known as &quot;triple buffering&quot;, although the existence of three buffers alone does not necessarily mean that the framerate is unlocked.</li>
</ul>
<p>Only the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PresentModeKHR.html#associatedconstant.FIFO"><code class="hljs">vk::PresentModeKHR::FIFO</code></a> mode is guaranteed to be available, so we'll again have to write a function that looks for the best mode that is available:</p>
<pre><code class="language-rust noplaypen">fn get_swapchain_present_mode(
    present_modes: &amp;[vk::PresentModeKHR],
) -&gt; vk::PresentModeKHR {
}
</code></pre>
<p>I personally think that <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PresentModeKHR.html#associatedconstant.MAILBOX"><code class="hljs">vk::PresentModeKHR::MAILBOX</code></a> is a very nice trade-off if energy usage is not a concern. It allows us to avoid tearing while still maintaining a fairly low latency by rendering new images that are as up-to-date as possible right until the vertical blank. On mobile devices, where energy usage is more important, you will probably want to use <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PresentModeKHR.html#associatedconstant.FIFO"><code class="hljs">vk::PresentModeKHR::FIFO</code></a> instead. Now, let's look through the list to see if <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PresentModeKHR.html#associatedconstant.MAILBOX"><code class="hljs">vk::PresentModeKHR::MAILBOX</code></a> is available:</p>
<pre><code class="language-rust noplaypen">fn get_swapchain_present_mode(
    present_modes: &amp;[vk::PresentModeKHR],
) -&gt; vk::PresentModeKHR {
    present_modes
        .iter()
        .cloned()
        .find(|m| *m == vk::PresentModeKHR::MAILBOX)
        .unwrap_or(vk::PresentModeKHR::FIFO)
}
</code></pre>
<h3 id="swap-extent"><a class="header" href="#swap-extent">Swap extent</a></h3>
<p>That leaves only one major property, for which we'll add one last function:</p>
<pre><code class="language-rust noplaypen">fn get_swapchain_extent(
    window: &amp;Window,
    capabilities: vk::SurfaceCapabilitiesKHR,
) -&gt; vk::Extent2D {
}
</code></pre>
<p>The swap extent is the resolution of the swapchain images and it's almost always exactly equal to the resolution of the window that we're drawing to. The range of the possible resolutions is defined in the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SurfaceCapabilitiesKHR.html"><code class="hljs">vk::SurfaceCapabilitiesKHR</code></a> structure. Vulkan tells us to match the resolution of the window by setting the width and height in the <code>current_extent</code> member. However, some window managers do allow us to differ here and this is indicated by setting the width and height in <code>current_extent</code> to a special value: the maximum value of <code>u32</code>. In that case we'll pick the resolution that best matches the window within the <code>min_image_extent</code> and <code>max_image_extent</code> bounds.</p>
<pre><code class="language-rust noplaypen">fn get_swapchain_extent(
    window: &amp;Window,
    capabilities: vk::SurfaceCapabilitiesKHR,
) -&gt; vk::Extent2D {
    if capabilities.current_extent.width != u32::MAX {
        capabilities.current_extent
    } else {
        vk::Extent2D::builder()
            .width(window.inner_size().width.clamp(
                capabilities.min_image_extent.width,
                capabilities.max_image_extent.width,
            ))
            .height(window.inner_size().height.clamp(
                capabilities.min_image_extent.height,
                capabilities.max_image_extent.height,
            ))
            .build()
    }
}
</code></pre>
<p>We use the <a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html#method.clamp"><code>clamp</code> function</a> to restrict the actual size of the window within the supported range supported by the Vulkan device.</p>
<h2 id="creating-the-swapchain"><a class="header" href="#creating-the-swapchain">Creating the swapchain</a></h2>
<p>Now that we have all of these helper functions assisting us with the choices we have to make at runtime, we finally have all the information that is needed to create a working swapchain.</p>
<p>Create a <code>create_swapchain</code> function that starts out with the results of these calls and make sure to call it from <code>App::create</code> after logical device creation.</p>
<pre><code class="language-rust noplaypen">impl App {
    unsafe fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        // ...
        let device = create_logical_device(&amp;instance, &amp;mut data)?;
        create_swapchain(window, &amp;instance, &amp;device, &amp;mut data)?;
        // ...
    }
}

unsafe fn create_swapchain(
    window: &amp;Window,
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;mut AppData,
) -&gt; Result&lt;()&gt; {
    let indices = QueueFamilyIndices::get(instance, data, data.physical_device)?;
    let support = SwapchainSupport::get(instance, data, data.physical_device)?;

    let surface_format = get_swapchain_surface_format(&amp;support.formats);
    let present_mode = get_swapchain_present_mode(&amp;support.present_modes);
    let extent = get_swapchain_extent(window, support.capabilities);

    Ok(())
}
</code></pre>
<p>Aside from these properties we also have to decide how many images we would like to have in the swapchain. The implementation specifies the minimum number that it requires to function:</p>
<pre><code class="language-rust noplaypen">let image_count = support.capabilities.min_image_count;
</code></pre>
<p>However, simply sticking to this minimum means that we may sometimes have to wait on the driver to complete internal operations before we can acquire another image to render to. Therefore it is recommended to request at least one more image than the minimum:</p>
<pre><code class="language-rust noplaypen">let image_count = support.capabilities.min_image_count + 1;
</code></pre>
<p>We should also make sure to not exceed the maximum number of images while doing this, where <code>0</code> is a special value that means that there is no maximum:</p>
<pre><code class="language-rust noplaypen">let mut image_count = support.capabilities.min_image_count + 1;
if support.capabilities.max_image_count != 0
    &amp;&amp; image_count &gt; support.capabilities.max_image_count
{
    image_count = support.capabilities.max_image_count;
}
</code></pre>
<p>Next, we need to specify how to handle swapchain images that will be used across multiple queue families. That will be the case in our application if the graphics queue family is different from the presentation queue. We'll be drawing on the images in the swapchain from the graphics queue and then submitting them on the presentation queue. There are two ways to handle images that are accessed from multiple queues:</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SharingMode.html#associatedconstant.EXCLUSIVE"><code class="hljs">vk::SharingMode::EXCLUSIVE</code></a> – An image is owned by one queue family at a time and ownership must be explicitly transferred before using it in another queue family. This option offers the best performance.</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SharingMode.html#associatedconstant.CONCURRENT"><code class="hljs">vk::SharingMode::CONCURRENT</code></a> – Images can be used across multiple queue families without explicit ownership transfers.</li>
</ul>
<p>If the queue families differ, then we'll be using the concurrent mode in this tutorial to avoid having to do the ownership chapters, because these involve some concepts that are better explained at a later time. Concurrent mode requires you to specify in advance between which queue families ownership will be shared using the <code>queue_family_indices</code> builder method. If the graphics queue family and presentation queue family are the same, which will be the case on most hardware, then we should stick to exclusive mode, because concurrent mode requires you to specify at least two distinct queue families.</p>
<pre><code class="language-rust noplaypen">let mut queue_family_indices = vec![];
let image_sharing_mode = if indices.graphics != indices.present {
    queue_family_indices.push(indices.graphics);
    queue_family_indices.push(indices.present);
    vk::SharingMode::CONCURRENT
} else {
    vk::SharingMode::EXCLUSIVE
};
</code></pre>
<p>As is tradition with Vulkan objects, creating the swapchain object requires filling in a large structure. It starts out very familiarly:</p>
<pre><code class="language-rust noplaypen">let info = vk::SwapchainCreateInfoKHR::builder()
    .surface(data.surface)
    // continued...
</code></pre>
<p>After specifying which surface the swapchain should be tied to, the details of the swapchain images are specified:</p>
<pre><code class="language-rust noplaypen">    .min_image_count(image_count)
    .image_format(surface_format.format)
    .image_color_space(surface_format.color_space)
    .image_extent(extent)
    .image_array_layers(1)
    .image_usage(vk::ImageUsageFlags::COLOR_ATTACHMENT)
</code></pre>
<p>The <code>image_array_layers</code> specifies the amount of layers each image consists of. This is always <code>1</code> unless you are developing a stereoscopic 3D application. The <code>image_usage</code> bitmask specifies what kind of operations we'll use the images in the swapchain for. In this tutorial we're going to render directly to them, which means that they're used as color attachment. It is also possible that you'll render images to a separate image first to perform operations like post-processing. In that case you may use a value like <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageUsageFlags.html#associatedconstant.TRANSFER_DST"><code class="hljs">vk::ImageUsageFlags::TRANSFER_DST</code></a> instead and use a memory operation to transfer the rendered image to a swapchain image.</p>
<pre><code class="language-rust noplaypen">    .image_sharing_mode(image_sharing_mode)
    .queue_family_indices(&amp;queue_family_indices)
</code></pre>
<p>Next we'll provide the image sharing mode and indices of the queue families permitted to share the swapchain images.</p>
<pre><code class="language-rust noplaypen">    .pre_transform(support.capabilities.current_transform)
</code></pre>
<p>We can specify that a certain transform should be applied to images in the swapchain if it is supported (<code>supported_transforms</code> in <code>capabilities</code>), like a 90 degree clockwise rotation or horizontal flip. To specify that you do not want any transformation, simply specify the current transformation.</p>
<pre><code class="language-rust noplaypen">    .composite_alpha(vk::CompositeAlphaFlagsKHR::OPAQUE)
</code></pre>
<p>The <code>composite_alpha</code> method specifies if the alpha channel should be used for blending with other windows in the window system. You'll almost always want to simply ignore the alpha channel, hence <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.CompositeAlphaFlagsKHR.html#associatedconstant.OPAQUE"><code class="hljs">vk::CompositeAlphaFlagsKHR::OPAQUE</code></a>.</p>
<pre><code class="language-rust noplaypen">    .present_mode(present_mode)
    .clipped(true)
</code></pre>
<p>The <code>present_mode</code> member speaks for itself. If the <code>clipped</code> member is set to <code>true</code> then that means that we don't care about the color of pixels that are obscured, for example because another window is in front of them. Unless you really need to be able to read these pixels back and get predictable results, you'll get the best performance by enabling clipping.</p>
<pre><code class="language-rust noplaypen">    .old_swapchain(vk::SwapchainKHR::null());
</code></pre>
<p>That leaves one last method, <code>old_swapchain</code>. With Vulkan it's possible that your swapchain becomes invalid or unoptimized while your application is running, for example because the window was resized. In that case the swapchain actually needs to be recreated from scratch and a reference to the old one must be specified in this method. This is a complex topic that we'll learn more about in a future chapter. For now we'll assume that we'll only ever create one swapchain. We could omit this method since the underlying field will default to a null handle, but we'll leave it in for completeness.</p>
<p>Now add an <code>AppData</code> field to store the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SwapchainKHR.html"><code class="hljs">vk::SwapchainKHR</code></a> object:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    swapchain: vk::SwapchainKHR,
}
</code></pre>
<p>Creating the swapchain is now as simple as calling <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.KhrSwapchainExtension.html#method.create_swapchain_khr"><code class="hljs">create_swapchain_khr</code></a>:</p>
<pre><code class="language-rust noplaypen">data.swapchain = device.create_swapchain_khr(&amp;info, None)?;
</code></pre>
<p>The parameters are the swapchain creation info and optional custom allocators. No surprises there. It should be cleaned up in <code>App::destroy</code> before the device:</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy(&amp;mut self) {
    self.device.destroy_swapchain_khr(self.data.swapchain, None);
    // ...
}
</code></pre>
<p>Now run the application to ensure that the swapchain is created successfully! If at this point you get an access violation error in <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/vkCreateSwapchainKHR.html"><code class="hljs">vkCreateSwapchainKHR</code></a> or see a message like <code>Failed to find 'vkGetInstanceProcAddress' in layer SteamOverlayVulkanLayer.dll</code>, then see the <a href="presentation/../faq.html">FAQ entry</a> about the Steam overlay layer.</p>
<p>Try removing the <code>.image_extent(extent)</code> line from where you are building the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SwapchainCreateInfoKHR.html"><code class="hljs">vk::SwapchainCreateInfoKHR</code></a> struct with validation layers enabled. You'll see that one of the validation layers immediately catches the mistake and some helpful messages are printed which call out the illegal value provided for <code>image_extent</code>:</p>
<p><img src="presentation/../images/swapchain_validation_layer.png" alt="" /></p>
<h2 id="retrieving-the-swapchain-images"><a class="header" href="#retrieving-the-swapchain-images">Retrieving the swapchain images</a></h2>
<p>The swapchain has been created now, so all that remains is retrieving the handles of the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Image.html"><code class="hljs">vk::Image</code></a>s in it. We'll reference these during rendering operations in later chapters. Add an <code>AppData</code> field to store the handles:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    swapchain_images: Vec&lt;vk::Image&gt;,
}
</code></pre>
<p>The images were created by the implementation for the swapchain and they will be automatically cleaned up once the swapchain has been destroyed, therefore we don't need to add any cleanup code.</p>
<p>I'm adding the code to retrieve the handles to the end of the <code>create_swapchain</code> function, right after the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.KhrSwapchainExtension.html#method.create_swapchain_khr"><code class="hljs">create_swapchain_khr</code></a> call.</p>
<pre><code class="language-rust noplaypen">data.swapchain_images = device.get_swapchain_images_khr(data.swapchain)?;
</code></pre>
<p>One last thing, store the format and extent we've chosen for the swapchain images in <code>AppData</code> fields. We'll need them in future chapters.</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    swapchain_format: vk::Format,
    swapchain_extent: vk::Extent2D,
    swapchain: vk::SwapchainKHR,
    swapchain_images: Vec&lt;vk::Image&gt;,
}
</code></pre>
<p>And then in <code>create_swapchain</code>:</p>
<pre><code class="language-rust noplaypen">data.swapchain_format = surface_format.format;
data.swapchain_extent = extent;
</code></pre>
<p>We now have a set of images that can be drawn onto and can be presented to the window. The next chapter will begin to cover how we can set up the images as render targets and then we start looking into the actual graphics pipeline and drawing commands!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="image-views"><a class="header" href="#image-views">Image views</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/07_image_views.rs">main.rs</a></p>
<p>To use any <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Image.html"><code class="hljs">vk::Image</code></a>, including those in the swapchain, in the render pipeline we have to create a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageView.html"><code class="hljs">vk::ImageView</code></a> object. An image view is quite literally a view into an image. It describes how to access the image and which part of the image to access, for example if it should be treated as a 2D texture depth texture without any mipmapping levels.</p>
<p>In this chapter we'll write a <code>create_swapchain_image_views</code> function that creates a basic image view for every image in the swapchain so that we can use them as color targets later on.</p>
<p>First add an <code>AppData</code> field to store the image views in:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    swapchain_image_views: Vec&lt;vk::ImageView&gt;,
}

</code></pre>
<p>Create the <code>create_swapchain_image_views</code> function and call it right after swapchain creation in <code>App::create</code>.</p>
<pre><code class="language-rust noplaypen">impl App {
    unsafe fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        // ...
        create_swapchain(window, &amp;instance, &amp;device, &amp;mut data)?;
        create_swapchain_image_views(&amp;device, &amp;mut data)?;
        // ...
    }
}

unsafe fn create_swapchain_image_views(
    device: &amp;Device,
    data: &amp;mut AppData,
) -&gt; Result&lt;()&gt; {
    Ok(())
}
</code></pre>
<p>What we next need to do is iterate over the swapchain images to create an image view for each:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_swapchain_image_views(
    device: &amp;Device,
    data: &amp;mut AppData,
) -&gt; Result&lt;()&gt; {
    data.swapchain_image_views = data
        .swapchain_images
        .iter()
        .map(|i| {

        })
        .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?;

    Ok(())
}
</code></pre>
<p>For each image view we are creating we'll first need to define the color component mapping for the image view. This allows you to swizzle the color channels around. For example, you can map all of the channels to the red channel for a monochrome texture. You can also map constant values of <code>0</code> and <code>1</code> to a channel. In our case we'll stick to the default mapping.</p>
<pre><code class="language-rust noplaypen">let components = vk::ComponentMapping::builder()
    .r(vk::ComponentSwizzle::IDENTITY)
    .g(vk::ComponentSwizzle::IDENTITY)
    .b(vk::ComponentSwizzle::IDENTITY)
    .a(vk::ComponentSwizzle::IDENTITY);
</code></pre>
<p>Next we will define the subresource range for the image view which describes the image's purpose and which part of the image should be accessed. Our images will be used as color targets without any mipmapping levels or multiple layers.</p>
<pre><code class="language-rust noplaypen">let subresource_range = vk::ImageSubresourceRange::builder()
    .aspect_mask(vk::ImageAspectFlags::COLOR)
    .base_mip_level(0)
    .level_count(1)
    .base_array_layer(0)
    .layer_count(1);
</code></pre>
<p>If you were working on a stereographic 3D application, then you would create a swapchain with multiple layers. You could then create multiple image views for each image representing the views for the left and right eyes by accessing different layers.</p>
<p>We can now create a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageViewCreateInfo.html"><code class="hljs">vk::ImageViewCreateInfo</code></a> struct which provides the parameters for image view creation.</p>
<pre><code class="language-rust noplaypen">let info = vk::ImageViewCreateInfo::builder()
    .image(*i)
    .view_type(vk::ImageViewType::_2D)
    .format(data.swapchain_format)
    .components(components)
    .subresource_range(subresource_range);
</code></pre>
<p>The <code>view_type</code> and <code>format</code> fields specify how the image data should be interpreted. The <code>view_type</code> field allows you to treat images as 1D textures, 2D textures, 3D textures, and cube maps.</p>
<p>Creating the image view is now a matter of calling <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.create_image_view"><code class="hljs">create_image_view</code></a>:</p>
<pre><code class="language-rust noplaypen">device.create_image_view(&amp;info, None)
</code></pre>
<p>Unlike images, the image views were explicitly created by us, so we need to add a similar loop to destroy them again in <code>App::destroy</code>:</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy(&amp;mut self) {
    self.data.swapchain_image_views
        .iter()
        .for_each(|v| self.device.destroy_image_view(*v, None));
    // ...
}
</code></pre>
<p>An image view is sufficient to start using an image as a texture, but it's not quite ready to be used as a render target just yet. That requires one more step of indirection, known as a framebuffer. But first we'll have to set up the graphics pipeline.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/08_graphics_pipeline.rs">main.rs</a></p>
<p>Over the course of the next few chapters we'll be setting up a graphics pipeline that is configured to draw our first triangle. The graphics pipeline is the sequence of operations that take the vertices and textures of your meshes all the way to the pixels in the render targets. A simplified overview is displayed below:</p>
<p><img src="pipeline/../images/vulkan_simplified_pipeline.svg" alt="" /></p>
<p>The <em>input assembler</em> collects the raw vertex data from the buffers you specify and may also use an index buffer to repeat certain elements without having to duplicate the vertex data itself.</p>
<p>The <em>vertex shader</em> is run for every vertex and generally applies transformations to turn vertex positions from model space to screen space. It also passes per-vertex data down the pipeline.</p>
<p>The <em>tessellation shaders</em> allow you to subdivide geometry based on certain rules to increase the mesh quality. This is often used to make surfaces like brick walls and staircases look less flat when they are nearby.</p>
<p>The <em>geometry shader</em> is run on every primitive (triangle, line, point) and can discard it or output more primitives than came in. This is similar to the tessellation shader, but much more flexible. However, it is not used much in today's applications because the performance is not that good on most graphics cards except for Intel's integrated GPUs.</p>
<p>The <em>rasterization</em> stage discretizes the primitives into <em>fragments</em>. These are the pixel elements that they fill on the framebuffer. Any fragments that fall outside the screen are discarded and the attributes outputted by the vertex shader are interpolated across the fragments, as shown in the figure. Usually the fragments that are behind other primitive fragments are also discarded here because of depth testing.</p>
<p>The <em>fragment shader</em> is invoked for every fragment that survives and determines which framebuffer(s) the fragments are written to and with which color and depth values. It can do this using the interpolated data from the vertex shader, which can include things like texture coordinates and normals for lighting.</p>
<p>The <em>color blending</em> stage applies operations to mix different fragments that map to the same pixel in the framebuffer. Fragments can simply overwrite each other, add up or be mixed based upon transparency.</p>
<p>Stages with a green color are known as <em>fixed-function</em> stages. These stages allow you to tweak their operations using parameters, but the way they work is predefined.</p>
<p>Stages with an orange color on the other hand are <em>programmable</em>, which means that you can upload your own code to the graphics card to apply exactly the operations you want. This allows you to use fragment shaders, for example, to implement anything from texturing and lighting to ray tracers. These programs run on many GPU cores simultaneously to process many objects, like vertices and fragments in parallel.</p>
<p>If you've used older APIs like OpenGL and Direct3D before, then you'll be used to being able to change any pipeline settings at will with calls like <code>glBlendFunc</code> and <code>OMSetBlendState</code>. The graphics pipeline in Vulkan is almost completely immutable, so you must recreate the pipeline from scratch if you want to change shaders, bind different framebuffers or change the blend function. The disadvantage is that you'll have to create a number of pipelines that represent all of the different combinations of states you want to use in your rendering operations. However, because all of the operations you'll be doing in the pipeline are known in advance, the driver can optimize for it much better.</p>
<p>Some of the programmable stages are optional based on what you intend to do. For example, the tessellation and geometry stages can be disabled if you are just drawing simple geometry. If you are only interested in depth values then you can disable the fragment shader stage, which is useful for <a href="https://en.wikipedia.org/wiki/Shadow_mapping">shadow map</a> generation.</p>
<p>In the next chapter we'll first create the two programmable stages required to put a triangle onto the screen: the vertex shader and fragment shader. The fixed-function configuration like blending mode, viewport, rasterization will be set up in the chapter after that. The final part of setting up the graphics pipeline in Vulkan involves the specification of input and output framebuffers.</p>
<p>Create a <code>create_pipeline</code> function that is called right after <code>create_swapchain_image_views</code> in <code>App::create</code>. We'll work on this function throughout the following chapters.</p>
<pre><code class="language-rust noplaypen">impl App {
    unsafe fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        // ...
        create_swapchain_image_views(&amp;device, &amp;mut data)?;
        create_pipeline(&amp;device, &amp;mut data)?;
        // ...
    }
}

unsafe fn create_pipeline(device: &amp;Device, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    Ok(())
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shader-modules"><a class="header" href="#shader-modules">Shader modules</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/09_shader_modules.rs">main.rs</a> | <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/shaders/09/shader.vert">shader.vert</a> | <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/shaders/09/shader.frag">shader.frag</a></p>
<p>Unlike earlier APIs, shader code in Vulkan has to be specified in a bytecode format as opposed to human-readable syntax like <a href="https://en.wikipedia.org/wiki/OpenGL_Shading_Language">GLSL</a> and <a href="https://en.wikipedia.org/wiki/High-Level_Shading_Language">HLSL</a>. This bytecode format is called <a href="https://www.khronos.org/spir">SPIR-V</a> and is designed to be used with both Vulkan and OpenCL (both Khronos APIs). It is a format that can be used to write graphics and compute shaders, but we will focus on shaders used in Vulkan's graphics pipelines in this tutorial.</p>
<p>The advantage of using a bytecode format is that the compilers written by GPU vendors to turn shader code into native code are significantly less complex. The past has shown that with human-readable syntax like GLSL, some GPU vendors were rather flexible with their interpretation of the standard. If you happen to write non-trivial shaders with a GPU from one of these vendors, then you'd risk other vendor's drivers rejecting your code due to syntax errors, or worse, your shader running differently because of compiler bugs. With a straightforward bytecode format like SPIR-V that will hopefully be avoided.</p>
<p>However, that does not mean that we need to write this bytecode by hand. Khronos has released their own vendor-independent compiler that compiles GLSL to SPIR-V. This compiler is designed to verify that your shader code is fully standards compliant and produces one SPIR-V binary that you can ship with your program. You can also include this compiler as a library to produce SPIR-V at runtime, but we won't be doing that in this tutorial. Although we can use this compiler directly via <code>glslangValidator.exe</code>, we will be using <code>glslc.exe</code> by Google instead. The advantage of <code>glslc</code> is that it uses the same parameter format as well-known compilers like GCC and Clang and includes some extra functionality like <em>includes</em>. Both of them are already included in the Vulkan SDK, so you don't need to download anything extra.</p>
<p>GLSL is a shading language with a C-style syntax. Programs written in it have a <code>main</code> function that is invoked for every object. Instead of using parameters for input and a return value as output, GLSL uses global variables to handle input and output. The language includes many features to aid in graphics programming, like built-in vector and matrix primitives. Functions for operations like cross products, matrix-vector products and reflections around a vector are included. The vector type is called <code>vec</code> with a number indicating the amount of elements. For example, a 3D position would be stored in a <code>vec3</code>. It is possible to access single components through fields like <code>.x</code>, but it's also possible to create a new vector from multiple components at the same time. For example, the expression <code>vec3(1.0, 2.0, 3.0).xy</code> would result in <code>vec2</code>. The constructors of vectors can also take combinations of vector objects and scalar values. For example, a <code>vec3</code> can be constructed with <code>vec3(vec2(1.0, 2.0), 3.0)</code>.</p>
<p>As the previous chapter mentioned, we need to write a vertex shader and a fragment shader to get a triangle on the screen. The next two sections will cover the GLSL code of each of those and after that I'll show you how to produce two SPIR-V binaries and load them into the program.</p>
<h2 id="vertex-shader"><a class="header" href="#vertex-shader">Vertex shader</a></h2>
<p>The vertex shader processes each incoming vertex. It takes its attributes, like world position, color, normal and texture coordinates as input. The output is the final position in clip coordinates and the attributes that need to be passed on to the fragment shader, like color and texture coordinates. These values will then be interpolated over the fragments by the rasterizer to produce a smooth gradient.</p>
<p>A <em>clip coordinate</em> is a four dimensional vector from the vertex shader that is subsequently turned into a <em>normalized device coordinate</em> by dividing the whole vector by its last component. These normalized device coordinates are <a href="https://en.wikipedia.org/wiki/Homogeneous_coordinates">homogeneous coordinates</a> that map the framebuffer to a [-1, 1] by [-1, 1] coordinate system that looks like the following:</p>
<p><img src="pipeline/../images/normalized_device_coordinates.svg" alt="" /></p>
<p>You should already be familiar with these if you have dabbled in computer graphics before. If you have used OpenGL before, then you'll notice that the sign of the Y coordinates is now flipped. The Z coordinate now uses the same range as it does in Direct3D, from 0 to 1.</p>
<p>For our first triangle we won't be applying any transformations, we'll just specify the positions of the three vertices directly as normalized device coordinates to create the following shape:</p>
<p><img src="pipeline/../images/triangle_coordinates.svg" alt="" /></p>
<p>We can directly output normalized device coordinates by outputting them as clip coordinates from the vertex shader with the last component set to <code>1</code>. That way the division to transform clip coordinates to normalized device coordinates will not change anything.</p>
<p>Normally these coordinates would be stored in a vertex buffer, but creating a vertex buffer in Vulkan and filling it with data is not trivial. Therefore I've decided to postpone that until after we've had the satisfaction of seeing a triangle pop up on the screen. We're going to do something a little unorthodox in the meanwhile: include the coordinates directly inside the vertex shader. The code looks like this:</p>
<pre><code class="language-glsl">#version 450

vec2 positions[3] = vec2[](
    vec2(0.0, -0.5),
    vec2(0.5, 0.5),
    vec2(-0.5, 0.5)
);

void main() {
    gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0);
}
</code></pre>
<p>The <code>main</code> function is invoked for every vertex. The built-in <code>gl_VertexIndex</code> variable contains the index of the current vertex. This is usually an index into the vertex buffer, but in our case it will be an index into a hardcoded array of vertex data. The position of each vertex is accessed from the constant array in the shader and combined with dummy <code>z</code> and <code>w</code> components to produce a position in clip coordinates. The built-in variable <code>gl_Position</code> functions as the output.</p>
<h2 id="fragment-shader"><a class="header" href="#fragment-shader">Fragment shader</a></h2>
<p>The triangle that is formed by the positions from the vertex shader fills an area on the screen with fragments. The fragment shader is invoked on these fragments to produce a color and depth for the framebuffer (or framebuffers). A simple fragment shader that outputs the color red for the entire triangle looks like this:</p>
<pre><code class="language-glsl">#version 450

layout(location = 0) out vec4 outColor;

void main() {
    outColor = vec4(1.0, 0.0, 0.0, 1.0);
}
</code></pre>
<p>The <code>main</code> function is called for every fragment just like the vertex shader <code>main</code> function is called for every vertex. Colors in GLSL are 4-component vectors with the R, G, B and alpha channels within the [0, 1] range. Unlike <code>gl_Position</code> in the vertex shader, there is no built-in variable to output a color for the current fragment. You have to specify your own output variable for each framebuffer where the <code>layout(location = 0)</code> modifier specifies the index of the framebuffer. The color red is written to this <code>outColor</code> variable that is linked to the first (and only) framebuffer at index <code>0</code>.</p>
<h2 id="per-vertex-colors"><a class="header" href="#per-vertex-colors">Per-vertex colors</a></h2>
<p>Making the entire triangle red is not very interesting, wouldn't something like the following look a lot nicer?</p>
<p><img src="pipeline/../images/triangle_coordinates_colors.png" alt="" /></p>
<p>We have to make a couple of changes to both shaders to accomplish this. First off, we need to specify a distinct color for each of the three vertices. The vertex shader should now include an array with colors just like it does for positions:</p>
<pre><code class="language-glsl">vec3 colors[3] = vec3[](
    vec3(1.0, 0.0, 0.0),
    vec3(0.0, 1.0, 0.0),
    vec3(0.0, 0.0, 1.0)
);
</code></pre>
<p>Now we just need to pass these per-vertex colors to the fragment shader so it can output their interpolated values to the framebuffer. Add an output for color to the vertex shader and write to it in the <code>main</code> function:</p>
<pre><code class="language-glsl">layout(location = 0) out vec3 fragColor;

void main() {
    gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0);
    fragColor = colors[gl_VertexIndex];
}
</code></pre>
<p>Next, we need to add a matching input in the fragment shader:</p>
<pre><code class="language-glsl">layout(location = 0) in vec3 fragColor;

void main() {
    outColor = vec4(fragColor, 1.0);
}
</code></pre>
<p>The input variable does not necessarily have to use the same name, they will be linked together using the indexes specified by the <code>location</code> directives. The <code>main</code> function has been modified to output the color along with an alpha value. As shown in the image above, the values for <code>fragColor</code> will be automatically interpolated for the fragments between the three vertices, resulting in a smooth gradient.</p>
<h2 id="compiling-the-shaders"><a class="header" href="#compiling-the-shaders">Compiling the shaders</a></h2>
<p>Create a directory called <code>shaders</code> in the root directory of your project (adjacent to the <code>src</code> directory) and store the vertex shader in a file called <code>shader.vert</code> and the fragment shader in a file called <code>shader.frag</code> in that directory. GLSL shaders don't have an official extension, but these two are commonly used to distinguish them.</p>
<p>The contents of <code>shader.vert</code> should be:</p>
<pre><code class="language-glsl">#version 450

layout(location = 0) out vec3 fragColor;

vec2 positions[3] = vec2[](
    vec2(0.0, -0.5),
    vec2(0.5, 0.5),
    vec2(-0.5, 0.5)
);

vec3 colors[3] = vec3[](
    vec3(1.0, 0.0, 0.0),
    vec3(0.0, 1.0, 0.0),
    vec3(0.0, 0.0, 1.0)
);

void main() {
    gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0);
    fragColor = colors[gl_VertexIndex];
}
</code></pre>
<p>And the contents of <code>shader.frag</code> should be:</p>
<pre><code class="language-glsl">#version 450

layout(location = 0) in vec3 fragColor;

layout(location = 0) out vec4 outColor;

void main() {
    outColor = vec4(fragColor, 1.0);
}
</code></pre>
<p>We're now going to compile these into SPIR-V bytecode using the <code>glslc</code> program.</p>
<p><strong>Windows</strong></p>
<p>Create a <code>compile.bat</code> file with the following contents:</p>
<pre><code class="language-bash">C:/VulkanSDK/x.x.x.x/Bin32/glslc.exe shader.vert -o vert.spv
C:/VulkanSDK/x.x.x.x/Bin32/glslc.exe shader.frag -o frag.spv
pause
</code></pre>
<p>Replace the path to <code>glslc.exe</code> with the path to where you installed the Vulkan SDK. Double click the file to run it.</p>
<p><strong>Linux</strong></p>
<p>Create a <code>compile.sh</code> file with the following contents:</p>
<pre><code class="language-bash">/home/user/VulkanSDK/x.x.x.x/x86_64/bin/glslc shader.vert -o vert.spv
/home/user/VulkanSDK/x.x.x.x/x86_64/bin/glslc shader.frag -o frag.spv
</code></pre>
<p>Replace the path to <code>glslc</code> with the path to where you installed the Vulkan SDK. Make the script executable with <code>chmod +x compile.sh</code> and run it.</p>
<p><strong>macOS</strong></p>
<p>Create a <code>compile.sh</code> file with the following contents:</p>
<pre><code class="language-bash">/Users/user/VulkanSDK/x.x.x.x/macOS/bin/glslc shaders/shader.vert -o vert.spv
/Users/user/VulkanSDK/x.x.x.x/macOS/bin/glslc shaders/shader.frag -o frag.spv
</code></pre>
<p><strong>End of platform-specific instructions</strong></p>
<p>These two commands tell the compiler to read the GLSL source file and output a SPIR-V bytecode file using the <code>-o</code> (output) flag.</p>
<p>If your shader contains a syntax error then the compiler will tell you the line number and problem, as you would expect. Try leaving out a semicolon for example and run the compile script again. Also try running the compiler without any arguments to see what kinds of flags it supports. It can, for example, also output the bytecode into a human-readable format so you can see exactly what your shader is doing and any optimizations that have been applied at this stage.</p>
<p>Compiling shaders on the commandline is one of the most straightforward options and it's the one that we'll use in this tutorial, but it's also possible to compile shaders directly from your own code. The Vulkan SDK includes <a href="https://github.com/google/shaderc">libshaderc</a>, which is a library to compile GLSL code to SPIR-V from within your program.</p>
<h2 id="loading-a-shader"><a class="header" href="#loading-a-shader">Loading a shader</a></h2>
<p>Now that we have a way of producing SPIR-V shaders, it's time to bring them into our program to plug them into the graphics pipeline at some point. We'll start by using <a href="https://doc.rust-lang.org/stable/std/macro.include_bytes.html"><code>include_bytes!</code></a> from the Rust standard library to include the compiled SPIR-V bytecode for the shaders in our executable.</p>
<pre><code class="language-rust noplaypen">unsafe fn create_pipeline(device: &amp;Device, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    let vert = include_bytes!(&quot;../shaders/vert.spv&quot;);
    let frag = include_bytes!(&quot;../shaders/frag.spv&quot;);

    Ok(())
}
</code></pre>
<h2 id="creating-shader-modules"><a class="header" href="#creating-shader-modules">Creating shader modules</a></h2>
<p>Before we can pass the code to the pipeline, we have to wrap it in a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ShaderModule.html"><code class="hljs">vk::ShaderModule</code></a> object. Let's create a helper function <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.create_shader_module"><code class="hljs">create_shader_module</code></a> to do that.</p>
<pre><code class="language-rust noplaypen">unsafe fn create_shader_module(
    device: &amp;Device,
    bytecode: &amp;[u8],
) -&gt; Result&lt;vk::ShaderModule&gt; {
}
</code></pre>
<p>The function will take a slice containing the bytecode as parameter and create a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ShaderModule.html"><code class="hljs">vk::ShaderModule</code></a> from it using our logical device.</p>
<p>Creating a shader module is simple, we only need to specify the length of our bytecode slice and the bytecode slice itself. This information is specified in a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ShaderModuleCreateInfo.html"><code class="hljs">vk::ShaderModuleCreateInfo</code></a> structure. The one catch is that the size of the bytecode is specified in bytes, but the bytecode slice expected by this struct is a <code>&amp;[u32]</code> instead of a <code>&amp;[u8]</code>. Therefore we will first need to convert our <code>&amp;[u8]</code> into an <code>&amp;[u32]</code>.</p>
<p><code>vulkanalia</code> has a helper struct called <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/bytecode/struct.Bytecode.html"><code class="hljs">Bytecode</code></a> that we will use to copy the shader bytecode into a new buffer that is guaranteed to have the correct alignment for an array of <code>u32</code>s. Add an import for this helper struct:</p>
<pre><code class="language-rust noplaypen">use vulkanalia::bytecode::Bytecode;
</code></pre>
<p>Getting back to our <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.create_shader_module"><code class="hljs">create_shader_module</code></a> function, <code>Bytecode::new</code> will return an error if the supplied byte slice has a length that is not a multiple of 4 or if the allocation of the aligned buffer fails. As long as you are providing valid shader bytecode this should never be a problem, so we'll just <code>unwrap</code> the result.</p>
<pre><code class="language-rust noplaypen">let bytecode = Bytecode::new(bytecode).unwrap();
</code></pre>
<p>We can then construct a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ShaderModuleCreateInfo.html"><code class="hljs">vk::ShaderModuleCreateInfo</code></a> and use it to call <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.create_shader_module"><code class="hljs">create_shader_module</code></a> to create the shader module:</p>
<pre><code class="language-rust noplaypen">let info = vk::ShaderModuleCreateInfo::builder()
    .code(bytecode.code())
    .code_size(bytecode.code_size());

Ok(device.create_shader_module(&amp;info, None)?)
</code></pre>
<p>The parameters are the same as those in previous object creation functions: the create info structure and the optional custom allocators.</p>
<p>Shader modules are just a thin wrapper around the shader bytecode that we've previously loaded from a file and the functions defined in it. The compilation and linking of the SPIR-V bytecode to machine code for execution by the GPU doesn't happen until the graphics pipeline is created. That means that we're allowed to destroy the shader modules again as soon as pipeline creation is finished, which is why we'll make them local variables in the <code>create_pipeline</code> function instead of fields in <code>AppData</code>:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_pipeline(device: &amp;Device, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    let vert = include_bytes!(&quot;../shaders/vert.spv&quot;);
    let frag = include_bytes!(&quot;../shaders/frag.spv&quot;);

    let vert_shader_module = create_shader_module(device, &amp;vert[..])?;
    let frag_shader_module = create_shader_module(device, &amp;frag[..])?;

    // ...
</code></pre>
<p>The cleanup should then happen at the end of the function by adding two calls to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.destroy_shader_module"><code class="hljs">destroy_shader_module</code></a>. All of the remaining code in this chapter will be inserted before these lines.</p>
<pre><code class="language-rust noplaypen">    // ...

    device.destroy_shader_module(vert_shader_module, None);
    device.destroy_shader_module(frag_shader_module, None);

    Ok(())
}
</code></pre>
<h2 id="shader-stage-creation"><a class="header" href="#shader-stage-creation">Shader stage creation</a></h2>
<p>To actually use the shaders we'll need to assign them to a specific pipeline stage through <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PipelineShaderStageCreateInfo.html"><code class="hljs">vk::PipelineShaderStageCreateInfo</code></a> structures as part of the actual pipeline creation process.</p>
<p>We'll start by filling in the structure for the vertex shader, again in the <code>create_pipeline</code> function.</p>
<pre><code class="language-rust noplaypen">let vert_stage = vk::PipelineShaderStageCreateInfo::builder()
    .stage(vk::ShaderStageFlags::VERTEX)
    .module(vert_shader_module)
    .name(b&quot;main\0&quot;);
</code></pre>
<p>The first step is telling Vulkan in which pipeline stage the shader is going to be used. There is a variant for each of the programmable stages described in the previous chapter.</p>
<p>The next two fields specify the shader module containing the code, and the function to invoke, known as the <em>entrypoint</em>. That means that it's possible to combine multiple fragment shaders into a single shader module and use different entry points to differentiate between their behaviors. In this case we'll stick to the standard <code>main</code>, however.</p>
<p>There is one more (optional) member, <code>specialization_info</code>, which we won't be using here, but is worth discussing. It allows you to specify values for shader constants. You can use a single shader module where its behavior can be configured at pipeline creation by specifying different values for the constants used in it. This is more efficient than configuring the shader using variables at render time, because the compiler can do optimizations like eliminating <code>if</code> statements that depend on these values. If you don't have any constants like that, then you can just skip setting it as we are doing here.</p>
<p>Modifying the structure to suit the fragment shader is easy:</p>
<pre><code class="language-rust noplaypen">let frag_stage = vk::PipelineShaderStageCreateInfo::builder()
    .stage(vk::ShaderStageFlags::FRAGMENT)
    .module(frag_shader_module)
    .name(b&quot;main\0&quot;);
</code></pre>
<p>That's all there is to describing the programmable stages of the pipeline. In the next chapter we'll look at the fixed-function stages.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fixed-functions"><a class="header" href="#fixed-functions">Fixed functions</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/10_fixed_functions.rs">main.rs</a></p>
<p>The older graphics APIs provided default state for most of the stages of the graphics pipeline. In Vulkan you have to be explicit about everything, from viewport size to color blending function. In this chapter we'll fill in all of the structures to configure these fixed-function operations.</p>
<h2 id="vertex-input"><a class="header" href="#vertex-input">Vertex input</a></h2>
<p>The <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PipelineVertexInputStateCreateInfo.html"><code class="hljs">vk::PipelineVertexInputStateCreateInfo</code></a> structure describes the format of the vertex data that will be passed to the vertex shader. It describes this in roughly two ways:</p>
<ul>
<li>Bindings – spacing between data and whether the data is per-vertex or per-instance (see <a href="https://en.wikipedia.org/wiki/Geometry_instancing">instancing</a>)</li>
<li>Attribute descriptions – type of the attributes passed to the vertex shader, which binding to load them from and at which offset</li>
</ul>
<p>Because we're hard coding the vertex data directly in the vertex shader, we'll leave this structure with the defaults to specify that there is no vertex data to load for now. We'll get back to it in the vertex buffer chapter. Add this to the <code>create_pipeline</code> function right after the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PipelineShaderStageCreateInfo.html"><code class="hljs">vk::PipelineShaderStageCreateInfo</code></a> structs:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_pipeline(device: &amp;Device, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    // ...

    let vertex_input_state = vk::PipelineVertexInputStateCreateInfo::builder();
</code></pre>
<p>The <code>vertex_binding_descriptions</code> and <code>vertex_attribute_descriptions</code> fields for this struct that could have been set here would be slices of structs that describe the aforementioned details for loading vertex data.</p>
<h2 id="input-assembly"><a class="header" href="#input-assembly">Input assembly</a></h2>
<p>The <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PipelineInputAssemblyStateCreateInfo.html"><code class="hljs">vk::PipelineInputAssemblyStateCreateInfo</code></a> struct describes two things: what kind of geometry will be drawn from the vertices and if primitive restart should be enabled. The former is specified in the <code>topology</code> member and can have values like:</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PrimitiveTopology.html#associatedconstant.POINT_LIST"><code class="hljs">vk::PrimitiveTopology::POINT_LIST</code></a> – points from vertices</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PrimitiveTopology.html#associatedconstant.LINE_LIST"><code class="hljs">vk::PrimitiveTopology::LINE_LIST</code></a> – line from every 2 vertices without reuse</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PrimitiveTopology.html#associatedconstant.LINE_STRIP"><code class="hljs">vk::PrimitiveTopology::LINE_STRIP</code></a> – the end vertex of every line is used as start vertex for the next line</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PrimitiveTopology.html#associatedconstant.TRIANGLE_LIST"><code class="hljs">vk::PrimitiveTopology::TRIANGLE_LIST</code></a> – triangle from every 3 vertices without reuse</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PrimitiveTopology.html#associatedconstant.TRIANGLE_STRIP"><code class="hljs">vk::PrimitiveTopology::TRIANGLE_STRIP</code></a> – the second and third vertex of every triangle are used as first two vertices of the next triangle</li>
</ul>
<p>Normally, the vertices are loaded from the vertex buffer by index in sequential order, but with an <em>element buffer</em> you can specify the indices to use yourself. This allows you to perform optimizations like reusing vertices. If you set the <code>primitive_restart_enable</code> member to <code>true</code>, then it's possible to break up lines and triangles in the <code>_STRIP</code> topology modes by using a special index of <code>0xFFFF</code> or <code>0xFFFFFFFF</code>.</p>
<p>We intend to draw triangles throughout this tutorial, so we'll stick to the following data for the structure:</p>
<pre><code class="language-rust noplaypen">let input_assembly_state = vk::PipelineInputAssemblyStateCreateInfo::builder()
    .topology(vk::PrimitiveTopology::TRIANGLE_LIST)
    .primitive_restart_enable(false);
</code></pre>
<h2 id="viewports-and-scissors"><a class="header" href="#viewports-and-scissors">Viewports and scissors</a></h2>
<p>A viewport basically describes the region of the framebuffer that the output will be rendered to. This will almost always be <code>(0, 0)</code> to <code>(width, height)</code> and in this tutorial that will also be the case.</p>
<pre><code class="language-rust noplaypen">let viewport = vk::Viewport::builder()
    .x(0.0)
    .y(0.0)
    .width(data.swapchain_extent.width as f32)
    .height(data.swapchain_extent.height as f32)
    .min_depth(0.0)
    .max_depth(1.0);
</code></pre>
<p>Remember that the size of the swapchain and its images may differ from the <code>WIDTH</code> and <code>HEIGHT</code> of the window. The swapchain images will be used as framebuffers later on, so we should stick to their size.</p>
<p>The <code>min_depth</code> and <code>max_depth</code> values specify the range of depth values to use for the framebuffer. These values must be within the <code>[0.0, 1.0]</code> range, but <code>min_depth</code> may be higher than <code>max_depth</code>. If you aren't doing anything special, then you should stick to the standard values of <code>0.0</code> and <code>1.0</code>.</p>
<p>While viewports define the transformation from the image to the framebuffer, scissor rectangles define in which regions pixels will actually be stored. Any pixels outside the scissor rectangles will be discarded by the rasterizer. They function like a filter rather than a transformation. The difference is illustrated below. Note that the left scissor rectangle is just one of the many possibilities that would result in that image, as long as it's larger than the viewport.</p>
<p><img src="pipeline/../images/viewports_scissors.png" alt="" /></p>
<p>In this tutorial we simply want to draw to the entire framebuffer, so we'll specify a scissor rectangle that covers it entirely:</p>
<pre><code class="language-rust noplaypen">let scissor = vk::Rect2D::builder()
    .offset(vk::Offset2D { x: 0, y: 0 })
    .extent(data.swapchain_extent);
</code></pre>
<p>Now this viewport and scissor rectangle need to be combined into a viewport state using the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PipelineViewportStateCreateInfo.html"><code class="hljs">vk::PipelineViewportStateCreateInfo</code></a> struct. It is possible to use multiple viewports and scissor rectangles on some graphics cards, so its members reference an array of them. Using multiple requires enabling a GPU feature (see logical device creation).</p>
<pre><code class="language-rust noplaypen">let viewports = &amp;[viewport];
let scissors = &amp;[scissor];
let viewport_state = vk::PipelineViewportStateCreateInfo::builder()
    .viewports(viewports)
    .scissors(scissors);
</code></pre>
<h2 id="rasterizer"><a class="header" href="#rasterizer">Rasterizer</a></h2>
<p>The rasterizer takes the geometry that is shaped by the vertices from the vertex shader and turns it into fragments to be colored by the fragment shader. It also performs <a href="https://en.wikipedia.org/wiki/Z-buffering">depth testing</a>, <a href="https://en.wikipedia.org/wiki/Back-face_culling">face culling</a> and the scissor test, and it can be configured to output fragments that fill entire polygons or just the edges (wireframe rendering). All this is configured using the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PipelineRasterizationStateCreateInfo.html"><code class="hljs">vk::PipelineRasterizationStateCreateInfo</code></a> structure.</p>
<pre><code class="language-rust noplaypen">let rasterization_state = vk::PipelineRasterizationStateCreateInfo::builder()
    .depth_clamp_enable(false)
    // continued...
</code></pre>
<p>If <code>depth_clamp_enable</code> is set to <code>true</code>, then fragments that are beyond the near and far planes are clamped to them as opposed to discarding them. This is useful in some special cases like shadow maps. Using this requires enabling a GPU feature.</p>
<pre><code class="language-rust noplaypen">    .rasterizer_discard_enable(false)
</code></pre>
<p>If <code>rasterizer_discard_enable</code> is set to <code>true</code>, then geometry never passes through the rasterizer stage. This basically disables any output to the framebuffer.</p>
<pre><code class="language-rust noplaypen">    .polygon_mode(vk::PolygonMode::FILL)
</code></pre>
<p>The <code>polygon_mode</code> determines how fragments are generated for geometry. The following modes are available:</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PolygonMode.html#associatedconstant.FILL"><code class="hljs">vk::PolygonMode::FILL</code></a> – fill the area of the polygon with fragments</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PolygonMode.html#associatedconstant.LINE"><code class="hljs">vk::PolygonMode::LINE</code></a> – polygon edges are drawn as lines</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PolygonMode.html#associatedconstant.POINT"><code class="hljs">vk::PolygonMode::POINT</code></a> – polygon vertices are drawn as points</li>
</ul>
<p>Using any mode other than fill requires enabling a GPU feature.</p>
<pre><code class="language-rust noplaypen">    .line_width(1.0)
</code></pre>
<p>The <code>line_width</code> member is straightforward, it describes the thickness of lines in terms of number of fragments. The maximum line width that is supported depends on the hardware and any line thicker than <code>1.0</code> requires you to enable the <code>wide_lines</code> GPU feature.</p>
<pre><code class="language-rust noplaypen">    .cull_mode(vk::CullModeFlags::BACK)
    .front_face(vk::FrontFace::CLOCKWISE)
</code></pre>
<p>The <code>cull_mode</code> variable determines the type of face culling to use. You can disable culling, cull the front faces, cull the back faces or both. The <code>front_face</code> variable specifies the vertex order for faces to be considered front-facing and can be clockwise or counterclockwise.</p>
<pre><code class="language-rust noplaypen">    .depth_bias_enable(false);
</code></pre>
<p>The rasterizer can alter the depth values by adding a constant value or biasing them based on a fragment's slope. This is sometimes used for shadow mapping, but we won't be using it. Just set <code>depth_bias_enable</code> to <code>false</code>.</p>
<h2 id="multisampling"><a class="header" href="#multisampling">Multisampling</a></h2>
<p>The <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PipelineMultisampleStateCreateInfo.html"><code class="hljs">vk::PipelineMultisampleStateCreateInfo</code></a> struct configures multisampling, which is one of the ways to perform <a href="https://en.wikipedia.org/wiki/Multisample_anti-aliasing">anti-aliasing</a>. It works by combining the fragment shader results of multiple polygons that rasterize to the same pixel. This mainly occurs along edges, which is also where the most noticeable aliasing artifacts occur. Because it doesn't need to run the fragment shader multiple times if only one polygon maps to a pixel, it is significantly less expensive than simply rendering to a higher resolution and then downscaling. Enabling it requires enabling a GPU feature.</p>
<pre><code class="language-rust noplaypen">let multisample_state = vk::PipelineMultisampleStateCreateInfo::builder()
    .sample_shading_enable(false)
    .rasterization_samples(vk::SampleCountFlags::_1);
</code></pre>
<p>We'll revisit multisampling in a later chapter, for now let's keep it disabled.</p>
<h2 id="depth-and-stencil-testing"><a class="header" href="#depth-and-stencil-testing">Depth and stencil testing</a></h2>
<p>If you are using a depth and/or stencil buffer, then you also need to configure the depth and stencil tests using <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PipelineDepthStencilStateCreateInfo.html"><code class="hljs">vk::PipelineDepthStencilStateCreateInfo</code></a>. We don't have one right now, so we can simply ignore it for now. We'll get back to it in the depth buffering chapter.</p>
<h2 id="color-blending"><a class="header" href="#color-blending">Color blending</a></h2>
<p>After a fragment shader has returned a color, it needs to be combined with the color that is already in the framebuffer. This transformation is known as color blending and there are two ways to do it:</p>
<ul>
<li>Mix the old and new value to produce a final color</li>
<li>Combine the old and new value using a bitwise operation</li>
</ul>
<p>There are two types of structs to configure color blending. The first struct, <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PipelineColorBlendAttachmentState.html"><code class="hljs">vk::PipelineColorBlendAttachmentState</code></a> contains the configuration per attached framebuffer and the second struct, <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PipelineColorBlendStateCreateInfo.html"><code class="hljs">vk::PipelineColorBlendStateCreateInfo</code></a> contains the <em>global</em> color blending settings. In our case we only have one framebuffer:</p>
<pre><code class="language-rust noplaypen">let attachment = vk::PipelineColorBlendAttachmentState::builder()
    .color_write_mask(vk::ColorComponentFlags::all())
    .blend_enable(false)
    .src_color_blend_factor(vk::BlendFactor::ONE)  // Optional
    .dst_color_blend_factor(vk::BlendFactor::ZERO) // Optional
    .color_blend_op(vk::BlendOp::ADD)              // Optional
    .src_alpha_blend_factor(vk::BlendFactor::ONE)  // Optional
    .dst_alpha_blend_factor(vk::BlendFactor::ZERO) // Optional
    .alpha_blend_op(vk::BlendOp::ADD);             // Optional
</code></pre>
<p>This per-framebuffer struct allows you to configure the first way of color blending. The operations that will be performed are best demonstrated using the following pseudocode:</p>
<pre><code class="language-rust noplaypen">if blend_enable {
    final_color.rgb = (src_color_blend_factor * new_color.rgb)
        &lt;color_blend_op&gt; (dst_color_blend_factor * old_color.rgb);
    final_color.a = (src_alpha_blend_factor * new_color.a)
        &lt;alpha_blend_op&gt; (dst_alpha_blend_factor * old_color.a);
} else {
    final_color = new_color;
}

final_color = final_color &amp; color_write_mask;
</code></pre>
<p>If <code>blend_enable</code> is set to <code>false</code>, then the new color from the fragment shader is passed through unmodified. Otherwise, the two mixing operations are performed to compute a new color. The resulting color is AND'd with the <code>color_write_mask</code> to determine which channels are actually passed through.</p>
<p>The most common way to use color blending is to implement alpha blending, where we want the new color to be blended with the old color based on its opacity. The <code>final_color</code> should then be computed as follows:</p>
<pre><code class="language-c++">final_color.rgb = new_alpha * new_color + (1 - new_alpha) * old_color;
final_color.a = new_alpha.a;
</code></pre>
<p>This can be accomplished with the following parameters:</p>
<pre><code class="language-rust noplaypen">let attachment = vk::PipelineColorBlendAttachmentState::builder()
    .color_write_mask(vk::ColorComponentFlags::all())
    .blend_enable(true)
    .src_color_blend_factor(vk::BlendFactor::SRC_ALPHA)
    .dst_color_blend_factor(vk::BlendFactor::ONE_MINUS_SRC_ALPHA)
    .color_blend_op(vk::BlendOp::ADD)
    .src_alpha_blend_factor(vk::BlendFactor::ONE)
    .dst_alpha_blend_factor(vk::BlendFactor::ZERO)
    .alpha_blend_op(vk::BlendOp::ADD);
</code></pre>
<p>You can find all of the possible operations in the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.BlendFactor.html"><code class="hljs">vk::BlendFactor</code></a> and <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.BlendOp.html"><code class="hljs">vk::BlendOp</code></a> enumerations in the specification (or <code>vulkanalia</code>'s documentation).</p>
<p>The second structure references the array of structures for all of the framebuffers and allows you to set blend constants that you can use as blend factors in the aforementioned calculations.</p>
<pre><code class="language-rust noplaypen">let attachments = &amp;[attachment];
let color_blend_state = vk::PipelineColorBlendStateCreateInfo::builder()
    .logic_op_enable(false)
    .logic_op(vk::LogicOp::COPY)
    .attachments(attachments)
    .blend_constants([0.0, 0.0, 0.0, 0.0]);
</code></pre>
<p>If you want to use the second method of blending (bitwise combination), then you should set <code>logic_op_enable</code> to <code>true</code>. The bitwise operation can then be specified in the <code>logic_op</code> field. Note that this will automatically disable the first method, as if you had set <code>blend_enable</code> to <code>false</code> for every attached framebuffer! The <code>color_write_mask</code> will also be used in this mode to determine which channels in the framebuffer will actually be affected. It is also possible to disable both modes, as we've done here, in which case the fragment colors will be written to the framebuffer unmodified.</p>
<h2 id="dynamic-state-example-dont-add"><a class="header" href="#dynamic-state-example-dont-add">Dynamic state (example, don't add)</a></h2>
<p>A limited amount of the state that we've specified in the previous structs <em>can</em> actually be changed without recreating the pipeline. Examples are the size of the viewport, line width and blend constants. If you want to do that, then you'll have to fill in a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PipelineDynamicStateCreateInfo.html"><code class="hljs">vk::PipelineDynamicStateCreateInfo</code></a> structure like this:</p>
<pre><code class="language-rust noplaypen">let dynamic_states = &amp;[
    vk::DynamicState::VIEWPORT,
    vk::DynamicState::LINE_WIDTH,
];

let dynamic_state = vk::PipelineDynamicStateCreateInfo::builder()
    .dynamic_states(dynamic_states);
</code></pre>
<p>This will cause the configuration of these values to be ignored and you will be required to specify the data at drawing time. We'll get back to this in a future chapter. This struct can be omitted if you don't have any dynamic state.</p>
<h2 id="pipeline-layout"><a class="header" href="#pipeline-layout">Pipeline layout</a></h2>
<p>You can use <code>uniform</code> values in shaders, which are globals similar to dynamic state variables that can be changed at drawing time to alter the behavior of your shaders without having to recreate them. They are commonly used to pass the transformation matrix to the vertex shader, or to create texture samplers in the fragment shader.</p>
<p>These uniform values need to be specified during pipeline creation by creating a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PipelineLayout.html"><code class="hljs">vk::PipelineLayout</code></a> object. Even though we won't be using them until a future chapter, we are still required to create an empty pipeline layout.</p>
<p>Create an <code>AppData</code> field to hold this object, because we'll refer to it from other functions at a later point in time:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    pipeline_layout: vk::PipelineLayout,
}
</code></pre>
<p>And then create the object in the <code>create_pipeline</code> function just above the calls to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.destroy_shader_module"><code class="hljs">destroy_shader_module</code></a>:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_pipeline(device: &amp;Device, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    // ...

    let layout_info = vk::PipelineLayoutCreateInfo::builder();

    data.pipeline_layout = device.create_pipeline_layout(&amp;layout_info, None)?;

    device.destroy_shader_module(vert_shader_module, None);
    device.destroy_shader_module(frag_shader_module, None);

    Ok(())
}
</code></pre>
<p>The structure also specifies <em>push constants</em>, which are another way of passing dynamic values to shaders that we may get into in a future chapter. The pipeline layout will be referenced throughout the program's lifetime, so it should be destroyed in <code>App::destroy</code>:</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy(&amp;mut self) {
    self.device.destroy_pipeline_layout(self.data.pipeline_layout, None);
    // ...
}
</code></pre>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>That's it for all of the fixed-function state! It's a lot of work to set all of this up from scratch, but the advantage is that we're now nearly fully aware of everything that is going on in the graphics pipeline! This reduces the chance of running into unexpected behavior because the default state of certain components is not what you expect.</p>
<p>There is however one more object to create before we can finally create the graphics pipeline and that is a render pass.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="render-passes"><a class="header" href="#render-passes">Render passes</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/11_render_passes.rs">main.rs</a></p>
<p>Before we can finish creating the pipeline, we need to tell Vulkan about the framebuffer attachments that will be used while rendering. We need to specify how many color and depth buffers there will be, how many samples to use for each of them and how their contents should be handled throughout the rendering operations. All of this information is wrapped in a <em>render pass</em> object, for which we'll create a new <code>create_render_pass</code> function. Call this function from <code>App::create</code> before <code>create_pipeline</code>.</p>
<pre><code class="language-rust noplaypen">impl App {
    unsafe fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        // ...
        create_render_pass(&amp;instance, &amp;device, &amp;mut data)?;
        create_pipeline(&amp;device, &amp;mut data)?;
        // ...
    }
}

unsafe fn create_render_pass(
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;mut AppData,
) -&gt; Result&lt;()&gt; {
    Ok(())
}
</code></pre>
<h2 id="attachment-description"><a class="header" href="#attachment-description">Attachment description</a></h2>
<p>In our case we'll have just a single color buffer attachment represented by one of the images from the swapchain. This will be represented by a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.AttachmentDescription.html"><code class="hljs">vk::AttachmentDescription</code></a> which we will build in <code>create_render_pass</code>.</p>
<pre><code class="language-rust noplaypen">let color_attachment = vk::AttachmentDescription::builder()
    .format(data.swapchain_format)
    .samples(vk::SampleCountFlags::_1)
    // continued...
</code></pre>
<p>The <code>format</code> of the color attachment should match the format of the swapchain images, and we're not doing anything with multisampling yet, so we'll stick to 1 sample.</p>
<pre><code class="language-rust noplaypen">    .load_op(vk::AttachmentLoadOp::CLEAR)
    .store_op(vk::AttachmentStoreOp::STORE)
</code></pre>
<p>The <code>load_op</code> and <code>store_op</code> determine what to do with the data in the attachment before rendering and after rendering. We have the following choices for <code>load_op</code>:</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.AttachmentLoadOp.html#associatedconstant.LOAD"><code class="hljs">vk::AttachmentLoadOp::LOAD</code></a> – Preserve the existing contents of the attachment</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.AttachmentLoadOp.html#associatedconstant.CLEAR"><code class="hljs">vk::AttachmentLoadOp::CLEAR</code></a> – Clear the values to a constant at the start</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.AttachmentLoadOp.html#associatedconstant.DONT_CARE"><code class="hljs">vk::AttachmentLoadOp::DONT_CARE</code></a> – Existing contents are undefined; we don't care about them</li>
</ul>
<p>In our case we're going to use the clear operation to clear the framebuffer to black before drawing a new frame. There are only two possibilities for the <code>store_op</code>:</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.AttachmentStoreOp.html#associatedconstant.STORE"><code class="hljs">vk::AttachmentStoreOp::STORE</code></a> – Rendered contents will be stored in memory and can be read later</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.AttachmentStoreOp.html#associatedconstant.DONT_CARE"><code class="hljs">vk::AttachmentStoreOp::DONT_CARE</code></a> – Contents of the framebuffer will be undefined after the rendering operation</li>
</ul>
<p>We're interested in seeing the rendered triangle on the screen, so we're going with the store operation here.</p>
<pre><code class="language-rust noplaypen">    .stencil_load_op(vk::AttachmentLoadOp::DONT_CARE)
    .stencil_store_op(vk::AttachmentStoreOp::DONT_CARE)
</code></pre>
<p>The <code>load_op</code> and <code>store_op</code> apply to color and depth data, and <code>stencil_load_op</code> / <code>stencil_store_op</code> apply to stencil data. Our application won't do anything with the stencil buffer, so the results of loading and storing are irrelevant.</p>
<pre><code class="language-rust noplaypen">    .initial_layout(vk::ImageLayout::UNDEFINED)
    .final_layout(vk::ImageLayout::PRESENT_SRC_KHR);
</code></pre>
<p>Textures and framebuffers in Vulkan are represented by <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Image.html"><code class="hljs">vk::Image</code></a> objects with a certain pixel format, however the layout of the pixels in memory can change based on what you're trying to do with an image.</p>
<p>Some of the most common layouts are:</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.COLOR_ATTACHMENT_OPTIMAL"><code class="hljs">vk::ImageLayout::COLOR_ATTACHMENT_OPTIMAL</code></a> – Images used as color attachment</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.PRESENT_SRC_KHR"><code class="hljs">vk::ImageLayout::PRESENT_SRC_KHR</code></a> – Images to be presented in the swapchain</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.TRANSFER_DST_OPTIMAL"><code class="hljs">vk::ImageLayout::TRANSFER_DST_OPTIMAL</code></a> – Images to be used as destination for a memory copy operation</li>
</ul>
<p>We'll discuss this topic in more depth in the texturing chapter, but what's important to know right now is that images need to be transitioned to specific layouts that are suitable for the operation that they're going to be involved in next.</p>
<p>The <code>initial_layout</code> specifies which layout the image will have before the render pass begins. The <code>final_layout</code> specifies the layout to automatically transition to when the render pass finishes. Using <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.UNDEFINED"><code class="hljs">vk::ImageLayout::UNDEFINED</code></a> for <code>initial_layout</code> means that we don't care what previous layout the image was in. The caveat of this special value is that the contents of the image are not guaranteed to be preserved, but that doesn't matter since we're going to clear it anyway. We want the image to be ready for presentation using the swapchain after rendering, which is why we use <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.PRESENT_SRC_KHR"><code class="hljs">vk::ImageLayout::PRESENT_SRC_KHR</code></a> as <code>final_layout</code>.</p>
<h2 id="subpasses-and-attachment-references"><a class="header" href="#subpasses-and-attachment-references">Subpasses and attachment references</a></h2>
<p>A single render pass can consist of multiple subpasses. Subpasses are subsequent rendering operations that depend on the contents of framebuffers in previous passes, for example a sequence of post-processing effects that are applied one after another. If you group these rendering operations into one render pass, then Vulkan is able to reorder the operations and conserve memory bandwidth for possibly better performance. For our very first triangle, however, we'll stick to a single subpass.</p>
<p>Every subpass references one or more of the attachments that we've described using the structure in the previous sections. These references are themselves <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.AttachmentReference.html"><code class="hljs">vk::AttachmentReference</code></a> structs that look like this:</p>
<pre><code class="language-rust noplaypen">let color_attachment_ref = vk::AttachmentReference::builder()
    .attachment(0)
    .layout(vk::ImageLayout::COLOR_ATTACHMENT_OPTIMAL);
</code></pre>
<p>The <code>attachment</code> parameter specifies which attachment to reference by its index in the attachment descriptions array. Our array consists of a single <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.AttachmentDescription.html"><code class="hljs">vk::AttachmentDescription</code></a>, so its index is <code>0</code>. The <code>layout</code> specifies which layout we would like the attachment to have during a subpass that uses this reference. Vulkan will automatically transition the attachment to this layout when the subpass is started. We intend to use the attachment to function as a color buffer and the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.COLOR_ATTACHMENT_OPTIMAL"><code class="hljs">vk::ImageLayout::COLOR_ATTACHMENT_OPTIMAL</code></a> layout will give us the best performance, as its name implies.</p>
<p>The subpass is described using a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SubpassDescription.html"><code class="hljs">vk::SubpassDescription</code></a> structure:</p>
<pre><code class="language-rust noplaypen">let color_attachments = &amp;[color_attachment_ref];
let subpass = vk::SubpassDescription::builder()
    .pipeline_bind_point(vk::PipelineBindPoint::GRAPHICS)
    .color_attachments(color_attachments);
</code></pre>
<p>Vulkan may also support compute subpasses in the future, so we have to be explicit about this being a graphics subpass. Then we specify the reference to the color attachment.</p>
<p>The index of the attachment in this array is directly referenced from the fragment shader with the <code>layout(location = 0) out vec4 outColor</code> directive!</p>
<p>The following other types of attachments can be referenced by a subpass:</p>
<ul>
<li><code>input_attachments</code> – Attachments that are read from a shader</li>
<li><code>resolve_attachments</code> – Attachments used for multisampling color attachments</li>
<li><code>depth_stencil_attachment</code> – Attachment for depth and stencil data</li>
<li><code>preserve_attachments</code> – Attachments that are not used by this subpass, but for which the data must be preserved</li>
</ul>
<h2 id="render-pass"><a class="header" href="#render-pass">Render pass</a></h2>
<p>Now that the attachment and a basic subpass referencing it have been described, we can create the render pass itself. Create a new class member variable to hold the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.RenderPass.html"><code class="hljs">vk::RenderPass</code></a> object right above the <code>pipeline_layout</code> field in <code>AppData</code>:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    render_pass: vk::RenderPass,
    pipeline_layout: vk::PipelineLayout,
}
</code></pre>
<p>The render pass object can then be created by filling in the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.RenderPassCreateInfo.html"><code class="hljs">vk::RenderPassCreateInfo</code></a> structure with an array of attachments and subpasses. The <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.AttachmentReference.html"><code class="hljs">vk::AttachmentReference</code></a> objects reference attachments using the indices of this array.</p>
<pre><code class="language-rust noplaypen">let attachments = &amp;[color_attachment];
let subpasses = &amp;[subpass];
let info = vk::RenderPassCreateInfo::builder()
    .attachments(attachments)
    .subpasses(subpasses);

data.render_pass = device.create_render_pass(&amp;info, None)?;
</code></pre>
<p>Just like the pipeline layout, the render pass will be referenced throughout the program, so it should only be cleaned up at the end in <code>App::destroy</code>:</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy(&amp;mut self) {
    self.device.destroy_pipeline_layout(self.data.pipeline_layout, None);
    self.device.destroy_render_pass(self.data.render_pass, None);
    // ...
}
</code></pre>
<p>That was a lot of work, but in the next chapter it all comes together to finally create the graphics pipeline object!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/12_graphics_pipeline_complete.rs">main.rs</a></p>
<p>We can now combine all of the structures and objects from the previous chapters to create the graphics pipeline! Here's the types of objects we have now, as a quick recap:</p>
<ul>
<li>Shader stages – the shader modules that define the functionality of the programmable stages of the graphics pipeline</li>
<li>Fixed-function state – all of the structures that define the fixed-function stages of the pipeline, like input assembly, rasterizer, viewport and color blending</li>
<li>Pipeline layout – the uniform and push values referenced by the shader that can be updated at draw time</li>
<li>Render pass – the attachments referenced by the pipeline stages and their usage</li>
</ul>
<p>All of these combined fully define the functionality of the graphics pipeline, so we can now begin filling in the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.GraphicsPipelineCreateInfo.html"><code class="hljs">vk::GraphicsPipelineCreateInfo</code></a> structure at the end of the <code>create_pipeline</code> function (but before the shader modules are destroyed). But before the calls to <code>DeviceV1_0:::destroy_shader_module</code> because these are still to be used during the creation.</p>
<pre><code class="language-rust noplaypen">let stages = &amp;[vert_stage, frag_stage];
let info = vk::GraphicsPipelineCreateInfo::builder()
    .stages(stages)
    // continued...
</code></pre>
<p>We start by providing an array of the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PipelineShaderStageCreateInfo.html"><code class="hljs">vk::PipelineShaderStageCreateInfo</code></a> structs.</p>
<pre><code class="language-rust noplaypen">    .vertex_input_state(&amp;vertex_input_state)
    .input_assembly_state(&amp;input_assembly_state)
    .viewport_state(&amp;viewport_state)
    .rasterization_state(&amp;rasterization_state)
    .multisample_state(&amp;multisample_state)
    .color_blend_state(&amp;color_blend_state)
</code></pre>
<p>Then we reference all of the structures describing the fixed-function stage.</p>
<pre><code class="language-rust noplaypen">    .layout(data.pipeline_layout)
</code></pre>
<p>After that comes the pipeline layout, which is a Vulkan handle rather than a struct reference.</p>
<pre><code class="language-rust noplaypen">    .render_pass(data.render_pass)
    .subpass(0);
</code></pre>
<p>And finally we have the reference to the render pass and the index of the sub pass where this graphics pipeline will be used. It is also possible to use other render passes with this pipeline instead of this specific instance, but they have to be <em>compatible</em> with <code>render_pass</code>. The requirements for compatibility are described <a href="https://www.khronos.org/registry/vulkan/specs/1.2/html/vkspec.html#renderpass-compatibility">here</a>, but we won't be using that feature in this tutorial.</p>
<pre><code class="language-rust noplaypen">    .base_pipeline_handle(vk::Pipeline::null()) // Optional.
    .base_pipeline_index(-1)                    // Optional.
</code></pre>
<p>There are actually two more parameters: <code>base_pipeline_handle</code> and <code>base_pipeline_index</code>. Vulkan allows you to create a new graphics pipeline by deriving from an existing pipeline. The idea of pipeline derivatives is that it is less expensive to set up pipelines when they have much functionality in common with an existing pipeline and switching between pipelines from the same parent can also be done quicker. You can either specify the handle of an existing pipeline with <code>base_pipeline_handle</code> or reference another pipeline that is about to be created by index with <code>base_pipeline_index</code>. Right now there is only a single pipeline, so we'll simply specify a null handle and an invalid index. These values are only used if the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PipelineCreateFlags.html#associatedconstant.DERIVATIVE"><code class="hljs">vk::PipelineCreateFlags::DERIVATIVE</code></a> flag is also specified in the <code>flags</code> field of <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.GraphicsPipelineCreateInfo.html"><code class="hljs">vk::GraphicsPipelineCreateInfo</code></a>.</p>
<p>Now prepare for the final step by creating a field in <code>AppData</code> to hold the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Pipeline.html"><code class="hljs">vk::Pipeline</code></a> object:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    pipeline: vk::Pipeline,
}
</code></pre>
<p>And finally create the graphics pipeline:</p>
<pre><code class="language-rust noplaypen">data.pipeline = device.create_graphics_pipelines(
    vk::PipelineCache::null(), &amp;[info], None)?.0[0];
</code></pre>
<p>The <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.create_graphics_pipelines"><code class="hljs">create_graphics_pipelines</code></a> function actually has more parameters than the usual object creation functions in Vulkan. It is designed to take multiple <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.GraphicsPipelineCreateInfo.html"><code class="hljs">vk::GraphicsPipelineCreateInfo</code></a> objects and create multiple <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Pipeline.html"><code class="hljs">vk::Pipeline</code></a> objects in a single call.</p>
<p>The first parameter, for which we've passed the <code>vk::PipelineCache::null()</code> argument, references an optional <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PipelineCache.html"><code class="hljs">vk::PipelineCache</code></a> object. A pipeline cache can be used to store and reuse data relevant to pipeline creation across multiple calls to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.create_graphics_pipelines"><code class="hljs">create_graphics_pipelines</code></a> and even across program executions if the cache is stored to a file. This makes it possible to significantly speed up pipeline creation at a later time.</p>
<p>The graphics pipeline is required for all common drawing operations, so it should also only be destroyed at the end of the program in <code>App::destroy</code>:</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy(&amp;mut self) {
    self.device.destroy_pipeline(self.data.pipeline, None);
    // ...
}
</code></pre>
<p>Now run your program to confirm that all this hard work has resulted in a successful pipeline creation! We are already getting quite close to seeing something pop up on the screen. In the next couple of chapters we'll set up the actual framebuffers from the swapchain images and prepare the drawing commands.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="framebuffers"><a class="header" href="#framebuffers">Framebuffers</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/13_framebuffers.rs">main.rs</a></p>
<p>We've talked a lot about framebuffers in the past few chapters and we've set up the render pass to expect a single framebuffer with the same format as the swapchain images, but we haven't actually created any yet.</p>
<p>The attachments specified during render pass creation are bound by wrapping them into a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Framebuffer.html"><code class="hljs">vk::Framebuffer</code></a> object. A framebuffer object references all of the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageView.html"><code class="hljs">vk::ImageView</code></a> objects that represent the attachments. In our case that will be only a single one: the color attachment. However, the image that we have to use for the attachment depends on which image the swapchain returns when we retrieve one for presentation. That means that we have to create a framebuffer for all of the images in the swapchain and use the one that corresponds to the retrieved image at drawing time.</p>
<p>To that end, create another <code>Vec</code> field in <code>AppData</code> to hold the framebuffers:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    framebuffers: Vec&lt;vk::Framebuffer&gt;,
}
</code></pre>
<p>We'll create the objects for this array in a new function <code>create_framebuffers</code> that is called from <code>App::create</code> right after creating the graphics pipeline:</p>
<pre><code class="language-rust noplaypen">impl App {
    unsafe fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        // ...
        create_pipeline(&amp;device, &amp;mut data)?;
        create_framebuffers(&amp;device, &amp;mut data)?;
        // ...
    }
}

unsafe fn create_framebuffers(device: &amp;Device, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    Ok(())
}
</code></pre>
<p>Start by mapping over the swapchain image views:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_framebuffers(device: &amp;Device, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    data.framebuffers = data
        .swapchain_image_views
        .iter()
        .map(|i| {

        })
        .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?;

    Ok(())
}
</code></pre>
<p>We'll then create a framebuffer for each image view:</p>
<pre><code class="language-rust noplaypen">let attachments = &amp;[*i];
let create_info = vk::FramebufferCreateInfo::builder()
    .render_pass(data.render_pass)
    .attachments(attachments)
    .width(data.swapchain_extent.width)
    .height(data.swapchain_extent.height)
    .layers(1);

device.create_framebuffer(&amp;create_info, None)
</code></pre>
<p>As you can see, creation of framebuffers is quite straightforward. We first need to specify with which <code>render_pass</code> the framebuffer needs to be compatible. You can only use a framebuffer with the render passes that it is compatible with, which roughly means that they use the same number and type of attachments.</p>
<p>The <code>attachments</code> field specifies the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageView.html"><code class="hljs">vk::ImageView</code></a> objects that should be bound to the respective attachment descriptions in the render pass <code>attachment</code> array.</p>
<p>The <code>width</code> and <code>height</code> parameters are self-explanatory and <code>layers</code> refers to the number of layers in image arrays. Our swapchain images are single images, so the number of layers is <code>1</code>.</p>
<p>We should delete the framebuffers before the image views and render pass that they are based on, but only after we've finished rendering:</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy(&amp;mut self) {
    self.data.framebuffers
        .iter()
        .for_each(|f| self.device.destroy_framebuffer(*f, None));
    // ...
}
</code></pre>
<p>We've now reached the milestone where we have all of the objects that are required for rendering. In the next chapter we're going to write the first actual drawing commands.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-buffers"><a class="header" href="#command-buffers">Command buffers</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/14_command_buffers.rs">main.rs</a></p>
<p>Commands in Vulkan, like drawing operations and memory transfers, are not executed directly using function calls. You have to record all of the operations you want to perform in command buffer objects. The advantage of this is that all of the hard work of setting up the drawing commands can be done in advance and in multiple threads. After that, you just have to tell Vulkan to execute the commands in the main loop.</p>
<h2 id="command-pools"><a class="header" href="#command-pools">Command pools</a></h2>
<p>We have to create a command pool before we can create command buffers. Command pools manage the memory that is used to store the buffers and command buffers are allocated from them. Add a new <code>AppData</code> field to store a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.CommandPool.html"><code class="hljs">vk::CommandPool</code></a>:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    command_pool: vk::CommandPool,
}
</code></pre>
<p>Then create a new function <code>create_command_pool</code> and call it from <code>App::create</code> after the framebuffers were created.</p>
<pre><code class="language-rust noplaypen">impl App {
    unsafe fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        // ...
        create_framebuffers(&amp;device, &amp;mut data)?;
        create_command_pool(&amp;instance, &amp;device, &amp;mut data)?;
        // ...
    }
}

unsafe fn create_command_pool(
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;mut AppData,
) -&gt; Result&lt;()&gt; {
    Ok(())
}
</code></pre>
<p>Command pool creation only takes two parameters:</p>
<pre><code class="language-rust noplaypen">let indices = QueueFamilyIndices::get(instance, data, data.physical_device)?;

let info = vk::CommandPoolCreateInfo::builder()
    .flags(vk::CommandPoolCreateFlags::empty()) // Optional.
    .queue_family_index(indices.graphics);
</code></pre>
<p>Command buffers are executed by submitting them on one of the device queues, like the graphics and presentation queues we retrieved. Each command pool can only allocate command buffers that are submitted on a single type of queue. We're going to record commands for drawing, which is why we've chosen the graphics queue family.</p>
<p>There are three possible flags for command pools:</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.CommandPoolCreateFlags.html#associatedconstant.TRANSIENT"><code class="hljs">vk::CommandPoolCreateFlags::TRANSIENT</code></a> – Hint that command buffers are rerecorded with new commands very often (may change memory allocation behavior)</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.CommandPoolCreateFlags.html#associatedconstant.RESET_COMMAND_BUFFER"><code class="hljs">vk::CommandPoolCreateFlags::RESET_COMMAND_BUFFER</code></a> – Allow command buffers to be rerecorded individually, without this flag they all have to be reset together</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.CommandPoolCreateFlags.html#associatedconstant.PROTECTED"><code class="hljs">vk::CommandPoolCreateFlags::PROTECTED</code></a> – Creates &quot;protected&quot; command buffers which are stored in <a href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#memory-protected-access-rules">&quot;protected&quot; memory</a> where Vulkan prevents unauthorized operations from accessing the memory</li>
</ul>
<p>We will only record the command buffers at the beginning of the program and then execute them many times in the main loop and we don't need to protect our triangle with DRM, so we're not going to use any of these flags.</p>
<pre><code class="language-rust noplaypen">data.command_pool = device.create_command_pool(&amp;info, None)?;
</code></pre>
<p>Commands will be used throughout the program to draw things on the screen, so the pool should only be destroyed at the end:</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy(&amp;mut self) {
    self.device.destroy_command_pool(self.data.command_pool, None);
    // ...
}
</code></pre>
<h2 id="command-buffer-allocation"><a class="header" href="#command-buffer-allocation">Command buffer allocation</a></h2>
<p>We can now start allocating command buffers and recording drawing commands in them. Because one of the drawing commands involves binding the right <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Framebuffer.html"><code class="hljs">vk::Framebuffer</code></a>, we'll actually have to record a command buffer for every image in the swapchain once again. To that end, create a list of <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.CommandBuffer.html"><code class="hljs">vk::CommandBuffer</code></a> objects as an <code>AppData</code> field. Command buffers will be automatically freed when their command pool is destroyed, so we don't need any explicit cleanup.</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    command_buffers: Vec&lt;vk::CommandBuffer&gt;,
}
</code></pre>
<p>We'll now start working on a <code>create_command_buffers</code> function that allocates and records the commands for each swapchain image.</p>
<pre><code class="language-rust noplaypen">impl App {
    unsafe fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        // ...
        create_command_pool(&amp;instance, &amp;device, &amp;mut data)?;
        create_command_buffers(&amp;device, &amp;mut data)?;
        // ...
    }
}

unsafe fn create_command_buffers(device: &amp;Device, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    Ok(())
}
</code></pre>
<p>Command buffers are allocated with the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.allocate_command_buffers"><code class="hljs">allocate_command_buffers</code></a> function, which takes a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.CommandBufferAllocateInfo.html"><code class="hljs">vk::CommandBufferAllocateInfo</code></a> struct as parameter that specifies the command pool and number of buffers to allocate:</p>
<pre><code class="language-rust noplaypen">let allocate_info = vk::CommandBufferAllocateInfo::builder()
    .command_pool(data.command_pool)
    .level(vk::CommandBufferLevel::PRIMARY)
    .command_buffer_count(data.framebuffers.len() as u32);

data.command_buffers = device.allocate_command_buffers(&amp;allocate_info)?;
</code></pre>
<p>The <code>level</code> parameter specifies if the allocated command buffers are primary or secondary command buffers.</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.CommandBufferLevel.html#associatedconstant.PRIMARY"><code class="hljs">vk::CommandBufferLevel::PRIMARY</code></a> – Can be submitted to a queue for execution, but cannot be called from other command buffers.</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.CommandBufferLevel.html#associatedconstant.SECONDARY"><code class="hljs">vk::CommandBufferLevel::SECONDARY</code></a> – Cannot be submitted directly, but can be called from primary command buffers.</li>
</ul>
<p>We won't make use of the secondary command buffer functionality here, but you can imagine that it's helpful to reuse common operations from primary command buffers.</p>
<h2 id="starting-command-buffer-recording"><a class="header" href="#starting-command-buffer-recording">Starting command buffer recording</a></h2>
<p>We begin recording a command buffer by calling <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.begin_command_buffer"><code class="hljs">begin_command_buffer</code></a> with a small <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.CommandBufferBeginInfo.html"><code class="hljs">vk::CommandBufferBeginInfo</code></a> structure as argument that specifies some details about the usage of this specific command buffer.</p>
<pre><code class="language-rust noplaypen">for (i, command_buffer) in data.command_buffers.iter().enumerate() {
    let inheritance = vk::CommandBufferInheritanceInfo::builder();

    let info = vk::CommandBufferBeginInfo::builder()
        .flags(vk::CommandBufferUsageFlags::empty()) // Optional.
        .inheritance_info(&amp;inheritance);             // Optional.

    device.begin_command_buffer(*command_buffer, &amp;info)?;
}
</code></pre>
<p>The <code>flags</code> parameter specifies how we're going to use the command buffer. The following values are available:</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.CommandBufferUsageFlags.html#associatedconstant.ONE_TIME_SUBMIT"><code class="hljs">vk::CommandBufferUsageFlags::ONE_TIME_SUBMIT</code></a> – The command buffer will be rerecorded right after executing it once.</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.CommandBufferUsageFlags.html#associatedconstant.RENDER_PASS_CONTINUE"><code class="hljs">vk::CommandBufferUsageFlags::RENDER_PASS_CONTINUE</code></a> – This is a secondary command buffer that will be entirely within a single render pass.</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.CommandBufferUsageFlags.html#associatedconstant.SIMULTANEOUS_USE"><code class="hljs">vk::CommandBufferUsageFlags::SIMULTANEOUS_USE</code></a> – The command buffer can be resubmitted while it is also already pending execution.</li>
</ul>
<p>None of these flags are applicable for us right now.</p>
<p>The <code>inheritance_info</code> parameter is only relevant for secondary command buffers. It specifies which state to inherit from the calling primary command buffers.</p>
<p>If the command buffer was already recorded once, then a call to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.begin_command_buffer"><code class="hljs">begin_command_buffer</code></a> will implicitly reset it. It's not possible to append commands to a buffer at a later time.</p>
<h2 id="starting-a-render-pass"><a class="header" href="#starting-a-render-pass">Starting a render pass</a></h2>
<p>Before we can start a render pass we'll need to build some parameters.</p>
<pre><code class="language-rust noplaypen">let render_area = vk::Rect2D::builder()
    .offset(vk::Offset2D::default())
    .extent(data.swapchain_extent);
</code></pre>
<p>Here we define the size of the render area. The render area defines where shader loads and stores will take place during the execution of the render pass. The pixels outside this region will have undefined values. It should match the size of the attachments for best performance.</p>
<pre><code class="language-rust noplaypen">let color_clear_value = vk::ClearValue {
    color: vk::ClearColorValue {
        float32: [0.0, 0.0, 0.0, 1.0],
    },
};
</code></pre>
<p>Next we define a clear value that will be used to clear the framebuffer at the beginning of the render pass (because we used <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.AttachmentLoadOp.html#associatedconstant.CLEAR"><code class="hljs">vk::AttachmentLoadOp::CLEAR</code></a> when creating the render pass). <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/union.ClearValue.html"><code class="hljs">vk::ClearValue</code></a> is a union that can be used to set clear values for color attachments or for depth/stencil attachments. Here we are setting the <code>color</code> field with a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/union.ClearColorValue.html"><code class="hljs">vk::ClearColorValue</code></a> union with 4 <code>f32</code>s that define a black clear color with 100% opacity.</p>
<p>Drawing starts by beginning the render pass with <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_begin_render_pass"><code class="hljs">cmd_begin_render_pass</code></a>. The render pass is configured using some parameters in a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.RenderPassBeginInfo.html"><code class="hljs">vk::RenderPassBeginInfo</code></a> struct.</p>
<pre><code class="language-rust noplaypen">let clear_values = &amp;[color_clear_value];
let info = vk::RenderPassBeginInfo::builder()
    .render_pass(data.render_pass)
    .framebuffer(data.framebuffers[i])
    .render_area(render_area)
    .clear_values(clear_values);
</code></pre>
<p>The first parameters are the render pass itself and the attachments to bind. We created a framebuffer for each swapchain image that specifies it as color attachment. Then we provide the previously constructed render area and clear value.</p>
<pre><code class="language-rust noplaypen">device.cmd_begin_render_pass(
    *command_buffer, &amp;info, vk::SubpassContents::INLINE);
</code></pre>
<p>The render pass can now begin. All of the functions that record commands can be recognized by their <code>cmd_</code> prefix. They all return <code>()</code>, so there is no need for error handling until we've finished recording.</p>
<p>The first parameter for every command is always the command buffer to record the command to. The second parameter specifies the details of the render pass we've just provided. The final parameter controls how the drawing commands within the render pass will be provided. It can have one of two values:</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SubpassContents.html#associatedconstant.INLINE"><code class="hljs">vk::SubpassContents::INLINE</code></a> – The render pass commands will be embedded in the primary command buffer itself and no secondary command buffers will be executed.</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SubpassContents.html#associatedconstant.SECONDARY_COMMAND_BUFFERS"><code class="hljs">vk::SubpassContents::SECONDARY_COMMAND_BUFFERS</code></a> – The render pass commands will be executed from secondary command buffers.</li>
</ul>
<p>We will not be using secondary command buffers, so we'll go with the first option.</p>
<h2 id="basic-drawing-commands"><a class="header" href="#basic-drawing-commands">Basic drawing commands</a></h2>
<p>We can now bind the graphics pipeline:</p>
<pre><code class="language-rust noplaypen">device.cmd_bind_pipeline(
    *command_buffer, vk::PipelineBindPoint::GRAPHICS, data.pipeline);
</code></pre>
<p>The second parameter specifies if the pipeline object is a graphics or compute pipeline. We've now told Vulkan which operations to execute in the graphics pipeline and which attachment to use in the fragment shader, so all that remains is telling it to draw the triangle:</p>
<pre><code class="language-rust noplaypen">device.cmd_draw(*command_buffer, 3, 1, 0, 0);
</code></pre>
<p>The actual drawing function is a bit anticlimactic, but it's so simple because of all the information we specified in advance. It has the following parameters, aside from the command buffer:</p>
<ul>
<li><code>vertex_count</code> – Even though we don't have a vertex buffer, we technically still have 3 vertices to draw.</li>
<li><code>instance_count</code> – Used for instanced rendering, use <code>1</code> if you're not doing that.</li>
<li><code>first_vertex</code> – Used as an offset into the vertex buffer, defines the lowest value of <code>gl_VertexIndex</code>.</li>
<li><code>first_instance</code> – Used as an offset for instanced rendering, defines the lowest value of <code>gl_InstanceIndex</code>.</li>
</ul>
<h2 id="finishing-up"><a class="header" href="#finishing-up">Finishing up</a></h2>
<p>The render pass can now be ended:</p>
<pre><code class="language-rust noplaypen">device.cmd_end_render_pass(*command_buffer);
</code></pre>
<p>And we've finished recording the command buffer:</p>
<pre><code class="language-rust noplaypen">device.end_command_buffer(*command_buffer)?;
</code></pre>
<p>In the next chapter we'll write the code for the main loop, which will acquire an image from the swapchain, execute the right command buffer and return the finished image to the swapchain.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rendering-and-presentation"><a class="header" href="#rendering-and-presentation">Rendering and presentation</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/15_hello_triangle.rs">main.rs</a></p>
<p>This is the chapter where everything is going to come together. We're going to implement the <code>App::render</code> function that will be called from the main loop to put the triangle on the screen.</p>
<h2 id="synchronization"><a class="header" href="#synchronization">Synchronization</a></h2>
<p>The <code>App::render</code> function will perform the following operations:</p>
<ul>
<li>Acquire an image from the swapchain</li>
<li>Execute the command buffer with that image as attachment in the framebuffer</li>
<li>Return the image to the swapchain for presentation</li>
</ul>
<p>Each of these events is set in motion using a single function call, but they are executed asynchronously. The function calls will return before the operations are actually finished and the order of execution is also undefined. That is unfortunate, because each of the operations depends on the previous one finishing.</p>
<p>There are two ways of synchronizing swapchain events: fences and semaphores. They're both objects that can be used for coordinating operations by having one operation signal and another operation wait for a fence or semaphore to go from the unsignaled to signaled state.</p>
<p>The difference is that the state of fences can be accessed from your program using calls like <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.wait_for_fences"><code class="hljs">wait_for_fences</code></a> and semaphores cannot be. Fences are mainly designed to synchronize your application itself with rendering operation, whereas semaphores are used to synchronize operations within or across command queues. We want to synchronize the queue operations of draw commands and presentation, which makes semaphores the best fit.</p>
<h2 id="semaphores"><a class="header" href="#semaphores">Semaphores</a></h2>
<p>We'll need one semaphore to signal that an image has been acquired and is ready for rendering, and another one to signal that rendering has finished and presentation can happen. Create two <code>AppData</code> fields to store these semaphore objects:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    image_available_semaphore: vk::Semaphore,
    render_finished_semaphore: vk::Semaphore,
}
</code></pre>
<p>To create the semaphores, we'll add the last <code>create</code> function for this part of the tutorial, <code>create_sync_objects</code>:</p>
<pre><code class="language-rust noplaypen">impl App {
    unsafe fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        // ...
        create_command_buffers(&amp;device, &amp;mut data)?;
        create_sync_objects(&amp;device, &amp;mut data)?;
        // ...
    }
}

unsafe fn create_sync_objects(device: &amp;Device, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    Ok(())
}
</code></pre>
<p>Creating semaphores requires filling in the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SemaphoreCreateInfo.html"><code class="hljs">vk::SemaphoreCreateInfo</code></a>, but in the current version of the API it doesn't actually have any required fields.</p>
<pre><code class="language-rust noplaypen">unsafe fn create_sync_objects(device: &amp;Device, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    let semaphore_info = vk::SemaphoreCreateInfo::builder();

    Ok(())
}
</code></pre>
<p>Future versions of the Vulkan API or extensions may add functionality for the <code>flags</code> and <code>p_next</code> parameters like it does for the other structures. Creating the semaphores follows the familiar pattern:</p>
<pre><code class="language-rust noplaypen">data.image_available_semaphore = device.create_semaphore(&amp;semaphore_info, None)?;
data.render_finished_semaphore = device.create_semaphore(&amp;semaphore_info, None)?;
</code></pre>
<p>The semaphores should be cleaned up at the end of the program, when all commands have finished and no more synchronization is necessary:</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy(&amp;mut self) {
    self.device.destroy_semaphore(self.data.render_finished_semaphore, None);
    self.device.destroy_semaphore(self.data.image_available_semaphore, None);
    // ...
}
</code></pre>
<h2 id="acquiring-an-image-from-the-swapchain"><a class="header" href="#acquiring-an-image-from-the-swapchain">Acquiring an image from the swapchain</a></h2>
<p>As mentioned before, the first thing we need to do in the <code>App::render</code> function is acquire an image from the swapchain. Recall that the swapchain is an extension feature, so we must use a function with the <code>*_khr</code> naming convention:</p>
<pre><code class="language-rust noplaypen">unsafe fn render(&amp;mut self, window: &amp;Window) -&gt; Result&lt;()&gt; {
    let image_index = self
        .device
        .acquire_next_image_khr(
            self.data.swapchain,
            u64::MAX,
            self.data.image_available_semaphore,
            vk::Fence::null(),
        )?
        .0 as usize;

    Ok(())
}
</code></pre>
<p>The first parameter of <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.KhrSwapchainExtension.html#method.acquire_next_image_khr"><code class="hljs">acquire_next_image_khr</code></a> is the swapchain from which we wish to acquire an image. The second parameter specifies a timeout in nanoseconds for an image to become available. Using the maximum value of a 64 bit unsigned integer disables the timeout.</p>
<p>The next two parameters specify synchronization objects that are to be signaled when the presentation engine is finished using the image. That's the point in time where we can start drawing to it. It is possible to specify a semaphore, fence or both. We're going to use our <code>image_available_semaphore</code> for that purpose here.</p>
<p>This function returns the index of the swapchain image that has become available. The index refers to the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Image.html"><code class="hljs">vk::Image</code></a> in our <code>swapchain_images</code> array. We're going to use that index to pick the right command buffer.</p>
<h2 id="submitting-the-command-buffer"><a class="header" href="#submitting-the-command-buffer">Submitting the command buffer</a></h2>
<p>Queue submission and synchronization is configured through parameters in the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SubmitInfo.html"><code class="hljs">vk::SubmitInfo</code></a> structure.</p>
<pre><code class="language-rust noplaypen">let wait_semaphores = &amp;[self.data.image_available_semaphore];
let wait_stages = &amp;[vk::PipelineStageFlags::COLOR_ATTACHMENT_OUTPUT];
let command_buffers = &amp;[self.data.command_buffers[image_index as usize]];
let signal_semaphores = &amp;[self.data.render_finished_semaphore];
let submit_info = vk::SubmitInfo::builder()
    .wait_semaphores(wait_semaphores)
    .wait_dst_stage_mask(wait_stages)
    .command_buffers(command_buffers)
    .signal_semaphores(signal_semaphores);
</code></pre>
<p>The first two parameters, <code>wait_semaphores</code> and <code>wait_dst_stage_mask</code>, specify which semaphores to wait on before execution begins and in which stage(s) of the pipeline to wait. We want to wait with writing colors to the image until it's available, so we're specifying the stage of the graphics pipeline that writes to the color attachment. That means that theoretically the implementation can already start executing our vertex shader and such while the image is not yet available. Each entry in the <code>wait_stages</code> array corresponds to the semaphore with the same index in <code>wait_semaphores</code>.</p>
<p>The next parameter, <code>command_buffers</code>, specifies which command buffers to actually submit for execution. As mentioned earlier, we should submit the command buffer that binds the swapchain image we just acquired as color attachment.</p>
<p>Lastly <code>signal_semaphores</code> specifies which semaphores to signal once the command buffer(s) have finished execution. In our case we're using the <code>render_finished_semaphore</code> for that purpose.</p>
<pre><code class="language-rust noplaypen">self.device.queue_submit(
    self.data.graphics_queue, &amp;[submit_info], vk::Fence::null())?;
</code></pre>
<p>We can now submit the command buffer to the graphics queue using <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.queue_submit"><code class="hljs">queue_submit</code></a>. The function takes an array of <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SubmitInfo.html"><code class="hljs">vk::SubmitInfo</code></a> structures as argument for efficiency when the workload is much larger. The last parameter references an optional fence that will be signaled when the command buffers finish execution. We're using semaphores for synchronization, so we'll just pass a <code>vk::Fence::null()</code>.</p>
<h2 id="subpass-dependencies"><a class="header" href="#subpass-dependencies">Subpass dependencies</a></h2>
<p>Remember that the subpasses in a render pass automatically take care of image layout transitions. These transitions are controlled by <em>subpass dependencies</em>, which specify memory and execution dependencies between subpasses. We have only a single subpass right now, but the operations right before and right after this subpass also count as implicit &quot;subpasses&quot;.</p>
<p>There are two built-in dependencies that take care of the transition at the start of the render pass and at the end of the render pass, but the former does not occur at the right time. It assumes that the transition occurs at the start of the pipeline, but we haven't acquired the image yet at that point! There are two ways to deal with this problem. We could change the <code>wait_stages</code> for the <code>image_available_semaphore</code> to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PipelineStageFlags.html#associatedconstant.TOP_OF_PIPE"><code class="hljs">vk::PipelineStageFlags::TOP_OF_PIPE</code></a> to ensure that the render passes don't begin until the image is available, or we can make the render pass wait for the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PipelineStageFlags.html#associatedconstant.COLOR_ATTACHMENT_OUTPUT"><code class="hljs">vk::PipelineStageFlags::COLOR_ATTACHMENT_OUTPUT</code></a> stage. I've decided to go with the second option here, because it's a good excuse to have a look at subpass dependencies and how they work.</p>
<p>Subpass dependencies are specified in <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SubpassDependency.html"><code class="hljs">vk::SubpassDependency</code></a> structs. Go to our <code>create_render_pass</code> function and add one:</p>
<pre><code class="language-rust noplaypen">let dependency = vk::SubpassDependency::builder()
    .src_subpass(vk::SUBPASS_EXTERNAL)
    .dst_subpass(0)
    // continued...
</code></pre>
<p>The first two fields specify the indices of the dependency and the dependent subpass. The special value <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/constant.SUBPASS_EXTERNAL.html"><code class="hljs">vk::SUBPASS_EXTERNAL</code></a> refers to the implicit subpass before or after the render pass depending on whether it is specified in <code>src_subpass</code> or <code>dst_subpass</code>. The index <code>0</code> refers to our subpass, which is the first and only one. The <code>dst_subpass</code> must always be higher than <code>src_subpass</code> to prevent cycles in the dependency graph (unless one of the subpasses is <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/constant.SUBPASS_EXTERNAL.html"><code class="hljs">vk::SUBPASS_EXTERNAL</code></a>).</p>
<pre><code class="language-rust noplaypen">    .src_stage_mask(vk::PipelineStageFlags::COLOR_ATTACHMENT_OUTPUT)
    .src_access_mask(vk::AccessFlags::empty())
</code></pre>
<p>The next two fields specify the operations to wait on and the stages in which these operations occur. We need to wait for the swapchain to finish reading from the image before we can access it. This can be accomplished by waiting on the color attachment output stage itself.</p>
<pre><code class="language-rust noplaypen">    .dst_stage_mask(vk::PipelineStageFlags::COLOR_ATTACHMENT_OUTPUT)
    .dst_access_mask(vk::AccessFlags::COLOR_ATTACHMENT_WRITE);
</code></pre>
<p>The operations that should wait on this are in the color attachment stage and involve the writing of the color attachment. These settings will prevent the transition from happening until it's actually necessary (and allowed): when we want to start writing colors to it.</p>
<pre><code class="language-rust noplaypen">let attachments = &amp;[color_attachment];
let subpasses = &amp;[subpass];
let dependencies = &amp;[dependency];
let info = vk::RenderPassCreateInfo::builder()
    .attachments(attachments)
    .subpasses(subpasses)
    .dependencies(dependencies);
</code></pre>
<p>The <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.RenderPassCreateInfo.html"><code class="hljs">vk::RenderPassCreateInfo</code></a> struct has a field to specify an array of dependencies.</p>
<h2 id="presentation"><a class="header" href="#presentation">Presentation</a></h2>
<p>The last step of drawing a frame is submitting the result back to the swapchain to have it eventually show up on the screen. Presentation is configured through a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PresentInfoKHR.html"><code class="hljs">vk::PresentInfoKHR</code></a> structure at the end of the <code>App::render</code> function.</p>
<pre><code class="language-rust noplaypen">let swapchains = &amp;[self.data.swapchain];
let image_indices = &amp;[image_index as u32];
let present_info = vk::PresentInfoKHR::builder()
    .wait_semaphores(signal_semaphores)
    .swapchains(swapchains)
    .image_indices(image_indices);
</code></pre>
<p>The first parameter specifies which semaphores to wait on before presentation can happen, just like <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SubmitInfo.html"><code class="hljs">vk::SubmitInfo</code></a>.</p>
<p>The next two parameters specify the swapchains to present images to and the index of the image for each swapchain. This will almost always be a single one.</p>
<p>There is one last optional parameter called <code>results</code>. It allows you to specify an array of <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Result.html"><code class="hljs">vk::Result</code></a> values to check for every individual swapchain if presentation was successful. It's not necessary if you're only using a single swapchain, because you can simply use the return value of the present function.</p>
<pre><code class="language-rust noplaypen">self.device.queue_present_khr(self.data.present_queue, &amp;present_info)?;
</code></pre>
<p>The <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.KhrSwapchainExtension.html#method.queue_present_khr"><code class="hljs">queue_present_khr</code></a> function submits the request to present an image to the swapchain. We'll modify the error handling for both <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.KhrSwapchainExtension.html#method.acquire_next_image_khr"><code class="hljs">acquire_next_image_khr</code></a> and <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.KhrSwapchainExtension.html#method.queue_present_khr"><code class="hljs">queue_present_khr</code></a> in the next chapter, because their failure does not necessarily mean that the program should terminate, unlike the functions we've seen so far.</p>
<p>If you did everything correctly up to this point, then you should now see something resembling the following when you run your program:</p>
<p><img src="drawing/../images/triangle.png" alt="" /></p>
<blockquote>
<p>This colored triangle may look a bit different from the one you're used to seeing in graphics tutorials. That's because this tutorial lets the shader interpolate in linear color space and converts to sRGB color space afterwards. See <a href="https://medium.com/@heypete/hello-triangle-meet-swift-and-wide-color-6f9e246616d9">this blog post</a> for a discussion of the difference.</p>
</blockquote>
<p>Yay! Unfortunately, you'll see that when validation layers are enabled, the program crashes as soon as you close it. The messages printed to the terminal from <code>debug_callback</code> tell us why:</p>
<p><img src="drawing/../images/semaphore_in_use.png" alt="" /></p>
<p>Remember that all of the operations in <code>App::render</code> are asynchronous. That means that when we call <code>App::destroy</code> before exiting the loop in <code>main</code>, drawing and presentation operations may still be going on. Cleaning up resources while that is happening is a bad idea.</p>
<p>To fix that problem, we should wait for the logical device to finish operations using <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.device_wait_idle"><code class="hljs">device_wait_idle</code></a> before calling <code>App::destroy</code>:</p>
<pre><code class="language-rust noplaypen">Event::WindowEvent { event: WindowEvent::CloseRequested, .. } =&gt; {
    destroying = true;
    *control_flow = ControlFlow::Exit;
    unsafe { app.device.device_wait_idle().unwrap(); }
    unsafe { app.destroy(); }
}
</code></pre>
<p>You can also wait for operations in a specific command queue to be finished with <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.queue_wait_idle"><code class="hljs">queue_wait_idle</code></a>. These functions can be used as a very rudimentary way to perform synchronization. You'll see that the program no longer crashes when closing the window (though you will see some errors related to synchronization if you have the validation layers enabled).</p>
<h2 id="frames-in-flight"><a class="header" href="#frames-in-flight">Frames in flight</a></h2>
<p>If you run your application with validation layers enabled now you may either get errors or notice that the memory usage slowly grows. The reason for this is that the application is rapidly submitting work in the <code>App::render</code> function, but doesn't actually check if any of it finishes. If the CPU is submitting work faster than the GPU can keep up with then the queue will slowly fill up with work. Worse, even, is that we are reusing the <code>image_available_semaphore</code> and <code>render_finished_semaphore</code> semaphores, along with the command buffers, for multiple frames at the same time!</p>
<p>The easy way to solve this is to wait for work to finish right after submitting it, for example by using <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.queue_wait_idle"><code class="hljs">queue_wait_idle</code></a> (note: don't actually make this change):</p>
<pre><code class="language-rust noplaypen">unsafe fn render(&amp;mut self, window: &amp;Window) -&gt; Result&lt;()&gt; {
    // ...

    self.device.queue_present_khr(self.data.present_queue, &amp;present_info)?;
    self.device.queue_wait_idle(self.data.present_queue)?;

    Ok(())
}
</code></pre>
<p>However, we are likely not optimally using the GPU in this way, because the whole graphics pipeline is only used for one frame at a time right now. The stages that the current frame has already progressed through are idle and could already be used for a next frame. We will now extend our application to allow for multiple frames to be <em>in-flight</em> while still bounding the amount of work that piles up.</p>
<p>Start by adding a constant at the top of the program that defines how many frames should be processed concurrently:</p>
<pre><code class="language-rust noplaypen">const MAX_FRAMES_IN_FLIGHT: usize = 2;
</code></pre>
<p>Each frame should have its own set of semaphores in <code>AppData</code>:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    image_available_semaphores: Vec&lt;vk::Semaphore&gt;,
    render_finished_semaphores: Vec&lt;vk::Semaphore&gt;,
}
</code></pre>
<p>The <code>create_sync_objects</code> function should be changed to create all of these:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_sync_objects(device: &amp;Device, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    let semaphore_info = vk::SemaphoreCreateInfo::builder();

    for _ in 0..MAX_FRAMES_IN_FLIGHT {
        data.image_available_semaphores
            .push(device.create_semaphore(&amp;semaphore_info, None)?);
        data.render_finished_semaphores
            .push(device.create_semaphore(&amp;semaphore_info, None)?);
    }

    Ok(())
}
</code></pre>
<p>Similarly, they should also all be cleaned up:</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy(&amp;mut self) {
    self.data.render_finished_semaphores
        .iter()
        .for_each(|s| self.device.destroy_semaphore(*s, None));
    self.data.image_available_semaphores
        .iter()
        .for_each(|s| self.device.destroy_semaphore(*s, None));
    // ...
}
</code></pre>
<p>To use the right pair of semaphores every time, we need to keep track of the current frame. We will use a frame index for that purpose which we'll add to <code>App</code> (initialize it to <code>0</code> in <code>App::create</code>):</p>
<pre><code class="language-rust noplaypen">struct App {
    // ...
    frame: usize,
}
</code></pre>
<p>The <code>App::render</code> function can now be modified to use the right objects:</p>
<pre><code class="language-rust noplaypen">unsafe fn render(&amp;mut self, window: &amp;Window) -&gt; Result&lt;()&gt; {
    let image_index = self
        .device
        .acquire_next_image_khr(
            self.data.swapchain,
            u64::MAX,
            self.data.image_available_semaphores[self.frame],
            vk::Fence::null(),
        )?
        .0 as usize;

    // ...

    let wait_semaphores = &amp;[self.data.image_available_semaphores[self.frame]];

    // ...

    let signal_semaphores = &amp;[self.data.render_finished_semaphores[self.frame]];

    // ...

    Ok(())
}
</code></pre>
<p>Of course, we shouldn't forget to advance to the next frame every time:</p>
<pre><code class="language-rust noplaypen">unsafe fn render(&amp;mut self, window: &amp;Window) -&gt; Result&lt;()&gt; {
    // ...

    self.frame = (self.frame + 1) % MAX_FRAMES_IN_FLIGHT;

    Ok(())
}
</code></pre>
<p>By using the modulo (%) operator, we ensure that the frame index loops around after every <code>MAX_FRAMES_IN_FLIGHT</code> enqueued frames.</p>
<p>Although we've now set up the required objects to facilitate processing of multiple frames simultaneously, we still don't actually prevent more than <code>MAX_FRAMES_IN_FLIGHT</code> from being submitted. Right now there is only GPU-GPU synchronization and no CPU-GPU synchronization going on to keep track of how the work is going. We may be using the frame #0 objects while frame #0 is still in-flight!</p>
<p>To perform CPU-GPU synchronization, Vulkan offers a second type of synchronization primitive called <em>fences</em>. Fences are similar to semaphores in the sense that they can be signaled and waited for, but this time we actually wait for them in our own code. We'll first create a fence for each frame in <code>AppData</code>:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    in_flight_fences: Vec&lt;vk::Fence&gt;,
}
</code></pre>
<p>We'll create the fences together with the semaphores in the <code>create_sync_objects</code> function:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_sync_objects(device: &amp;Device, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    let semaphore_info = vk::SemaphoreCreateInfo::builder();
    let fence_info = vk::FenceCreateInfo::builder();

    for _ in 0..MAX_FRAMES_IN_FLIGHT {
        data.image_available_semaphores
            .push(device.create_semaphore(&amp;semaphore_info, None)?);
        data.render_finished_semaphores
            .push(device.create_semaphore(&amp;semaphore_info, None)?);

        data.in_flight_fences.push(device.create_fence(&amp;fence_info, None)?);
    }

    Ok(())
}
</code></pre>
<p>The creation of fences (<a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Fence.html"><code class="hljs">vk::Fence</code></a>) is very similar to the creation of semaphores. Also make sure to clean up the fences in <code>App::destroy</code>:</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy(&amp;mut self) {
    self.data.in_flight_fences
        .iter()
        .for_each(|f| self.device.destroy_fence(*f, None));
    // ...
}
</code></pre>
<p>We will now change <code>App::render</code> to use the fences for synchronization. The <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.queue_submit"><code class="hljs">queue_submit</code></a> call includes an optional parameter to pass a fence that should be signaled when the command buffer finishes executing. We can use this to signal that a frame has finished.</p>
<pre><code class="language-rust noplaypen">unsafe fn render(&amp;mut self, window: &amp;Window) -&gt; Result&lt;()&gt; {
    // ...

    self.device.queue_submit(
        self.data.graphics_queue,
        &amp;[submit_info],
        self.data.in_flight_fences[self.frame],
    )?;

    // ...
}
</code></pre>
<p>Now the only thing remaining is to change the beginning of <code>App::render</code> to wait for the frame to be finished:</p>
<pre><code class="language-rust noplaypen">unsafe fn render(&amp;mut self, window: &amp;Window) -&gt; Result&lt;()&gt; {
    self.device.wait_for_fences(
        &amp;[self.data.in_flight_fences[self.frame]],
        true,
        u64::MAX,
    )?;

    self.device.reset_fences(&amp;[self.data.in_flight_fences[self.frame]])?;

    // ...
}
</code></pre>
<p>The <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.wait_for_fences"><code class="hljs">wait_for_fences</code></a> function takes an array of fences and waits for either any or all of them to be signaled before returning. The <code>true</code> we pass here indicates that we want to wait for all fences, but in the case of a single one it obviously doesn't matter. Just like <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.KhrSwapchainExtension.html#method.acquire_next_image_khr"><code class="hljs">acquire_next_image_khr</code></a> this function also takes a timeout. Unlike the semaphores, we manually need to restore the fence to the unsignaled state by resetting it with the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.reset_fences"><code class="hljs">reset_fences</code></a> call.</p>
<p>If you run the program now, you'll notice something something strange. The application no longer seems to be rendering anything and might even be frozen.</p>
<p>That means that we're waiting for a fence that has not been submitted. The problem here is that, by default, fences are created in the unsignaled state. That means that <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.wait_for_fences"><code class="hljs">wait_for_fences</code></a> will wait forever if we haven't used the fence before. To solve that, we can change the fence creation to initialize it in the signaled state as if we had rendered an initial frame that finished:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_sync_objects(device: &amp;Device, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    // ...

    let fence_info = vk::FenceCreateInfo::builder()
        .flags(vk::FenceCreateFlags::SIGNALED);

    // ...
}
</code></pre>
<p>The memory leak is gone now, but the program is not quite working correctly yet. If <code>MAX_FRAMES_IN_FLIGHT</code> is higher than the number of swapchain images or <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.KhrSwapchainExtension.html#method.acquire_next_image_khr"><code class="hljs">acquire_next_image_khr</code></a> returns images out-of-order then it's possible that we may start rendering to a swapchain image that is already <em>in flight</em>. To avoid this, we need to track for each swapchain image if a frame in flight is currently using it. This mapping will refer to frames in flight by their fences so we'll immediately have a synchronization object to wait on before a new frame can use that image.</p>
<p>First add a new list called <code>images_in_flight</code> to <code>AppData</code> to track this:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    in_flight_fences: Vec&lt;vk::Fence&gt;,
    images_in_flight: Vec&lt;vk::Fence&gt;,
}
</code></pre>
<p>Prepare it in <code>create_sync_objects</code>:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_sync_objects(device: &amp;Device, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    // ...

    data.images_in_flight = data.swapchain_images
        .iter()
        .map(|_| vk::Fence::null())
        .collect();

    Ok(())
}
</code></pre>
<p>Initially not a single frame is using an image so we explicitly initialize it to <em>no fence</em>. Now we'll modify <code>App::render</code> to wait on any previous frame that is using the image that we've just been assigned for the new frame:</p>
<pre><code class="language-rust noplaypen">unsafe fn render(&amp;mut self, window: &amp;Window) -&gt; Result&lt;()&gt; {
    // ...

    let image_index = self
        .device
        .acquire_next_image_khr(
            self.data.swapchain,
            u64::MAX,
            self.data.image_available_semaphores[self.frame],
            vk::Fence::null(),
        )?
        .0 as usize;

    if !self.data.images_in_flight[image_index as usize].is_null() {
        self.device.wait_for_fences(
            &amp;[self.data.images_in_flight[image_index as usize]],
            true,
            u64::MAX,
        )?;
    }

    self.data.images_in_flight[image_index as usize] =
        self.data.in_flight_fences[self.frame];

    // ...
}
</code></pre>
<p>Because we now have more calls to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.wait_for_fences"><code class="hljs">wait_for_fences</code></a>, the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.reset_fences"><code class="hljs">reset_fences</code></a> call should be <strong>moved</strong>. It's best to simply call it right before actually using the fence:</p>
<pre><code class="language-rust noplaypen">unsafe fn render(&amp;mut self, window: &amp;Window) -&gt; Result&lt;()&gt; {
    // ...

    self.device.reset_fences(&amp;[self.data.in_flight_fences[self.frame]])?;

    self.device.queue_submit(
        self.data.graphics_queue,
        &amp;[submit_info],
        self.data.in_flight_fences[self.frame],
    )?;

    // ...
}
</code></pre>
<p>We've now implemented all the needed synchronization to ensure that there are no more than two frames of work enqueued and that these frames are not accidentally using the same image. Note that it is fine for other parts of the code, like the final cleanup, to rely on more rough synchronization like <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.device_wait_idle"><code class="hljs">device_wait_idle</code></a>. You should decide on which approach to use based on performance requirements.</p>
<p>To learn more about synchronization through examples, have a look at <a href="https://github.com/KhronosGroup/Vulkan-Docs/wiki/Synchronization-Examples#swapchain-image-acquire-and-present">this extensive overview</a> by Khronos.</p>
<h2 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h2>
<p>A little over 600 (non-empty) lines of code later, we've finally gotten to the stage of seeing something pop up on the screen! Bootstrapping a Vulkan program is definitely a lot of work, but the take-away message is that Vulkan gives you an immense amount of control through its explicitness. I recommend you to take some time now to reread the code and build a mental model of the purpose of all of the Vulkan objects in the program and how they relate to each other. We'll be building on top of that knowledge to extend the functionality of the program from this point on.</p>
<p>In the next chapter we'll deal with one more small thing that is required for a well-behaved Vulkan program.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recreation"><a class="header" href="#recreation">Recreation</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/16_swapchain_recreation.rs">main.rs</a></p>
<p>The application we have now successfully draws a triangle, but there are some circumstances that it isn't handling properly yet. It is possible for the window surface to change such that the swapchain is no longer compatible with it. One of the reasons that could cause this to happen is the size of the window changing. We have to catch these events and recreate the swapchain.</p>
<h2 id="recreating-the-swapchain"><a class="header" href="#recreating-the-swapchain">Recreating the swapchain</a></h2>
<p>Create a new <code>App::recreate_swapchain</code> method that calls <code>create_swapchain</code> and all of the creation functions for the objects that depend on the swapchain or the window size.</p>
<pre><code class="language-rust noplaypen">unsafe fn recreate_swapchain(&amp;mut self, window: &amp;Window) -&gt; Result&lt;()&gt; {
    self.device.device_wait_idle()?;
    create_swapchain(window, &amp;self.instance, &amp;self.device, &amp;mut self.data)?;
    create_swapchain_image_views(&amp;self.device, &amp;mut self.data)?;
    create_render_pass(&amp;self.instance, &amp;self.device, &amp;mut self.data)?;
    create_pipeline(&amp;self.device, &amp;mut self.data)?;
    create_framebuffers(&amp;self.device, &amp;mut self.data)?;
    create_command_buffers(&amp;self.device, &amp;mut self.data)?;
    self.data
        .images_in_flight
        .resize(self.data.swapchain_images.len(), vk::Fence::null());
    Ok(())
}
</code></pre>
<p>We first call <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.device_wait_idle"><code class="hljs">device_wait_idle</code></a>, because just like in the last chapter, we shouldn't touch resources that may still be in use. Obviously, the first thing we'll have to do is recreate the swapchain itself. The image views need to be recreated because they are based directly on the swapchain images. The render pass needs to be recreated because it depends on the format of the swapchain images. It is rare for the swapchain image format to change during an operation like a window resize, but it should still be handled. Viewport and scissor rectangle size is specified during graphics pipeline creation, so the pipeline also needs to be rebuilt. It is possible to avoid this by using dynamic state for the viewports and scissor rectangles. Then, the framebuffers and command buffers also directly depend on the swapchain images. Lastly we resize our list of fences for the swapchain images since there is a possibility that there might be a different number of swapchain images after recreation.</p>
<p>To make sure that the old versions of these objects are cleaned up before recreating them, we should move some of the cleanup code to a separate method that we can call from the <code>App::recreate_swapchain</code> method after waiting for the device to be idle. Let's call it <code>App::destroy_swapchain</code>:</p>
<pre><code class="language-rust noplaypen">unsafe fn recreate_swapchain(&amp;mut self, window: &amp;Window) -&gt; Result&lt;()&gt; {
    self.device.device_wait_idle()?;
    self.destroy_swapchain();
    // ...
}

unsafe fn destroy_swapchain(&amp;mut self) {

}
</code></pre>
<p>We'll move the cleanup code of all objects that are recreated as part of a swapchain refresh from <code>App::destroy</code> to <code>App::destroy_swapchain</code>:</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy(&amp;mut self) {
    self.destroy_swapchain();

    self.data.in_flight_fences
        .iter()
        .for_each(|f| self.device.destroy_fence(*f, None));
    self.data.render_finished_semaphores
        .iter()
        .for_each(|s| self.device.destroy_semaphore(*s, None));
    self.data.image_available_semaphores
        .iter()
        .for_each(|s| self.device.destroy_semaphore(*s, None));
    self.device.destroy_command_pool(self.data.command_pool, None);
    self.device.destroy_device(None);
    self.instance.destroy_surface_khr(self.data.surface, None);

    if VALIDATION_ENABLED {
        self.instance.destroy_debug_utils_messenger_ext(self.data.messenger, None);
    }

    self.instance.destroy_instance(None);
}

unsafe fn destroy_swapchain(&amp;mut self) {
    self.data.framebuffers
        .iter()
        .for_each(|f| self.device.destroy_framebuffer(*f, None));
    self.device.free_command_buffers(self.data.command_pool, &amp;self.data.command_buffers);
    self.device.destroy_pipeline(self.data.pipeline, None);
    self.device.destroy_pipeline_layout(self.data.pipeline_layout, None);
    self.device.destroy_render_pass(self.data.render_pass, None);
    self.data.swapchain_image_views
        .iter()
        .for_each(|v| self.device.destroy_image_view(*v, None));
    self.device.destroy_swapchain_khr(self.data.swapchain, None);
}
</code></pre>
<p>We could recreate the command pool from scratch, but that is rather wasteful. Instead I've opted to clean up the existing command buffers with the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.free_command_buffers"><code class="hljs">free_command_buffers</code></a> command. This way we can reuse the existing pool to allocate the new command buffers.</p>
<p>That's all it takes to recreate the swapchain! However, the disadvantage of this approach is that we need to stop all rendering before creating the new swapchain. It is possible to create a new swapchain while drawing commands on an image from the old swapchain are still in-flight. You need to pass the previous swapchain to the <code>old_swapchain</code> field in the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SwapchainCreateInfoKHR.html"><code class="hljs">vk::SwapchainCreateInfoKHR</code></a> struct and destroy the old swapchain as soon as you've finished using it.</p>
<h2 id="suboptimal-or-out-of-date-swapchain"><a class="header" href="#suboptimal-or-out-of-date-swapchain">Suboptimal or out-of-date swapchain</a></h2>
<p>Now we just need to figure out when swapchain recreation is necessary and call our new <code>App::recreate_swapchain</code> method. Luckily, Vulkan will usually just tell us that the swapchain is no longer adequate during presentation. The <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.KhrSwapchainExtension.html#method.acquire_next_image_khr"><code class="hljs">acquire_next_image_khr</code></a> and <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.KhrSwapchainExtension.html#method.queue_present_khr"><code class="hljs">queue_present_khr</code></a> commands can return the following special values to indicate this.</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ErrorCode.html#associatedconstant.OUT_OF_DATE_KHR"><code class="hljs">vk::ErrorCode::OUT_OF_DATE_KHR</code></a> – The swapchain has become incompatible with the surface and can no longer be used for rendering. Usually happens after a window resize.</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SuccessCode.html#associatedconstant.SUBOPTIMAL_KHR"><code class="hljs">vk::SuccessCode::SUBOPTIMAL_KHR</code></a> – The swapchain can still be used to successfully present to the surface, but the surface properties are no longer matched exactly.</li>
</ul>
<pre><code class="language-rust noplaypen">let result = self.device.acquire_next_image_khr(
    self.data.swapchain,
    u64::MAX,
    self.data.image_available_semaphores[self.frame],
    vk::Fence::null(),
);

let image_index = match result {
    Ok((image_index, _)) =&gt; image_index as usize,
    Err(vk::ErrorCode::OUT_OF_DATE_KHR) =&gt; return self.recreate_swapchain(window),
    Err(e) =&gt; return Err(anyhow!(e)),
};
</code></pre>
<p>If the swapchain turns out to be out of date when attempting to acquire an image, then it is no longer possible to present to it. Therefore we should immediately recreate the swapchain and try again in the next <code>App::render</code> call.</p>
<p>You could also decide to do that if the swapchain is suboptimal, but I've chosen to proceed anyway in that case because we've already acquired an image. Since <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SuccessCode.html#associatedconstant.SUBOPTIMAL_KHR"><code class="hljs">vk::SuccessCode::SUBOPTIMAL_KHR</code></a> is considered a success code rather than an error code, it will be handled by the <code>Ok</code> arm in the <code>match</code> block.</p>
<pre><code class="language-rust noplaypen">let result = self.device.queue_present_khr(self.data.present_queue, &amp;present_info);

let changed = result == Ok(vk::SuccessCode::SUBOPTIMAL_KHR)
    || result == Err(vk::ErrorCode::OUT_OF_DATE_KHR);

if changed {
    self.recreate_swapchain(window)?;
} else if let Err(e) = result {
    return Err(anyhow!(e));
}
</code></pre>
<p>The <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.KhrSwapchainExtension.html#method.queue_present_khr"><code class="hljs">queue_present_khr</code></a> function returns the same values with the same meaning. In this case we will also recreate the swapchain if it is suboptimal, because we want the best possible result.</p>
<h2 id="handling-resizes-explicitly"><a class="header" href="#handling-resizes-explicitly">Handling resizes explicitly</a></h2>
<p>Although many drivers and platforms trigger <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ErrorCode.html#associatedconstant.OUT_OF_DATE_KHR"><code class="hljs">vk::ErrorCode::OUT_OF_DATE_KHR</code></a> automatically after a window resize, it is not guaranteed to happen. That's why we'll add some extra code to also handle resizes explicitly. First add a new field to the <code>App</code> struct to track whether a resize has happpened:</p>
<pre><code class="language-rust noplaypen">struct App {
    // ...
    resized: bool,
}
</code></pre>
<p>Don't forget to initialize this new field to <code>false</code> in <code>App::create</code>. The <code>App::render</code> method should then be modified to also check for this flag after calling <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.KhrSwapchainExtension.html#method.queue_present_khr"><code class="hljs">queue_present_khr</code></a>:</p>
<pre><code class="language-rust noplaypen">let result = self.device.queue_present_khr(self.data.present_queue, &amp;present_info);

let changed = result == Ok(vk::SuccessCode::SUBOPTIMAL_KHR)
    || result == Err(vk::ErrorCode::OUT_OF_DATE_KHR);

if self.resized || changed {
    self.resized = false;
    self.recreate_swapchain(window)?;
} else if let Err(e) = result {
    return Err(anyhow!(e));
}
</code></pre>
<p>It is important to do this after <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.KhrSwapchainExtension.html#method.queue_present_khr"><code class="hljs">queue_present_khr</code></a> to ensure that the semaphores are in a consistent state, otherwise a signalled semaphore may never be properly waited upon. Now to actually detect resizes we can add an arm to our window event <code>match</code> block in <code>main</code>:</p>
<pre><code class="language-rust noplaypen">match event {
    // ...
    Event::WindowEvent { event: WindowEvent::Resized(_), .. } =&gt; app.resized = true,
    // ...
}
</code></pre>
<p>Now try to run the program and resize the window to see if the framebuffer is indeed resized properly with the window.</p>
<h2 id="handling-minimization"><a class="header" href="#handling-minimization">Handling minimization</a></h2>
<p>There is another case where a swapchain may become out of date and that is a special kind of window resizing: window minimization. This case is special because it will result in a framebuffer size of <code>0</code>. In this tutorial we will handle that by not rendering frames while the window is minimized:</p>
<pre><code class="language-rust noplaypen">let mut app = unsafe { App::create(&amp;window)? };
let mut minimized = false;
event_loop.run(move |event,elwt| {
    match event {
        // ...
        Event::WindowEvent { event, .. } =&gt; match event {
            WindowEvent::RedrawRequested if !elwt.exiting() &amp;&amp; !minimized =&gt; {
                unsafe { app.render(&amp;window) }.unwrap();
            },
            WindowEvent::Resized(size) =&gt; {
                if size.width == 0 || size.height == 0 {
                    minimized = true;
                } else {
                    minimized = false;
                    app.resized = true;
                }
            }
            // ...
        }
        // ...
    }
})?;
</code></pre>
<p>Congratulations, you've now finished your very first well-behaved Vulkan program! In the next chapter we're going to get rid of the hardcoded vertices in the vertex shader and actually use a vertex buffer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vertex-input-description"><a class="header" href="#vertex-input-description">Vertex input description</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/17_vertex_input.rs">main.rs</a> | <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/shaders/17/shader.vert">shader.vert</a> | <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/shaders/17/shader.frag">shader.frag</a></p>
<p>In the next few chapters, we're going to replace the hardcoded vertex data in the vertex shader with a vertex buffer in memory. We'll start with the easiest approach of creating a CPU visible buffer copying the vertex data into it directly, and after that we'll see how to use a staging buffer to copy the vertex data to high performance memory.</p>
<h2 id="vertex-shader-1"><a class="header" href="#vertex-shader-1">Vertex shader</a></h2>
<p>First change the vertex shader to no longer include the vertex data in the shader code itself. The vertex shader takes input from a vertex buffer using the <code>in</code> keyword.</p>
<pre><code class="language-glsl">#version 450

layout(location = 0) in vec2 inPosition;
layout(location = 1) in vec3 inColor;

layout(location = 0) out vec3 fragColor;

void main() {
    gl_Position = vec4(inPosition, 0.0, 1.0);
    fragColor = inColor;
}
</code></pre>
<p>The <code>inPosition</code> and <code>inColor</code> variables are <em>vertex attributes</em>. They're properties that are specified per-vertex in the vertex buffer, just like we manually specified a position and color per vertex using the two arrays. Make sure to recompile the vertex shader!</p>
<p>Just like <code>fragColor</code>, the <code>layout(location = x)</code> annotations assign indices to the inputs that we can later use to reference them. It is important to know that some types, like <code>dvec3</code> 64 bit vectors, use multiple <em>slots</em>. That means that the index after it must be at least 2 higher:</p>
<pre><code class="language-glsl">layout(location = 0) in dvec3 inPosition;
layout(location = 2) in vec3 inColor;
</code></pre>
<p>You can find more info about the layout qualifier in the <a href="https://www.khronos.org/opengl/wiki/Layout_Qualifier_(GLSL)">OpenGL wiki</a>.</p>
<h2 id="vertex-data"><a class="header" href="#vertex-data">Vertex data</a></h2>
<p>We're moving the vertex data from the shader code to an array in the code of our program. We'll start by adding a few more imports and several type aliases to our program.</p>
<pre><code class="language-rust noplaypen">use std::mem::size_of;

use cgmath::{vec2, vec3};

type Vec2 = cgmath::Vector2&lt;f32&gt;;
type Vec3 = cgmath::Vector3&lt;f32&gt;;
</code></pre>
<p><code>size_of</code> will be used to calculate the size of the vertex data we'll be defining while <code>cgmath</code> defines the vector types we need.</p>
<p>Next, create a new <code>#[repr(C)]</code> structure called <code>Vertex</code> with the two attributes that we're going to use in the vertex shader inside it and add a simple constructor:</p>
<pre><code class="language-rust noplaypen">#[repr(C)]
#[derive(Copy, Clone, Debug)]
struct Vertex {
    pos: Vec2,
    color: Vec3,
}

impl Vertex {
    const fn new(pos: Vec2, color: Vec3) -&gt; Self {
        Self { pos, color }
    }
}
</code></pre>
<p><code>cgmath</code> conveniently provides us with Rust types that exactly match the vector types used in the shader language.</p>
<pre><code class="language-rust noplaypen">static VERTICES: [Vertex; 3] = [
    Vertex::new(vec2(0.0, -0.5), vec3(1.0, 0.0, 0.0)),
    Vertex::new(vec2(0.5, 0.5), vec3(0.0, 1.0, 0.0)),
    Vertex::new(vec2(-0.5, 0.5), vec3(0.0, 0.0, 1.0)),
];
</code></pre>
<p>Now use the <code>Vertex</code> structure to specify a list of vertex data. We're using exactly the same position and color values as before, but now they're combined into one array of vertices. This is known as <em>interleaving</em> vertex attributes.</p>
<h2 id="binding-descriptions"><a class="header" href="#binding-descriptions">Binding descriptions</a></h2>
<p>The next step is to tell Vulkan how to pass this data format to the vertex shader once it's been uploaded into GPU memory. There are two types of structures needed to convey this information.</p>
<p>The first structure is <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.VertexInputBindingDescription.html"><code class="hljs">vk::VertexInputBindingDescription</code></a> and we'll add a method to the <code>Vertex</code> struct to populate it with the right data.</p>
<pre><code class="language-rust noplaypen">impl Vertex {
    fn binding_description() -&gt; vk::VertexInputBindingDescription {
    }
}
</code></pre>
<p>A vertex binding describes at which rate to load data from memory throughout the vertices. It specifies the number of bytes between data entries and whether to move to the next data entry after each vertex or after each instance.</p>
<pre><code class="language-rust noplaypen">vk::VertexInputBindingDescription::builder()
    .binding(0)
    .stride(size_of::&lt;Vertex&gt;() as u32)
    .input_rate(vk::VertexInputRate::VERTEX)
    .build()
</code></pre>
<p>All of our per-vertex data is packed together in one array, so we're only going to have one binding. The <code>binding</code> parameter specifies the index of the binding in the array of bindings. The <code>stride</code> parameter specifies the number of bytes from one entry to the next, and the <code>input_rate</code> parameter can have one of the following values:</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.VertexInputRate.html#associatedconstant.VERTEX"><code class="hljs">vk::VertexInputRate::VERTEX</code></a> – Move to the next data entry after each vertex</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.VertexInputRate.html#associatedconstant.INSTANCE"><code class="hljs">vk::VertexInputRate::INSTANCE</code></a> – Move to the next data entry after each instance</li>
</ul>
<p>We're not going to use instanced rendering, so we'll stick to per-vertex data.</p>
<h2 id="attribute-descriptions"><a class="header" href="#attribute-descriptions">Attribute descriptions</a></h2>
<p>The second structure that describes how to handle vertex input is <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.VertexInputAttributeDescription.html"><code class="hljs">vk::VertexInputAttributeDescription</code></a>. We're going to add another helper method to <code>Vertex</code> to fill in these structs.</p>
<pre><code class="language-rust noplaypen">impl Vertex {
    fn attribute_descriptions() -&gt; [vk::VertexInputAttributeDescription; 2] {
    }
}
</code></pre>
<p>As the function prototype indicates, there are going to be two of these structures. An attribute description struct describes how to extract a vertex attribute from a chunk of vertex data originating from a binding description. We have two attributes, position and color, so we need two attribute description structs.</p>
<pre><code class="language-rust noplaypen">let pos = vk::VertexInputAttributeDescription::builder()
    .binding(0)
    .location(0)
    .format(vk::Format::R32G32_SFLOAT)
    .offset(0)
    .build();
</code></pre>
<p>The <code>binding</code> parameter tells Vulkan from which binding the per-vertex data comes. The <code>location</code> parameter references the <code>location</code> directive of the input in the vertex shader. The input in the vertex shader with location <code>0</code> is the position, which has two 32-bit float components.</p>
<p>The <code>format</code> parameter describes the type of data for the attribute. A bit confusingly, the formats are specified using the same enumeration as color formats. The following shader types and formats are commonly used together:</p>
<ul>
<li><code>f32</code> – <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Format.html#associatedconstant.R32_SFLOAT"><code class="hljs">vk::Format::R32_SFLOAT</code></a> </li>
<li><code>cgmath::Vector2&lt;f32&gt;</code> (our <code>Vec2</code>) – <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Format.html#associatedconstant.R32G32_SFLOAT"><code class="hljs">vk::Format::R32G32_SFLOAT</code></a> </li>
<li><code>cgmath::Vector3&lt;f32&gt;</code> (our <code>Vec3</code>) – <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Format.html#associatedconstant.R32G32B32_SFLOAT"><code class="hljs">vk::Format::R32G32B32_SFLOAT</code></a> </li>
<li><code>cgmath::Vector4&lt;f32&gt;</code> – <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Format.html#associatedconstant.R32G32B32A32_SFLOAT"><code class="hljs">vk::Format::R32G32B32A32_SFLOAT</code></a> </li>
</ul>
<p>As you can see, you should use the format where the amount of color channels matches the number of components in the shader data type. It is allowed to use more channels than the number of components in the shader, but they will be silently discarded. If the number of channels is lower than the number of components, then the BGA components will use default values of <code>(0, 0, 1)</code>. The color type (<code>SFLOAT</code>, <code>UINT</code>, <code>SINT</code>) and bit width should also match the type of the shader input. See the following examples:</p>
<ul>
<li><code>cgmath::Vector2&lt;i32&gt;</code> – <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Format.html#associatedconstant.R32G32_SINT"><code class="hljs">vk::Format::R32G32_SINT</code></a>, a 2-component vector of <code>i32</code>s</li>
<li><code>cgmath::Vector4&lt;u32&gt;</code> – <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Format.html#associatedconstant.R32G32B32A32_UINT"><code class="hljs">vk::Format::R32G32B32A32_UINT</code></a>, a 4-component vector of <code>u32</code>s</li>
<li><code>f64</code> – <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Format.html#associatedconstant.R64_SFLOAT"><code class="hljs">vk::Format::R64_SFLOAT</code></a>, a double-precision (64-bit) float</li>
</ul>
<p>The <code>format</code> parameter implicitly defines the byte size of attribute data and the <code>offset</code> parameter specifies the number of bytes since the start of the per-vertex data to read from. The binding is loading one <code>Vertex</code> at a time and the position attribute (<code>pos</code>) is at an offset of <code>0</code> bytes from the beginning of this struct.</p>
<pre><code class="language-rust noplaypen">let color = vk::VertexInputAttributeDescription::builder()
    .binding(0)
    .location(1)
    .format(vk::Format::R32G32B32_SFLOAT)
    .offset(size_of::&lt;Vec2&gt;() as u32)
    .build();
</code></pre>
<p>The color attribute is described in much the same way.</p>
<p>Lastly, construct the array to return from the helper method:</p>
<pre><code class="language-rust noplaypen">[pos, color]
</code></pre>
<h2 id="pipeline-vertex-input"><a class="header" href="#pipeline-vertex-input">Pipeline vertex input</a></h2>
<p>We now need to set up the graphics pipeline to accept vertex data in this format by referencing the structures in <code>create_pipeline</code>. Find the <code>vertex_input_state</code> struct and modify it to reference the two descriptions:</p>
<pre><code class="language-rust noplaypen">let binding_descriptions = &amp;[Vertex::binding_description()];
let attribute_descriptions = Vertex::attribute_descriptions();
let vertex_input_state = vk::PipelineVertexInputStateCreateInfo::builder()
    .vertex_binding_descriptions(binding_descriptions)
    .vertex_attribute_descriptions(&amp;attribute_descriptions);
</code></pre>
<p>The pipeline is now ready to accept vertex data in the format of the <code>vertices</code> container and pass it on to our vertex shader. If you run the program now with validation layers enabled, you'll see that it complains that there is no vertex buffer bound to the binding. The next step is to create a vertex buffer and move the vertex data to it so the GPU is able to access it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vertex-buffer-creation"><a class="header" href="#vertex-buffer-creation">Vertex buffer creation</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/18_vertex_buffer.rs">main.rs</a></p>
<p>Buffers in Vulkan are regions of memory used for storing arbitrary data that can be read by the graphics card. They can be used to store vertex data, which we'll do in this chapter, but they can also be used for many other purposes that we'll explore in future chapters. Unlike the Vulkan objects we've been dealing with so far, buffers do not automatically allocate memory for themselves. The work from the previous chapters has shown that the Vulkan API puts the programmer in control of almost everything and memory management is one of those things.</p>
<blockquote>
<p>While this tutorial will stick to using the Vulkan API to manage memory, many Vulkan applications in the real world use a higher-level abstraction such as <a href="https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator">Vulkan Memory Allocator</a> (VMA). VMA is a library that wraps the Vulkan API and makes managing memory much less laborious and difficult. The <a href="https://docs.rs/vulkanalia-vma"><code>vulkanalia-vma</code> crate</a> (part of the <code>vulkanalia</code> project) provides an integration of VMA with <code>vulkanalia</code>.</p>
</blockquote>
<h2 id="buffer-creation"><a class="header" href="#buffer-creation">Buffer creation</a></h2>
<p>Create a new function <code>create_vertex_buffer</code> and call it from <code>App::create</code> right before <code>create_command_buffers</code>.</p>
<pre><code class="language-rust noplaypen">impl App {
    unsafe fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        // ...
        create_vertex_buffer(&amp;instance, &amp;device, &amp;mut data)?;
        create_command_buffers(&amp;device, &amp;mut data)?;
        // ...
    }
}

unsafe fn create_vertex_buffer(
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;mut AppData,
) -&gt; Result&lt;()&gt; {
    Ok(())
}
</code></pre>
<p>Creating a buffer requires us to fill a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.BufferCreateInfo.html"><code class="hljs">vk::BufferCreateInfo</code></a> structure.</p>
<pre><code class="language-rust noplaypen">let buffer_info = vk::BufferCreateInfo::builder()
    .size((size_of::&lt;Vertex&gt;() * VERTICES.len()) as u64)
    // continued...
</code></pre>
<p>The first field of the struct is <code>size</code>, which specifies the size of the buffer in bytes. Calculating the byte size of the vertex data is straightforward with <code>size_of</code>.</p>
<pre><code class="language-rust noplaypen">    .usage(vk::BufferUsageFlags::VERTEX_BUFFER)
</code></pre>
<p>The second field is <code>usage</code>, which indicates for which purposes the data in the buffer is going to be used. It is possible to specify multiple purposes using a bitwise or. Our use case will be a vertex buffer, we'll look at other types of usage in future chapters.</p>
<pre><code class="language-rust noplaypen">    .sharing_mode(vk::SharingMode::EXCLUSIVE);
</code></pre>
<p>Just like the images in the swapchain, buffers can also be owned by a specific queue family or be shared between multiple at the same time. The buffer will only be used from the graphics queue, so we can stick to exclusive access.</p>
<pre><code class="language-rust noplaypen">    .flags(vk::BufferCreateFlags::empty()); // Optional.
</code></pre>
<p>The <code>flags</code> parameter is used to configure sparse buffer memory, which is not relevant right now. You can omit the builder method for this field which will set it to the default value (an empty set of flags).</p>
<p>We can now create the buffer with <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.create_buffer"><code class="hljs">create_buffer</code></a>. First, define an <code>AppData</code> field to hold the buffer handle and call it <code>vertex_buffer</code>.</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    vertex_buffer: vk::Buffer,
}
</code></pre>
<p>Next add the call to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.create_buffer"><code class="hljs">create_buffer</code></a>:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_vertex_buffer(
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;mut AppData,
) -&gt; Result&lt;()&gt; {
    let buffer_info = vk::BufferCreateInfo::builder()
        .size((size_of::&lt;Vertex&gt;() * VERTICES.len()) as u64)
        .usage(vk::BufferUsageFlags::VERTEX_BUFFER)
        .sharing_mode(vk::SharingMode::EXCLUSIVE);

    data.vertex_buffer = device.create_buffer(&amp;buffer_info, None)?;

    Ok(())
}
</code></pre>
<p>The buffer should be available for use in rendering commands until the end of the program and it does not depend on the swapchain, so we'll clean it up in the original <code>App::destroy</code> method:</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy(&amp;mut self) {
    self.destroy_swapchain();
    self.device.destroy_buffer(self.data.vertex_buffer, None);
    // ...
}
</code></pre>
<h2 id="memory-requirements"><a class="header" href="#memory-requirements">Memory requirements</a></h2>
<p>The buffer has been created, but it doesn't actually have any memory assigned to it yet. The first step of allocating memory for the buffer is to query its memory requirements using the aptly named <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.get_buffer_memory_requirements"><code class="hljs">get_buffer_memory_requirements</code></a> command.</p>
<pre><code class="language-rust noplaypen">let requirements = device.get_buffer_memory_requirements(data.vertex_buffer);
</code></pre>
<p>The <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.MemoryRequirements.html"><code class="hljs">vk::MemoryRequirements</code></a> struct this command returns has three fields:</p>
<ul>
<li><code>size</code> – The size of the required amount of memory in bytes, may differ from <code>bufferInfo.size</code>.</li>
<li><code>alignment</code> – The offset in bytes where the buffer begins in the allocated region of memory, depends on <code>buffer_info.usage</code> and <code>buffer_info.flags</code>.</li>
<li><code>memory_type_bits</code> – Bit field of the memory types that are suitable for the buffer.</li>
</ul>
<p>Graphics cards can offer different types of memory to allocate from. Each type of memory varies in terms of allowed operations and performance characteristics. We need to combine the requirements of the buffer and our own application requirements to find the right type of memory to use. Let's create a new function <code>get_memory_type_index</code> for this purpose.</p>
<pre><code class="language-rust noplaypen">unsafe fn get_memory_type_index(
    instance: &amp;Instance,
    data: &amp;AppData,
    properties: vk::MemoryPropertyFlags,
    requirements: vk::MemoryRequirements,
) -&gt; Result&lt;u32&gt; {
}
</code></pre>
<p>First we need to query info about the available types of memory using <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.InstanceV1_0.html#method.get_physical_device_memory_properties"><code class="hljs">get_physical_device_memory_properties</code></a>.</p>
<pre><code class="language-rust noplaypen">let memory = instance.get_physical_device_memory_properties(data.physical_device);
</code></pre>
<p>The returned <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PhysicalDeviceMemoryProperties.html"><code class="hljs">vk::PhysicalDeviceMemoryProperties</code></a> structure has two arrays <code>memory_types</code> and <code>memory_heaps</code>. Memory heaps are distinct memory resources like dedicated VRAM and swap space in RAM for when VRAM runs out. The different types of memory exist within these heaps. Right now we'll only concern ourselves with the type of memory and not the heap it comes from, but you can imagine that this can affect performance.</p>
<p>Let's first find a memory type that is suitable for the buffer itself:</p>
<pre><code class="language-rust noplaypen">(0..memory.memory_type_count)
    .find(|i| (requirements.memory_type_bits &amp; (1 &lt;&lt; i)) != 0)
    .ok_or_else(|| anyhow!(&quot;Failed to find suitable memory type.&quot;))
</code></pre>
<p>The <code>memory_type_bits</code> field from the <code>requirements</code> parameter will be used to specify the bit field of memory types that are suitable. That means that we can find the index of a suitable memory type by simply iterating over them and checking if the corresponding bit is set to <code>1</code>.</p>
<p>However, we're not just interested in a memory type that is suitable for the vertex buffer. We also need to be able to write our vertex data to that memory. The <code>memory_types</code> array consists of <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.MemoryType.html"><code class="hljs">vk::MemoryType</code></a> structs that specify the heap and properties of each type of memory. The properties define special features of the memory, like being able to map it so we can write to it from the CPU. This property is indicated with <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.MemoryPropertyFlags.html#associatedconstant.HOST_VISIBLE"><code class="hljs">vk::MemoryPropertyFlags::HOST_VISIBLE</code></a>, but we also need to use the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.MemoryPropertyFlags.html#associatedconstant.HOST_COHERENT"><code class="hljs">vk::MemoryPropertyFlags::HOST_COHERENT</code></a> property. We'll see why when we map the memory.</p>
<p>We can now modify the loop to also check for the support of this property:</p>
<pre><code class="language-rust noplaypen">(0..memory.memory_type_count)
    .find(|i| {
        let suitable = (requirements.memory_type_bits &amp; (1 &lt;&lt; i)) != 0;
        let memory_type = memory.memory_types[*i as usize];
        suitable &amp;&amp; memory_type.property_flags.contains(properties)
    })
    .ok_or_else(|| anyhow!(&quot;Failed to find suitable memory type.&quot;))
</code></pre>
<p>If there is a memory type suitable for the buffer that also has all of the properties we need, then we return its index, otherwise we return an error.</p>
<h2 id="memory-allocation"><a class="header" href="#memory-allocation">Memory allocation</a></h2>
<p>We now have a way to determine the right memory type, so we can actually allocate the memory by filling in the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.MemoryAllocateInfo.html"><code class="hljs">vk::MemoryAllocateInfo</code></a> structure.</p>
<pre><code class="language-rust noplaypen">let memory_info = vk::MemoryAllocateInfo::builder()
    .allocation_size(requirements.size)
    .memory_type_index(get_memory_type_index(
        instance,
        data,
        vk::MemoryPropertyFlags::HOST_COHERENT | vk::MemoryPropertyFlags::HOST_VISIBLE,
        requirements,
    )?);
</code></pre>
<p>Memory allocation is now as simple as specifying the size and type, both of which are derived from the memory requirements of the vertex buffer and the desired property. Create an <code>AppData</code> field to store the handle to the memory:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    vertex_buffer: vk::Buffer,
    vertex_buffer_memory: vk::DeviceMemory,
}
</code></pre>
<p>Populate that new field by calling <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.allocate_memory"><code class="hljs">allocate_memory</code></a>:</p>
<pre><code class="language-rust noplaypen">data.vertex_buffer_memory = device.allocate_memory(&amp;memory_info, None)?;
</code></pre>
<p>If memory allocation was successful, then we can now associate this memory with the buffer using <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.bind_buffer_memory"><code class="hljs">bind_buffer_memory</code></a>:</p>
<pre><code class="language-rust noplaypen">device.bind_buffer_memory(data.vertex_buffer, data.vertex_buffer_memory, 0)?;
</code></pre>
<p>The first two parameters are self-explanatory and the third parameter is the offset within the region of memory. Since this memory is allocated specifically for this the vertex buffer, the offset is simply <code>0</code>. If the offset is non-zero, then it is required to be divisible by <code>requirements.alignment</code>.</p>
<p>Of course, just like dynamic memory allocation in C, the memory should be freed at some point. Memory that is bound to a buffer object may be freed once the buffer is no longer used, so let's free it after the buffer has been destroyed:</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy(&amp;mut self) {
    self.destroy_swapchain();
    self.device.destroy_buffer(self.data.vertex_buffer, None);
    self.device.free_memory(self.data.vertex_buffer_memory, None);
    // ...
}
</code></pre>
<h2 id="filling-the-vertex-buffer"><a class="header" href="#filling-the-vertex-buffer">Filling the vertex buffer</a></h2>
<p>It is now time to copy the vertex data to the buffer. This is done by <a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">mapping the buffer memory</a> into CPU accessible memory with <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.map_memory"><code class="hljs">map_memory</code></a>.</p>
<pre><code class="language-rust noplaypen">let memory = device.map_memory(
    data.vertex_buffer_memory,
    0,
    buffer_info.size,
    vk::MemoryMapFlags::empty(),
)?;
</code></pre>
<p>This command allows us to access a region of the specified memory resource defined by an offset and size. The offset and size here are <code>0</code> and <code>buffer_info.size</code>, respectively. It is also possible to specify the special value <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/constant.WHOLE_SIZE.html"><code class="hljs">vk::WHOLE_SIZE</code></a> to map all of the memory. The last parameter can be used to specify flags, but there aren't any available yet in the current API. It must be set to an empty set of flags. The returned value is the pointer to the mapped value.</p>
<p>Before we continue, we'll need to be able copy memory from our vertex list to the mapped memory. Add this import to your program:</p>
<pre><code class="language-rust noplaypen">use std::ptr::copy_nonoverlapping as memcpy;
</code></pre>
<p>Now we can copy the vertex data into the buffer memory and then unmap it again using <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.unmap_memory"><code class="hljs">unmap_memory</code></a>.</p>
<pre><code class="language-rust noplaypen">memcpy(VERTICES.as_ptr(), memory.cast(), VERTICES.len());
device.unmap_memory(data.vertex_buffer_memory);
</code></pre>
<p>Unfortunately the driver may not immediately copy the data into the buffer memory, for example because of caching. It is also possible that writes to the buffer are not visible in the mapped memory yet. There are two ways to deal with that problem:</p>
<ul>
<li>Use a memory heap that is host coherent, indicated with <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.MemoryPropertyFlags.html#associatedconstant.HOST_COHERENT"><code class="hljs">vk::MemoryPropertyFlags::HOST_COHERENT</code></a></li>
<li>Call <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.flush_mapped_memory_ranges"><code class="hljs">flush_mapped_memory_ranges</code></a> after writing to the mapped memory, and call <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.invalidate_mapped_memory_ranges"><code class="hljs">invalidate_mapped_memory_ranges</code></a> before reading from the mapped memory</li>
</ul>
<p>We went for the first approach, which ensures that the mapped memory always matches the contents of the allocated memory. Do keep in mind that this may lead to slightly worse performance than explicit flushing, but we'll see why that doesn't matter in the next chapter.</p>
<p>Flushing memory ranges or using a coherent memory heap means that the driver will be aware of our writes to the buffer, but it doesn't mean that they are actually visible on the GPU yet. The transfer of data to the GPU is an operation that happens in the background and the specification simply <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-submission-host-writes">tells us</a> that it is guaranteed to be complete as of the next call to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.queue_submit"><code class="hljs">queue_submit</code></a>.</p>
<h2 id="binding-the-vertex-buffer"><a class="header" href="#binding-the-vertex-buffer">Binding the vertex buffer</a></h2>
<p>All that remains now is binding the vertex buffer during rendering operations. We're going to extend the <code>create_command_buffers</code> function to do that.</p>
<pre><code class="language-rust noplaypen">// ...
device.cmd_bind_vertex_buffers(*command_buffer, 0, &amp;[data.vertex_buffer], &amp;[0]);
device.cmd_draw(*command_buffer, VERTICES.len() as u32, 1, 0, 0);
// ...
</code></pre>
<p>The <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_bind_vertex_buffers"><code class="hljs">cmd_bind_vertex_buffers</code></a> command is used to bind vertex buffers to bindings, like the one we set up in the previous chapter. The second parameter specifies the index of the vertex input binding we are using. The last two parameters specify the vertex buffers to bind and the byte offsets to start reading vertex data from. You should also change the call to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_draw"><code class="hljs">cmd_draw</code></a> to pass the number of vertices in the buffer as opposed to the hardcoded number <code>3</code>.</p>
<p>Now run the program and you should see the familiar triangle again:</p>
<p><img src="vertex/../images/triangle.png" alt="" /></p>
<p>Try changing the color of the top vertex to white by modifying the <code>VERTICES</code> list:</p>
<pre><code class="language-rust noplaypen">static VERTICES: [Vertex; 3] = [
    Vertex::new(vec2(0.0, -0.5), vec3(1.0, 1.0, 1.0)),
    Vertex::new(vec2(0.5, 0.5), vec3(0.0, 1.0, 0.0)),
    Vertex::new(vec2(-0.5, 0.5), vec3(0.0, 0.0, 1.0)),
];
</code></pre>
<p>Run the program again and you should see the following:</p>
<p><img src="vertex/../images/triangle_white.png" alt="" /></p>
<p>In the next chapter we'll look at a different way to copy vertex data to a vertex buffer that results in better performance, but takes some more work.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="staging-buffer"><a class="header" href="#staging-buffer">Staging buffer</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/19_staging_buffer.rs">main.rs</a></p>
<p>The vertex buffer we have right now works correctly, but the memory type that allows us to access it from the CPU may not be the most optimal memory type for the graphics card itself to read from. The most optimal memory has the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.MemoryPropertyFlags.html#associatedconstant.DEVICE_LOCAL"><code class="hljs">vk::MemoryPropertyFlags::DEVICE_LOCAL</code></a> flag and is usually not accessible by the CPU on dedicated graphics cards. In this chapter we're going to create two vertex buffers. One <em>staging buffer</em> in CPU accessible memory to upload the data from the vertex array to, and the final vertex buffer in device local memory. We'll then use a buffer copy command to move the data from the staging buffer to the actual vertex buffer.</p>
<h2 id="transfer-queue"><a class="header" href="#transfer-queue">Transfer queue</a></h2>
<p>The buffer copy command requires a queue family that supports transfer operations, which is indicated using <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.QueueFlags.html#associatedconstant.TRANSFER"><code class="hljs">vk::QueueFlags::TRANSFER</code></a>. The good news is that any queue family with <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.QueueFlags.html#associatedconstant.GRAPHICS"><code class="hljs">vk::QueueFlags::GRAPHICS</code></a> or <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.QueueFlags.html#associatedconstant.COMPUTE"><code class="hljs">vk::QueueFlags::COMPUTE</code></a> capabilities already implicitly support <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.QueueFlags.html#associatedconstant.TRANSFER"><code class="hljs">vk::QueueFlags::TRANSFER</code></a> operations. The implementation is not required to explicitly list it in <code>queue_flags</code> in those cases.</p>
<p>If you like a challenge, then you can still try to use a different queue family specifically for transfer operations. It will require you to make the following modifications to your program:</p>
<ul>
<li>Modify <code>QueueFamilyIndices</code> and <code>QueueFamilyIndices::get</code> to explicitly look for a queue family with the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.QueueFlags.html#associatedconstant.TRANSFER"><code class="hljs">vk::QueueFlags::TRANSFER</code></a> bit, but not the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.QueueFlags.html#associatedconstant.GRAPHICS"><code class="hljs">vk::QueueFlags::GRAPHICS</code></a>.</li>
<li>Modify <code>create_logical_device</code> to request a handle to the transfer queue</li>
<li>Create a second command pool for command buffers that are submitted on the transfer queue family</li>
<li>Change the <code>sharing_mode</code> of resources to be <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SharingMode.html#associatedconstant.CONCURRENT"><code class="hljs">vk::SharingMode::CONCURRENT</code></a> and specify both the graphics and transfer queue families</li>
<li>Submit any transfer commands like <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_copy_buffer"><code class="hljs">cmd_copy_buffer</code></a> (which we'll be using in this chapter) to the transfer queue instead of the graphics queue</li>
</ul>
<p>It's a bit of work, but it'll teach you a lot about how resources are shared between queue families.</p>
<h2 id="abstracting-buffer-creation"><a class="header" href="#abstracting-buffer-creation">Abstracting buffer creation</a></h2>
<p>Because we're going to create multiple buffers in this chapter, it's a good idea to move buffer creation to a helper function. Create a new function <code>create_buffer</code> and move the code in <code>create_vertex_buffer</code> (except mapping) to it.</p>
<pre><code class="language-rust noplaypen">unsafe fn create_buffer(
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;AppData,
    size: vk::DeviceSize,
    usage: vk::BufferUsageFlags,
    properties: vk::MemoryPropertyFlags,
) -&gt; Result&lt;(vk::Buffer, vk::DeviceMemory)&gt; {
    let buffer_info = vk::BufferCreateInfo::builder()
        .size(size)
        .usage(usage)
        .sharing_mode(vk::SharingMode::EXCLUSIVE);

    let buffer = device.create_buffer(&amp;buffer_info, None)?;

    let requirements = device.get_buffer_memory_requirements(buffer);

    let memory_info = vk::MemoryAllocateInfo::builder()
        .allocation_size(requirements.size)
        .memory_type_index(get_memory_type_index(
            instance,
            data,
            properties,
            requirements,
        )?);

    let buffer_memory = device.allocate_memory(&amp;memory_info, None)?;

    device.bind_buffer_memory(buffer, buffer_memory, 0)?;

    Ok((buffer, buffer_memory))
}
</code></pre>
<p>Make sure to add parameters for the buffer size, usage and memory properties so that we can use this function to create many different types of buffers.</p>
<p>You can now remove the buffer creation and memory allocation code from <code>create_vertex_buffer</code> and just call <code>create_buffer</code> instead:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_vertex_buffer(
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;mut AppData,
) -&gt; Result&lt;()&gt; {
    let size = (size_of::&lt;Vertex&gt;() * VERTICES.len()) as u64;

    let (vertex_buffer, vertex_buffer_memory) = create_buffer(
        instance,
        device,
        data,
        size,
        vk::BufferUsageFlags::VERTEX_BUFFER,
        vk::MemoryPropertyFlags::HOST_COHERENT | vk::MemoryPropertyFlags::HOST_VISIBLE,
    )?;

    data.vertex_buffer = vertex_buffer;
    data.vertex_buffer_memory = vertex_buffer_memory;

    let memory = device.map_memory(
        vertex_buffer_memory,
        0,
        size,
        vk::MemoryMapFlags::empty(),
    )?;

    memcpy(VERTICES.as_ptr(), memory.cast(), VERTICES.len());

    device.unmap_memory(vertex_buffer_memory);

    Ok(())
}
</code></pre>
<p>Run your program to make sure that the vertex buffer still works properly.</p>
<h2 id="using-a-staging-buffer"><a class="header" href="#using-a-staging-buffer">Using a staging buffer</a></h2>
<p>We're now going to change <code>create_vertex_buffer</code> to only use a host visible buffer as temporary buffer and use a device local one as actual vertex buffer.</p>
<pre><code class="language-rust noplaypen">unsafe fn create_vertex_buffer(
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;mut AppData,
) -&gt; Result&lt;()&gt; {
    let size = (size_of::&lt;Vertex&gt;() * VERTICES.len()) as u64;

    let (staging_buffer, staging_buffer_memory) = create_buffer(
        instance,
        device,
        data,
        size,
        vk::BufferUsageFlags::TRANSFER_SRC,
        vk::MemoryPropertyFlags::HOST_COHERENT | vk::MemoryPropertyFlags::HOST_VISIBLE,
    )?;

    let memory = device.map_memory(
        staging_buffer_memory,
        0,
        size,
        vk::MemoryMapFlags::empty(),
    )?;

    memcpy(VERTICES.as_ptr(), memory.cast(), VERTICES.len());

    device.unmap_memory(staging_buffer_memory);

    let (vertex_buffer, vertex_buffer_memory) = create_buffer(
        instance,
        device,
        data,
        size,
        vk::BufferUsageFlags::TRANSFER_DST | vk::BufferUsageFlags::VERTEX_BUFFER,
        vk::MemoryPropertyFlags::DEVICE_LOCAL,
    )?;

    data.vertex_buffer = vertex_buffer;
    data.vertex_buffer_memory = vertex_buffer_memory;

    Ok(())
}
</code></pre>
<p>We're now using a new <code>staging_buffer</code> with <code>staging_buffer_memory</code> for mapping and copying the vertex data. In this chapter we're going to use two new buffer usage flags:</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.BufferUsageFlags.html#associatedconstant.TRANSFER_SRC"><code class="hljs">vk::BufferUsageFlags::TRANSFER_SRC</code></a> – Buffer can be used as source in a memory transfer operation.</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.BufferUsageFlags.html#associatedconstant.TRANSFER_DST"><code class="hljs">vk::BufferUsageFlags::TRANSFER_DST</code></a> – Buffer can be used as destination in a memory transfer operation.</li>
</ul>
<p>The <code>vertex_buffer</code> is now allocated from a memory type that is device local, which generally means that we're not able to use <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.map_memory"><code class="hljs">map_memory</code></a>. However, we can copy data from the <code>staging_buffer</code> to the <code>vertex_buffer</code>. We have to indicate that we intend to do that by specifying the transfer source flag for the <code>staging_buffer</code> and the transfer destination flag for the <code>vertex_buffer</code>, along with the vertex buffer usage flag.</p>
<p>We're now going to write a function to copy the contents from one buffer to another, called <code>copy_buffer</code>.</p>
<pre><code class="language-rust noplaypen">unsafe fn copy_buffer(
    device: &amp;Device,
    data: &amp;AppData,
    source: vk::Buffer,
    destination: vk::Buffer,
    size: vk::DeviceSize,
) -&gt; Result&lt;()&gt; {
    Ok(())
}
</code></pre>
<p>Memory transfer operations are executed using command buffers, just like drawing commands. Therefore we must first allocate a temporary command buffer. You may wish to create a separate command pool for these kinds of short-lived buffers, because the implementation may be able to apply memory allocation optimizations. You should use the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.CommandPoolCreateFlags.html#associatedconstant.TRANSIENT"><code class="hljs">vk::CommandPoolCreateFlags::TRANSIENT</code></a> flag during command pool generation in that case.</p>
<pre><code class="language-rust noplaypen">unsafe fn copy_buffer(
    device: &amp;Device,
    data: &amp;AppData,
    source: vk::Buffer,
    destination: vk::Buffer,
    size: vk::DeviceSize,
) -&gt; Result&lt;()&gt; {
    let info = vk::CommandBufferAllocateInfo::builder()
        .level(vk::CommandBufferLevel::PRIMARY)
        .command_pool(data.command_pool)
        .command_buffer_count(1);

    let command_buffer = device.allocate_command_buffers(&amp;info)?[0];

    Ok(())
}
</code></pre>
<p>And immediately start recording the command buffer:</p>
<pre><code class="language-rust noplaypen">let info = vk::CommandBufferBeginInfo::builder()
    .flags(vk::CommandBufferUsageFlags::ONE_TIME_SUBMIT);

device.begin_command_buffer(command_buffer, &amp;info)?;
</code></pre>
<p>We're only going to use the command buffer once and wait with returning from the function until the copy operation has finished executing. It's good practice to tell the driver about our intent using <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.CommandBufferUsageFlags.html#associatedconstant.ONE_TIME_SUBMIT"><code class="hljs">vk::CommandBufferUsageFlags::ONE_TIME_SUBMIT</code></a>.</p>
<pre><code class="language-rust noplaypen">let regions = vk::BufferCopy::builder().size(size);
device.cmd_copy_buffer(command_buffer, source, destination, &amp;[regions]);
</code></pre>
<p>Contents of buffers are transferred using the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_copy_buffer"><code class="hljs">cmd_copy_buffer</code></a> command. It takes the source and destination buffers as arguments, and an array of regions to copy. The regions are defined in <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.BufferCopy.html"><code class="hljs">vk::BufferCopy</code></a> structs and consist of a source buffer offset, destination buffer offset and size. It is not possible to specify <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/constant.WHOLE_SIZE.html"><code class="hljs">vk::WHOLE_SIZE</code></a> here, unlike the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.map_memory"><code class="hljs">map_memory</code></a> command.</p>
<pre><code class="language-rust noplaypen">device.end_command_buffer(command_buffer)?;
</code></pre>
<p>This command buffer only contains the copy command, so we can stop recording right after that. Now execute the command buffer to complete the transfer:</p>
<pre><code class="language-rust noplaypen">let command_buffers = &amp;[command_buffer];
let info = vk::SubmitInfo::builder()
    .command_buffers(command_buffers);

device.queue_submit(data.graphics_queue, &amp;[info], vk::Fence::null())?;
device.queue_wait_idle(data.graphics_queue)?;
</code></pre>
<p>Unlike the draw commands, there are no events we need to wait on this time. We just want to execute the transfer on the buffers immediately. There are again two possible ways to wait on this transfer to complete. We could use a fence and wait with <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.wait_for_fences"><code class="hljs">wait_for_fences</code></a>, or simply wait for the transfer queue to become idle with <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.queue_wait_idle"><code class="hljs">queue_wait_idle</code></a>. A fence would allow you to schedule multiple transfers simultaneously and wait for all of them complete, instead of executing one at a time. That may give the driver more opportunities to optimize.</p>
<pre><code class="language-rust noplaypen">device.free_command_buffers(data.command_pool, &amp;[command_buffer]);
</code></pre>
<p>Don't forget to clean up the command buffer used for the transfer operation.</p>
<p>We can now call <code>copy_buffer</code> from the <code>create_vertex_buffer</code> function to move the vertex data to the device local buffer:</p>
<pre><code class="language-rust noplaypen">copy_buffer(device, data, staging_buffer, vertex_buffer, size)?;
</code></pre>
<p>After copying the data from the staging buffer to the device buffer, we should clean it up:</p>
<pre><code class="language-rust noplaypen">device.destroy_buffer(staging_buffer, None);
device.free_memory(staging_buffer_memory, None);
</code></pre>
<p>Run your program to verify that you're seeing the familiar triangle again. The improvement may not be visible right now, but its vertex data is now being loaded from high performance memory. This will matter when we're going to start rendering more complex geometry.</p>
<h2 id="conclusion-3"><a class="header" href="#conclusion-3">Conclusion</a></h2>
<p>It should be noted that in a real world application, you're not supposed to actually call <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.allocate_memory"><code class="hljs">allocate_memory</code></a> for every individual buffer. The maximum number of simultaneous memory allocations is limited by the <code>max_memory_allocation_count</code> physical device limit, which may be as low as <code>4096</code> even on high end hardware like an NVIDIA GTX 1080. The right way to allocate memory for a large number of objects at the same time is to create a custom allocator that splits up a single allocation among many different objects by using the <code>offset</code> parameters that we've seen in many functions.</p>
<p>However, for this tutorial it's okay to use a separate allocation for every resource, because we won't come close to hitting any of these limits for now.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="index-buffer"><a class="header" href="#index-buffer">Index buffer</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/20_index_buffer.rs">main.rs</a></p>
<p>The 3D meshes you'll be rendering in a real world application will often share vertices between multiple triangles. This already happens even with something simple like drawing a rectangle:</p>
<p><img src="vertex/../images/vertex_vs_index.svg" alt="" /></p>
<p>Drawing a rectangle takes two triangles, which means that we need a vertex buffer with 6 vertices. The problem is that the data of two vertices needs to be duplicated resulting in 50% redundancy. It only gets worse with more complex meshes, where vertices are reused in an average number of 3 triangles. The solution to this problem is to use an <em>index buffer</em>.</p>
<p>An index buffer is essentially an array of pointers into the vertex buffer. It allows you to reorder the vertex data, and reuse existing data for multiple vertices. The illustration above demonstrates what the index buffer would look like for the rectangle if we have a vertex buffer containing each of the four unique vertices. The first three indices define the upper-right triangle and the last three indices define the vertices for the bottom-left triangle.</p>
<h2 id="index-buffer-creation"><a class="header" href="#index-buffer-creation">Index buffer creation</a></h2>
<p>In this chapter we're going to modify the vertex data and add index data to draw a rectangle like the one in the illustration. Modify the vertex data to represent the four corners:</p>
<pre><code class="language-rust noplaypen">static VERTICES: [Vertex; 4] = [
    Vertex::new(vec2(-0.5, -0.5), vec3(1.0, 0.0, 0.0)),
    Vertex::new(vec2(0.5, -0.5), vec3(0.0, 1.0, 0.0)),
    Vertex::new(vec2(0.5, 0.5), vec3(0.0, 0.0, 1.0)),
    Vertex::new(vec2(-0.5, 0.5), vec3(1.0, 1.0, 1.0)),
];
</code></pre>
<p>The top-left corner is red, top-right is green, bottom-right is blue and the bottom-left is white. We'll add a new array <code>INDICES</code> to represent the contents of the index buffer. It should match the indices in the illustration to draw the upper-right triangle and bottom-left triangle.</p>
<pre><code class="language-rust noplaypen">const INDICES: &amp;[u16] = &amp;[0, 1, 2, 2, 3, 0];
</code></pre>
<p>It is possible to use either <code>u16</code> or <code>u32</code> for your index buffer depending on the number of entries in <code>VERTICES</code>. We can stick to <code>u16</code> for now because we're using less than 65,536 unique vertices.</p>
<p>Just like the vertex data, the indices need to be uploaded into a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Buffer.html"><code class="hljs">vk::Buffer</code></a> for the GPU to be able to access them. Define two new <code>AppData</code> fields to hold the resources for the index buffer:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    vertex_buffer: vk::Buffer,
    vertex_buffer_memory: vk::DeviceMemory,
    index_buffer: vk::Buffer,
    index_buffer_memory: vk::DeviceMemory,
}
</code></pre>
<p>The <code>create_index_buffer</code> function that we'll add now is almost identical to <code>create_vertex_buffer</code>:</p>
<pre><code class="language-rust noplaypen">impl App {
    unsafe fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        // ...
        create_vertex_buffer(&amp;instance, &amp;device, &amp;mut data)?;
        create_index_buffer(&amp;instance, &amp;device, &amp;mut data)?;
        // ...
    }
}

unsafe fn create_index_buffer(
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;mut AppData,
) -&gt; Result&lt;()&gt; {
    let size = (size_of::&lt;u16&gt;() * INDICES.len()) as u64;

    let (staging_buffer, staging_buffer_memory) = create_buffer(
        instance,
        device,
        data,
        size,
        vk::BufferUsageFlags::TRANSFER_SRC,
        vk::MemoryPropertyFlags::HOST_COHERENT | vk::MemoryPropertyFlags::HOST_VISIBLE,
    )?;

    let memory = device.map_memory(
        staging_buffer_memory,
        0,
        size,
        vk::MemoryMapFlags::empty(),
    )?;

    memcpy(INDICES.as_ptr(), memory.cast(), INDICES.len());

    device.unmap_memory(staging_buffer_memory);

    let (index_buffer, index_buffer_memory) = create_buffer(
        instance,
        device,
        data,
        size,
        vk::BufferUsageFlags::TRANSFER_DST | vk::BufferUsageFlags::INDEX_BUFFER,
        vk::MemoryPropertyFlags::DEVICE_LOCAL,
    )?;

    data.index_buffer = index_buffer;
    data.index_buffer_memory = index_buffer_memory;

    copy_buffer(device, data, staging_buffer, index_buffer, size)?;

    device.destroy_buffer(staging_buffer, None);
    device.free_memory(staging_buffer_memory, None);

    Ok(())
}
</code></pre>
<p>There are only two notable differences. The <code>size</code> is now equal to the number of indices times the size of the index type, either <code>u16</code> or <code>u32</code>. The usage of the <code>index_buffer</code> should be <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.BufferUsageFlags.html#associatedconstant.INDEX_BUFFER"><code class="hljs">vk::BufferUsageFlags::INDEX_BUFFER</code></a> instead of <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.BufferUsageFlags.html#associatedconstant.VERTEX_BUFFER"><code class="hljs">vk::BufferUsageFlags::VERTEX_BUFFER</code></a>, which makes sense. Other than that, the process is exactly the same. We create a staging buffer to copy the contents of <code>INDICES</code> to and then copy it to the final device local index buffer.</p>
<p>The index buffer should be cleaned up at the end of the program, just like the vertex buffer:</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy(&amp;mut self) {
    self.destroy_swapchain();
    self.device.destroy_buffer(self.data.index_buffer, None);
    self.device.free_memory(self.data.index_buffer_memory, None);
    self.device.destroy_buffer(self.data.vertex_buffer, None);
    self.device.free_memory(self.data.vertex_buffer_memory, None);
    // ...
}
</code></pre>
<h2 id="using-an-index-buffer"><a class="header" href="#using-an-index-buffer">Using an index buffer</a></h2>
<p>Using an index buffer for drawing involves two changes to <code>create_command_buffers</code>. We first need to bind the index buffer, just like we did for the vertex buffer. The difference is that you can only have a single index buffer. It's unfortunately not possible to use different indices for each vertex attribute, so we do still have to completely duplicate vertex data even if just one attribute varies.</p>
<pre><code class="language-rust noplaypen">device.cmd_bind_vertex_buffers(*command_buffer, 0, &amp;[data.vertex_buffer], &amp;[0]);
device.cmd_bind_index_buffer(*command_buffer, data.index_buffer, 0, vk::IndexType::UINT16);
</code></pre>
<p>An index buffer is bound with <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_bind_index_buffer"><code class="hljs">cmd_bind_index_buffer</code></a> which has the index buffer, a byte offset into it, and the type of index data as parameters. As mentioned before, the possible types are <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.IndexType.html#associatedconstant.UINT16"><code class="hljs">vk::IndexType::UINT16</code></a> and <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.IndexType.html#associatedconstant.UINT32"><code class="hljs">vk::IndexType::UINT32</code></a>.</p>
<p>Just binding an index buffer doesn't change anything yet, we also need to change the drawing command to tell Vulkan to use the index buffer. Remove the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_draw"><code class="hljs">cmd_draw</code></a> line and replace it with <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_draw_indexed"><code class="hljs">cmd_draw_indexed</code></a>:</p>
<pre><code class="language-rust noplaypen">device.cmd_draw_indexed(*command_buffer, INDICES.len() as u32, 1, 0, 0, 0);
</code></pre>
<p>A call to this function is very similar to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_draw"><code class="hljs">cmd_draw</code></a>. The first two parameters after the command buffer specify the number of indices and the number of instances. We're not using instancing, so just specify <code>1</code> instance. The number of indices represents the number of vertices that will be passed to the vertex buffer. The next parameter specifies an offset into the index buffer, using a value of <code>1</code> would cause the graphics card to start reading at the second index. The second to last parameter specifies an offset to add to the indices in the index buffer. The final parameter specifies an offset for instancing, which we're not using.</p>
<p>Now run your program and you should see the following:</p>
<p><img src="vertex/../images/indexed_rectangle.png" alt="" /></p>
<p>You now know how to save memory by reusing vertices with index buffers. This will become especially important in a future chapter where we're going to load complex 3D models.</p>
<p>The previous chapter already mentioned that you should allocate multiple resources like buffers from a single memory allocation, but in fact you should go a step further. <a href="https://developer.nvidia.com/vulkan-memory-management">Driver developers recommend</a> that you also store multiple buffers, like the vertex and index buffer, into a single <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Buffer.html"><code class="hljs">vk::Buffer</code></a> and use offsets in commands like <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_bind_vertex_buffers"><code class="hljs">cmd_bind_vertex_buffers</code></a>. The advantage is that your data is more cache friendly in that case, because it's closer together. It is even possible to reuse the same chunk of memory for multiple resources if they are not used during the same render operations, provided that their data is refreshed, of course. This is known as <em>aliasing</em> and some Vulkan functions have explicit flags to specify that you want to do this.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="descriptor-layout-and-buffer"><a class="header" href="#descriptor-layout-and-buffer">Descriptor layout and buffer</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/21_descriptor_set_layout.rs">main.rs</a> | <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/shaders/21/shader.vert">shader.vert</a> | <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/shaders/21/shader.frag">shader.frag</a></p>
<p>We're now able to pass arbitrary attributes to the vertex shader for each vertex, but what about global variables? We're going to move on to 3D graphics from this chapter on and that requires a model-view-projection matrix. We could include it as vertex data, but that's a waste of memory and it would require us to update the vertex buffer whenever the transformation changes. The transformation could easily change every single frame.</p>
<p>The right way to tackle this in Vulkan is to use <em>resource descriptors</em>. A descriptor is a way for shaders to freely access resources like buffers and images. We're going to set up a buffer that contains the transformation matrices and have the vertex shader access them through a descriptor. Usage of descriptors consists of three parts:</p>
<ul>
<li>Specify a descriptor layout during pipeline creation</li>
<li>Allocate a descriptor set from a descriptor pool</li>
<li>Bind the descriptor set during rendering</li>
</ul>
<p>The <em>descriptor layout</em> specifies the types of resources that are going to be accessed by the pipeline, just like a render pass specifies the types of attachments that will be accessed. A <em>descriptor set</em> specifies the actual buffer or image resources that will be bound to the descriptors, just like a framebuffer specifies the actual image views to bind to render pass attachments. The descriptor set is then bound for the drawing commands just like the vertex buffers and framebuffer.</p>
<p>There are many types of descriptors, but in this chapter we'll work with uniform buffer objects (UBO). We'll look at other types of descriptors in future chapters, but the basic process is the same. Let's say we have the data we want the vertex shader to have in a struct like this:</p>
<pre><code class="language-rust noplaypen">#[repr(C)]
#[derive(Copy, Clone, Debug)]
struct UniformBufferObject {
    model: Mat4,
    view: Mat4,
    proj: Mat4,
}
</code></pre>
<p>Then we can copy the data to a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Buffer.html"><code class="hljs">vk::Buffer</code></a> and access it through a uniform buffer object descriptor from the vertex shader like this:</p>
<pre><code class="language-glsl">layout(binding = 0) uniform UniformBufferObject {
    mat4 model;
    mat4 view;
    mat4 proj;
} ubo;

// ...

void main() {
    gl_Position = ubo.proj * ubo.view * ubo.model * vec4(inPosition, 0.0, 1.0);
    fragColor = inColor;
}
</code></pre>
<p>We're going to update the model, view and projection matrices every frame to make the rectangle from the previous chapter spin around in 3D.</p>
<h2 id="vertex-shader-2"><a class="header" href="#vertex-shader-2">Vertex shader</a></h2>
<p>Modify the vertex shader to include the uniform buffer object like it was specified above. I will assume that you are familiar with MVP transformations. If you're not, see <a href="https://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/">the resource</a> mentioned in the first chapter.</p>
<pre><code class="language-glsl">#version 450

layout(binding = 0) uniform UniformBufferObject {
    mat4 model;
    mat4 view;
    mat4 proj;
} ubo;

layout(location = 0) in vec2 inPosition;
layout(location = 1) in vec3 inColor;

layout(location = 0) out vec3 fragColor;

void main() {
    gl_Position = ubo.proj * ubo.view * ubo.model * vec4(inPosition, 0.0, 1.0);
    fragColor = inColor;
}
</code></pre>
<p>Note that the order of the <code>uniform</code>, <code>in</code> and <code>out</code> declarations doesn't matter. The <code>binding</code> directive is similar to the <code>location</code> directive for attributes. We're going to reference this binding in the descriptor layout. The line with <code>gl_Position</code> is changed to use the transformations to compute the final position in clip coordinates. Unlike the 2D triangles, the last component of the clip coordinates may not be <code>1</code>, which will result in a division when converted to the final normalized device coordinates on the screen. This is used in perspective projection as the <em>perspective division</em> and is essential for making closer objects look larger than objects that are further away.</p>
<h2 id="descriptor-set-layout"><a class="header" href="#descriptor-set-layout">Descriptor set layout</a></h2>
<p>The next step is to define the UBO on the Rust side and to tell Vulkan about this descriptor in the vertex shader. First we add a few more imports and a type alias:</p>
<pre><code class="language-rust noplaypen">use cgmath::{point3, Deg};

type Mat4 = cgmath::Matrix4&lt;f32&gt;;
</code></pre>
<p>Then create the <code>UniformBufferObject</code> struct:</p>
<pre><code class="language-rust noplaypen">#[repr(C)]
#[derive(Copy, Clone, Debug)]
struct UniformBufferObject {
    model: Mat4,
    view: Mat4,
    proj: Mat4,
}
</code></pre>
<p>We can exactly match the definition in the shader using data types in the <code>cgmath</code> crate. The data in the matrices is binary compatible with the way the shader expects it, so we can later just copy a <code>UniformBufferObject</code> to a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Buffer.html"><code class="hljs">vk::Buffer</code></a>.</p>
<p>We need to provide details about every descriptor binding used in the shaders for pipeline creation, just like we had to do for every vertex attribute and its <code>location</code> index. We'll set up a new function to define all of this information called <code>create_descriptor_set_layout</code>. It should be called right before pipeline creation, because we're going to need it there.</p>
<pre><code class="language-rust noplaypen">impl App {
    unsafe fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        // ...
        create_descriptor_set_layout(&amp;device, &amp;mut data)?;
        create_pipeline(&amp;device, &amp;mut data)?;
        // ...
    }
}


unsafe fn create_descriptor_set_layout(
    device: &amp;Device,
    data: &amp;mut AppData,
) -&gt; Result&lt;()&gt; {
    Ok(())
}
</code></pre>
<p>Every binding needs to be described through a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DescriptorSetLayoutBinding.html"><code class="hljs">vk::DescriptorSetLayoutBinding</code></a> struct.</p>
<pre><code class="language-rust noplaypen">unsafe fn create_descriptor_set_layout(
    device: &amp;Device,
    data: &amp;mut AppData,
) -&gt; Result&lt;()&gt; {
    let ubo_binding = vk::DescriptorSetLayoutBinding::builder()
        .binding(0)
        .descriptor_type(vk::DescriptorType::UNIFORM_BUFFER)
        .descriptor_count(1)
        .stage_flags(vk::ShaderStageFlags::VERTEX);

    Ok(())
}
</code></pre>
<p>The first two fields specify the <code>binding</code> used in the shader and the type of descriptor, which is a uniform buffer object. It is possible for the shader variable to represent an array of uniform buffer objects, and <code>descriptor_count</code> specifies the number of values in the array. This could be used to specify a transformation for each of the bones in a skeleton for skeletal animation, for example. Our MVP transformation is in a single uniform buffer object, so we're using a <code>descriptor_count</code> of <code>1</code>.</p>
<p>We also need to specify in which shader stages the descriptor is going to be referenced. The <code>stage_flags</code> field can be a combination of <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ShaderStageFlags.html"><code class="hljs">vk::ShaderStageFlags</code></a> values or the value <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ShaderStageFlags.html#associatedconstant.ALL_GRAPHICS"><code class="hljs">vk::ShaderStageFlags::ALL_GRAPHICS</code></a>. In our case, we're only referencing the descriptor from the vertex shader.</p>
<p>There is also an <code>immutable_samplers</code> field which is only relevant for image sampling related descriptors, which we'll look at later. You can leave this to its default value.</p>
<p>All of the descriptor bindings are combined into a single <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DescriptorSetLayout.html"><code class="hljs">vk::DescriptorSetLayout</code></a> object. Define a new <code>AppData</code> field above <code>pipeline_layout</code>:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    descriptor_set_layout: vk::DescriptorSetLayout,
    pipeline_layout: vk::PipelineLayout,
    // ...
}
</code></pre>
<p>We can then create it using <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.create_descriptor_set_layout"><code class="hljs">create_descriptor_set_layout</code></a>. This function accepts a simple <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DescriptorSetLayoutCreateInfo.html"><code class="hljs">vk::DescriptorSetLayoutCreateInfo</code></a> with the array of bindings:</p>
<pre><code class="language-rust noplaypen">let bindings = &amp;[ubo_binding];
let info = vk::DescriptorSetLayoutCreateInfo::builder()
    .bindings(bindings);

data.descriptor_set_layout = device.create_descriptor_set_layout(&amp;info, None)?;
</code></pre>
<p>We need to specify the descriptor set layout during pipeline creation to tell Vulkan which descriptors the shaders will be using. Descriptor set layouts are specified in the pipeline layout object. Modify the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PipelineLayoutCreateInfo.html"><code class="hljs">vk::PipelineLayoutCreateInfo</code></a> to reference the layout object:</p>
<pre><code class="language-rust noplaypen">let set_layouts = &amp;[data.descriptor_set_layout];
let layout_info = vk::PipelineLayoutCreateInfo::builder()
    .set_layouts(set_layouts);
</code></pre>
<p>You may be wondering why it's possible to specify multiple descriptor set layouts here, because a single one already includes all of the bindings. We'll get back to that in the next chapter, where we'll look into descriptor pools and descriptor sets.</p>
<p>The descriptor layout should stick around while we may create new graphics pipelines i.e. until the program ends:</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy(&amp;mut self) {
    self.destroy_swapchain();
    self.device.destroy_descriptor_set_layout(self.data.descriptor_set_layout, None);
    // ...
}
</code></pre>
<h2 id="uniform-buffer"><a class="header" href="#uniform-buffer">Uniform buffer</a></h2>
<p>In the next chapter we'll specify the buffer that contains the UBO data for the shader, but we need to create this buffer first. We're going to copy new data to the uniform buffer every frame, so it doesn't really make any sense to have a staging buffer. It would just add extra overhead in this case and likely degrade performance instead of improving it.</p>
<p>We should have multiple buffers, because multiple frames may be in flight at the same time and we don't want to update the buffer in preparation of the next frame while a previous one is still reading from it! We could either have a uniform buffer per frame or per swapchain image. However, since we need to refer to the uniform buffer from the command buffer that we have per swapchain image, it makes the most sense to also have a uniform buffer per swapchain image.</p>
<p>To that end, add new <code>AppData</code> fields for <code>uniform_buffers</code>, and <code>uniform_buffers_memory</code>:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    index_buffer: vk::Buffer,
    index_buffer_memory: vk::DeviceMemory,
    uniform_buffers: Vec&lt;vk::Buffer&gt;,
    uniform_buffers_memory: Vec&lt;vk::DeviceMemory&gt;,
    // ...
}
</code></pre>
<p>Similarly, create a new function <code>create_uniform_buffers</code> that is called after <code>create_index_buffer</code> and allocates the buffers:</p>
<pre><code class="language-rust noplaypen">impl App {
    unsafe fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        // ...
        create_vertex_buffer(&amp;instance, &amp;device, &amp;mut data)?;
        create_index_buffer(&amp;instance, &amp;device, &amp;mut data)?;
        create_uniform_buffers(&amp;instance, &amp;device, &amp;mut data)?;
        // ...
    }
}

unsafe fn create_uniform_buffers(
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;mut AppData,
) -&gt; Result&lt;()&gt; {
    data.uniform_buffers.clear();
    data.uniform_buffers_memory.clear();

    for _ in 0..data.swapchain_images.len() {
        let (uniform_buffer, uniform_buffer_memory) = create_buffer(
            instance,
            device,
            data,
            size_of::&lt;UniformBufferObject&gt;() as u64,
            vk::BufferUsageFlags::UNIFORM_BUFFER,
            vk::MemoryPropertyFlags::HOST_COHERENT | vk::MemoryPropertyFlags::HOST_VISIBLE,
        )?;

        data.uniform_buffers.push(uniform_buffer);
        data.uniform_buffers_memory.push(uniform_buffer_memory);
    }

    Ok(())
}
</code></pre>
<p>We're going to write a separate function that updates the uniform buffer with a new transformation every frame, so there will be no <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.map_memory"><code class="hljs">map_memory</code></a> here. The uniform data will be used for all draw calls, so the buffer containing it should only be destroyed when we stop rendering. Since it also depends on the number of swapchain images, which could change after a recreation, we'll clean it up in <code>destroy_swapchain</code>:</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy_swapchain(&amp;mut self) {
    self.data.uniform_buffers
        .iter()
        .for_each(|b| self.device.destroy_buffer(*b, None));
    self.data.uniform_buffers_memory
        .iter()
        .for_each(|m| self.device.free_memory(*m, None));
    // ...
}
</code></pre>
<p>This means that we also need to recreate it in <code>recreate_swapchain</code>:</p>
<pre><code class="language-rust noplaypen">unsafe fn recreate_swapchain(&amp;mut self, window: &amp;Window) -&gt; Result&lt;()&gt; {
    // ...
    create_framebuffers(&amp;self.device, &amp;mut self.data)?;
    create_uniform_buffers(&amp;self.instance, &amp;self.device, &amp;mut self.data)?;
    create_command_buffers(&amp;self.device, &amp;mut self.data)?;
    Ok(())
}
</code></pre>
<h2 id="updating-uniform-data"><a class="header" href="#updating-uniform-data">Updating uniform data</a></h2>
<p>Create a new method <code>App::update_uniform_buffer</code> and add a call to it from the <code>App::render</code> method right after we wait for the fence for the acquired swapchain image to be signalled:</p>
<pre><code class="language-rust noplaypen">impl App {
    unsafe fn render(&amp;mut self, window: &amp;Window) -&gt; Result&lt;()&gt; {
        // ...

        if !self.data.images_in_flight[image_index as usize].is_null() {
            self.device.wait_for_fences(
                &amp;[self.data.images_in_flight[image_index as usize]],
                true,
                u64::MAX,
            )?;
        }

        self.data.images_in_flight[image_index as usize] =
            self.data.in_flight_fences[self.frame];

        self.update_uniform_buffer(image_index)?;

        // ...
    }

    unsafe fn update_uniform_buffer(&amp;self, image_index: usize) -&gt; Result&lt;()&gt; {
        Ok(())
    }
}
</code></pre>
<p>It is important that the uniform buffer is not updated until after this fence is signalled!</p>
<p>As a quick refresher on the usage of fences as introduced in the <a href="uniform/../drawing/rendering_and_presentation.html#frames-in-flight"><code>Rendering and Presentation</code> chapter</a>, we are using fences so that the GPU can notify the CPU once it is done processing a previously submitted frame. These notifications are used for two purposes: to prevent the CPU from submitting more frames when there are already <code>MAX_FRAMES_IN_FLIGHT</code> unfinished frames submitted to the GPU and also to ensure the CPU doesn't alter or delete resources like uniform buffers or command buffers while they are still being used by the GPU to process a frame.</p>
<p>Our uniform buffers are associated with our swapchain images, so we need to be sure that any previous frame that rendered to the acquired swapchain image is complete before we can safely update the uniform buffer. By only updating the uniform buffer after the GPU has notified the CPU that this is the case we can safely do whatever we want with the uniform buffer.</p>
<p>Going back to <code>App::update_uniform_buffer</code>, this method will generate a new transformation every frame to make the geometry spin around. We need to add an import to implement this functionality:</p>
<pre><code class="language-rust noplaypen">use std::time::Instant;
</code></pre>
<p>The <code>Instant</code> struct will allow us to do precise timekeeping. We'll use this to make sure that the geometry rotates 90 degrees per second regardless of frame rate. Add a field to <code>App</code> to track the time the application started and initialize the field to <code>Instant::now()</code> in <code>App::create</code>:</p>
<pre><code class="language-rust noplaypen">struct App {
    // ...
    start: Instant,
}
</code></pre>
<p>We can now use that field to determine how many seconds it has been since the application started:</p>
<pre><code class="language-rust noplaypen">unsafe fn update_uniform_buffer(&amp;self, image_index: usize) -&gt; Result&lt;()&gt; {
    let time = self.start.elapsed().as_secs_f32();

    Ok(())
}
</code></pre>
<p>We will now define the model, view and projection transformations in the uniform buffer object. The model rotation will be a simple rotation around the Z-axis using the <code>time</code> variable:</p>
<pre><code class="language-rust noplaypen">let model = Mat4::from_axis_angle(
    vec3(0.0, 0.0, 1.0),
    Deg(90.0) * time
);
</code></pre>
<p>The <code>Mat4::from_axis_angle</code> function creates a transformation matrix from the given rotation angle and rotation axis. Using a rotation angle of <code>Deg(90.0) * time</code> accomplishes the purpose of rotating 90 degrees per second.</p>
<pre><code class="language-rust noplaypen">let view = Mat4::look_at_rh(
    point3(2.0, 2.0, 2.0),
    point3(0.0, 0.0, 0.0),
    vec3(0.0, 0.0, 1.0),
);
</code></pre>
<p>For the view transformation I've decided to look at the geometry from above at a 45 degree angle. The <code>Mat4::look_at_rh</code> function takes the eye position, center position and up axis as parameters. The <code>rh</code> at the end of this function indicates that it uses the &quot;right-handed&quot; coordinate system which is the coordinate system that Vulkan uses.</p>
<pre><code class="language-rust noplaypen">let mut proj = cgmath::perspective(
    Deg(45.0),
    self.data.swapchain_extent.width as f32 / self.data.swapchain_extent.height as f32,
    0.1,
    10.0,
);
</code></pre>
<p>I've chosen to use a perspective projection with a 45 degree vertical field-of-view. The other parameters are the aspect ratio, near and far view planes. It is important to use the current swapchain extent to calculate the aspect ratio to take into account the new width and height of the window after a resize.</p>
<pre><code class="language-rust noplaypen">proj[1][1] *= -1.0;
</code></pre>
<p><code>cgmath</code> was originally designed for OpenGL, where the Y coordinate of the clip coordinates is inverted. The easiest way to compensate for that is to flip the sign on the scaling factor of the Y axis in the projection matrix. If you don't do this, then the image will be rendered upside down.</p>
<pre><code class="language-rust noplaypen">let ubo = UniformBufferObject { model, view, proj };
</code></pre>
<p>Lastly we combine our matrices into a uniform buffer object.</p>
<p>All of the transformations are defined now, so we can copy the data in the uniform buffer object to the current uniform buffer. This happens in exactly the same way as we did for vertex buffers, except without a staging buffer:</p>
<pre><code class="language-rust noplaypen">let memory = self.device.map_memory(
    self.data.uniform_buffers_memory[image_index],
    0,
    size_of::&lt;UniformBufferObject&gt;() as u64,
    vk::MemoryMapFlags::empty(),
)?;

memcpy(&amp;ubo, memory.cast(), 1);

self.device.unmap_memory(self.data.uniform_buffers_memory[image_index]);
</code></pre>
<p>Using a UBO this way is not the most efficient way to pass frequently changing values to the shader. A more efficient way to pass a small buffer of data to shaders are <em>push constants</em>. We may look at these in a future chapter.</p>
<p>If you run the program now, you'll get errors about unbound descriptor sets from the validation layer and nothing will be rendered. In the next chapter we'll look at these descriptor sets, which will actually bind the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Buffer.html"><code class="hljs">vk::Buffer</code></a>s to the uniform buffer descriptors so that the shader can access this transformation data and get our program in running order again.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="descriptor-pool-and-sets"><a class="header" href="#descriptor-pool-and-sets">Descriptor pool and sets</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/22_descriptor_sets.rs">main.rs</a></p>
<p>The descriptor set layout from the previous chapter describes the type of descriptors that can be bound. In this chapter we're going to create a descriptor set for each <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Buffer.html"><code class="hljs">vk::Buffer</code></a> resource to bind it to the uniform buffer descriptor.</p>
<h2 id="descriptor-pool"><a class="header" href="#descriptor-pool">Descriptor pool</a></h2>
<p>Descriptor sets can't be created directly, they must be allocated from a pool like command buffers. The equivalent for descriptor sets is unsurprisingly called a <em>descriptor pool</em>. We'll write a new function <code>create_descriptor_pool</code> to set it up.</p>
<pre><code class="language-rust noplaypen">impl App {
    unsafe fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        // ...
        create_uniform_buffers(&amp;instance, &amp;device, &amp;mut data)?;
        create_descriptor_pool(&amp;device, &amp;mut data)?;
        // ...
    }
}

unsafe fn create_descriptor_pool(device: &amp;Device, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    Ok(())
}
</code></pre>
<p>We first need to describe which descriptor types our descriptor sets are going to contain and how many of them, using <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DescriptorPoolSize.html"><code class="hljs">vk::DescriptorPoolSize</code></a> structures.</p>
<pre><code class="language-rust noplaypen">let ubo_size = vk::DescriptorPoolSize::builder()
    .type_(vk::DescriptorType::UNIFORM_BUFFER)
    .descriptor_count(data.swapchain_images.len() as u32);
</code></pre>
<p>We will allocate one of these descriptors for every frame. This pool size structure is referenced by the main <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DescriptorPoolCreateInfo.html"><code class="hljs">vk::DescriptorPoolCreateInfo</code></a> along with the maximum number of descriptor sets that may be allocated:</p>
<pre><code class="language-rust noplaypen">let pool_sizes = &amp;[ubo_size];
let info = vk::DescriptorPoolCreateInfo::builder()
    .pool_sizes(pool_sizes)
    .max_sets(data.swapchain_images.len() as u32);
</code></pre>
<p>The structure has an optional flag similar to command pools that determines if individual descriptor sets can be freed or not: <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DescriptorPoolCreateFlags.html#associatedconstant.FREE_DESCRIPTOR_SET"><code class="hljs">vk::DescriptorPoolCreateFlags::FREE_DESCRIPTOR_SET</code></a>. We're not going to touch the descriptor set after creating it, so we don't need this flag.</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    uniform_buffers: Vec&lt;vk::Buffer&gt;,
    uniform_buffers_memory: Vec&lt;vk::DeviceMemory&gt;,
    descriptor_pool: vk::DescriptorPool,
    // ...
}
</code></pre>
<p>Add a new <code>AppData</code> field to store the handle of the descriptor pool so you can call <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.create_descriptor_pool"><code class="hljs">create_descriptor_pool</code></a> to create it.</p>
<pre><code class="language-rust noplaypen">data.descriptor_pool = device.create_descriptor_pool(&amp;info, None)?;
</code></pre>
<p>The descriptor pool should be destroyed when the swapchain is recreated because it depends on the number of images:</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy_swapchain(&amp;mut self) {
    self.device.destroy_descriptor_pool(self.data.descriptor_pool, None);
    // ...
}
</code></pre>
<p>And recreated in <code>App::recreate_swapchain</code>:</p>
<pre><code class="language-rust noplaypen">unsafe fn recreate_swapchain(&amp;mut self, window: &amp;Window) -&gt; Result&lt;()&gt; {
    // ...
    create_uniform_buffers(&amp;self.instance, &amp;self.device, &amp;mut self.data)?;
    create_descriptor_pool(&amp;self.device, &amp;mut self.data)?;
    // ...
}
</code></pre>
<h2 id="descriptor-set"><a class="header" href="#descriptor-set">Descriptor set</a></h2>
<p>We can now allocate the descriptor sets themselves. Add a <code>create_descriptor_sets</code> function for that purpose:</p>
<pre><code class="language-rust noplaypen">impl App {
    unsafe fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        // ...
        create_descriptor_pool(&amp;device, &amp;mut data)?;
        create_descriptor_sets(&amp;device, &amp;mut data)?;
        // ...
    }

    unsafe fn recreate_swapchain(&amp;mut self, window: &amp;Window) -&gt; Result&lt;()&gt; {
        // ..
        create_descriptor_pool(&amp;self.device, &amp;mut self.data)?;
        create_descriptor_sets(&amp;self.device, &amp;mut self.data)?;
        // ..
    }
}

unsafe fn create_descriptor_sets(device: &amp;Device, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    Ok(())
}
</code></pre>
<p>A descriptor set allocation is described with a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DescriptorSetAllocateInfo.html"><code class="hljs">vk::DescriptorSetAllocateInfo</code></a> struct. You need to specify the descriptor pool to allocate from and an array of descriptor set layouts that describes each of the descriptor sets you are allocating:</p>
<pre><code class="language-rust noplaypen">let layouts = vec![data.descriptor_set_layout; data.swapchain_images.len()];
let info = vk::DescriptorSetAllocateInfo::builder()
    .descriptor_pool(data.descriptor_pool)
    .set_layouts(&amp;layouts);
</code></pre>
<p>In our case we will create one descriptor set for each swapchain image, all with the same layout. Unfortunately we do need all the copies of the layout because the next function expects an array matching the number of sets.</p>
<p>Add an <code>AppData</code> field to hold the descriptor set handles:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    descriptor_pool: vk::DescriptorPool,
    descriptor_sets: Vec&lt;vk::DescriptorSet&gt;,
    // ...
}
</code></pre>
<p>And then allocate them with <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.allocate_descriptor_sets"><code class="hljs">allocate_descriptor_sets</code></a>:</p>
<pre><code class="language-rust noplaypen">data.descriptor_sets = device.allocate_descriptor_sets(&amp;info)?;
</code></pre>
<p>You don't need to explicitly clean up descriptor sets, because they will be automatically freed when the descriptor pool is destroyed. The call to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.allocate_descriptor_sets"><code class="hljs">allocate_descriptor_sets</code></a> will allocate descriptor sets, each with one uniform buffer descriptor.</p>
<p>The descriptor sets have been allocated now, but the descriptors within still need to be configured. We'll now add a loop to populate every descriptor:</p>
<pre><code class="language-rust noplaypen">for i in 0..data.swapchain_images.len() {

}
</code></pre>
<p>Descriptors that refer to buffers, like our uniform buffer descriptor, are configured with a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DescriptorBufferInfo.html"><code class="hljs">vk::DescriptorBufferInfo</code></a> struct. This structure specifies the buffer and the region within it that contains the data for the descriptor.</p>
<pre><code class="language-rust noplaypen">for i in 0..data.swapchain_images.len() {
    let info = vk::DescriptorBufferInfo::builder()
        .buffer(data.uniform_buffers[i])
        .offset(0)
        .range(size_of::&lt;UniformBufferObject&gt;() as u64);
}
</code></pre>
<p>If you're overwriting the whole buffer, like we are in this case, then it is is also possible to use the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/constant.WHOLE_SIZE.html"><code class="hljs">vk::WHOLE_SIZE</code></a> value for the range. The configuration of descriptors is updated using the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.update_descriptor_sets"><code class="hljs">update_descriptor_sets</code></a> function, which takes an array of <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.WriteDescriptorSet.html"><code class="hljs">vk::WriteDescriptorSet</code></a> structs as parameter.</p>
<pre><code class="language-rust noplaypen">let buffer_info = &amp;[info];
let ubo_write = vk::WriteDescriptorSet::builder()
    .dst_set(data.descriptor_sets[i])
    .dst_binding(0)
    .dst_array_element(0)
    // continued...
</code></pre>
<p>The first two fields specify the descriptor set to update and the binding. We gave our uniform buffer binding index <code>0</code>. Remember that descriptors can be arrays, so we also need to specify the first index in the array that we want to update. We're not using an array, so the index is simply <code>0</code>.</p>
<pre><code class="language-rust noplaypen">    .descriptor_type(vk::DescriptorType::UNIFORM_BUFFER)
</code></pre>
<p>We need to specify the type of descriptor again. It's possible to update multiple descriptors at once in an array, starting at index <code>dst_array_element</code>.</p>
<pre><code class="language-rust noplaypen">    .buffer_info(buffer_info);
</code></pre>
<p>The last field references an array with <code>descriptor_count</code> structs that actually configure the descriptors. It depends on the type of descriptor which one of the three you actually need to use. The <code>buffer_info</code> field is used for descriptors that refer to buffer data, <code>image_info</code> is used for descriptors that refer to image data, and <code>texel_buffer_view</code> is used for descriptors that refer to buffer views. Our descriptor is based on buffers, so we're using <code>buffer_info</code>.</p>
<pre><code class="language-rust noplaypen">device.update_descriptor_sets(&amp;[ubo_write], &amp;[] as &amp;[vk::CopyDescriptorSet]);
</code></pre>
<p>The updates are applied using <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.update_descriptor_sets"><code class="hljs">update_descriptor_sets</code></a>. It accepts two kinds of arrays as parameters: an array of <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.WriteDescriptorSet.html"><code class="hljs">vk::WriteDescriptorSet</code></a> and an array of <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.CopyDescriptorSet.html"><code class="hljs">vk::CopyDescriptorSet</code></a>. The latter can be used to copy descriptors to each other, as its name implies.</p>
<h2 id="using-descriptor-sets"><a class="header" href="#using-descriptor-sets">Using descriptor sets</a></h2>
<p>We now need to update the <code>create_command_buffers</code> function to actually bind the right descriptor set for each swapchain image to the descriptors in the shader with <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_bind_descriptor_sets"><code class="hljs">cmd_bind_descriptor_sets</code></a>. This needs to be done before the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_draw_indexed"><code class="hljs">cmd_draw_indexed</code></a> call:</p>
<pre><code class="language-rust noplaypen">device.cmd_bind_descriptor_sets(
    *command_buffer,
    vk::PipelineBindPoint::GRAPHICS,
    data.pipeline_layout,
    0,
    &amp;[data.descriptor_sets[i]],
    &amp;[],
);
device.cmd_draw_indexed(*command_buffer, INDICES.len() as u32, 1, 0, 0, 0);
</code></pre>
<p>Unlike vertex and index buffers, descriptor sets are not unique to graphics pipelines. Therefore we need to specify if we want to bind descriptor sets to the graphics or compute pipeline. The next parameter is the layout that the descriptors are based on. The next two parameters specify the index of the first descriptor set and the array of sets to bind. We'll get back to this in a moment. The last parameter specifies an array of offsets that are used for dynamic descriptors. We'll look at these in a future chapter.</p>
<p>If you run your program now, then you'll notice that unfortunately nothing is visible. The problem is that because of the Y-flip we did in the projection matrix, the vertices are now being drawn in counter-clockwise order instead of clockwise order. This causes backface culling to kick in and prevents any geometry from being drawn. Go to the <code>create_pipeline</code> function and modify the <code>front_face</code> in <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PipelineRasterizationStateCreateInfo.html"><code class="hljs">vk::PipelineRasterizationStateCreateInfo</code></a> to correct this:</p>
<pre><code class="language-rust noplaypen">    .cull_mode(vk::CullModeFlags::BACK)
    .front_face(vk::FrontFace::COUNTER_CLOCKWISE)
</code></pre>
<p>Run your program again and you should now see the following:</p>
<p><img src="uniform/../images/spinning_quad.png" alt="" /></p>
<p>The rectangle has changed into a square because the projection matrix now corrects for aspect ratio. The <code>App::update_uniform_buffer</code> method takes care of screen resizing, so we don't need to recreate the descriptor set in <code>App::recreate_swapchain</code>.</p>
<h2 id="alignment-requirements"><a class="header" href="#alignment-requirements">Alignment requirements</a></h2>
<p>One thing we've glossed over so far is how exactly the data in the Rust structure should match with the uniform definition in the shader. It seems obvious enough to simply use the same types in both:</p>
<pre><code class="language-rust noplaypen">#[repr(C)]
#[derive(Copy, Clone, Debug)]
struct UniformBufferObject {
    model: Mat4,
    view: Mat4,
    proj: Mat4,
}
</code></pre>
<pre><code class="language-glsl">layout(binding = 0) uniform UniformBufferObject {
    mat4 model;
    mat4 view;
    mat4 proj;
} ubo;
</code></pre>
<p>However, that's not all there is to it. For example, try modifying the struct and shader to look like this:</p>
<pre><code class="language-rust noplaypen">#[repr(C)]
#[derive(Copy, Clone, Debug)]
struct UniformBufferObject {
    foo: Vec2,
    model: Mat4,
    view: Mat4,
    proj: Mat4,
}
</code></pre>
<pre><code class="language-glsl">layout(binding = 0) uniform UniformBufferObject {
    vec2 foo;
    mat4 model;
    mat4 view;
    mat4 proj;
} ubo;
</code></pre>
<p>Recompile your shader and your program and run it and you'll find that the colorful square you worked so far has disappeared! That's because we haven't taken into account the <em>alignment requirements</em>.</p>
<p>Vulkan expects the data in your structure to be aligned in memory in a specific way, for example:</p>
<ul>
<li>Scalars have to be aligned by N (= 4 bytes given 32 bit floats).</li>
<li>A <code>vec2</code> must be aligned by 2N (= 8 bytes)</li>
<li>A <code>vec3</code> or <code>vec4</code> must be aligned by 4N (= 16 bytes)</li>
<li>A nested structure must be aligned by the base alignment of its members rounded up to a multiple of 16.</li>
<li>A <code>mat4</code> matrix must have the same alignment as a <code>vec4</code>.</li>
</ul>
<p>You can find the full list of alignment requirements in <a href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/chap14.html#interfaces-resources-layout">the specification</a>.</p>
<p>Our original shader with just three <code>mat4</code> fields already met the alignment requirements. As each <code>mat4</code> is 4 x 4 x 4 = 64 bytes in size, <code>model</code> has an offset of <code>0</code>, <code>view</code> has an offset of 64 and <code>proj</code> has an offset of 128. All of these are multiples of 16 and that's why it worked fine.</p>
<p>The new structure starts with a <code>vec2</code> which is only 8 bytes in size and therefore throws off all of the offsets. Now <code>model</code> has an offset of <code>8</code>, <code>view</code> an offset of <code>72</code> and <code>proj</code> an offset of <code>136</code>, none of which are multiples of 16. Unfortunately Rust does not have great support for controlling the alignment of fields in structs, but we can use some manual padding to fix the alignment issues:</p>
<pre><code class="language-rust noplaypen">#[repr(C)]
#[derive(Copy, Clone, Debug)]
struct UniformBufferObject {
    foo: Vec2,
    _padding: [u8; 8],
    model: Mat4,
    view: Mat4,
    proj: Mat4,
}
</code></pre>
<p>If you now compile and run your program again you should see that the shader correctly receives its matrix values once again.</p>
<h2 id="multiple-descriptor-sets"><a class="header" href="#multiple-descriptor-sets">Multiple descriptor sets</a></h2>
<p>As some of the structures and function calls hinted at, it is actually possible to bind multiple descriptor sets simultaneously. You need to specify a descriptor set layout for each descriptor set when creating the pipeline layout. Shaders can then reference specific descriptor sets like this:</p>
<pre><code class="language-glsl">layout(set = 0, binding = 0) uniform UniformBufferObject { ... }
</code></pre>
<p>You can use this feature to put descriptors that vary per-object and descriptors that are shared into separate descriptor sets. In that case you avoid rebinding most of the descriptors across draw calls which is potentially more efficient.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="images"><a class="header" href="#images">Images</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/23_texture_image.rs">main.rs</a></p>
<p>The geometry has been colored using per-vertex colors so far, which is a rather limited approach. In this part of the tutorial we're going to implement texture mapping to make the geometry look more interesting. This will also allow us to load and draw basic 3D models in a future chapter.</p>
<p>Adding a texture to our application will involve the following steps:</p>
<ul>
<li>Create an image object backed by device memory</li>
<li>Fill it with pixels from an image file</li>
<li>Create an image sampler</li>
<li>Add a combined image sampler descriptor to sample colors from the texture</li>
</ul>
<p>We've already worked with image objects before, but those were automatically created by the swapchain extension. This time we'll have to create one by ourselves. Creating an image and filling it with data is similar to vertex buffer creation. We'll start by creating a staging resource and filling it with pixel data and then we copy this to the final image object that we'll use for rendering. Although it is possible to create a staging image for this purpose, Vulkan also allows you to copy pixels from a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Buffer.html"><code class="hljs">vk::Buffer</code></a> to an image and the API for this is actually <a href="https://developer.nvidia.com/vulkan-memory-management">faster on some hardware</a>. We'll first create this buffer and fill it with pixel values, and then we'll create an image to copy the pixels to. Creating an image is not very different from creating buffers. It involves querying the memory requirements, allocating device memory and binding it, just like we've seen before.</p>
<p>However, there is something extra that we'll have to take care of when working with images. Images can have different <em>layouts</em> that affect how the pixels are organized in memory. Due to the way graphics hardware works, simply storing the pixels row by row may not lead to the best performance, for example. When performing any operation on images, you must make sure that they have the layout that is optimal for use in that operation. We've actually already seen some of these layouts when we specified the render pass:</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.PRESENT_SRC_KHR"><code class="hljs">vk::ImageLayout::PRESENT_SRC_KHR</code></a> – Optimal for presentation </li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.COLOR_ATTACHMENT_OPTIMAL"><code class="hljs">vk::ImageLayout::COLOR_ATTACHMENT_OPTIMAL</code></a> – Optimal as attachment for writing colors from the fragment shader </li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.TRANSFER_SRC_OPTIMAL"><code class="hljs">vk::ImageLayout::TRANSFER_SRC_OPTIMAL</code></a> – Optimal as source in a transfer operation, like <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_copy_image_to_buffer"><code class="hljs">cmd_copy_image_to_buffer</code></a> </li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.TRANSFER_DST_OPTIMAL"><code class="hljs">vk::ImageLayout::TRANSFER_DST_OPTIMAL</code></a> – Optimal as destination in a transfer operation, like <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_copy_buffer_to_image"><code class="hljs">cmd_copy_buffer_to_image</code></a> </li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.SHADER_READ_ONLY_OPTIMAL"><code class="hljs">vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL</code></a> – Optimal for sampling from a shader </li>
</ul>
<p>One of the most common ways to transition the layout of an image is a <em>pipeline barrier</em>. Pipeline barriers are primarily used for synchronizing access to resources, like making sure that an image was written to before it is read, but they can also be used to transition layouts. In this chapter we'll see how pipeline barriers are used for this purpose. Barriers can additionally be used to transfer queue family ownership when using <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SharingMode.html#associatedconstant.EXCLUSIVE"><code class="hljs">vk::SharingMode::EXCLUSIVE</code></a>.</p>
<h2 id="image-library"><a class="header" href="#image-library">Image library</a></h2>
<p>There are many libraries available for loading images, and you can even write your own code to load simple formats like BMP and PPM. In this tutorial we'll be using the <a href="https://crates.io/crates/png"><code>png</code></a> crate which you should have already added to your program's dependencies.</p>
<h2 id="loading-an-image"><a class="header" href="#loading-an-image">Loading an image</a></h2>
<p>We'll need to open the image file, so add the following import:</p>
<pre><code class="language-rust noplaypen">use std::fs::File;
</code></pre>
<p>Create a new function <code>create_texture_image</code> where we'll load an image and upload it into a Vulkan image object. We're going to use command buffers, so it should be called after <code>create_command_pool</code>.</p>
<pre><code class="language-rust noplaypen">impl App {
    unsafe fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        // ...
        create_command_pool(&amp;instance, &amp;device, &amp;mut data)?;
        create_texture_image(&amp;instance, &amp;device, &amp;mut data)?;
        // ...
    }
}

unsafe fn create_texture_image(
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;mut AppData,
) -&gt; Result&lt;()&gt; {
    Ok(())
}
</code></pre>
<p>Create a new directory <code>resources</code> next to the <code>shaders</code> directory to store texture images in. We're going to load an image called <code>texture.png</code> from that directory. I've chosen to use the following <a href="https://pixabay.com/en/statue-sculpture-fig-historically-1275469/">CC0 licensed image</a> resized to 512 x 512 pixels, but feel free to pick any PNG image (with an alpha channel) you want.</p>
<p><img src="texture/../images/texture.png" alt="" /></p>
<p>Loading an image with this library is really easy:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_texture_image(
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;mut AppData,
) -&gt; Result&lt;()&gt; {
    let image = File::open(&quot;resources/texture.png&quot;)?;

    let decoder = png::Decoder::new(image);
    let mut reader = decoder.read_info()?;

    let mut pixels = vec![0;  reader.info().raw_bytes()];
    reader.next_frame(&amp;mut pixels)?;

    let size = reader.info().raw_bytes() as u64;
    let (width, height) = reader.info().size();

    Ok(())
}
</code></pre>
<p>This code will populate the <code>pixels</code> list with the pixels data with 4 bytes per pixel which will result in a total of <code>width * height * 4</code> values. Note that the <code>png</code> crate <a href="https://github.com/image-rs/image-png/issues/239">does not have support for converting RGB images into RGBA images (at the time of writing)</a> and the following code is expecting the pixel data to have an alpha channel. As a result you will need to make sure you use PNG images with alpha channels (such as the above image).</p>
<h2 id="staging-buffer-1"><a class="header" href="#staging-buffer-1">Staging buffer</a></h2>
<p>We're now going to create a buffer in host visible memory so that we can use <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.map_memory"><code class="hljs">map_memory</code></a> and copy the pixels to it. The buffer should be in host visible memory so that we can map it and it should be usable as a transfer source so that we can copy it to an image later on:</p>
<pre><code class="language-rust noplaypen">let (staging_buffer, staging_buffer_memory) = create_buffer(
    instance,
    device,
    data,
    size,
    vk::BufferUsageFlags::TRANSFER_SRC,
    vk::MemoryPropertyFlags::HOST_COHERENT | vk::MemoryPropertyFlags::HOST_VISIBLE,
)?;
</code></pre>
<p>We can then directly copy the pixel values that we got from the image loading library to the buffer:</p>
<pre><code class="language-rust noplaypen">let memory = device.map_memory(
    staging_buffer_memory,
    0,
    size,
    vk::MemoryMapFlags::empty(),
)?;

memcpy(pixels.as_ptr(), memory.cast(), pixels.len());

device.unmap_memory(staging_buffer_memory);
</code></pre>
<h2 id="texture-image"><a class="header" href="#texture-image">Texture Image</a></h2>
<p>Although we could set up the shader to access the pixel values in the buffer, it's better to use image objects in Vulkan for this purpose. Image objects will make it easier and faster to retrieve colors by allowing us to use 2D coordinates, for one. Pixels within an image object are known as texels and we'll use that name from this point on. Add the following new <code>AppData</code> fields:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    texture_image: vk::Image,
    texture_image_memory: vk::DeviceMemory,
}
</code></pre>
<p>The parameters for an image are specified in a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageCreateInfo.html"><code class="hljs">vk::ImageCreateInfo</code></a> struct:</p>
<pre><code class="language-rust noplaypen">let info = vk::ImageCreateInfo::builder()
    .image_type(vk::ImageType::_2D)
    .extent(vk::Extent3D { width, height, depth: 1 })
    .mip_levels(1)
    .array_layers(1)
    // continued...
</code></pre>
<p>The image type, specified in the <code>image_type</code> field, tells Vulkan with what kind of coordinate system the texels in the image are going to be addressed. It is possible to create 1D, 2D and 3D images. One dimensional images can be used to store an array of data or gradient, two dimensional images are mainly used for textures, and three dimensional images can be used to store voxel volumes, for example. The <code>extent</code> field specifies the dimensions of the image, basically how many texels there are on each axis. That's why <code>depth</code> must be <code>1</code> instead of <code>0</code>. Our texture will not be an array and we won't be using mipmapping for now.</p>
<pre><code class="language-rust noplaypen">    .format(vk::Format::R8G8B8A8_SRGB)
</code></pre>
<p>Vulkan supports many possible image formats, but we should use the same format for the texels as the pixels in the buffer, otherwise the copy operation will fail.</p>
<pre><code class="language-rust noplaypen">    .tiling(vk::ImageTiling::OPTIMAL)
</code></pre>
<p>The <code>tiling</code> field can have one of two values:</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageTiling.html#associatedconstant.LINEAR"><code class="hljs">vk::ImageTiling::LINEAR</code></a> – Texels are laid out in row-major order like our <code>pixels</code> array</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageTiling.html#associatedconstant.OPTIMAL"><code class="hljs">vk::ImageTiling::OPTIMAL</code></a> – Texels are laid out in an implementation defined order for optimal access</li>
</ul>
<p>Unlike the layout of an image, the tiling mode cannot be changed at a later time. If you want to be able to directly access texels in the memory of the image, then you must use <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageTiling.html#associatedconstant.LINEAR"><code class="hljs">vk::ImageTiling::LINEAR</code></a>. We will be using a staging buffer instead of a staging image, so this won't be necessary. We will be using <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageTiling.html#associatedconstant.OPTIMAL"><code class="hljs">vk::ImageTiling::OPTIMAL</code></a> for efficient access from the shader.</p>
<pre><code class="language-rust noplaypen">    .initial_layout(vk::ImageLayout::UNDEFINED)
</code></pre>
<p>There are only two possible values for the <code>initial_layout</code> of an image:</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.UNDEFINED"><code class="hljs">vk::ImageLayout::UNDEFINED</code></a> – Not usable by the GPU and the very first transition will discard the texels.</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.PREINITIALIZED"><code class="hljs">vk::ImageLayout::PREINITIALIZED</code></a> – Not usable by the GPU, but the first transition will preserve the texels.</li>
</ul>
<p>There are few situations where it is necessary for the texels to be preserved during the first transition. One example, however, would be if you wanted to use an image as a staging image in combination with the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageTiling.html#associatedconstant.LINEAR"><code class="hljs">vk::ImageTiling::LINEAR</code></a> layout. In that case, you'd want to upload the texel data to it and then transition the image to be a transfer source without losing the data. In our case, however, we're first going to transition the image to be a transfer destination and then copy texel data to it from a buffer object, so we don't need this property and can safely use <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.UNDEFINED"><code class="hljs">vk::ImageLayout::UNDEFINED</code></a>.</p>
<pre><code class="language-rust noplaypen">    .usage(vk::ImageUsageFlags::SAMPLED | vk::ImageUsageFlags::TRANSFER_DST)
</code></pre>
<p>The <code>usage</code> field has the same semantics as the one during buffer creation. The image is going to be used as destination for the buffer copy, so it should be set up as a transfer destination. We also want to be able to access the image from the shader to color our mesh, so the usage should include <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageUsageFlags.html#associatedconstant.SAMPLED"><code class="hljs">vk::ImageUsageFlags::SAMPLED</code></a>.</p>
<pre><code class="language-rust noplaypen">    .sharing_mode(vk::SharingMode::EXCLUSIVE)
</code></pre>
<p>The image will only be used by one queue family: the one that supports graphics (and therefore also) transfer operations.</p>
<pre><code class="language-rust noplaypen">    .samples(vk::SampleCountFlags::_1)
</code></pre>
<p>The <code>samples</code> flag is related to multisampling. This is only relevant for images that will be used as attachments, so stick to one sample. </p>
<pre><code class="language-rust noplaypen">    .flags(vk::ImageCreateFlags::empty()); // Optional.
</code></pre>
<p>There are also some optional flags for images that allow controlling more advanced properties for things like sparse images. Sparse images are images where only certain regions are actually backed by memory. If you were using a 3D texture for a voxel terrain, for example, then you could use this to avoid allocating memory to store large volumes of &quot;air&quot; values. We won't be using it in this tutorial, so you can omit the builder method for this field which will set it to the default (an empty set of flags).</p>
<pre><code class="language-c++">data.texture_image = device.create_image(&amp;info, None)?;
</code></pre>
<p>The image is created using <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.create_image"><code class="hljs">create_image</code></a>, which doesn't have any particularly noteworthy parameters. It is possible that the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Format.html#associatedconstant.R8G8B8A8_SRGB"><code class="hljs">vk::Format::R8G8B8A8_SRGB</code></a> format is not supported by the graphics hardware. You should have a list of acceptable alternatives and go with the best one that is supported. However, support for this particular format is so widespread that we'll skip this step. Using different formats would also require annoying conversions. We will get back to this in the depth buffer chapter, where we'll implement such a system.</p>
<pre><code class="language-rust noplaypen">let requirements = device.get_image_memory_requirements(data.texture_image);

let info = vk::MemoryAllocateInfo::builder()
    .allocation_size(requirements.size)
    .memory_type_index(get_memory_type_index(
        instance,
        data,
        vk::MemoryPropertyFlags::DEVICE_LOCAL,
        requirements,
    )?);

data.texture_image_memory = device.allocate_memory(&amp;info, None)?;

device.bind_image_memory(data.texture_image, data.texture_image_memory, 0)?;
</code></pre>
<p>Allocating memory for an image works in exactly the same way as allocating memory for a buffer. Use <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.get_image_memory_requirements"><code class="hljs">get_image_memory_requirements</code></a> instead of <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.get_buffer_memory_requirements"><code class="hljs">get_buffer_memory_requirements</code></a>, and use <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.bind_image_memory"><code class="hljs">bind_image_memory</code></a> instead of <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.bind_buffer_memory"><code class="hljs">bind_buffer_memory</code></a>.</p>
<p>This function is already getting quite large and there'll be a need to create more images in later chapters, so we should abstract image creation into a <code>create_image</code> function, like we did for buffers. Create the function and move the image object creation and memory allocation to it:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_image(
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;AppData,
    width: u32,
    height: u32,
    format: vk::Format,
    tiling: vk::ImageTiling,
    usage: vk::ImageUsageFlags,
    properties: vk::MemoryPropertyFlags,
) -&gt; Result&lt;(vk::Image, vk::DeviceMemory)&gt; {
    let info = vk::ImageCreateInfo::builder()
        .image_type(vk::ImageType::_2D)
        .extent(vk::Extent3D {
            width,
            height,
            depth: 1,
        })
        .mip_levels(1)
        .array_layers(1)
        .format(format)
        .tiling(tiling)
        .initial_layout(vk::ImageLayout::UNDEFINED)
        .usage(usage)
        .samples(vk::SampleCountFlags::_1)
        .sharing_mode(vk::SharingMode::EXCLUSIVE);

    let image = device.create_image(&amp;info, None)?;

    let requirements = device.get_image_memory_requirements(image);

    let info = vk::MemoryAllocateInfo::builder()
        .allocation_size(requirements.size)
        .memory_type_index(get_memory_type_index(
            instance,
            data,
            properties,
            requirements,
        )?);

    let image_memory = device.allocate_memory(&amp;info, None)?;

    device.bind_image_memory(image, image_memory, 0)?;

    Ok((image, image_memory))
}
</code></pre>
<p>I've made the width, height, format, tiling mode, usage, and memory properties parameters, because these will all vary between the images we'll be creating throughout this tutorial.</p>
<p>The <code>create_texture_image</code> function can now be simplified to:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_texture_image(
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;mut AppData,
) -&gt; Result&lt;()&gt; {
    let image = File::open(&quot;resources/texture.png&quot;)?;

    let decoder = png::Decoder::new(image);
    let mut reader = decoder.read_info()?;

    let mut pixels = vec![0;  reader.info().raw_bytes()];
    reader.next_frame(&amp;mut pixels)?;

    let size = reader.info().raw_bytes() as u64;
    let (width, height) = reader.info().size();

    let (staging_buffer, staging_buffer_memory) = create_buffer(
        instance,
        device,
        data,
        size,
        vk::BufferUsageFlags::TRANSFER_SRC,
        vk::MemoryPropertyFlags::HOST_COHERENT | vk::MemoryPropertyFlags::HOST_VISIBLE,
    )?;

    let memory = device.map_memory(
        staging_buffer_memory,
        0,
        size,
        vk::MemoryMapFlags::empty(),
    )?;

    memcpy(pixels.as_ptr(), memory.cast(), pixels.len());

    device.unmap_memory(staging_buffer_memory);

    let (texture_image, texture_image_memory) = create_image(
        instance,
        device,
        data,
        width,
        height,
        vk::Format::R8G8B8A8_SRGB,
        vk::ImageTiling::OPTIMAL,
        vk::ImageUsageFlags::SAMPLED | vk::ImageUsageFlags::TRANSFER_DST,
        vk::MemoryPropertyFlags::DEVICE_LOCAL,
    )?;

    data.texture_image = texture_image;
    data.texture_image_memory = texture_image_memory;

    Ok(())
}
</code></pre>
<h2 id="layout-transitions"><a class="header" href="#layout-transitions">Layout transitions</a></h2>
<p>The function we're going to write now involves recording and executing a command buffer again, so now's a good time to move that logic into a helper function or two:</p>
<pre><code class="language-rust noplaypen">unsafe fn begin_single_time_commands(
    device: &amp;Device,
    data: &amp;AppData,
) -&gt; Result&lt;vk::CommandBuffer&gt; {
    let info = vk::CommandBufferAllocateInfo::builder()
        .level(vk::CommandBufferLevel::PRIMARY)
        .command_pool(data.command_pool)
        .command_buffer_count(1);

    let command_buffer = device.allocate_command_buffers(&amp;info)?[0];

    let info = vk::CommandBufferBeginInfo::builder()
        .flags(vk::CommandBufferUsageFlags::ONE_TIME_SUBMIT);

    device.begin_command_buffer(command_buffer, &amp;info)?;

    Ok(command_buffer)
}

unsafe fn end_single_time_commands(
    device: &amp;Device,
    data: &amp;AppData,
    command_buffer: vk::CommandBuffer,
) -&gt; Result&lt;()&gt; {
    device.end_command_buffer(command_buffer)?;

    let command_buffers = &amp;[command_buffer];
    let info = vk::SubmitInfo::builder()
        .command_buffers(command_buffers);

    device.queue_submit(data.graphics_queue, &amp;[info], vk::Fence::null())?;
    device.queue_wait_idle(data.graphics_queue)?;

    device.free_command_buffers(data.command_pool, &amp;[command_buffer]);

    Ok(())
}
</code></pre>
<p>The code for these functions is based on the existing code in <code>copy_buffer</code>. You can now simplify that function to:</p>
<pre><code class="language-rust noplaypen">unsafe fn copy_buffer(
    device: &amp;Device,
    data: &amp;AppData,
    source: vk::Buffer,
    destination: vk::Buffer,
    size: vk::DeviceSize,
) -&gt; Result&lt;()&gt; {
    let command_buffer = begin_single_time_commands(device, data)?;

    let regions = vk::BufferCopy::builder().size(size);
    device.cmd_copy_buffer(command_buffer, source, destination, &amp;[regions]);

    end_single_time_commands(device, data, command_buffer)?;

    Ok(())
}
</code></pre>
<p>If we were still using buffers, then we could now write a function to record and execute <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_copy_buffer_to_image"><code class="hljs">cmd_copy_buffer_to_image</code></a> to finish the job, but this command requires the image to be in the right layout first. Create a new function to handle layout transitions:</p>
<pre><code class="language-rust noplaypen">unsafe fn transition_image_layout(
    device: &amp;Device,
    data: &amp;AppData,
    image: vk::Image,
    format: vk::Format,
    old_layout: vk::ImageLayout,
    new_layout: vk::ImageLayout,
) -&gt; Result&lt;()&gt; {
    let command_buffer = begin_single_time_commands(device, data)?;

    end_single_time_commands(device, data, command_buffer)?;

    Ok(())
}
</code></pre>
<p>One of the most common ways to perform layout transitions is using an <em>image memory barrier</em>. A pipeline barrier like that is generally used to synchronize access to resources, like ensuring that a write to a buffer completes before reading from it, but it can also be used to transition image layouts and transfer queue family ownership when <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SharingMode.html#associatedconstant.EXCLUSIVE"><code class="hljs">vk::SharingMode::EXCLUSIVE</code></a> is used. There is an equivalent <em>buffer memory barrier</em> to do this for buffers.</p>
<pre><code class="language-rust noplaypen">let barrier = vk::ImageMemoryBarrier::builder()
    .old_layout(old_layout)
    .new_layout(new_layout)
    // continued...
</code></pre>
<p>The first two fields specify layout transition. It is possible to use <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.UNDEFINED"><code class="hljs">vk::ImageLayout::UNDEFINED</code></a> as <code>old_layout</code> if you don't care about the existing contents of the image.</p>
<pre><code class="language-rust noplaypen">    .src_queue_family_index(vk::QUEUE_FAMILY_IGNORED)
    .dst_queue_family_index(vk::QUEUE_FAMILY_IGNORED)
</code></pre>
<p>If you are using the barrier to transfer queue family ownership, then these two fields should be the indices of the queue families. They must be set to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/constant.QUEUE_FAMILY_IGNORED.html"><code class="hljs">vk::QUEUE_FAMILY_IGNORED</code></a> if you don't want to do this (not the default value!).</p>
<pre><code class="language-rust noplaypen">    .image(image)
    .subresource_range(subresource)
</code></pre>
<p>The <code>image</code> and <code>subresource_range</code> specify the image that is affected and the specific part of the image. We'll need to define <code>subresource</code> before our image memory barrier:</p>
<pre><code class="language-rust noplaypen">let subresource = vk::ImageSubresourceRange::builder()
    .aspect_mask(vk::ImageAspectFlags::COLOR)
    .base_mip_level(0)
    .level_count(1)
    .base_array_layer(0)
    .layer_count(1);
</code></pre>
<p>Our image is not an array and does not have mipmapping levels, so only one level and layer are specified.</p>
<pre><code class="language-rust noplaypen">    .src_access_mask(vk::AccessFlags::empty())  // TODO
    .dst_access_mask(vk::AccessFlags::empty()); // TODO
</code></pre>
<p>Barriers are primarily used for synchronization purposes, so you must specify which types of operations that involve the resource must happen before the barrier, and which operations that involve the resource must wait on the barrier. We need to do that despite already using <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.queue_wait_idle"><code class="hljs">queue_wait_idle</code></a> to manually synchronize. The right values depend on the old and new layout, so we'll get back to this once we've figured out which transitions we're going to use.</p>
<pre><code class="language-rust noplaypen">device.cmd_pipeline_barrier(
    command_buffer,
    vk::PipelineStageFlags::empty(), // TODO
    vk::PipelineStageFlags::empty(), // TODO
    vk::DependencyFlags::empty(),
    &amp;[] as &amp;[vk::MemoryBarrier],
    &amp;[] as &amp;[vk::BufferMemoryBarrier],
    &amp;[barrier],
);
</code></pre>
<p>All types of pipeline barriers are submitted using the same function. The first parameter after the command buffer specifies in which pipeline stage the operations occur that should happen before the barrier. The second parameter specifies the pipeline stage in which operations will wait on the barrier. The pipeline stages that you are allowed to specify before and after the barrier depend on how you use the resource before and after the barrier. The allowed values are listed in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-types-supported">this table</a> of the specification. For example, if you're going to read from a uniform after the barrier, you would specify a usage of <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.AccessFlags.html#associatedconstant.UNIFORM_READ"><code class="hljs">vk::AccessFlags::UNIFORM_READ</code></a> and the earliest shader that will read from the uniform as pipeline stage, for example <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PipelineStageFlags.html#associatedconstant.FRAGMENT_SHADER"><code class="hljs">vk::PipelineStageFlags::FRAGMENT_SHADER</code></a>. It would not make sense to specify a non-shader pipeline stage for this type of usage and the validation layers will warn you when you specify a pipeline stage that does not match the type of usage.</p>
<p>The fourth parameter is either an empty set of <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DependencyFlags.html"><code class="hljs">vk::DependencyFlags</code></a> or <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DependencyFlags.html#associatedconstant.BY_REGION"><code class="hljs">vk::DependencyFlags::BY_REGION</code></a>. The latter turns the barrier into a per-region condition. That means that the implementation is allowed to already begin reading from the parts of a resource that were written so far, for example.</p>
<p>The last three parameters reference slices of pipeline barriers of the three available types: memory barriers, buffer memory barriers, and image memory barriers like the one we're using here. Note that we're not using the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Format.html"><code class="hljs">vk::Format</code></a> parameter yet, but we'll be using that one for special transitions in the depth buffer chapter.</p>
<h2 id="copying-buffer-to-image"><a class="header" href="#copying-buffer-to-image">Copying buffer to image</a></h2>
<p>Before we get back to <code>create_texture_image</code>, we're going to write one more helper function: <code>copy_buffer_to_image</code>:</p>
<pre><code class="language-rust noplaypen">unsafe fn copy_buffer_to_image(
    device: &amp;Device,
    data: &amp;AppData,
    buffer: vk::Buffer,
    image: vk::Image,
    width: u32,
    height: u32,
) -&gt; Result&lt;()&gt; {
    let command_buffer = begin_single_time_commands(device, data)?;

    end_single_time_commands(device, data, command_buffer)?;

    Ok(())
}
</code></pre>
<p>Just like with buffer copies, you need to specify which part of the buffer is going to be copied to which part of the image. This happens through <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.BufferImageCopy.html"><code class="hljs">vk::BufferImageCopy</code></a> structs:</p>
<pre><code class="language-rust noplaypen">let subresource = vk::ImageSubresourceLayers::builder()
    .aspect_mask(vk::ImageAspectFlags::COLOR)
    .mip_level(0)
    .base_array_layer(0)
    .layer_count(1);

let region = vk::BufferImageCopy::builder()
    .buffer_offset(0)
    .buffer_row_length(0)
    .buffer_image_height(0)
    .image_subresource(subresource)
    .image_offset(vk::Offset3D { x: 0, y: 0, z: 0 })
    .image_extent(vk::Extent3D { width, height, depth: 1 });
</code></pre>
<p>Most of these fields are self-explanatory. The <code>buffer_offset</code> specifies the byte offset in the buffer at which the pixel values start. The <code>buffer_row_length</code> and <code>buffer_image_height</code> fields specify how the pixels are laid out in memory. For example, you could have some padding bytes between rows of the image. Specifying <code>0</code> for both indicates that the pixels are simply tightly packed like they are in our case. The <code>image_subresource</code>, <code>image_offset</code> and <code>image_extent</code> fields indicate to which part of the image we want to copy the pixels.</p>
<p>Buffer to image copy operations are enqueued using the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_copy_buffer_to_image"><code class="hljs">cmd_copy_buffer_to_image</code></a> function:</p>
<pre><code class="language-rust noplaypen">device.cmd_copy_buffer_to_image(
    command_buffer,
    buffer,
    image,
    vk::ImageLayout::TRANSFER_DST_OPTIMAL,
    &amp;[region],
);
</code></pre>
<p>The fourth parameter indicates which layout the image is currently using. I'm assuming here that the image has already been transitioned to the layout that is optimal for copying pixels to. Right now we're only copying one chunk of pixels to the whole image, but it's possible to specify an array of <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.BufferImageCopy.html"><code class="hljs">vk::BufferImageCopy</code></a> to perform many different copies from this buffer to the image in one operation.</p>
<h2 id="preparing-the-texture-image"><a class="header" href="#preparing-the-texture-image">Preparing the texture image</a></h2>
<p>We now have all of the tools we need to finish setting up the texture image, so we're going back to the <code>create_texture_image</code> function. The last thing we did there was creating the texture image. The next step is to copy the staging buffer to the texture image. This involves two steps:</p>
<ul>
<li>Transition the texture image to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.TRANSFER_DST_OPTIMAL"><code class="hljs">vk::ImageLayout::TRANSFER_DST_OPTIMAL</code></a> </li>
<li>Execute the buffer to image copy operation</li>
</ul>
<p>This is easy to do with the functions we just created:</p>
<pre><code class="language-rust noplaypen">transition_image_layout(
    device,
    data,
    data.texture_image,
    vk::Format::R8G8B8A8_SRGB,
    vk::ImageLayout::UNDEFINED,
    vk::ImageLayout::TRANSFER_DST_OPTIMAL,
)?;

copy_buffer_to_image(
    device,
    data,
    staging_buffer,
    data.texture_image,
    width,
    height,
)?;
</code></pre>
<p>The image was created with the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.UNDEFINED"><code class="hljs">vk::ImageLayout::UNDEFINED</code></a> layout, so that one should be specified as old layout when transitioning <code>texture_image</code>. Remember that we can do this because we don't care about its contents before performing the copy operation.</p>
<p>To be able to start sampling from the texture image in the shader, we need one last transition to prepare it for shader access:</p>
<pre><code class="language-rust noplaypen">transition_image_layout(
    device,
    data,
    data.texture_image,
    vk::Format::R8G8B8A8_SRGB,
    vk::ImageLayout::TRANSFER_DST_OPTIMAL,
    vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL,
)?;
</code></pre>
<h2 id="transition-barrier-masks"><a class="header" href="#transition-barrier-masks">Transition barrier masks</a></h2>
<p>If you run your application with validation layers enabled now, then you'll see that it complains about the access masks and pipeline stages in <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_4.html#method.transition_image_layout"><code class="hljs">transition_image_layout</code></a> being invalid. We still need to set those based on the layouts in the transition.</p>
<p>There are two transitions we need to handle:</p>
<ul>
<li>Undefined → transfer destination – transfer writes that don't need to wait on anything</li>
<li>Transfer destination → shader reading – shader reads should wait on transfer writes, specifically the shader reads in the fragment shader, because that's where we're going to use the texture</li>
</ul>
<p>These rules are specified using the following access masks and pipeline stages which should be added at the beginning of <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_4.html#method.transition_image_layout"><code class="hljs">transition_image_layout</code></a>:</p>
<pre><code class="language-rust noplaypen">let (
    src_access_mask,
    dst_access_mask,
    src_stage_mask,
    dst_stage_mask,
) = match (old_layout, new_layout) {
    (vk::ImageLayout::UNDEFINED, vk::ImageLayout::TRANSFER_DST_OPTIMAL) =&gt; (
        vk::AccessFlags::empty(),
        vk::AccessFlags::TRANSFER_WRITE,
        vk::PipelineStageFlags::TOP_OF_PIPE,
        vk::PipelineStageFlags::TRANSFER,
    ),
    (vk::ImageLayout::TRANSFER_DST_OPTIMAL, vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL) =&gt; (
        vk::AccessFlags::TRANSFER_WRITE,
        vk::AccessFlags::SHADER_READ,
        vk::PipelineStageFlags::TRANSFER,
        vk::PipelineStageFlags::FRAGMENT_SHADER,
    ),
    _ =&gt; return Err(anyhow!(&quot;Unsupported image layout transition!&quot;)),
};
</code></pre>
<p>Then update the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageMemoryBarrier.html"><code class="hljs">vk::ImageMemoryBarrier</code></a> struct and the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_pipeline_barrier"><code class="hljs">cmd_pipeline_barrier</code></a> call with the access flags and pipeline stage masks:</p>
<pre><code class="language-rust noplaypen">let barrier = vk::ImageMemoryBarrier::builder()
    .old_layout(old_layout)
    .new_layout(new_layout)
    .src_queue_family_index(vk::QUEUE_FAMILY_IGNORED)
    .dst_queue_family_index(vk::QUEUE_FAMILY_IGNORED)
    .image(image)
    .subresource_range(subresource)
    .src_access_mask(src_access_mask)
    .dst_access_mask(dst_access_mask);

device.cmd_pipeline_barrier(
    command_buffer,
    src_stage_mask,
    dst_stage_mask,
    vk::DependencyFlags::empty(),
    &amp;[] as &amp;[vk::MemoryBarrier],
    &amp;[] as &amp;[vk::BufferMemoryBarrier],
    &amp;[barrier],
);
</code></pre>
<p>As you can see in the aforementioned table, transfer writes must occur in the pipeline transfer stage. Since the writes don't have to wait on anything, you may specify an empty access mask and the earliest possible pipeline stage <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PipelineStageFlags.html#associatedconstant.TOP_OF_PIPE"><code class="hljs">vk::PipelineStageFlags::TOP_OF_PIPE</code></a> for the pre-barrier operations. It should be noted that <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PipelineStageFlags.html#associatedconstant.TRANSFER"><code class="hljs">vk::PipelineStageFlags::TRANSFER</code></a> is not a <em>real</em> stage within the graphics and compute pipelines. It is more of a pseudo-stage where transfers happen. See <a href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/VkPipelineStageFlagBits.html">the documentation</a> for more information and other examples of pseudo-stages.</p>
<p>The image will be written in the same pipeline stage and subsequently read by the fragment shader, which is why we specify shader reading access in the fragment shader pipeline stage.</p>
<p>If we need to do more transitions in the future, then we'll extend the function. The application should now run successfully, although there are of course no visual changes yet.</p>
<p>One thing to note is that command buffer submission results in implicit <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.AccessFlags.html#associatedconstant.HOST_WRITE"><code class="hljs">vk::AccessFlags::HOST_WRITE</code></a> synchronization at the beginning. Since the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_4.html#method.transition_image_layout"><code class="hljs">transition_image_layout</code></a> function executes a command buffer with only a single command, you could use this implicit synchronization and set <code>src_access_mask</code> to <code>vk::AccessFlags::empty()</code> if you ever needed a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.AccessFlags.html#associatedconstant.HOST_WRITE"><code class="hljs">vk::AccessFlags::HOST_WRITE</code></a> dependency in a layout transition. It's up to you if you want to be explicit about it or not, but I'm personally not a fan of relying on these OpenGL-like &quot;hidden&quot; operations.</p>
<p>There is actually a special type of image layout that supports all operations, <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.GENERAL"><code class="hljs">vk::ImageLayout::GENERAL</code></a>. The problem with it, of course, is that it doesn't necessarily offer the best performance for any operation. It is required for some special cases, like using an image as both input and output, or for reading an image after it has left the preinitialized layout.</p>
<p>All of the helper functions that submit commands so far have been set up to execute synchronously by waiting for the queue to become idle. For practical applications it is recommended to combine these operations in a single command buffer and execute them asynchronously for higher throughput, especially the transitions and copy in the <code>create_texture_image</code> function. Try to experiment with this by creating a <code>setup_command_buffer</code> that the helper functions record commands into, and add a <code>flush_setup_commands</code> to execute the commands that have been recorded so far. It's best to do this after the texture mapping works to check if the texture resources are still set up correctly.</p>
<h2 id="cleanup"><a class="header" href="#cleanup">Cleanup</a></h2>
<p>Finish the <code>create_texture_image</code> function by cleaning up the staging buffer and its memory at the end:</p>
<pre><code class="language-rust noplaypen">device.destroy_buffer(staging_buffer, None);
device.free_memory(staging_buffer_memory, None);
</code></pre>
<p>The main texture image is used until the end of the program:</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy(&amp;mut self) {
    self.destroy_swapchain();
    self.device.destroy_image(self.data.texture_image, None);
    self.device.free_memory(self.data.texture_image_memory, None);
    // ...
}
</code></pre>
<p>The image now contains the texture, but we still need a way to access it from the graphics pipeline. We'll work on that in the next chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="image-view-and-sampler"><a class="header" href="#image-view-and-sampler">Image view and sampler</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/24_sampler.rs">main.rs</a></p>
<p>In this chapter we're going to create two more resources that are needed for the graphics pipeline to sample an image. The first resource is one that we've already seen before while working with the swapchain images, but the second one is new - it relates to how the shader will read texels from the image.</p>
<h2 id="texture-image-view"><a class="header" href="#texture-image-view">Texture image view</a></h2>
<p>We've seen before, with the swapchain images and the framebuffer, that images are accessed through image views rather than directly. We will also need to create such an image view for the texture image.</p>
<p>Add an <code>AppData</code> field to hold a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageView.html"><code class="hljs">vk::ImageView</code></a> for the texture image and create a new function <code>create_texture_image_view</code> where we'll create it:</p>
<pre><code class="language-rust noplaypen">impl App {
    unsafe fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        // ...
        create_texture_image(&amp;instance, &amp;device, &amp;mut data)?;
        create_texture_image_view(&amp;device, &amp;mut data)?;
        // ...
    }
}

struct AppData {
    // ...
    texture_image: vk::Image,
    texture_image_memory: vk::DeviceMemory,
    texture_image_view: vk::ImageView,
    // ...
}

unsafe fn create_texture_image_view(device: &amp;Device, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    Ok(())
}
</code></pre>
<p>The code for this function can be based directly on <code>create_swapchain_image_views</code>. The only two changes you have to make are the <code>format</code> and the <code>image</code>:</p>
<pre><code class="language-rust noplaypen">let subresource_range = vk::ImageSubresourceRange::builder()
    .aspect_mask(vk::ImageAspectFlags::COLOR)
    .base_mip_level(0)
    .level_count(1)
    .base_array_layer(0)
    .layer_count(1);

let info = vk::ImageViewCreateInfo::builder()
    .image(data.texture_image)
    .view_type(vk::ImageViewType::_2D)
    .format(vk::Format::R8G8B8A8_SRGB)
    .subresource_range(subresource_range);
</code></pre>
<p>I've left out the explicit <code>components</code> initialization, because <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ComponentSwizzle.html#associatedconstant.IDENTITY"><code class="hljs">vk::ComponentSwizzle::IDENTITY</code></a> is defined as <code>0</code> anyway. Finish creating the image view by calling <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.create_image_view"><code class="hljs">create_image_view</code></a>:</p>
<pre><code class="language-rust noplaypen">data.texture_image_view = device.create_image_view(&amp;info, None)?;
</code></pre>
<p>Because so much of the logic is duplicated from <code>create_swapchain_image_views</code>, you may wish to abstract it into a new <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.create_image_view"><code class="hljs">create_image_view</code></a> function:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_image_view(
    device: &amp;Device,
    image: vk::Image,
    format: vk::Format,
) -&gt; Result&lt;vk::ImageView&gt; {
    let subresource_range = vk::ImageSubresourceRange::builder()
        .aspect_mask(vk::ImageAspectFlags::COLOR)
        .base_mip_level(0)
        .level_count(1)
        .base_array_layer(0)
        .layer_count(1);

    let info = vk::ImageViewCreateInfo::builder()
        .image(image)
        .view_type(vk::ImageViewType::_2D)
        .format(format)
        .subresource_range(subresource_range);

    Ok(device.create_image_view(&amp;info, None)?)
}
</code></pre>
<p>The <code>create_texture_image_view</code> function can now be simplified to:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_texture_image_view(device: &amp;Device, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    data.texture_image_view = create_image_view(
        device,
        data.texture_image,
        vk::Format::R8G8B8A8_SRGB,
    )?;

    Ok(())
}
</code></pre>
<p>And <code>create_swapchain_image_views</code> can be simplified to:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_swapchain_image_views(device: &amp;Device, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    data.swapchain_image_views = data
        .swapchain_images
        .iter()
        .map(|i| create_image_view(device, *i, data.swapchain_format))
        .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?;

    Ok(())
}
</code></pre>
<p>Make sure to destroy the image view at the end of the program, right before destroying the image itself:</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy(&amp;mut self) {
    self.destroy_swapchain();
    self.device.destroy_image_view(self.data.texture_image_view, None);
    // ...
}
</code></pre>
<h2 id="samplers"><a class="header" href="#samplers">Samplers</a></h2>
<p>It is possible for shaders to read texels directly from images, but that is not very common when they are used as textures. Textures are usually accessed through samplers, which will apply filtering and transformations to compute the final color that is retrieved.</p>
<p>These filters are helpful to deal with problems like oversampling. Consider a texture that is mapped to geometry with more fragments than texels. If you simply took the closest texel for the texture coordinate in each fragment, then you would get a result like the first image:</p>
<p><img src="texture/../images/texture_filtering.png" alt="" /></p>
<p>If you combined the 4 closest texels through linear interpolation, then you would get a smoother result like the one on the right. Of course your application may have art style requirements that fit the left style more (think Minecraft), but the right is preferred in conventional graphics applications. A sampler object automatically applies this filtering for you when reading a color from the texture.</p>
<p>Undersampling is the opposite problem, where you have more texels than fragments. This will lead to artifacts when sampling high frequency patterns like a checkerboard texture at a sharp angle:</p>
<p><img src="texture/../images/anisotropic_filtering.png" alt="" /></p>
<p>As shown in the left image, the texture turns into a blurry mess in the distance. The solution to this is <a href="https://en.wikipedia.org/wiki/Anisotropic_filtering">anisotropic filtering</a>, which can also be applied automatically by a sampler.</p>
<p>Aside from these filters, a sampler can also take care of transformations. It determines what happens when you try to read texels outside the image through its <em>addressing mode</em>. The image below displays some of the possibilities:</p>
<p><img src="texture/../images/texture_addressing.png" alt="" /></p>
<p>We will now create a function <code>create_texture_sampler</code> to set up such a sampler object. We'll be using that sampler to read colors from the texture in the shader later on.</p>
<pre><code class="language-rust noplaypen">impl App {
    unsafe fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        // ...
        create_texture_image(&amp;instance, &amp;device, &amp;mut data)?;
        create_texture_image_view(&amp;device, &amp;mut data)?;
        create_texture_sampler(&amp;device, &amp;mut data)?;
        // ...
    }
}

unsafe fn create_texture_sampler(device: &amp;Device, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    Ok(())
}
</code></pre>
<p>Samplers are configured through a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SamplerCreateInfo.html"><code class="hljs">vk::SamplerCreateInfo</code></a> structure, which specifies all filters and transformations that it should apply.</p>
<pre><code class="language-rust noplaypen">let info = vk::SamplerCreateInfo::builder()
    .mag_filter(vk::Filter::LINEAR)
    .min_filter(vk::Filter::LINEAR)
    // continued...
</code></pre>
<p>The <code>mag_filter</code> and <code>min_filter</code> fields specify how to interpolate texels that are magnified or minified. Magnification concerns the oversampling problem describes above, and minification concerns undersampling. The choices are <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Filter.html#associatedconstant.NEAREST"><code class="hljs">vk::Filter::NEAREST</code></a> and <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Filter.html#associatedconstant.LINEAR"><code class="hljs">vk::Filter::LINEAR</code></a>, corresponding to the modes demonstrated in the images above.</p>
<pre><code class="language-rust noplaypen">    .address_mode_u(vk::SamplerAddressMode::REPEAT)
    .address_mode_v(vk::SamplerAddressMode::REPEAT)
    .address_mode_w(vk::SamplerAddressMode::REPEAT)
</code></pre>
<p>The addressing mode can be specified per axis using the <code>address_mode</code> fields. The available values are listed below. Most of these are demonstrated in the image above. Note that the axes are called U, V and W instead of X, Y and Z. This is a convention for texture space coordinates.</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SamplerAddressMode.html#associatedconstant.REPEAT"><code class="hljs">vk::SamplerAddressMode::REPEAT</code></a> – Repeat the texture when going beyond the image dimensions.</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SamplerAddressMode.html#associatedconstant.MIRRORED_REPEAT"><code class="hljs">vk::SamplerAddressMode::MIRRORED_REPEAT</code></a> – Like repeat, but inverts the coordinates to mirror the image when going beyond the dimensions.</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SamplerAddressMode.html#associatedconstant.CLAMP_TO_EDGE"><code class="hljs">vk::SamplerAddressMode::CLAMP_TO_EDGE</code></a> – Take the color of the edge closest to the coordinate beyond the image dimensions.</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SamplerAddressMode.html#associatedconstant.MIRROR_CLAMP_TO_EDGE"><code class="hljs">vk::SamplerAddressMode::MIRROR_CLAMP_TO_EDGE</code></a> – Like clamp to edge, but instead uses the edge opposite to the closest edge.</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SamplerAddressMode.html#associatedconstant.CLAMP_TO_BORDER"><code class="hljs">vk::SamplerAddressMode::CLAMP_TO_BORDER</code></a> – Return a solid color when sampling beyond the dimensions of the image.</li>
</ul>
<p>It doesn't really matter which addressing mode we use here, because we're not going to sample outside of the image in this tutorial. However, the repeat mode is probably the most common mode, because it can be used to tile textures like floors and walls.</p>
<pre><code class="language-rust noplaypen">    .anisotropy_enable(true)
    .max_anisotropy(16.0)
</code></pre>
<p>These two fields specify if anisotropic filtering should be used. There is no reason not to use this unless performance is a concern. The <code>max_anisotropy</code> field limits the amount of texel samples that can be used to calculate the final color. A lower value results in better performance, but lower quality results. There is no graphics hardware available today that will use more than 16 samples, because the difference is negligible beyond that point.</p>
<pre><code class="language-rust noplaypen">    .border_color(vk::BorderColor::INT_OPAQUE_BLACK)
</code></pre>
<p>The <code>border_color</code> field specifies which color is returned when sampling beyond the image with clamp to border addressing mode. It is possible to return black, white or transparent in either float or int formats. You cannot specify an arbitrary color.</p>
<pre><code class="language-rust noplaypen">    .unnormalized_coordinates(false)
</code></pre>
<p>The <code>unnormalized_coordinates</code> field specifies which coordinate system you want to use to address texels in an image. If this field is <code>true</code>, then you can simply use coordinates within the <code>[0, width)</code> and <code>[0, height)</code> range. If it is <code>false</code>, then the texels are addressed using the <code>[0, 1)</code> range on all axes. Real-world applications almost always use normalized coordinates, because then it's possible to use textures of varying resolutions with the exact same coordinates.</p>
<pre><code class="language-rust noplaypen">    .compare_enable(false)
    .compare_op(vk::CompareOp::ALWAYS)
</code></pre>
<p>If a comparison function is enabled, then texels will first be compared to a value, and the result of that comparison is used in filtering operations. This is mainly used for <a href="https://developer.nvidia.com/gpugems/GPUGems/gpugems_ch11.html">percentage-closer filtering</a> on shadow maps. We'll look at this in a future chapter.</p>
<pre><code class="language-rust noplaypen">    .mipmap_mode(vk::SamplerMipmapMode::LINEAR)
    .mip_lod_bias(0.0)
    .min_lod(0.0)
    .max_lod(0.0);
</code></pre>
<p>All of these fields apply to mipmapping. We will look at mipmapping in a <a href="texture//Generating_Mipmaps">later chapter</a>, but basically it's another type of filter that can be applied.</p>
<p>The functioning of the sampler is now fully defined. Add an <code>AppData</code> field to hold the handle of the sampler object:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    texture_image_view: vk::ImageView,
    texture_sampler: vk::Sampler,
    // ...
}
</code></pre>
<p>Then create the sampler with <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.create_sampler"><code class="hljs">create_sampler</code></a>:</p>
<pre><code class="language-rust noplaypen">data.texture_sampler = device.create_sampler(&amp;info, None)?;
</code></pre>
<p>Note the sampler does not reference a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Image.html"><code class="hljs">vk::Image</code></a> anywhere. The sampler is a distinct object that provides an interface to extract colors from a texture. It can be applied to any image you want, whether it is 1D, 2D or 3D. This is different from many older APIs, which combined texture images and filtering into a single state.</p>
<p>Destroy the sampler at the end of the program when we'll no longer be accessing the image:</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy(&amp;mut self) {
    self.destroy_swapchain();
    self.device.destroy_sampler(self.data.texture_sampler, None);
    // ...
}
</code></pre>
<h2 id="anisotropy-device-feature"><a class="header" href="#anisotropy-device-feature">Anisotropy device feature</a></h2>
<p>If you run your program right now, you'll see a validation layer message like this:</p>
<p><img src="texture/../images/validation_layer_anisotropy.png" alt="" /></p>
<p>That's because anisotropic filtering is actually an optional device feature. We need to update the <code>create_logical_device</code> function to request it:</p>
<pre><code class="language-rust noplaypen">let features = vk::PhysicalDeviceFeatures::builder()
    .sampler_anisotropy(true);
</code></pre>
<p>And even though it is very unlikely that a modern graphics card will not support it, we should update <code>check_physical_device</code> to check if it is available:</p>
<pre><code class="language-rust noplaypen">unsafe fn check_physical_device(
    instance: &amp;Instance,
    data: &amp;AppData,
    physical_device: vk::PhysicalDevice,
) -&gt; Result&lt;()&gt; {
    // ...

    let features = instance.get_physical_device_features(physical_device);
    if features.sampler_anisotropy != vk::TRUE {
        return Err(anyhow!(SuitabilityError(&quot;No sampler anisotropy.&quot;)));
    }

    Ok(())
}
</code></pre>
<p>The <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.InstanceV1_0.html#method.get_physical_device_features"><code class="hljs">get_physical_device_features</code></a> repurposes the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PhysicalDeviceFeatures.html"><code class="hljs">vk::PhysicalDeviceFeatures</code></a> struct to indicate which features are supported rather than requested by setting the boolean values.</p>
<p>Instead of enforcing the availability of anisotropic filtering, it's also possible to simply not use it by conditionally setting:</p>
<pre><code class="language-rust noplaypen">    .anisotropy_enable(false)
    .max_anisotropy(1.0)
</code></pre>
<p>In the next chapter we will expose the image and sampler objects to the shaders to draw the texture onto the square.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="combined-image-sampler"><a class="header" href="#combined-image-sampler">Combined image sampler</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/25_texture_mapping.rs">main.rs</a> | <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/shaders/25/shader.vert">shader.vert</a> | <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/shaders/25/shader.frag">shader.frag</a></p>
<p>We looked at descriptors for the first time in the uniform buffers part of the tutorial. In this chapter we will look at a new type of descriptor: <em>combined image sampler</em>. This descriptor makes it possible for shaders to access an image resource through a sampler object like the one we created in the previous chapter.</p>
<p>We'll start by modifying the descriptor set layout, descriptor pool and descriptor set to include such a combined image sampler descriptor. After that, we're going to add texture coordinates to <code>Vertex</code> and modify the fragment shader to read colors from the texture instead of just interpolating the vertex colors.</p>
<h2 id="updating-the-descriptors"><a class="header" href="#updating-the-descriptors">Updating the descriptors</a></h2>
<p>Browse to the <code>create_descriptor_set_layout</code> function and add a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DescriptorSetLayoutBinding.html"><code class="hljs">vk::DescriptorSetLayoutBinding</code></a> for a combined image sampler descriptor. We'll simply put it in the binding after the uniform buffer:</p>
<pre><code class="language-rust noplaypen">let sampler_binding = vk::DescriptorSetLayoutBinding::builder()
    .binding(1)
    .descriptor_type(vk::DescriptorType::COMBINED_IMAGE_SAMPLER)
    .descriptor_count(1)
    .stage_flags(vk::ShaderStageFlags::FRAGMENT);

let bindings = &amp;[ubo_binding, sampler_binding];
let info = vk::DescriptorSetLayoutCreateInfo::builder()
    .bindings(bindings);
</code></pre>
<p>Make sure to set the <code>stage_flags</code> to indicate that we intend to use the combined image sampler descriptor in the fragment shader. That's where the color of the fragment is going to be determined. It is possible to use texture sampling in the vertex shader, for example to dynamically deform a grid of vertices by a <a href="https://en.wikipedia.org/wiki/Heightmap">heightmap</a>.</p>
<p>We must also create a larger descriptor pool to make room for the allocation of the combined image sampler by adding another <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DescriptorPoolSize.html"><code class="hljs">vk::DescriptorPoolSize</code></a> of type <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DescriptorType.html#associatedconstant.COMBINED_IMAGE_SAMPLER"><code class="hljs">vk::DescriptorType::COMBINED_IMAGE_SAMPLER</code></a> to the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DescriptorPoolCreateInfo.html"><code class="hljs">vk::DescriptorPoolCreateInfo</code></a>. Go to the <code>create_descriptor_pool</code> function and modify it to include a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DescriptorPoolSize.html"><code class="hljs">vk::DescriptorPoolSize</code></a> for this descriptor:</p>
<pre><code class="language-rust noplaypen">let sampler_size = vk::DescriptorPoolSize::builder()
    .type_(vk::DescriptorType::COMBINED_IMAGE_SAMPLER)
    .descriptor_count(data.swapchain_images.len() as u32);

let pool_sizes = &amp;[ubo_size, sampler_size];
let info = vk::DescriptorPoolCreateInfo::builder()
    .pool_sizes(pool_sizes)
    .max_sets(data.swapchain_images.len() as u32);
</code></pre>
<p>Inadequate descriptor pools are a good example of a problem that the validation layers will not catch: As of Vulkan 1.1, <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.allocate_descriptor_sets"><code class="hljs">allocate_descriptor_sets</code></a> may fail with the error code <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ErrorCode.html#associatedconstant.OUT_OF_POOL_MEMORY"><code class="hljs">vk::ErrorCode::OUT_OF_POOL_MEMORY</code></a> if the pool is not sufficiently large, but the driver may also try to solve the problem internally. This means that sometimes (depending on hardware, pool size and allocation size) the driver will let us get away with an allocation that exceeds the limits of our descriptor pool. Other times, <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.allocate_descriptor_sets"><code class="hljs">allocate_descriptor_sets</code></a> will fail and return <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ErrorCode.html#associatedconstant.OUT_OF_POOL_MEMORY"><code class="hljs">vk::ErrorCode::OUT_OF_POOL_MEMORY</code></a>. This can be particularly frustrating if the allocation succeeds on some machines, but fails on others.</p>
<p>Since Vulkan shifts the responsiblity for the allocation to the driver, it is no longer a strict requirement to only allocate as many descriptors of a certain type (<a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DescriptorType.html#associatedconstant.COMBINED_IMAGE_SAMPLER"><code class="hljs">vk::DescriptorType::COMBINED_IMAGE_SAMPLER</code></a>, etc.) as specified by the corresponding <code>descriptor_count</code> members for the creation of the descriptor pool. However, it remains best practise to do so, and in the future, <code>VK_LAYER_KHRONOS_validation</code> will warn about this type of problem if you enable <a href="https://vulkan.lunarg.com/doc/view/1.1.126.0/windows/best_practices.html">Best Practice Validation</a>.</p>
<p>The final step is to bind the actual image and sampler resources to the descriptors in the descriptor set. Go to the <code>create_descriptor_sets</code> function. The resources for a combined image sampler structure must be specified in a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DescriptorImageInfo.html"><code class="hljs">vk::DescriptorImageInfo</code></a> struct, just like the buffer resource for a uniform buffer descriptor is specified in a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DescriptorBufferInfo.html"><code class="hljs">vk::DescriptorBufferInfo</code></a> struct. This is where the objects from the previous chapter come together.</p>
<pre><code class="language-rust noplaypen">let info = vk::DescriptorImageInfo::builder()
    .image_layout(vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL)
    .image_view(data.texture_image_view)
    .sampler(data.texture_sampler);

let image_info = &amp;[info];
let sampler_write = vk::WriteDescriptorSet::builder()
    .dst_set(data.descriptor_sets[i])
    .dst_binding(1)
    .dst_array_element(0)
    .descriptor_type(vk::DescriptorType::COMBINED_IMAGE_SAMPLER)
    .image_info(image_info);

device.update_descriptor_sets(
    &amp;[ubo_write, sampler_write],
    &amp;[] as &amp;[vk::CopyDescriptorSet],
);
</code></pre>
<p>The descriptors must be updated with this image info, just like the buffer. This time we're using the <code>image_info</code> array instead of <code>buffer_info</code>. The descriptors are now ready to be used by the shaders!</p>
<h2 id="texture-coordinates"><a class="header" href="#texture-coordinates">Texture coordinates</a></h2>
<p>There is one important ingredient for texture mapping that is still missing, and that's the actual coordinates for each vertex. The coordinates determine how the image is actually mapped to the geometry.</p>
<pre><code class="language-rust noplaypen">#[repr(C)]
#[derive(Copy, Clone, Debug)]
struct Vertex {
    pos: Vec2,
    color: Vec3,
    tex_coord: Vec2,
}

impl Vertex {
    const fn new(pos: Vec2, color: Vec3, tex_coord: Vec2) -&gt; Self {
        Self { pos, color, tex_coord }
    }

    fn binding_description() -&gt; vk::VertexInputBindingDescription {
        vk::VertexInputBindingDescription::builder()
            .binding(0)
            .stride(size_of::&lt;Vertex&gt;() as u32)
            .input_rate(vk::VertexInputRate::VERTEX)
            .build()
    }

    fn attribute_descriptions() -&gt; [vk::VertexInputAttributeDescription; 3] {
        let pos = vk::VertexInputAttributeDescription::builder()
            .binding(0)
            .location(0)
            .format(vk::Format::R32G32_SFLOAT)
            .offset(0)
            .build();
        let color = vk::VertexInputAttributeDescription::builder()
            .binding(0)
            .location(1)
            .format(vk::Format::R32G32B32_SFLOAT)
            .offset(size_of::&lt;Vec2&gt;() as u32)
            .build();
        let tex_coord = vk::VertexInputAttributeDescription::builder()
            .binding(0)
            .location(2)
            .format(vk::Format::R32G32_SFLOAT)
            .offset((size_of::&lt;Vec2&gt;() + size_of::&lt;Vec3&gt;()) as u32)
            .build();
        [pos, color, tex_coord]
    }
}
</code></pre>
<p>Modify the <code>Vertex</code> struct to include a <code>Vec2</code> for texture coordinates. Make sure to also add a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.VertexInputAttributeDescription.html"><code class="hljs">vk::VertexInputAttributeDescription</code></a> so that we can use access texture coordinates as input in the vertex shader. That is necessary to be able to pass them to the fragment shader for interpolation across the surface of the square.</p>
<pre><code class="language-rust noplaypen">static VERTICES: [Vertex; 4] = [
    Vertex::new(vec2(-0.5, -0.5), vec3(1.0, 0.0, 0.0), vec2(1.0, 0.0)),
    Vertex::new(vec2(0.5, -0.5), vec3(0.0, 1.0, 0.0), vec2(0.0, 0.0)),
    Vertex::new(vec2(0.5, 0.5), vec3(0.0, 0.0, 1.0), vec2(0.0, 1.0)),
    Vertex::new(vec2(-0.5, 0.5), vec3(1.0, 1.0, 1.0), vec2(1.0, 1.0)),
];
</code></pre>
<p>In this tutorial, I will simply fill the square with the texture by using coordinates from <code>0, 0</code> in the top-left corner to <code>1, 1</code> in the bottom-right corner. Feel free to experiment with different coordinates. Try using coordinates below <code>0</code> or above <code>1</code> to see the addressing modes in action!</p>
<h2 id="shaders"><a class="header" href="#shaders">Shaders</a></h2>
<p>The final step is modifying the shaders to sample colors from the texture. We first need to modify the vertex shader to pass through the texture coordinates to the fragment shader:</p>
<pre><code class="language-glsl">layout(location = 0) in vec2 inPosition;
layout(location = 1) in vec3 inColor;
layout(location = 2) in vec2 inTexCoord;

layout(location = 0) out vec3 fragColor;
layout(location = 1) out vec2 fragTexCoord;

void main() {
    gl_Position = ubo.proj * ubo.view * ubo.model * vec4(inPosition, 0.0, 1.0);
    fragColor = inColor;
    fragTexCoord = inTexCoord;
}
</code></pre>
<p>Just like the per vertex colors, the <code>fragTexCoord</code> values will be smoothly interpolated across the area of the square by the rasterizer. We can visualize this by having the fragment shader output the texture coordinates as colors:</p>
<pre><code class="language-glsl">#version 450

layout(location = 0) in vec3 fragColor;
layout(location = 1) in vec2 fragTexCoord;

layout(location = 0) out vec4 outColor;

void main() {
    outColor = vec4(fragTexCoord, 0.0, 1.0);
}
</code></pre>
<p>You should see something like the image below. Don't forget to recompile the shaders!</p>
<p><img src="texture/../images/texcoord_visualization.png" alt="" /></p>
<p>The green channel represents the horizontal coordinates and the red channel the vertical coordinates. The black and yellow corners confirm that the texture coordinates are correctly interpolated from <code>0, 0</code> to <code>1, 1</code> across the square. Visualizing data using colors is the shader programming equivalent of <code>printf</code> debugging, for lack of a better option!</p>
<p>A combined image sampler descriptor is represented in GLSL by a sampler uniform. Add a reference to it in the fragment shader:</p>
<pre><code class="language-glsl">layout(binding = 1) uniform sampler2D texSampler;
</code></pre>
<p>There are equivalent <code>sampler1D</code> and <code>sampler3D</code> types for other types of images. Make sure to use the correct binding here.</p>
<pre><code class="language-glsl">void main() {
    outColor = texture(texSampler, fragTexCoord);
}
</code></pre>
<p>Textures are sampled using the built-in <code>texture</code> function. It takes a <code>sampler</code> and coordinate as arguments. The sampler automatically takes care of the filtering and transformations in the background. You should now see the texture on the square when you run the application:</p>
<p><img src="texture/../images/texture_on_square.png" alt="" /></p>
<p>Try experimenting with the addressing modes by scaling the texture coordinates to values higher than <code>1</code>. For example, the following fragment shader produces the result in the image below when using <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SamplerAddressMode.html#associatedconstant.REPEAT"><code class="hljs">vk::SamplerAddressMode::REPEAT</code></a>:</p>
<pre><code class="language-glsl">void main() {
    outColor = texture(texSampler, fragTexCoord * 2.0);
}
</code></pre>
<p><img src="texture/../images/texture_on_square_repeated.png" alt="" /></p>
<p>You can also manipulate the texture colors using the vertex colors:</p>
<pre><code class="language-glsl">void main() {
    outColor = vec4(fragColor * texture(texSampler, fragTexCoord).rgb, 1.0);
}
</code></pre>
<p>I've separated the RGB and alpha channels here to not scale the alpha channel.</p>
<p><img src="texture/../images/texture_on_square_colorized.png" alt="" /></p>
<p>You now know how to access images in shaders! This is a very powerful technique when combined with images that are also written to in framebuffers. You can use these images as inputs to implement cool effects like post-processing and camera displays within the 3D world.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="depth-buffering"><a class="header" href="#depth-buffering">Depth buffering</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/26_depth_buffering.rs">main.rs</a> | <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/shaders/26/shader.vert">shader.vert</a> | <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/shaders/26/shader.frag">shader.frag</a></p>
<p>The geometry we've worked with so far is projected into 3D, but it's still completely flat. In this chapter we're going to add a Z coordinate to the position to prepare for 3D meshes. We'll use this third coordinate to place a square over the current square to see a problem that arises when geometry is not sorted by depth.</p>
<h2 id="3d-geometry"><a class="header" href="#3d-geometry">3D geometry</a></h2>
<p>Change the <code>Vertex</code> struct to use a 3D vector for the position, and update the <code>format</code> in the corresponding <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.VertexInputAttributeDescription.html"><code class="hljs">vk::VertexInputAttributeDescription</code></a> and update the offsets in the others:</p>
<pre><code class="language-rust noplaypen">#[repr(C)]
#[derive(Copy, Clone, Debug)]
struct Vertex {
    pos: Vec3,
    color: Vec3,
    tex_coord: Vec2,
}

impl Vertex {
    const fn new(pos: Vec3, color: Vec3, tex_coord: Vec2) -&gt; Self {
        Self { pos, color, tex_coord }
    }

    fn binding_description() -&gt; vk::VertexInputBindingDescription {
        vk::VertexInputBindingDescription::builder()
            .binding(0)
            .stride(size_of::&lt;Vertex&gt;() as u32)
            .input_rate(vk::VertexInputRate::VERTEX)
            .build()
    }

    fn attribute_descriptions() -&gt; [vk::VertexInputAttributeDescription; 3] {
        let pos = vk::VertexInputAttributeDescription::builder()
            .binding(0)
            .location(0)
            .format(vk::Format::R32G32B32_SFLOAT)
            .offset(0)
            .build();
        let color = vk::VertexInputAttributeDescription::builder()
            .binding(0)
            .location(1)
            .format(vk::Format::R32G32B32_SFLOAT)
            .offset(size_of::&lt;Vec3&gt;() as u32)
            .build();
        let tex_coord = vk::VertexInputAttributeDescription::builder()
            .binding(0)
            .location(2)
            .format(vk::Format::R32G32_SFLOAT)
            .offset((size_of::&lt;Vec3&gt;() + size_of::&lt;Vec3&gt;()) as u32)
            .build();
        [pos, color, tex_coord]
    }
}
</code></pre>
<p>Next, update the vertex shader to accept and transform 3D coordinates as input. Don't forget to recompile it afterwards!</p>
<pre><code class="language-glsl">layout(location = 0) in vec3 inPosition;

// ...

void main() {
    gl_Position = ubo.proj * ubo.view * ubo.model * vec4(inPosition, 1.0);
    fragColor = inColor;
    fragTexCoord = inTexCoord;
}
</code></pre>
<p>Lastly, update the <code>vertices</code> container to include Z coordinates:</p>
<pre><code class="language-rust noplaypen">static VERTICES: [Vertex; 4] = [
    Vertex::new(vec3(-0.5, -0.5, 0.0), vec3(1.0, 0.0, 0.0), vec2(1.0, 0.0)),
    Vertex::new(vec3(0.5, -0.5, 0.0), vec3(0.0, 1.0, 0.0), vec2(0.0, 0.0)),
    Vertex::new(vec3(0.5, 0.5, 0.0), vec3(0.0, 0.0, 1.0), vec2(0.0, 1.0)),
    Vertex::new(vec3(-0.5, 0.5, 0.0), vec3(1.0, 1.0, 1.0), vec2(1.0, 1.0)),
];
</code></pre>
<p>If you run your application now, then you should see exactly the same result as before. It's time to add some extra geometry to make the scene more interesting, and to demonstrate the problem that we're going to tackle in this chapter. Duplicate the vertices to define positions for a square right under the current one like this:</p>
<p><img src="model/../images/extra_square.svg" alt="" /></p>
<p>Use Z coordinates of <code>-0.5</code> and add the appropriate indices for the extra square:</p>
<pre><code class="language-rust noplaypen">static VERTICES: [Vertex; 8] = [
    Vertex::new(vec3(-0.5, -0.5, 0.0), vec3(1.0, 0.0, 0.0), vec2(1.0, 0.0)),
    Vertex::new(vec3(0.5, -0.5, 0.0), vec3(0.0, 1.0, 0.0), vec2(0.0, 0.0)),
    Vertex::new(vec3(0.5, 0.5, 0.0), vec3(0.0, 0.0, 1.0), vec2(0.0, 1.0)),
    Vertex::new(vec3(-0.5, 0.5, 0.0), vec3(1.0, 1.0, 1.0), vec2(1.0, 1.0)),
    Vertex::new(vec3(-0.5, -0.5, -0.5), vec3(1.0, 0.0, 0.0), vec2(1.0, 0.0)),
    Vertex::new(vec3(0.5, -0.5, -0.5), vec3(0.0, 1.0, 0.0), vec2(0.0, 0.0)),
    Vertex::new(vec3(0.5, 0.5, -0.5), vec3(0.0, 0.0, 1.0), vec2(0.0, 1.0)),
    Vertex::new(vec3(-0.5, 0.5, -0.5), vec3(1.0, 1.0, 1.0), vec2(1.0, 1.0)),
];

const INDICES: &amp;[u16] = &amp;[
    0, 1, 2, 2, 3, 0,
    4, 5, 6, 6, 7, 4,
];
</code></pre>
<p>Run your program now and you'll see something resembling an Escher illustration:</p>
<p><img src="model/../images/depth_issues.png" alt="" /></p>
<p>The problem is that the fragments of the lower square are drawn over the fragments of the upper square, simply because it comes later in the index array. There are two ways to solve this:</p>
<ul>
<li>Sort all of the draw calls by depth from back to front</li>
<li>Use depth testing with a depth buffer</li>
</ul>
<p>The first approach is commonly used for drawing transparent objects, because order-independent transparency is a difficult challenge to solve. However, the problem of ordering fragments by depth is much more commonly solved using a <em>depth buffer</em>. A depth buffer is an additional attachment that stores the depth for every position, just like the color attachment stores the color of every position. Every time the rasterizer produces a fragment, the depth test will check if the new fragment is closer than the previous one. If it isn't, then the new fragment is discarded. A fragment that passes the depth test writes its own depth to the depth buffer. It is possible to manipulate this value from the fragment shader, just like you can manipulate the color output.</p>
<p>Before we continue, there is one issue we need to fix. The perspective projection matrix generated by <code>cgmath::perspective</code> in <code>App::update_uniform_buffer</code> uses the OpenGL depth range of <code>-1.0</code> to <code>1.0</code>. We want to use the Vulkan range of <code>0.0</code> to <code>1.0</code> instead so we'll pre-multiply the generated perspective matrix with a <a href="https://matthewwellings.com/blog/the-new-vulkan-coordinate-system">correction matrix</a> that maps the OpenGL range to the Vulkan range:</p>
<pre><code class="language-rust noplaypen">let correction = Mat4::new(
    1.0,  0.0,       0.0, 0.0,
    // We're also flipping the Y-axis with this line's `-1.0`.
    0.0, -1.0,       0.0, 0.0,
    0.0,  0.0, 1.0 / 2.0, 0.0,
    0.0,  0.0, 1.0 / 2.0, 1.0,
);

let proj = correction
    * cgmath::perspective(
        Deg(45.0),
        self.data.swapchain_extent.width as f32 / self.data.swapchain_extent.height as f32,
        0.1,
        10.0,
    );

// This line should be deleted because we're now accomplishing the Y-axis flip
// using the new correction matrix.
// proj[1][1] *= -1.0;
</code></pre>
<p>Note that <code>cgmath::Matrix4::new</code> constructs a matrix in column-major order, so the parameters we passed to it seem to be transposed. So the actual matrix would look like this in row-major order:</p>
<pre><code class="language-text">1   0   0   0
0  -1   0   0
0   0   ½   ½
0   0   0   1
</code></pre>
<h2 id="depth-image-and-view"><a class="header" href="#depth-image-and-view">Depth image and view</a></h2>
<p>A depth attachment is based on an image, just like the color attachment. The difference is that the swapchain will not automatically create depth images for us. We only need a single depth image, because only one draw operation is running at once. The depth image will again require the trifecta of resources: image, memory and image view.</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    depth_image: vk::Image,
    depth_image_memory: vk::DeviceMemory,
    depth_image_view: vk::ImageView,
}
</code></pre>
<p>Create a new function <code>create_depth_objects</code> to set up these resources:</p>
<pre><code class="language-rust noplaypen">impl App {
    unsafe fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        // ...
        create_command_pool(&amp;instance, &amp;device, &amp;mut data)?;
        create_depth_objects(&amp;instance, &amp;device, &amp;mut data)?;
        // ...
    }
}

unsafe fn create_depth_objects(
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;mut AppData,
) -&gt; Result&lt;()&gt; {
    Ok(())
}
</code></pre>
<p>Creating a depth image is fairly straightforward. It should have the same resolution as the color attachment, defined by the swapchain extent, an image usage appropriate for a depth attachment, optimal tiling and device local memory. The only question is: what is the right format for a depth image? The format must contain a depth component, indicated by <code>D??_</code> in the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Format.html"><code class="hljs">vk::Format</code></a> variant.</p>
<p>Unlike the texture image, we don't necessarily need a specific format, because we won't be directly accessing the texels from the program. It just needs to have a reasonable accuracy, at least 24 bits is common in real-world applications. There are several formats that fit this requirement:</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Format.html#associatedconstant.D32_SFLOAT"><code class="hljs">vk::Format::D32_SFLOAT</code></a> – 32-bit float for depth</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Format.html#associatedconstant.D32_SFLOAT_S8_UINT"><code class="hljs">vk::Format::D32_SFLOAT_S8_UINT</code></a> – 32-bit signed float for depth and 8 bit stencil component</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Format.html#associatedconstant.D24_UNORM_S8_UINT"><code class="hljs">vk::Format::D24_UNORM_S8_UINT</code></a> – 24-bit float for depth and 8 bit stencil component</li>
</ul>
<p>The stencil component is used for <a href="https://en.wikipedia.org/wiki/Stencil_buffer">stencil tests</a>, which is an additional test that can be combined with depth testing. We'll look at this in a future chapter.</p>
<p>We could simply go for the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Format.html#associatedconstant.D32_SFLOAT"><code class="hljs">vk::Format::D32_SFLOAT</code></a> format, because support for it is extremely common (see the hardware database), but it's nice to add some extra flexibility to our application where possible. We're going to write a <code>get_supported_format</code> function that takes a list of candidate formats in order from most desirable to least desirable and returns the first that satisfies our requirements:</p>
<pre><code class="language-rust noplaypen">unsafe fn get_supported_format(
    instance: &amp;Instance,
    data: &amp;AppData,
    candidates: &amp;[vk::Format],
    tiling: vk::ImageTiling,
    features: vk::FormatFeatureFlags,
) -&gt; Result&lt;vk::Format&gt; {
    candidates
        .iter()
        .cloned()
        .find(|f| {

        })
        .ok_or_else(|| anyhow!(&quot;Failed to find supported format!&quot;))
}
</code></pre>
<p>The support of a format depends on the tiling mode and usage, so we must also include these as parameters. The support of a format can be queried using the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.InstanceV1_0.html#method.get_physical_device_format_properties"><code class="hljs">get_physical_device_format_properties</code></a> function:</p>
<pre><code class="language-rust noplaypen">let properties = instance.get_physical_device_format_properties(
    data.physical_device,
    *f,
);
</code></pre>
<p>The <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.FormatProperties.html"><code class="hljs">vk::FormatProperties</code></a> struct contains three fields:</p>
<ul>
<li><code>linear_tiling_features</code> – Use cases that are supported with linear tiling</li>
<li><code>optimal_tiling_features</code> – Use cases that are supported with optimal tiling</li>
<li><code>buffer_features</code> – Use cases that are supported for buffers</li>
</ul>
<p>Only the first two are relevant here, and the one we check depends on the value provided for the <code>tiling</code> parameter of the function:</p>
<pre><code class="language-rust noplaypen">match tiling {
    vk::ImageTiling::LINEAR =&gt; properties.linear_tiling_features.contains(features),
    vk::ImageTiling::OPTIMAL =&gt; properties.optimal_tiling_features.contains(features),
    _ =&gt; false,
}
</code></pre>
<p>We'll use this function now to create a <code>get_depth_format</code> helper function to select a format with a depth component that supports usage as depth attachment:</p>
<pre><code class="language-rust noplaypen">unsafe fn get_depth_format(instance: &amp;Instance, data: &amp;AppData) -&gt; Result&lt;vk::Format&gt; {
    let candidates = &amp;[
        vk::Format::D32_SFLOAT,
        vk::Format::D32_SFLOAT_S8_UINT,
        vk::Format::D24_UNORM_S8_UINT,
    ];

    get_supported_format(
        instance,
        data,
        candidates,
        vk::ImageTiling::OPTIMAL,
        vk::FormatFeatureFlags::DEPTH_STENCIL_ATTACHMENT,
    )
}
</code></pre>
<p>Call the function to find a depth format from <code>create_depth_objects</code>:</p>
<pre><code class="language-rust noplaypen">let format = get_depth_format(instance, data)?;
</code></pre>
<p>We now have all the required information to invoke our <code>create_image</code> and <code>create_image_view</code> helper functions:</p>
<pre><code class="language-rust noplaypen">let (depth_image, depth_image_memory) = create_image(
    instance,
    device,
    data,
    data.swapchain_extent.width,
    data.swapchain_extent.height,
    format,
    vk::ImageTiling::OPTIMAL,
    vk::ImageUsageFlags::DEPTH_STENCIL_ATTACHMENT,
    vk::MemoryPropertyFlags::DEVICE_LOCAL,
)?;

data.depth_image = depth_image;
data.depth_image_memory = depth_image_memory;

// Image View

data.depth_image_view = create_image_view(device, data.depth_image, format)?;
</code></pre>
<p>However, the <code>create_image_view</code> function currently assumes that the subresource always uses <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageAspectFlags.html#associatedconstant.COLOR"><code class="hljs">vk::ImageAspectFlags::COLOR</code></a>, so we will need to turn that field into a parameter:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_image_view(
    device: &amp;Device,
    image: vk::Image,
    format: vk::Format,
    aspects: vk::ImageAspectFlags,
) -&gt; Result&lt;vk::ImageView&gt; {
    let subresource_range = vk::ImageSubresourceRange::builder()
        .aspect_mask(aspects)
        .base_mip_level(0)
        .level_count(1)
        .base_array_layer(0)
        .layer_count(1);

    // ...
}
</code></pre>
<p>Update all calls to this function to use the right aspect:</p>
<pre><code class="language-rust noplaypen">create_image_view(device, *i, data.swapchain_format, vk::ImageAspectFlags::COLOR)

// ...

data.depth_image_view = create_image_view(
    device,
    data.depth_image,
    format,
    vk::ImageAspectFlags::DEPTH,
)?;

// ...

data.texture_image_view = create_image_view(
    device,
    data.texture_image,
    vk::Format::R8G8B8A8_SRGB,
    vk::ImageAspectFlags::COLOR,
)?;
</code></pre>
<p>That's it for creating the depth image. We don't need to map it or copy another image to it, because we're going to clear it at the start of the render pass like the color attachment.</p>
<h3 id="explicitly-transitioning-the-depth-image"><a class="header" href="#explicitly-transitioning-the-depth-image">Explicitly transitioning the depth image</a></h3>
<p>We don't need to explicitly transition the layout of the image to a depth attachment because we'll take care of this in the render pass. However, for completeness I'll still describe the process in this section. You may skip it if you like.</p>
<p>Make a call to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_4.html#method.transition_image_layout"><code class="hljs">transition_image_layout</code></a> at the end of the <code>create_depth_objects</code> function like so:</p>
<pre><code class="language-rust noplaypen">transition_image_layout(
    device,
    data,
    data.depth_image,
    format,
    vk::ImageLayout::UNDEFINED,
    vk::ImageLayout::DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
)?;
</code></pre>
<p>The undefined layout can be used as initial layout, because there are no existing depth image contents that matter. We need to update some of the logic in <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_4.html#method.transition_image_layout"><code class="hljs">transition_image_layout</code></a> to use the right subresource aspect:</p>
<blockquote>
<p><strong>Note:</strong> The first usage of the <code>|</code> operator below describes a <a href="https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html"><em>pattern</em></a> that matches either of the specified <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Format.html"><code class="hljs">vk::Format</code></a>s in the <code>match</code> arm. Meanwhile, the second usage of the <code>|</code> operator is the <a href="https://doc.rust-lang.org/std/ops/trait.BitOr.html"><em>bitwise OR operator</em></a> which combines the bits of the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageAspectFlags.html"><code class="hljs">vk::ImageAspectFlags</code></a> we want to enable in this code path.</p>
</blockquote>
<pre><code class="language-rust noplaypen">let aspect_mask = if new_layout == vk::ImageLayout::DEPTH_STENCIL_ATTACHMENT_OPTIMAL {
    match format {
        vk::Format::D32_SFLOAT_S8_UINT | vk::Format::D24_UNORM_S8_UINT =&gt;
            vk::ImageAspectFlags::DEPTH | vk::ImageAspectFlags::STENCIL,
        _ =&gt; vk::ImageAspectFlags::DEPTH
    }
} else {
    vk::ImageAspectFlags::COLOR
};

let subresource = vk::ImageSubresourceRange::builder()
    .aspect_mask(aspect_mask)
    .base_mip_level(0)
    .level_count(1)
    .base_array_layer(0)
    .layer_count(1);
</code></pre>
<p>Although we're not using the stencil component, we do need to include it in the layout transitions of the depth image.</p>
<p>Finally, add the correct access masks and pipeline stages:</p>
<pre><code class="language-rust noplaypen">let (
    src_access_mask,
    dst_access_mask,
    src_stage_mask,
    dst_stage_mask,
) = match (old_layout, new_layout) {
    (vk::ImageLayout::UNDEFINED, vk::ImageLayout::DEPTH_STENCIL_ATTACHMENT_OPTIMAL) =&gt; (
        vk::AccessFlags::empty(),
        vk::AccessFlags::DEPTH_STENCIL_ATTACHMENT_READ | vk::AccessFlags::DEPTH_STENCIL_ATTACHMENT_WRITE,
        vk::PipelineStageFlags::TOP_OF_PIPE,
        vk::PipelineStageFlags::EARLY_FRAGMENT_TESTS,
    ),
    // ...
};
</code></pre>
<p>The depth buffer will be read from to perform depth tests to see if a fragment is visible, and will be written to when a new fragment is drawn. The reading happens in the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PipelineStageFlags.html#associatedconstant.EARLY_FRAGMENT_TESTS"><code class="hljs">vk::PipelineStageFlags::EARLY_FRAGMENT_TESTS</code></a> stage and the writing in the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PipelineStageFlags.html#associatedconstant.LATE_FRAGMENT_TESTS"><code class="hljs">vk::PipelineStageFlags::LATE_FRAGMENT_TESTS</code></a>. You should pick the earliest pipeline stage that matches the specified operations, so that it is ready for usage as depth attachment when it needs to be.</p>
<h2 id="render-pass-1"><a class="header" href="#render-pass-1">Render pass</a></h2>
<p>We're now going to modify <code>create_render_pass</code> to include a depth attachment. First specify the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.AttachmentDescription.html"><code class="hljs">vk::AttachmentDescription</code></a>:</p>
<pre><code class="language-rust noplaypen">let depth_stencil_attachment = vk::AttachmentDescription::builder()
    .format(get_depth_format(instance, data)?)
    .samples(vk::SampleCountFlags::_1)
    .load_op(vk::AttachmentLoadOp::CLEAR)
    .store_op(vk::AttachmentStoreOp::DONT_CARE)
    .stencil_load_op(vk::AttachmentLoadOp::DONT_CARE)
    .stencil_store_op(vk::AttachmentStoreOp::DONT_CARE)
    .initial_layout(vk::ImageLayout::UNDEFINED)
    .final_layout(vk::ImageLayout::DEPTH_STENCIL_ATTACHMENT_OPTIMAL);
</code></pre>
<p>The <code>format</code> should be the same as the depth image itself. This time we don't care about storing the depth data (<code>store_op</code>), because it will not be used after drawing has finished. This may allow the hardware to perform additional optimizations. Just like the color buffer, we don't care about the previous depth contents, so we can use <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.UNDEFINED"><code class="hljs">vk::ImageLayout::UNDEFINED</code></a> as <code>initial_layout</code>.</p>
<pre><code class="language-rust noplaypen">let depth_stencil_attachment_ref = vk::AttachmentReference::builder()
    .attachment(1)
    .layout(vk::ImageLayout::DEPTH_STENCIL_ATTACHMENT_OPTIMAL);
</code></pre>
<p>Add a reference to the attachment for the first (and only) subpass:</p>
<pre><code class="language-rust noplaypen">let subpass = vk::SubpassDescription::builder()
    .pipeline_bind_point(vk::PipelineBindPoint::GRAPHICS)
    .color_attachments(color_attachments)
    .depth_stencil_attachment(&amp;depth_stencil_attachment_ref);
</code></pre>
<p>Unlike color attachments, a subpass can only use a single depth (+stencil) attachment. It wouldn't really make any sense to do depth tests on multiple buffers.</p>
<pre><code class="language-rust noplaypen">let attachments = &amp;[color_attachment, depth_stencil_attachment];
let subpasses = &amp;[subpass];
let dependencies = &amp;[dependency];
let info = vk::RenderPassCreateInfo::builder()
    .attachments(attachments)
    .subpasses(subpasses)
    .dependencies(dependencies);
</code></pre>
<p>Next, update the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.RenderPassCreateInfo.html"><code class="hljs">vk::RenderPassCreateInfo</code></a> struct to refer to both attachments.</p>
<pre><code class="language-rust noplaypen">let dependency = vk::SubpassDependency::builder()
    .src_subpass(vk::SUBPASS_EXTERNAL)
    .dst_subpass(0)
    .src_stage_mask(vk::PipelineStageFlags::COLOR_ATTACHMENT_OUTPUT
        | vk::PipelineStageFlags::EARLY_FRAGMENT_TESTS)
    .src_access_mask(vk::AccessFlags::empty())
    .dst_stage_mask(vk::PipelineStageFlags::COLOR_ATTACHMENT_OUTPUT
        | vk::PipelineStageFlags::EARLY_FRAGMENT_TESTS)
    .dst_access_mask(vk::AccessFlags::COLOR_ATTACHMENT_WRITE
        | vk::AccessFlags::DEPTH_STENCIL_ATTACHMENT_WRITE);
</code></pre>
<p>Finally, we need to extend our subpass dependencies to make sure that there is no conflict between the transitioning of the depth image and it being cleared as part of its load operation. The depth image is first accessed in the early fragment test pipeline stage and because we have a load operation that <em>clears</em>, we should specify the access mask for writes.</p>
<h2 id="framebuffer"><a class="header" href="#framebuffer">Framebuffer</a></h2>
<p>The next step is to modify the framebuffer creation to bind the depth image to the depth attachment. Go to <code>create_framebuffers</code> and specify the depth image view as second attachment:</p>
<pre><code class="language-rust noplaypen">let attachments = &amp;[*i, data.depth_image_view];
let create_info = vk::FramebufferCreateInfo::builder()
    .render_pass(data.render_pass)
    .attachments(attachments)
    .width(data.swapchain_extent.width)
    .height(data.swapchain_extent.height)
    .layers(1);
</code></pre>
<p>The color attachment differs for every swapchain image, but the same depth image can be used by all of them because only a single subpass is running at the same time due to our semaphores.</p>
<p>You'll also need to move the call to <code>create_framebuffers</code> to make sure that it is called after the depth image view has actually been created:</p>
<pre><code class="language-rust noplaypen">unsafe fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
    // ...
    create_depth_objects(&amp;instance, &amp;device, &amp;mut data)?;
    create_framebuffers(&amp;device, &amp;mut data)?;
    // ...
}
</code></pre>
<h2 id="clear-values"><a class="header" href="#clear-values">Clear values</a></h2>
<p>Because we now have multiple attachments with <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.AttachmentLoadOp.html#associatedconstant.CLEAR"><code class="hljs">vk::AttachmentLoadOp::CLEAR</code></a>, we also need to specify multiple clear values. Go to <code>create_command_buffers</code> and add an instance of <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/union.ClearValue.html"><code class="hljs">vk::ClearValue</code></a> to the <code>clear_values</code> array:</p>
<pre><code class="language-rust noplaypen">let color_clear_value = vk::ClearValue {
    color: vk::ClearColorValue {
        float32: [0.0, 0.0, 0.0, 1.0],
    },
};

let depth_clear_value = vk::ClearValue {
    depth_stencil: vk::ClearDepthStencilValue {
        depth: 1.0,
        stencil: 0,
    },
};

let clear_values = &amp;[color_clear_value, depth_clear_value];
</code></pre>
<p>The range of depths in the depth buffer is <code>0.0</code> to <code>1.0</code> in Vulkan, where <code>1.0</code> lies at the far view plane and <code>0.0</code> at the near view plane. The initial value at each point in the depth buffer should be the furthest possible depth, which is <code>1.0</code>.</p>
<p>Note that the order of <code>clear_values</code> should be identical to the order of your attachments.</p>
<h2 id="depth-and-stencil-state"><a class="header" href="#depth-and-stencil-state">Depth and stencil state</a></h2>
<p>The depth attachment is ready to be used now, but depth testing still needs to be enabled in the graphics pipeline. It is configured through the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PipelineDepthStencilStateCreateInfo.html"><code class="hljs">vk::PipelineDepthStencilStateCreateInfo</code></a> struct:</p>
<pre><code class="language-rust noplaypen">let depth_stencil_state = vk::PipelineDepthStencilStateCreateInfo::builder()
    .depth_test_enable(true)
    .depth_write_enable(true)
    // continued ...
</code></pre>
<p>The <code>depth_test_enable</code> field specifies if the depth of new fragments should be compared to the depth buffer to see if they should be discarded. The <code>depth_write_enable</code> field specifies if the new depth of fragments that pass the depth test should actually be written to the depth buffer.</p>
<pre><code class="language-rust noplaypen">    .depth_compare_op(vk::CompareOp::LESS)
</code></pre>
<p>The <code>depth_compare_op</code> field specifies the comparison that is performed to keep or discard fragments. We're sticking to the convention of lower depth = closer, so the depth of new fragments should be <em>less</em>.</p>
<pre><code class="language-rust noplaypen">    .depth_bounds_test_enable(false)
    .min_depth_bounds(0.0) // Optional.
    .max_depth_bounds(1.0) // Optional.
</code></pre>
<p>The <code>depth_bounds_test_enable</code>, <code>min_depth_bounds</code> and <code>max_depth_bounds</code> fields are used for the optional depth bound test. Basically, this allows you to only keep fragments that fall within the specified depth range. We won't be using this functionality.</p>
<pre><code class="language-rust noplaypen">    .stencil_test_enable(false)
    .front(/* vk::StencilOpState */) // Optional.
    .back(/* vk::StencilOpState */); // Optional.
</code></pre>
<p>The last three fields configure stencil buffer operations, which we also won't be using in this tutorial. If you want to use these operations, then you will have to make sure that the format of the depth/stencil image contains a stencil component.</p>
<pre><code class="language-rust noplaypen">let info = vk::GraphicsPipelineCreateInfo::builder()
    .stages(stages)
    .vertex_input_state(&amp;vertex_input_state)
    .input_assembly_state(&amp;input_assembly_state)
    .viewport_state(&amp;viewport_state)
    .rasterization_state(&amp;rasterization_state)
    .multisample_state(&amp;multisample_state)
    .depth_stencil_state(&amp;depth_stencil_state)
    .color_blend_state(&amp;color_blend_state)
    .layout(data.pipeline_layout)
    .render_pass(data.render_pass)
    .subpass(0);
</code></pre>
<p>Update the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.GraphicsPipelineCreateInfo.html"><code class="hljs">vk::GraphicsPipelineCreateInfo</code></a> struct to reference the depth stencil state we just filled in. A depth stencil state must always be specified if the render pass contains a depth stencil attachment.</p>
<p>If you run your program now, then you should see that the fragments of the geometry are now correctly ordered:</p>
<p><img src="model/../images/depth_correct.png" alt="" /></p>
<h2 id="handling-window-resize"><a class="header" href="#handling-window-resize">Handling window resize</a></h2>
<p>The resolution of the depth buffer should change when the window is resized to match the new color attachment resolution. Extend the <code>App::recreate_swapchain</code> method to recreate the depth resources in that case:</p>
<pre><code class="language-rust noplaypen">unsafe fn recreate_swapchain(&amp;mut self, window: &amp;Window) -&gt; Result&lt;()&gt; {
    self.device.device_wait_idle()?;
    self.destroy_swapchain();
    create_swapchain(window, &amp;self.instance, &amp;self.device, &amp;mut self.data)?;
    create_swapchain_image_views(&amp;self.device, &amp;mut self.data)?;
    create_render_pass(&amp;self.instance, &amp;self.device, &amp;mut self.data)?;
    create_pipeline(&amp;self.device, &amp;mut self.data)?;
    create_depth_objects(&amp;self.instance, &amp;self.device, &amp;mut self.data)?;
    create_framebuffers(&amp;self.device, &amp;mut self.data)?;
    create_uniform_buffers(&amp;self.instance, &amp;self.device, &amp;mut self.data)?;
    create_descriptor_pool(&amp;self.device, &amp;mut self.data)?;
    create_descriptor_sets(&amp;self.device, &amp;mut self.data)?;
    create_command_buffers(&amp;self.device, &amp;mut self.data)?;
    Ok(())
}
</code></pre>
<p>The cleanup operations should happen in the swapchain cleanup function:</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy_swapchain(&amp;mut self) {
    self.device.destroy_image_view(self.data.depth_image_view, None);
    self.device.free_memory(self.data.depth_image_memory, None);
    self.device.destroy_image(self.data.depth_image, None);
    // ...
}
</code></pre>
<p>Congratulations, your application is now finally ready to render arbitrary 3D geometry and have it look right. We're going to try this out in the next chapter by drawing a textured model!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loading-models"><a class="header" href="#loading-models">Loading models</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/27_model_loading.rs">main.rs</a></p>
<p>Your program is now ready to render textured 3D meshes, but the current geometry in the <code>vertices</code> and <code>indices</code> arrays is not very interesting yet. In this chapter we're going to extend the program to load the vertices and indices from an actual model file to make the graphics card actually do some work.</p>
<p>Many graphics API tutorials have the reader write their own OBJ loader in a chapter like this. The problem with this is that any remotely interesting 3D application will soon require features that are not supported by this file format, like skeletal animation. We <em>will</em> load mesh data from an OBJ model in this chapter, but we'll focus more on integrating the mesh data with the program itself rather than the details of loading it from a file.</p>
<h2 id="library"><a class="header" href="#library">Library</a></h2>
<p>We will use the <a href="https://crates.io/crates/tobj"><code>tobj</code></a> crate to load vertices and faces from an OBJ file. If you followed the instructions in the <code>Development environment</code> chapter you already have this dependency installed and ready to go.</p>
<h2 id="sample-mesh"><a class="header" href="#sample-mesh">Sample mesh</a></h2>
<p>In this chapter we won't be enabling lighting yet, so it helps to use a sample model that has lighting baked into the texture. An easy way to find such models is to look for 3D scans on <a href="https://sketchfab.com/">Sketchfab</a>. Many of the models on that site are available in OBJ format with a permissive license.</p>
<p>For this tutorial I've decided to go with the <a href="https://sketchfab.com/3d-models/viking-room-a49f1b8e4f5c4ecf9e1fe7d81915ad38">Viking room</a> model by <a href="https://sketchfab.com/nigelgoh">nigelgoh</a> (<a href="https://web.archive.org/web/20200428202538/https://sketchfab.com/3d-models/viking-room-a49f1b8e4f5c4ecf9e1fe7d81915ad38">CC BY 4.0</a>). I tweaked the size and orientation of the model to use it as a drop in replacement for the current geometry:</p>
<ul>
<li><a href="model/../images/viking_room.obj">viking_room.obj</a></li>
<li><a href="model/../images/viking_room.png">viking_room.png</a></li>
</ul>
<blockquote>
<p><strong>Note:</strong> The <code>.obj</code> and <code>.png</code> files that are included in this tutorial may not be identical to the original files. Make sure you use the files from this tutorial (and beyond that, the <code>.obj</code> and <code>.png</code> files may also differ from the files used in the <a href="https://vulkan-tutorial.com">original C++ tutorial</a>).</p>
</blockquote>
<p>Feel free to use your own model, but make sure that it only consists of one material and that is has dimensions of about 1.5 x 1.5 x 1.5 units. If it is larger than that, then you'll have to change the view matrix. Put the model file and texture image in the <code>resources</code> directory.</p>
<p>Update <code>create_texture_image</code> to use this path variable:</p>
<pre><code class="language-rust noplaypen">let image = File::open(&quot;resources/viking_room.png&quot;)?;
</code></pre>
<p>To double-check your image file is correct, you can also add this code in <code>create_texture_image</code> right after decoding the file as a PNG image:</p>
<pre><code class="language-rust noplaypen">if width != 1024 || height != 1024 || reader.info().color_type != png::ColorType::Rgba {
    panic!(&quot;Invalid texture image.&quot;);
}
</code></pre>
<h2 id="loading-vertices-and-indices"><a class="header" href="#loading-vertices-and-indices">Loading vertices and indices</a></h2>
<p>We're going to load the vertices and indices from the model file now, so you should remove the global <code>VERTICES</code> and <code>INDICES</code> arrays now. Replace them with <code>AppData</code> fields:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    vertices: Vec&lt;Vertex&gt;,
    indices: Vec&lt;u32&gt;,
    vertex_buffer: vk::Buffer,
    vertex_buffer_memory: vk::DeviceMemory,
    // ...
}
</code></pre>
<p>You'll also need to replace all the references to the global arrays with the new <code>AppData</code> fields.</p>
<p>You should change the type of the indices from <code>u16</code> to <code>u32</code>, because there are going to be a lot more vertices than 65,536. Remember to also change the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_bind_index_buffer"><code class="hljs">cmd_bind_index_buffer</code></a> parameter:</p>
<pre><code class="language-rust noplaypen">device.cmd_bind_index_buffer(
    *command_buffer,
    data.index_buffer,
    0,
    vk::IndexType::UINT32,
);
</code></pre>
<p>You'll also need to update the size of the index buffer in <code>create_index_buffer</code>:</p>
<pre><code class="language-rust noplaypen">let size = (size_of::&lt;u32&gt;() * data.indices.len()) as u64;
</code></pre>
<p>Next we are going to need some more imports:</p>
<pre><code class="language-rust noplaypen">use std::collections::HashMap;
use std::hash::{Hash, Hasher};
use std::io::BufReader;
</code></pre>
<p>We're now going to write a <code>load_models</code> function that uses this library to populate the <code>vertices</code> and <code>indices</code> fields with the vertex data from the mesh. It should be called somewhere before the vertex and index buffers are created:</p>
<pre><code class="language-rust noplaypen">impl App {
    unsafe fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        // ...
        load_model(&amp;mut data)?;
        create_vertex_buffer(&amp;instance, &amp;device, &amp;mut data)?;
        create_index_buffer(&amp;instance, &amp;device, &amp;mut data)?;
        // ...
    }
}

fn load_model(data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    Ok(())
}
</code></pre>
<p>A model is loaded into the crate's data structures by calling the <code>tobj::load_obj_buf</code> function:</p>
<pre><code class="language-rust noplaypen">let mut reader = BufReader::new(File::open(&quot;resources/viking_room.obj&quot;)?);

let (models, _) = tobj::load_obj_buf(
    &amp;mut reader,
    &amp;tobj::LoadOptions { triangulate: true, ..Default::default() },
    |_| Ok(Default::default()),
)?;
</code></pre>
<p>An OBJ file consists of positions, normals, texture coordinates and faces. Faces consist of an arbitrary amount of vertices, where each vertex refers to a position, normal and/or texture coordinate by index. This makes it possible to not just reuse entire vertices, but also individual attributes.</p>
<p><code>tobj::load_obj_buf</code> returns a <code>Vec</code> of models and a <code>Vec</code> of materials. We are not interested in the materials, only the models, so the returned materials are ignored with <code>_</code>.</p>
<p>The second <code>tobj::load_obj_buf</code> parameter specifies options for processing the loaded models. The <code>triangulate</code> field we are setting to <code>true</code> ensures that the components of the loaded models are converted to triangles. This is important because our rendering code can only handle triangles. We don't need this for our Viking room model since its faces are already triangles but it might be necessary if you try using a different OBJ file.</p>
<p>The third <code>tobj::load_obj_buf</code> parameter is a callback used to load any materials referenced in the OBJ file. As we are not interested in the materials, we just return an empty material.</p>
<p>We're going to combine all of the faces in the file into a single model, so just iterate over all of the shapes:</p>
<pre><code class="language-rust noplaypen">for model in &amp;models {
}
</code></pre>
<p>The triangulation feature has already made sure that there are three vertices per face, so we can now directly iterate over the vertices and dump them straight into our <code>vertices</code> vector:</p>
<pre><code class="language-rust noplaypen">for model in &amp;models {
    for index in &amp;model.mesh.indices {
        let vertex = Vertex {
            pos: vec3(0.0, 0.0, 0.0),
            color: vec3(1.0, 1.0, 1.0),
            tex_coord: vec2(0.0, 0.0),
        };

        data.vertices.push(vertex);
        data.indices.push(data.indices.len() as u32);
    }
}
</code></pre>
<p>For simplicity, we will assume that every vertex is unique for now, hence the simple auto-increment indices. The <code>index</code> variable is used to look up the actual vertex attributes in the <code>positions</code> and <code>texcoords</code> arrays:</p>
<pre><code class="language-rust noplaypen">let pos_offset = (3 * index) as usize;
let tex_coord_offset = (2 * index) as usize;

let vertex = Vertex {
    pos: vec3(
        model.mesh.positions[pos_offset],
        model.mesh.positions[pos_offset + 1],
        model.mesh.positions[pos_offset + 2],
    ),
    color: vec3(1.0, 1.0, 1.0),
    tex_coord: vec2(
        model.mesh.texcoords[tex_coord_offset],
        model.mesh.texcoords[tex_coord_offset + 1],
    ),
};
</code></pre>
<p>Unfortunately, the <code>positions</code> returned from <code>tobj::load_obj_buf</code> are a flat array of <code>f32</code> values instead of something like <code>cgmath::Vector3&lt;f32&gt;</code>, so you need to multiply the index by <code>3</code> to account for each position having three components. Similarly, there are two texture coordinate components per entry. The offsets of <code>0</code>, <code>1</code> and <code>2</code> are used to access the X, Y and Z components, or the U and V components in the case of texture coordinates.</p>
<p>You may want to start compiling your program in release mode from now on because loading the texture and model can be quite slow without optimizations. If you run your program now you should see something like the following:</p>
<p><img src="model/../images/inverted_texture_coordinates.png" alt="" /></p>
<p>Great, the geometry looks correct, but what's going on with the texture? The OBJ format assumes a coordinate system where a vertical coordinate of <code>0</code> means the bottom of the image, however we've uploaded our image into Vulkan in a top to bottom orientation where <code>0</code> means the top of the image. Solve this by flipping the vertical component of the texture coordinates:</p>
<pre><code class="language-rust noplaypen">tex_coord: vec2(
    model.mesh.texcoords[tex_coord_offset],
    1.0 - model.mesh.texcoords[tex_coord_offset + 1],
),
</code></pre>
<p>When you run your program again, you should now see the correct result:</p>
<p><img src="model/../images/drawing_model.png" alt="" /></p>
<p>All that hard work is finally beginning to pay off with a demo like this!</p>
<h2 id="vertex-deduplication"><a class="header" href="#vertex-deduplication">Vertex deduplication</a></h2>
<p>Unfortunately we're not really taking advantage of the index buffer yet. The <code>vertices</code> vector contains a lot of duplicated vertex data, because many vertices are included in multiple triangles. We should keep only the unique vertices and use the index buffer to reuse them whenever they come up. A straightforward way to implement this is to use a <code>HashMap</code> to keep track of the unique vertices and respective indices:</p>
<pre><code class="language-rust noplaypen">let mut unique_vertices = HashMap::new();

for model in &amp;models {
    for index in &amp;model.mesh.indices {
        // ...

        if let Some(index) = unique_vertices.get(&amp;vertex) {
            data.indices.push(*index as u32);
        } else {
            let index = data.vertices.len();
            unique_vertices.insert(vertex, index);
            data.vertices.push(vertex);
            data.indices.push(index as u32);
        }
    }
</code></pre>
<p>Every time we read a vertex from the OBJ file, we check if we've already seen a vertex with the exact same position and texture coordinates before. If not, we add it to <code>vertices</code> and store its index in the <code>unique_vertices</code> container. After that we add the index of the new vertex to <code>indices</code>. If we've seen the exact same vertex before, then we look up its index in <code>unique_vertices</code> and store that index in <code>indices</code>.</p>
<p>The program will fail to compile right now because we need to implement the <code>Hash</code> trait for our <code>Vertex</code> struct to be able to use it as the key of a <code>HashMap</code>. Unfortunately since <code>Vertex</code> contains <code>f32</code>s we will need to implement <code>Hash</code> and the required traits (<code>PartialEq</code> and <code>Eq</code>) by hand (note that our <code>Eq</code> implementation is valid only as long as there aren't any <code>NaN</code>s in our vertex data which for now is a safe assumption).</p>
<pre><code class="language-rust noplaypen">impl PartialEq for Vertex {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.pos == other.pos
            &amp;&amp; self.color == other.color
            &amp;&amp; self.tex_coord == other.tex_coord
    }
}

impl Eq for Vertex {}

impl Hash for Vertex {
    fn hash&lt;H: Hasher&gt;(&amp;self, state: &amp;mut H) {
        self.pos[0].to_bits().hash(state);
        self.pos[1].to_bits().hash(state);
        self.pos[2].to_bits().hash(state);
        self.color[0].to_bits().hash(state);
        self.color[1].to_bits().hash(state);
        self.color[2].to_bits().hash(state);
        self.tex_coord[0].to_bits().hash(state);
        self.tex_coord[1].to_bits().hash(state);
    }
}
</code></pre>
<p>You should now be able to successfully compile and run your program. If you check the size of <code>vertices</code>, then you'll see that it has shrunk down from 1,500,000 to 265,645! That means that each vertex is reused in an average number of ~6 triangles. This definitely saves us a lot of GPU memory.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-mipmaps"><a class="header" href="#generating-mipmaps">Generating mipmaps</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/28_mipmapping.rs">main.rs</a></p>
<p>Our program can now load and render 3D models. In this chapter, we will add one more feature, mipmap generation. Mipmaps are widely used in games and rendering software, and Vulkan gives us complete control over how they are created.</p>
<p>Mipmaps are precalculated, downscaled versions of an image. Each new image is half the width and height of the previous one.  Mipmaps are used as a form of <em>Level of Detail</em> or <em>LOD.</em> Objects that are far away from the camera will sample their textures from the smaller mip images. Using smaller images increases the rendering speed and avoids artifacts such as <a href="https://en.wikipedia.org/wiki/Moir%C3%A9_pattern">Moiré patterns</a>. An example of what mipmaps look like:</p>
<p><img src="quality/../images/mipmaps_example.jpg" alt="" /></p>
<h2 id="image-creation"><a class="header" href="#image-creation">Image creation</a></h2>
<p>In Vulkan, each of the mip images is stored in different <em>mip levels</em> of a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Image.html"><code class="hljs">vk::Image</code></a>. Mip level 0 is the original image, and the mip levels after level 0 are commonly referred to as the <em>mip chain.</em></p>
<p>The number of mip levels is specified when the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Image.html"><code class="hljs">vk::Image</code></a> is created. Up until now, we have always set this value to one. We need to calculate the number of mip levels from the dimensions of the image. First, add an <code>AppData</code> field to store this number:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    mip_levels: u32,
    texture_image: vk::Image,
    // ...
}
</code></pre>
<p>The value for <code>mip_levels</code> can be found once we've loaded the texture in <code>create_texture_image</code>:</p>
<pre><code class="language-rust noplaypen">let image = File::open(&quot;resources/viking_room.png&quot;)?;

let decoder = png::Decoder::new(image);
let mut reader = decoder.read_info()?;

// ...

data.mip_levels = (width.max(height) as f32).log2().floor() as u32 + 1;
</code></pre>
<p>This calculates the number of levels in the mip chain. The <code>max</code> method selects the largest dimension. The <code>log2</code> method calculates how many times that dimension can be divided by 2. The <code>floor</code> method handles cases where the largest dimension is not a power of 2. <code>1</code> is added so that the original image has a mip level.</p>
<p>To use this value, we need to change the <code>create_image</code>, <code>create_image_view</code>, and <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_4.html#method.transition_image_layout"><code class="hljs">transition_image_layout</code></a> functions to allow us to specify the number of mip levels. Add a <code>mip_levels</code> parameter to the functions:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_image(
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;AppData,
    width: u32,
    height: u32,
    mip_levels: u32,
    format: vk::Format,
    tiling: vk::ImageTiling,
    usage: vk::ImageUsageFlags,
    properties: vk::MemoryPropertyFlags,
) -&gt; Result&lt;(vk::Image, vk::DeviceMemory)&gt; {
    let info = vk::ImageCreateInfo::builder()
        // ...
        .mip_levels(mip_levels)
        // ...

    // ...
}
</code></pre>
<pre><code class="language-rust noplaypen">unsafe fn create_image_view(
    device: &amp;Device,
    image: vk::Image,
    format: vk::Format,
    aspects: vk::ImageAspectFlags,
    mip_levels: u32,
) -&gt; Result&lt;vk::ImageView&gt; {
    let subresource_range = vk::ImageSubresourceRange::builder()
        // ...
        .level_count(mip_levels)
        // ...

    // ...
}
</code></pre>
<pre><code class="language-rust noplaypen">unsafe fn transition_image_layout(
    device: &amp;Device,
    data: &amp;AppData,
    image: vk::Image,
    format: vk::Format,
    old_layout: vk::ImageLayout,
    new_layout: vk::ImageLayout,
    mip_levels: u32,
) -&gt; Result&lt;()&gt; {
    // ...

    let subresource = vk::ImageSubresourceRange::builder()
        // ...
        .level_count(mip_levels)
        // ...

    // ...
}
</code></pre>
<p>Update all calls to these functions to use the right values:</p>
<blockquote>
<p>Note: Be sure to use a value of <code>1</code> for all of the images and image views except the image and image view that is for the texture.</p>
</blockquote>
<pre><code class="language-rust noplaypen">let (depth_image, depth_image_memory) = create_image(
    instance,
    device,
    data,
    data.swapchain_extent.width,
    data.swapchain_extent.height,
    1,
    format,
    vk::ImageTiling::OPTIMAL,
    vk::ImageUsageFlags::DEPTH_STENCIL_ATTACHMENT,
    vk::MemoryPropertyFlags::DEVICE_LOCAL,
)?;

// ...

let (texture_image, texture_image_memory) = create_image(
    instance,
    device,
    data,
    width,
    height,
    data.mip_levels,
    vk::Format::R8G8B8A8_SRGB,
    vk::ImageTiling::OPTIMAL,
    vk::ImageUsageFlags::SAMPLED | vk::ImageUsageFlags::TRANSFER_DST,
    vk::MemoryPropertyFlags::DEVICE_LOCAL,
)?;
</code></pre>
<pre><code class="language-rust noplaypen">create_image_view(
    device,
    *i,
    data.swapchain_format,
    vk::ImageAspectFlags::COLOR,
    1,
)

// ...

data.depth_image_view = create_image_view(
    device,
    data.depth_image,
    format,
    vk::ImageAspectFlags::DEPTH,
    1,
)?;

// ...

data.texture_image_view = create_image_view(
    device,
    data.texture_image,
    vk::Format::R8G8B8A8_SRGB,
    vk::ImageAspectFlags::COLOR,
    data.mip_levels,
)?;
</code></pre>
<pre><code class="language-rust noplaypen">transition_image_layout(
    device,
    data,
    data.texture_image,
    vk::Format::R8G8B8A8_SRGB,
    vk::ImageLayout::UNDEFINED,
    vk::ImageLayout::TRANSFER_DST_OPTIMAL,
    data.mip_levels,
)?;

// ...

transition_image_layout(
    device,
    data,
    data.texture_image,
    vk::Format::R8G8B8A8_SRGB,
    vk::ImageLayout::TRANSFER_DST_OPTIMAL,
    vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL,
    data.mip_levels,
)?;
</code></pre>
<h2 id="generating-mipmaps-1"><a class="header" href="#generating-mipmaps-1">Generating Mipmaps</a></h2>
<p>Our texture image now has multiple mip levels, but the staging buffer can only be used to fill mip level 0. The other levels are still undefined. To fill these levels we need to generate the data from the single level that we have. We will use the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_blit_image"><code class="hljs">cmd_blit_image</code></a> command. This command performs copying, scaling, and filtering operations. We will call this multiple times to <em>blit</em> data to each level of our texture image.</p>
<p><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_blit_image"><code class="hljs">cmd_blit_image</code></a> is considered a transfer operation, so we must inform Vulkan that we intend to use the texture image as both the source and destination of a transfer. Add <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageUsageFlags.html#associatedconstant.TRANSFER_SRC"><code class="hljs">vk::ImageUsageFlags::TRANSFER_SRC</code></a> to the texture image's usage flags in <code>create_texture_image</code>:</p>
<pre><code class="language-rust noplaypen">let (texture_image, texture_image_memory) = create_image(
    instance,
    device,
    data,
    width,
    height,
    data.mip_levels,
    vk::Format::R8G8B8A8_SRGB,
    vk::ImageTiling::OPTIMAL,
    vk::ImageUsageFlags::SAMPLED
        | vk::ImageUsageFlags::TRANSFER_DST
        | vk::ImageUsageFlags::TRANSFER_SRC,
    vk::MemoryPropertyFlags::DEVICE_LOCAL,
)?;
</code></pre>
<p>Like other image operations, <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_blit_image"><code class="hljs">cmd_blit_image</code></a> depends on the layout of the image it operates on. We could transition the entire image to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.GENERAL"><code class="hljs">vk::ImageLayout::GENERAL</code></a>, but this will most likely be slow. For optimal performance, the source image should be in <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.TRANSFER_SRC_OPTIMAL"><code class="hljs">vk::ImageLayout::TRANSFER_SRC_OPTIMAL</code></a> and the destination image should be in <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.TRANSFER_DST_OPTIMAL"><code class="hljs">vk::ImageLayout::TRANSFER_DST_OPTIMAL</code></a>. Vulkan allows us to transition each mip level of an image independently. Each blit will only deal with two mip levels at a time, so we can transition each level into the optimal layout between blits commands.</p>
<p><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_4.html#method.transition_image_layout"><code class="hljs">transition_image_layout</code></a> only performs layout transitions on the entire image, so we'll need to write a few more pipeline barrier commands. Remove the existing transition to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.SHADER_READ_ONLY_OPTIMAL"><code class="hljs">vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL</code></a> in <code>create_texture_image</code>.</p>
<p>This will leave each level of the texture image in <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.TRANSFER_DST_OPTIMAL"><code class="hljs">vk::ImageLayout::TRANSFER_DST_OPTIMAL</code></a>. Each level will be transitioned to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.SHADER_READ_ONLY_OPTIMAL"><code class="hljs">vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL</code></a> after the blit command reading from it is finished.</p>
<p>We're now going to write the function that generates the mipmaps:</p>
<pre><code class="language-rust noplaypen">unsafe fn generate_mipmaps(
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;AppData,
    image: vk::Image,
    width: u32,
    height: u32,
    mip_levels: u32,
) -&gt; Result&lt;()&gt; {
    let command_buffer = begin_single_time_commands(device, data)?;

    let subresource = vk::ImageSubresourceRange::builder()
        .aspect_mask(vk::ImageAspectFlags::COLOR)
        .base_array_layer(0)
        .layer_count(1)
        .level_count(1);

    let mut barrier = vk::ImageMemoryBarrier::builder()
        .image(image)
        .src_queue_family_index(vk::QUEUE_FAMILY_IGNORED)
        .dst_queue_family_index(vk::QUEUE_FAMILY_IGNORED)
        .subresource_range(subresource);

    end_single_time_commands(device, data, command_buffer)?;

    Ok(())
}
</code></pre>
<p>We're going to make several transitions, so we'll reuse this <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageMemoryBarrier.html"><code class="hljs">vk::ImageMemoryBarrier</code></a> (which is why it is defined as mutable). The fields set above will remain the same for all barriers. <code>subresource_range.mip_level</code>, <code>old_layout</code>, <code>new_layout</code>, <code>src_access_mask</code>, and <code>dst_access_mask</code> will be changed for each transition.</p>
<pre><code class="language-rust noplaypen">let mut mip_width = width;
let mut mip_height = height;

for i in 1..mip_levels {
}
</code></pre>
<p>This loop will record each of the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_blit_image"><code class="hljs">cmd_blit_image</code></a> commands. Note that the range index starts at 1, not 0.</p>
<pre><code class="language-rust noplaypen">barrier.subresource_range.base_mip_level = i - 1;
barrier.old_layout = vk::ImageLayout::TRANSFER_DST_OPTIMAL;
barrier.new_layout = vk::ImageLayout::TRANSFER_SRC_OPTIMAL;
barrier.src_access_mask = vk::AccessFlags::TRANSFER_WRITE;
barrier.dst_access_mask = vk::AccessFlags::TRANSFER_READ;

device.cmd_pipeline_barrier(
    command_buffer,
    vk::PipelineStageFlags::TRANSFER,
    vk::PipelineStageFlags::TRANSFER,
    vk::DependencyFlags::empty(),
    &amp;[] as &amp;[vk::MemoryBarrier],
    &amp;[] as &amp;[vk::BufferMemoryBarrier],
    &amp;[barrier],
);
</code></pre>
<p>First, we transition level <code>i - 1</code> to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.TRANSFER_SRC_OPTIMAL"><code class="hljs">vk::ImageLayout::TRANSFER_SRC_OPTIMAL</code></a>. This transition will wait for level <code>i - 1</code> to be filled, either from the previous blit command, or from <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_copy_buffer_to_image"><code class="hljs">cmd_copy_buffer_to_image</code></a>. The current blit command will wait on this transition.</p>
<pre><code class="language-rust noplaypen">let src_subresource = vk::ImageSubresourceLayers::builder()
    .aspect_mask(vk::ImageAspectFlags::COLOR)
    .mip_level(i - 1)
    .base_array_layer(0)
    .layer_count(1);

let dst_subresource = vk::ImageSubresourceLayers::builder()
    .aspect_mask(vk::ImageAspectFlags::COLOR)
    .mip_level(i)
    .base_array_layer(0)
    .layer_count(1);

let blit = vk::ImageBlit::builder()
    .src_offsets([
        vk::Offset3D { x: 0, y: 0, z: 0 },
        vk::Offset3D {
            x: mip_width as i32,
            y: mip_height as i32,
            z: 1,
        },
    ])
    .src_subresource(src_subresource)
    .dst_offsets([
        vk::Offset3D { x: 0, y: 0, z: 0 },
        vk::Offset3D {
            x: (if mip_width &gt; 1 { mip_width / 2 } else { 1 }) as i32,
            y: (if mip_height &gt; 1 { mip_height / 2 } else { 1 }) as i32,
            z: 1,
        },
    ])
    .dst_subresource(dst_subresource);
</code></pre>
<p>Next, we specify the regions that will be used in the blit operation. The source mip level is <code>i - 1</code> and the destination mip level is <code>i</code>. The two elements of the <code>src_offsets</code> array determine the 3D region that data will be blitted from. <code>dst_offsets</code> determines the region that data will be blitted to. The X and Y dimensions of the <code>dst_offsets[1]</code> are divided by two since each mip level is half the size of the previous level. The Z dimension of <code>src_offsets[1]</code> and <code>dst_offsets[1]</code> must be 1, since a 2D image has a depth of 1.</p>
<pre><code class="language-rust noplaypen">device.cmd_blit_image(
    command_buffer,
    image,
    vk::ImageLayout::TRANSFER_SRC_OPTIMAL,
    image,
    vk::ImageLayout::TRANSFER_DST_OPTIMAL,
    &amp;[blit],
    vk::Filter::LINEAR,
);
</code></pre>
<p>Now, we record the blit command. Note that <code>image</code> is used for both the <code>stc_image</code> and <code>dst_image</code> parameters. This is because we're blitting between different levels of the same image. The source mip level was just transitioned to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.TRANSFER_SRC_OPTIMAL"><code class="hljs">vk::ImageLayout::TRANSFER_SRC_OPTIMAL</code></a> and the destination level is still in <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.TRANSFER_DST_OPTIMAL"><code class="hljs">vk::ImageLayout::TRANSFER_DST_OPTIMAL</code></a> from <code>create_texture_image</code>.</p>
<p>Beware if you are using a dedicated transfer queue (as suggested in the <code>Vertex buffers</code> chapter): <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_blit_image"><code class="hljs">cmd_blit_image</code></a> must be submitted to a queue with graphics capability.</p>
<p>The last parameter allows us to specify a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Filter.html"><code class="hljs">vk::Filter</code></a> to use in the blit. We have the same filtering options here that we had when making the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Sampler.html"><code class="hljs">vk::Sampler</code></a>. We use the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Filter.html#associatedconstant.LINEAR"><code class="hljs">vk::Filter::LINEAR</code></a> to enable interpolation.</p>
<pre><code class="language-rust noplaypen">barrier.old_layout = vk::ImageLayout::TRANSFER_SRC_OPTIMAL;
barrier.new_layout = vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL;
barrier.src_access_mask = vk::AccessFlags::TRANSFER_READ;
barrier.dst_access_mask = vk::AccessFlags::SHADER_READ;

device.cmd_pipeline_barrier(
    command_buffer,
    vk::PipelineStageFlags::TRANSFER,
    vk::PipelineStageFlags::FRAGMENT_SHADER,
    vk::DependencyFlags::empty(),
    &amp;[] as &amp;[vk::MemoryBarrier],
    &amp;[] as &amp;[vk::BufferMemoryBarrier],
    &amp;[barrier],
);
</code></pre>
<p>This barrier transitions mip level <code>i - 1</code> to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.SHADER_READ_ONLY_OPTIMAL"><code class="hljs">vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL</code></a>. This transition waits on the current blit command to finish. All sampling operations will wait on this transition to finish.</p>
<pre><code class="language-rust noplaypen">if mip_width &gt; 1 {
    mip_width /= 2;
}

if mip_height &gt; 1 {
    mip_height /= 2;
}
</code></pre>
<p>At the end of the loop, we divide the current mip dimensions by two. We check each dimension before the division to ensure that dimension never becomes 0. This handles cases where the image is not square, since one of the mip dimensions would reach 1 before the other dimension. When this happens, that dimension should remain 1 for all remaining levels.</p>
<pre><code class="language-rust noplaypen">barrier.subresource_range.base_mip_level = mip_levels - 1;
barrier.old_layout = vk::ImageLayout::TRANSFER_DST_OPTIMAL;
barrier.new_layout = vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL;
barrier.src_access_mask = vk::AccessFlags::TRANSFER_WRITE;
barrier.dst_access_mask = vk::AccessFlags::SHADER_READ;

device.cmd_pipeline_barrier(
    command_buffer,
    vk::PipelineStageFlags::TRANSFER,
    vk::PipelineStageFlags::FRAGMENT_SHADER,
    vk::DependencyFlags::empty(),
    &amp;[] as &amp;[vk::MemoryBarrier],
    &amp;[] as &amp;[vk::BufferMemoryBarrier],
    &amp;[barrier],
);

end_single_time_commands(device, data, command_buffer)?;
</code></pre>
<p>Before we end the command buffer, we insert one more pipeline barrier. This barrier transitions the last mip level from <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.TRANSFER_DST_OPTIMAL"><code class="hljs">vk::ImageLayout::TRANSFER_DST_OPTIMAL</code></a> to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.SHADER_READ_ONLY_OPTIMAL"><code class="hljs">vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL</code></a>. This wasn't handled by the loop, since the last mip level is never blitted from.</p>
<p>Finally, add the call to <code>generate_mipmaps</code> at the end of <code>create_texture_image</code>:</p>
<pre><code class="language-rust noplaypen">generate_mipmaps(
    instance,
    device,
    data,
    data.texture_image,
    width,
    height,
    data.mip_levels,
)?;
</code></pre>
<p>Our texture image's mipmaps are now completely filled.</p>
<h2 id="linear-filtering-support"><a class="header" href="#linear-filtering-support">Linear filtering support</a></h2>
<p>It is very convenient to use a built-in command like <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_blit_image"><code class="hljs">cmd_blit_image</code></a> to generate all the mip levels, but unfortunately it is not guaranteed to be supported on all platforms. It requires the texture image format we use to support linear filtering, which can be checked with the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.InstanceV1_0.html#method.get_physical_device_format_properties"><code class="hljs">get_physical_device_format_properties</code></a> command. We will add a check to the <code>generate_mipmaps</code> function for this.</p>
<p>First add an additional parameter that specifies the image format:</p>
<pre><code class="language-rust noplaypen">generate_mipmaps(
    instance,
    device,
    data,
    data.texture_image,
    vk::Format::R8G8B8A8_SRGB,
    width,
    height,
    data.mip_levels,
)?;

// ...

unsafe fn generate_mipmaps(
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;AppData,
    image: vk::Image,
    format: vk::Format,
    width: u32,
    height: u32,
    mip_levels: u32,
) -&gt; Result&lt;()&gt; {
    // ...
}
</code></pre>
<p>In the <code>generate_mipmaps</code> function, use <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.InstanceV1_0.html#method.get_physical_device_format_properties"><code class="hljs">get_physical_device_format_properties</code></a> to request the properties of the texture image format and check that linear filtering is supported:</p>
<pre><code class="language-rust noplaypen">if !instance
    .get_physical_device_format_properties(data.physical_device, format)
    .optimal_tiling_features
    .contains(vk::FormatFeatureFlags::SAMPLED_IMAGE_FILTER_LINEAR)
{
    return Err(anyhow!(&quot;Texture image format does not support linear blitting!&quot;));
}
</code></pre>
<p>The <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.FormatProperties.html"><code class="hljs">vk::FormatProperties</code></a> struct has three fields named <code>linear_tiling_features</code>, <code>optimal_tiling_features</code>, and <code>buffer_features</code> that each describe how the format can be used depending on the way it is used. We create a texture image with the optimal tiling format, so we need to check <code>optimal_tiling_features</code>. Support for the linear filtering feature can be checked with <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.FormatFeatureFlags.html#associatedconstant.SAMPLED_IMAGE_FILTER_LINEAR"><code class="hljs">vk::FormatFeatureFlags::SAMPLED_IMAGE_FILTER_LINEAR</code></a>.</p>
<p>There are two alternatives in the case where this is not supported. You could implement a function that searches common texture image formats for one that <em>does</em> support linear blitting, or you could implement the mipmap generation in your software. Each mip level can then be loaded into the image in the same way that you loaded the original image.</p>
<p>It should be noted that it is uncommon in practice to generate the mipmap levels at runtime anyway. Usually they are pregenerated and stored in the texture file alongside the base level to improve loading speed. Implementing resizing in software and loading multiple levels from a file is left as an exercise to the reader.</p>
<h2 id="sampler"><a class="header" href="#sampler">Sampler</a></h2>
<p>While the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Image.html"><code class="hljs">vk::Image</code></a> holds the mipmap data, <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Sampler.html"><code class="hljs">vk::Sampler</code></a> controls how that data is read while rendering. Vulkan allows us to specify <code>min_lod</code>, <code>max_lod</code>, <code>mip_lod_bias</code>, and <code>mipmap_mode</code> (&quot;LOD&quot; means &quot;Level of Detail&quot;). When a texture is sampled, the sampler selects a mip level according to the following pseudocode:</p>
<pre><code class="language-rust noplaypen">// Smaller when the object is close, may be negative.
let mut lod = get_lod_level_from_screen_size();

lod = clamp(lod + mip_lod_bias, min_lod, max_lod);

// Clamped to the number of mip levels in the texture.
let level = clamp(floor(lod), 0, texture.mip_levels - 1);

let color = if mipmap_mode == vk::SamplerMipmapMode::NEAREST {
    sample(level)
} else {
    blend(sample(level), sample(level + 1))
};
</code></pre>
<p>If <code>sampler_info.mipmap_mode</code> is <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SamplerMipmapMode.html#associatedconstant.NEAREST"><code class="hljs">vk::SamplerMipmapMode::NEAREST</code></a>, <code>lod</code> selects the mip level to sample from. If the mipmap mode is <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SamplerMipmapMode.html#associatedconstant.LINEAR"><code class="hljs">vk::SamplerMipmapMode::LINEAR</code></a>, <code>lod</code> is used to select two mip levels to be sampled. Those levels are sampled and the results are linearly blended.</p>
<p>The sample operation is also affected by <code>lod</code>:</p>
<pre><code class="language-rust noplaypen">let color = if lod &lt;= 0 {
    read_texture(uv, mag_filter)
} else {
    read_texture(uv, min_filter)
};
</code></pre>
<p>If the object is close to the camera, <code>mag_filter</code> is used as the filter. If the object is further from the camera, <code>min_filter</code> is used. Normally, <code>lod</code> is non-negative, and is only 0 when close the camera. <code>mip_lod_bias</code> lets us force Vulkan to use lower <code>lod</code> and <code>level</code> than it would normally use.</p>
<p>To see the results of this chapter, we need to choose values for our <code>texture_sampler</code>. We've already set the <code>min_filter</code> and <code>mag_filter</code> to use <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.Filter.html#associatedconstant.LINEAR"><code class="hljs">vk::Filter::LINEAR</code></a>. We just need to choose values for <code>min_lod</code>, <code>max_lod</code>, <code>mip_lod_bias</code>, and <code>mipmap_mode</code>.</p>
<pre><code class="language-rust noplaypen">unsafe fn create_texture_sampler(device: &amp;Device, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    let info = vk::SamplerCreateInfo::builder()
        // ...
        .mipmap_mode(vk::SamplerMipmapMode::LINEAR)
        .min_lod(0.0)       // Optional.
        .max_lod(data.mip_levels as f32)
        .mip_lod_bias(0.0); // Optional.

    data.texture_sampler = device.create_sampler(&amp;info, None)?;

    Ok(())
}
</code></pre>
<p>To allow the full range of mip levels to be used, we set <code>min_lod</code> to <code>0.0</code> and <code>max_lod</code> to the number of mip levels. We have no reason to change the <code>lod</code> value, so we set <code>mip_lod_bias</code> to 0.0f.</p>
<p>Now run your program and you should see the following:</p>
<p><img src="quality/../images/mipmaps.png" alt="" /></p>
<p>It's not a dramatic difference, since our scene is so simple. There are subtle differences if you look closely (it will be much easier to spot differences if you open the below image in a separate tab so you can see it at full size).</p>
<p><img src="quality/../images/mipmaps_comparison.png" alt="" /></p>
<p>One of most noticeable differences is the axe head. With mipmaps, the borders between the dark gray and light gray areas have been smoothed. Without mipmaps, these borders are much sharper. The differences are clear in this image which shows the axe head with and without mipmapping at 8x magnification (without any filtering so the pixels are simply expanded).</p>
<p><img src="quality/../images/mipmaps_comparison_axe.png" alt="" /></p>
<p>You can play around with the sampler settings to see how they affect mipmapping. For example, by changing <code>min_lod</code>, you can force the sampler to not use the lowest mip levels:</p>
<pre><code class="language-rust noplaypen">.min_lod(data.mip_levels as f32 / 2.0)
</code></pre>
<p>These settings will produce this image:</p>
<p><img src="quality/../images/highmipmaps.png" alt="" /></p>
<p>This is how higher mip levels will be used when objects are further away from the camera.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multisampling-1"><a class="header" href="#multisampling-1">Multisampling</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/29_multisampling.rs">main.rs</a></p>
<p>Our program can now load multiple levels of detail for textures which fixes artifacts when rendering objects far away from the viewer. The image is now a lot smoother, however on closer inspection you will notice jagged saw-like patterns along the edges of drawn geometric shapes. This is visible in one of our early programs when we rendered a quad:</p>
<p><img src="quality/../images/texcoord_visualization.png" alt="" /></p>
<p>This undesired effect is called &quot;aliasing&quot; and it's a result of a limited numbers of pixels that are available for rendering. Since there are no displays out there with unlimited resolution, it will be always visible to some extent. There's a number of ways to fix this and in this chapter we'll focus on one of the more popular ones: <a href="https://en.wikipedia.org/wiki/Multisample_anti-aliasing">multisample anti-aliasing</a> (MSAA).</p>
<p>In ordinary rendering, the pixel color is determined based on a single sample point which in most cases is the center of the target pixel on screen. If part of the drawn line passes through a certain pixel but doesn't cover the sample point, that pixel will be left blank, leading to the jagged &quot;staircase&quot; effect.</p>
<p><img src="quality/../images/aliasing.png" alt="" /></p>
<p>What MSAA does is it uses multiple sample points per pixel (hence the name) to determine its final color. As one might expect, more samples lead to better results, however it is also more computationally expensive.</p>
<p><img src="quality/../images/antialiasing.png" alt="" /></p>
<p>In our implementation, we will focus on using the maximum available sample count. Depending on your application this may not always be the best approach and it might be better to use less samples for the sake of higher performance if the final result meets your quality demands.</p>
<h2 id="getting-available-sample-count"><a class="header" href="#getting-available-sample-count">Getting available sample count</a></h2>
<p>Let's start off by determining how many samples our hardware can use. Most modern GPUs support at least 8 samples but this number is not guaranteed to be the same everywhere. We'll keep track of it by adding a new field to <code>AppData</code>:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    physical_device: vk::PhysicalDevice,
    msaa_samples: vk::SampleCountFlags,
    // ...
}
</code></pre>
<p>By default we'll be using only one sample per pixel which is equivalent to no multisampling, in which case the final image will remain unchanged. The exact maximum number of samples can be extracted from <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PhysicalDeviceProperties.html"><code class="hljs">vk::PhysicalDeviceProperties</code></a> associated with our selected physical device. We're using a depth buffer, so we have to take into account the sample count for both color and depth. The highest sample count that is supported by both (&amp;) will be the maximum we can support. Add a function that will fetch this information for us:</p>
<pre><code class="language-rust noplaypen">unsafe fn get_max_msaa_samples(
    instance: &amp;Instance,
    data: &amp;AppData,
) -&gt; vk::SampleCountFlags {
    let properties = instance.get_physical_device_properties(data.physical_device);
    let counts = properties.limits.framebuffer_color_sample_counts
        &amp; properties.limits.framebuffer_depth_sample_counts;
    [
        vk::SampleCountFlags::_64,
        vk::SampleCountFlags::_32,
        vk::SampleCountFlags::_16,
        vk::SampleCountFlags::_8,
        vk::SampleCountFlags::_4,
        vk::SampleCountFlags::_2,
    ]
    .iter()
    .cloned()
    .find(|c| counts.contains(*c))
    .unwrap_or(vk::SampleCountFlags::_1)
}
</code></pre>
<p>We will now use this function to set the <code>msaa_samples</code> variable during the physical device selection process. For this, we have to slightly modify the <code>pick_physical_device</code> function to set the maximum MSAA samples after selecting a physical device:</p>
<pre><code class="language-rust noplaypen">unsafe fn pick_physical_device(instance: &amp;Instance, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    // ...

    for physical_device in instance.enumerate_physical_devices()? {
        // ...

        if let Err(error) = check_physical_device(instance, data, physical_device) {
            // ...
        } else {
            // ...
            data.msaa_samples = get_max_msaa_samples(instance, data);
            return Ok(());
        }
    }

    Ok(())
}
</code></pre>
<h2 id="setting-up-a-render-target"><a class="header" href="#setting-up-a-render-target">Setting up a render target</a></h2>
<p>In MSAA, each pixel is sampled in an offscreen buffer which is then rendered to the screen. This new buffer is slightly different from regular images we've been rendering to - they have to be able to store more than one sample per pixel. Once a multisampled buffer is created, it has to be resolved to the default framebuffer (which stores only a single sample per pixel). This is why we have to create an additional render target and modify our current drawing process. We only need one render target since only one drawing operation is active at a time, just like with the depth buffer. Add the following <code>AppData</code> fields:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    color_image: vk::Image,
    color_image_memory: vk::DeviceMemory,
    color_image_view: vk::ImageView,
    // ...
}
</code></pre>
<p>This new image will have to store the desired number of samples per pixel, so we need to pass this number to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageCreateInfo.html"><code class="hljs">vk::ImageCreateInfo</code></a> during the image creation process. Modify the <code>create_image</code> function by adding a <code>samples</code> parameter:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_image(
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;AppData,
    width: u32,
    height: u32,
    mip_levels: u32,
    samples: vk::SampleCountFlags,
    format: vk::Format,
    tiling: vk::ImageTiling,
    usage: vk::ImageUsageFlags,
    properties: vk::MemoryPropertyFlags,
) -&gt; Result&lt;(vk::Image, vk::DeviceMemory)&gt; {
    // Image

    let info = vk::ImageCreateInfo::builder()
        // ...
        .samples(samples)
        // ...

    // ...
}
</code></pre>
<p>For now, update all calls to this function using <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SampleCountFlags.html#associatedconstant._1"><code class="hljs">vk::SampleCountFlags::_1</code></a> - we will be replacing this with proper values as we progress with implementation:</p>
<pre><code class="language-rust noplaypen">let (depth_image, depth_image_memory) = create_image(
    instance,
    device,
    data,
    data.swapchain_extent.width,
    data.swapchain_extent.height,
    1,
    vk::SampleCountFlags::_1,
    format,
    vk::ImageTiling::OPTIMAL,
    vk::ImageUsageFlags::DEPTH_STENCIL_ATTACHMENT,
    vk::MemoryPropertyFlags::DEVICE_LOCAL,
)?;

// ...

let (texture_image, texture_image_memory) = create_image(
    instance,
    device,
    data,
    width,
    height,
    data.mip_levels,
    vk::SampleCountFlags::_1,
    vk::Format::R8G8B8A8_SRGB,
    vk::ImageTiling::OPTIMAL,
    vk::ImageUsageFlags::SAMPLED
        | vk::ImageUsageFlags::TRANSFER_DST
        | vk::ImageUsageFlags::TRANSFER_SRC,
    vk::MemoryPropertyFlags::DEVICE_LOCAL,
)?;
</code></pre>
<p>We will now create a multisampled color buffer. Add a <code>create_color_objects</code> function and note that we're using <code>msaaSamples</code> here as a function parameter to <code>createImage</code>. We're also using only one mip level, since this is enforced by the Vulkan specification in case of images with more than one sample per pixel. Also, this color buffer doesn't need mipmaps since it's not going to be used as a texture:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_color_objects(
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;mut AppData,
) -&gt; Result&lt;()&gt; {
    let (color_image, color_image_memory) = create_image(
        instance,
        device,
        data,
        data.swapchain_extent.width,
        data.swapchain_extent.height,
        1,
        data.msaa_samples,
        data.swapchain_format,
        vk::ImageTiling::OPTIMAL,
        vk::ImageUsageFlags::COLOR_ATTACHMENT
            | vk::ImageUsageFlags::TRANSIENT_ATTACHMENT,
        vk::MemoryPropertyFlags::DEVICE_LOCAL,
    )?;

    data.color_image = color_image;
    data.color_image_memory = color_image_memory;

    data.color_image_view = create_image_view(
        device,
        data.color_image,
        data.swapchain_format,
        vk::ImageAspectFlags::COLOR,
        1,
    )?;

    Ok(())
}
</code></pre>
<p>For consistency, call the function right before <code>create_depth_objects</code>:</p>
<pre><code class="language-rust noplaypen">unsafe fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
    // ...
    create_color_objects(&amp;instance, &amp;device, &amp;mut data)?;
    create_depth_objects(&amp;instance, &amp;device, &amp;mut data)?;
    // ...
}
</code></pre>
<p>Now that we have a multisampled color buffer in place it's time to take care of depth. Modify <code>create_depth_objects</code> and update the number of samples used by the depth buffer:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_depth_objects(
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;mut AppData,
) -&gt; Result&lt;()&gt; {
    // ...

    let (depth_image, depth_image_memory) = create_image(
        instance,
        device,
        data,
        data.swapchain_extent.width,
        data.swapchain_extent.height,
        1,
        data.msaa_samples,
        format,
        vk::ImageTiling::OPTIMAL,
        vk::ImageUsageFlags::DEPTH_STENCIL_ATTACHMENT,
        vk::MemoryPropertyFlags::DEVICE_LOCAL,
    )?;

    // ...
}
</code></pre>
<p>We have now created a couple of new Vulkan resources, so let's not forget to release them when necessary:</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy_swapchain(&amp;mut self) {
    self.device.destroy_image_view(self.data.color_image_view, None);
    self.device.free_memory(self.data.color_image_memory, None);
    self.device.destroy_image(self.data.color_image, None);
    // ...
}
</code></pre>
<p>And update the <code>App::recreate_swapchain</code> method so that the new color image can be recreated in the correct resolution when the window is resized:</p>
<pre><code class="language-rust noplaypen">unsafe fn recreate_swapchain(&amp;mut self, window: &amp;Window) -&gt; Result&lt;()&gt; {
    // ...
    create_color_objects(&amp;self.instance, &amp;self.device, &amp;mut self.data)?;
    create_depth_objects(&amp;self.instance, &amp;self.device, &amp;mut self.data)?;
    // ...
}
</code></pre>
<p>We made it past the initial MSAA setup, now we need to start using this new resource in our graphics pipeline, framebuffer, render pass and see the results!</p>
<h2 id="adding-new-attachments"><a class="header" href="#adding-new-attachments">Adding new attachments</a></h2>
<p>Let's take care of the render pass first. Modify <code>create_render_pass</code> and update color and depth attachment creation info structs:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_render_pass(
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;mut AppData,
) -&gt; Result&lt;()&gt; {
    let color_attachment = vk::AttachmentDescription::builder()
        // ...
        .samples(data.msaa_samples)
        // ...
        .final_layout(vk::ImageLayout::COLOR_ATTACHMENT_OPTIMAL);

    let depth_stencil_attachment = vk::AttachmentDescription::builder()
        // ...
        .samples(data.msaa_samples)
        // ...

    // ...
}
</code></pre>
<p>You'll notice that we have changed the finalLayout from <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.PRESENT_SRC_KHR"><code class="hljs">vk::ImageLayout::PRESENT_SRC_KHR</code></a> to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.COLOR_ATTACHMENT_OPTIMAL"><code class="hljs">vk::ImageLayout::COLOR_ATTACHMENT_OPTIMAL</code></a>. That's because multisampled images cannot be presented directly. We first need to resolve them to a regular image. This requirement does not apply to the depth buffer, since it won't be presented at any point. Therefore we will have to add only one new attachment for color which is a so-called resolve attachment:</p>
<pre><code class="language-rust noplaypen">let color_resolve_attachment = vk::AttachmentDescription::builder()
    .format(data.swapchain_format)
    .samples(vk::SampleCountFlags::_1)
    .load_op(vk::AttachmentLoadOp::DONT_CARE)
    .store_op(vk::AttachmentStoreOp::STORE)
    .stencil_load_op(vk::AttachmentLoadOp::DONT_CARE)
    .stencil_store_op(vk::AttachmentStoreOp::DONT_CARE)
    .initial_layout(vk::ImageLayout::UNDEFINED)
    .final_layout(vk::ImageLayout::PRESENT_SRC_KHR);
</code></pre>
<p>The render pass now has to be instructed to resolve multisampled color image into regular attachment. Create a new attachment reference that will point to the color buffer which will serve as the resolve target:</p>
<pre><code class="language-rust noplaypen">let color_resolve_attachment_ref = vk::AttachmentReference::builder()
    .attachment(2)
    .layout(vk::ImageLayout::COLOR_ATTACHMENT_OPTIMAL);
</code></pre>
<p>Set the <code>resolve_attachments</code> subpass struct member to point to the newly created attachment reference. This is enough to let the render pass define a multisample resolve operation which will let us render the image to screen:</p>
<pre><code class="language-rust noplaypen">let color_attachments = &amp;[color_attachment_ref];
let resolve_attachments = &amp;[color_resolve_attachment_ref];
let subpass = vk::SubpassDescription::builder()
    .pipeline_bind_point(vk::PipelineBindPoint::GRAPHICS)
    .color_attachments(color_attachments)
    .depth_stencil_attachment(&amp;depth_stencil_attachment_ref)
    .resolve_attachments(resolve_attachments);
</code></pre>
<p>Now update render pass info struct with the new color attachment:</p>
<pre><code class="language-rust noplaypen">let attachments = &amp;[
    color_attachment,
    depth_stencil_attachment,
    color_resolve_attachment,
];
let subpasses = &amp;[subpass];
let dependencies = &amp;[dependency];
let info = vk::RenderPassCreateInfo::builder()
    .attachments(attachments)
    .subpasses(subpasses)
    .dependencies(dependencies);
</code></pre>
<p>With the render pass in place, modify <code>create_framebuffers</code> and add the new image view to the attachments slice:</p>
<pre><code class="language-rust noplaypen">let attachments = &amp;[data.color_image_view, data.depth_image_view, *i];
</code></pre>
<p>Finally, tell the newly created pipeline to use more than one sample by modifying <code>create_pipeline</code>:</p>
<pre><code class="language-rust noplaypen">let multisample_state = vk::PipelineMultisampleStateCreateInfo::builder()
    .sample_shading_enable(false)
    .rasterization_samples(data.msaa_samples);
</code></pre>
<p>Now run your program and you should see the following:</p>
<p><img src="quality/../images/multisampling.png" alt="" /></p>
<p>Just like with mipmapping, the difference may not be apparent straight away. On a closer look you'll notice that the edges are not as jagged anymore and the whole image seems a bit smoother compared to the original (again it will be much easier to spot differences if you open the below image in a separate tab).</p>
<p><img src="quality/../images/multisampling_comparison.png" alt="" /></p>
<p>The difference is more noticeable when taking another close look at the axe head at 8x magnification:</p>
<p><img src="quality/../images/multisampling_comparison_axe.png" alt="" /></p>
<h2 id="quality-improvements"><a class="header" href="#quality-improvements">Quality improvements</a></h2>
<p>There are certain limitations of our current MSAA implementation which may impact the quality of the output image in more detailed scenes. For example, we're currently not solving potential problems caused by shader aliasing, i.e. MSAA only smoothens out the edges of geometry but not the interior filling. This may lead to a situation when you get a smooth polygon rendered on screen but the applied texture will still look aliased if it contains high contrasting colors. One way to approach this problem is to enable <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#primsrast-sampleshading">Sample Shading</a> which will improve the image quality even further, though at an additional performance cost:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_logical_device(
    instance: &amp;Instance,
    data: &amp;mut AppData,
) -&gt; Result&lt;Device&gt; {
    // ...

    let features = vk::PhysicalDeviceFeatures::builder()
        .sampler_anisotropy(true)
        // Enable sample shading feature for the device.
        .sample_rate_shading(true);

    // ...
}

// ...

unsafe fn create_pipeline(device: &amp;Device, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    // ...

    let multisample_state = vk::PipelineMultisampleStateCreateInfo::builder()
        // Enable sample shading in the pipeline.
        .sample_shading_enable(true)
        // Minimum fraction for sample shading; closer to one is smoother.
        .min_sample_shading(0.2)
        .rasterization_samples(data.msaa_samples);

    // ...
}
</code></pre>
<p>In this example we'll leave sample shading disabled but in certain scenarios the quality improvement may be noticeable:</p>
<p><img src="quality/../images/sample_shading.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="push-constants"><a class="header" href="#push-constants">Push constants</a></h1>
<blockquote>
<p><span style="display: flex; justify-content: center; margin-bottom: 16px"><img src="dynamic/../images/i_have_no_idea_what_im_doing.jpg" width="256"></span>The previous chapters of this tutorial that are not marked by this disclaimer were directly adapted from <a href="https://github.com/Overv/VulkanTutorial">https://github.com/Overv/VulkanTutorial</a>.<br/><br/>This chapter and the following chapters are instead original creations from someone who is most decidedly not an expert in Vulkan. An authoritative tone has been maintained, but these chapters should be considered a &quot;best effort&quot; by someone still learning Vulkan.<br/><br/>If you have questions, suggestions, or corrections, please <a href="https://github.com/KyleMayes/vulkanalia/issues">open an issue</a>!</p>
</blockquote>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/30_push_constants.rs">main.rs</a> | <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/shaders/30/shader.vert">shader.vert</a> | <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/shaders/30/shader.frag">shader.frag</a></p>
<p>The scene that we've created in the tutorial thus far is static. While we can rotate and otherwise move the model around on the screen by manipulating the uniform buffers that provide the model, view, and projection (MVP) matrices, we can't alter <em>what</em> is being rendered. This is because the decision of what to render is made during program initialization when our command buffers are allocated and recorded.</p>
<p>In the next few chapters we are going to explore various techniques we can use to accomplish the rendering of dynamic scenes. First, however, we are going to look at <em>push constants</em>, a Vulkan feature that allows us to easily and efficiently &quot;push&quot; dynamic data to shaders. Push constants alone will not accomplish our goal of a dynamic scene, but their usefulness should become clear over the next few chapters.</p>
<h2 id="push-constants-vs-uniform-buffers"><a class="header" href="#push-constants-vs-uniform-buffers">Push constants vs uniform buffers</a></h2>
<p>We are already using another Vulkan feature to provide dynamic data to our vertex shader: uniform buffers. Every frame, the <code>App::update_uniform_buffer</code> method calculates the updated MVP matrices for the model's current rotation and copies those matrices to a uniform buffer. The vertex shader then reads those matrices from the uniform buffer to figure out where the vertices of the model belong on the screen.</p>
<p>This approach works well enough, when would we want to use push constants instead? One advantage of push constants over uniform buffers is speed, updating a push constant will usually be significantly faster than copying new data to a uniform buffer. For a large number of values that need to be updated frequently, this difference can add up quickly.</p>
<p>Of course there is a catch: the amount of data that can be provided to a shader using push constants has a <em>very</em> limited maximum size. This maximum size varies from device to device and is specified in bytes by the <code>max_push_constants_size</code> field of <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PhysicalDeviceLimits.html"><code class="hljs">vk::PhysicalDeviceLimits</code></a>. Vulkan requires that this limit be <a href="https://www.khronos.org/registry/vulkan/specs/1.2/html/chap33.html#limits-minmax">at least 128 bytes</a> (see table 32), but you won't find values much larger than that in the wild. Even high-end hardware like the RTX 3080 only has a limit of 256 bytes.</p>
<p>If we wanted to, say, use push constants to provide our MVP matrices to our shaders we would immediately run into this limitation. The MVP matrices are too large to reliably fit in push constants, each matrix is 64 bytes (16 × 4 byte floats) leading to a total of 192 bytes. Of course we could maintain two code paths, one for devices that can handle push constants &gt;= 192 bytes and another for devices that can't, but there are simpler approaches we could take.</p>
<p>One would be to premultiply our MVP matrices into a single matrix. Another would be to provide only the model matrix as a push constant and leave the view and projection matrices in the uniform buffer. Both would give us at least 64 bytes of headroom for other push constants even on devices providing only the minimum 128 bytes for push constants. In this chapter we will take the second approach to start exploring push constants.</p>
<p>Why only the model matrix for the second approach? In the <code>App::update_uniform_buffer</code> method, you'll notice that the <code>model</code> matrix changes every frame as <code>time</code> increases, the <code>view</code> matrix is static, and the <code>proj</code> matrix only changes when the window is resized. This would allow us to only update the uniform buffer containing the view and projection matrices when the window is resized and use push constants to provide the constantly changing model matrix.</p>
<p>Of course, in a more realistic application the view matrix would most likely not be static. For example, if you were building a first-person game, the view matrix would change very frequently as the player moves through the game world. However, the view and projection matrices, even if they change every frame, would be shared between all or at least most of the models you are rendering. This means you could continue updating the uniform buffer once per frame to provide the shared view and projection matrices and use push constants to provide the model matrices for each model in your scene.</p>
<h2 id="pushing-the-model-matrix"><a class="header" href="#pushing-the-model-matrix">Pushing the model matrix</a></h2>
<p>With that wall of text out of the way, let's get started by moving the model matrix in the vertex shader from the uniform buffer object to a push constant. Don't forget to recompile the vertex shader afterwards!</p>
<pre><code class="language-glsl">#version 450

layout(binding = 0) uniform UniformBufferObject {
    mat4 view;
    mat4 proj;
} ubo;

layout(push_constant) uniform PushConstants {
    mat4 model;
} pcs;

// ...

void main() {
    gl_Position = ubo.proj * ubo.view * pcs.model * vec4(inPosition, 1.0);
    // ...
}
</code></pre>
<p>Note that the layout is <code>push_constant</code> and not something like <code>push_constant = 0</code> like how the uniform buffer object is defined. This is because we can only provide one collection of push constants for an invocation of a graphics pipeline and this collection is very limited in size as described previously.</p>
<p>Remove <code>model</code> from the <code>UniformBufferObject</code> struct since we will be specifying it as a push constant from here on out.</p>
<pre><code class="language-rust noplaypen">#[repr(C)]
#[derive(Copy, Clone, Debug)]
struct UniformBufferObject {
    view: Mat4,
    proj: Mat4,
}
</code></pre>
<p>Also remove <code>model</code> from the <code>App::update_uniform_buffer</code> method.</p>
<pre><code class="language-rust noplaypen">let view = Mat4::look_at_rh(
    point3(2.0, 2.0, 2.0),
    point3(0.0, 0.0, 0.0),
    vec3(0.0, 0.0, 1.0),
);

let correction = Mat4::new(
    1.0,  0.0,       0.0, 0.0,
    0.0, -1.0,       0.0, 0.0,
    0.0,  0.0, 1.0 / 2.0, 0.0,
    0.0,  0.0, 1.0 / 2.0, 1.0,
);

let proj = correction * cgmath::perspective(
    Deg(45.0),
    self.data.swapchain_extent.width as f32 / self.data.swapchain_extent.height as f32,
    0.1,
    10.0,
);

let ubo = UniformBufferObject { view, proj };

// ...
</code></pre>
<p>We need to tell Vulkan about our new push constant by describing it in the layout of our graphics pipeline. In the <code>create_pipeline</code> function you'll see that we are already providing our descriptor set layout to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.create_pipeline_layout"><code class="hljs">create_pipeline_layout</code></a>. This descriptor set layout describes the uniform buffer object and texture sampler used in our shaders and we need to similarly describe any push constants accessed by the shaders in our graphics pipeline using <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PushConstantRange.html"><code class="hljs">vk::PushConstantRange</code></a>.</p>
<pre><code class="language-rust noplaypen">let vert_push_constant_range = vk::PushConstantRange::builder()
    .stage_flags(vk::ShaderStageFlags::VERTEX)
    .offset(0)
    .size(64 /* 16 × 4 byte floats */);

let set_layouts = &amp;[data.descriptor_set_layout];
let push_constant_ranges = &amp;[vert_push_constant_range];
let layout_info = vk::PipelineLayoutCreateInfo::builder()
    .set_layouts(set_layouts)
    .push_constant_ranges(push_constant_ranges);

data.pipeline_layout = device.create_pipeline_layout(&amp;layout_info, None)?;
</code></pre>
<p>The push constant range here specifies that the push constants accessed by the vertex shader can be found at the beginning of the push constants provided to the graphics pipeline and are the size of a <code>mat4</code>.</p>
<p>With all that in place, we can actually start pushing the model matrix to the vertex shader. Push constants are recorded directly into the command buffers submitted to the GPU which is both why they are so fast and why their size is so limited.</p>
<p>In the <code>create_command_buffers</code> function, define a model matrix and use <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_push_constants"><code class="hljs">cmd_push_constants</code></a> to add it to the command buffers as a push constant right before we record the draw command.</p>
<pre><code class="language-rust noplaypen">let model = Mat4::from_axis_angle(
    vec3(0.0, 0.0, 1.0),
    Deg(0.0)
);

let model_bytes = std::slice::from_raw_parts(
    &amp;model as *const Mat4 as *const u8,
    size_of::&lt;Mat4&gt;()
);

for (i, command_buffer) in data.command_buffers.iter().enumerate() {
    // ...

    device.cmd_push_constants(
        *command_buffer,
        data.pipeline_layout,
        vk::ShaderStageFlags::VERTEX,
        0,
        model_bytes,
    );
    device.cmd_draw_indexed(*command_buffer, data.indices.len() as u32, 1, 0, 0, 0);

    // ...
}
</code></pre>
<p>If you run the program now you will see the familiar model, but it is no longer rotating! Instead of updating the model matrix in the uniform buffer object every frame we are now encoding it into the command buffers which, as previously discussed, are never updated. This further highlights the need to somehow update our command buffers, a topic that will be covered in the next chapter. For now, let's round out this chapter by adding a push constant to the fragment shader.</p>
<h2 id="pushing-the-opacity"><a class="header" href="#pushing-the-opacity">Pushing the opacity</a></h2>
<p>Next we'll add a push constant to the fragment shader which we can use to control the opacity of the model. Start by modifying the fragment shader to include the push constant and to use it as the alpha channel of the fragment color. Again, be sure to recompile the shader!</p>
<pre><code class="language-glsl">#version 450

layout(binding = 1) uniform sampler2D texSampler;

layout(push_constant) uniform PushConstants {
    layout(offset = 64) float opacity;
} pcs;

// ...

void main() {
    outColor = vec4(texture(texSampler, fragTexCoord).rgb, pcs.opacity);
}
</code></pre>
<p>This time we specify an offset for the push constant value. Remember that push constants are shared between all of the shaders in a graphics pipeline so we need to account for the fact that the first 64 bytes of the push constants are occupied by the model matrix used in the vertex shader.</p>
<p>Add a push constant range for the new opacity push constant to the pipeline layout.</p>
<pre><code class="language-rust noplaypen">let vert_push_constant_range = vk::PushConstantRange::builder()
    .stage_flags(vk::ShaderStageFlags::VERTEX)
    .offset(0)
    .size(64 /* 16 × 4 byte floats */);

let frag_push_constant_range = vk::PushConstantRange::builder()
    .stage_flags(vk::ShaderStageFlags::FRAGMENT)
    .offset(64)
    .size(4);

let set_layouts = &amp;[data.descriptor_set_layout];
let push_constant_ranges = &amp;[vert_push_constant_range, frag_push_constant_range];
let layout_info = vk::PipelineLayoutCreateInfo::builder()
    .set_layouts(set_layouts)
    .push_constant_ranges(push_constant_ranges);

data.pipeline_layout = device.create_pipeline_layout(&amp;layout_info, None)?;
</code></pre>
<p>Lastly, add another call to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_push_constants"><code class="hljs">cmd_push_constants</code></a> in the <code>create_command_buffers</code> after the call for the model matrix.</p>
<pre><code class="language-rust noplaypen">device.cmd_push_constants(
    *command_buffer,
    data.pipeline_layout,
    vk::ShaderStageFlags::VERTEX,
    0,
    model_bytes,
);
device.cmd_push_constants(
    *command_buffer,
    data.pipeline_layout,
    vk::ShaderStageFlags::FRAGMENT,
    64,
    &amp;0.25f32.to_ne_bytes()[..],
);
device.cmd_draw_indexed(*command_buffer, data.indices.len() as u32, 1, 0, 0, 0);
</code></pre>
<p>Here we provide an opacity of <code>0.25</code> to the fragment shader by recording it into the command buffer after the 64 bytes of the model matrix. However, if you were to run the program now, you'd find that the model is still entirely opaque!</p>
<p>Back in the <a href="dynamic/../pipeline/fixed_functions.html#color-blending">chapter on fixed function operations</a>, we discussed what was necessary to set up alpha blending so that we could render transparent geometries to the framebuffers. However, back then we left alpha blending disabled. Update the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.PipelineColorBlendAttachmentState.html"><code class="hljs">vk::PipelineColorBlendAttachmentState</code></a> in the <code>create_pipeline</code> function to enable alpha blending as described in that chapter.</p>
<pre><code class="language-rust noplaypen">let attachment = vk::PipelineColorBlendAttachmentState::builder()
    .color_write_mask(vk::ColorComponentFlags::all())
    .blend_enable(true)
    .src_color_blend_factor(vk::BlendFactor::SRC_ALPHA)
    .dst_color_blend_factor(vk::BlendFactor::ONE_MINUS_SRC_ALPHA)
    .color_blend_op(vk::BlendOp::ADD)
    .src_alpha_blend_factor(vk::BlendFactor::ONE)
    .dst_alpha_blend_factor(vk::BlendFactor::ZERO)
    .alpha_blend_op(vk::BlendOp::ADD);
</code></pre>
<p>Run the program to see our now ghostly model.</p>
<p><img src="dynamic/../images/opacity_push_constant.png" alt="" /></p>
<p>Success!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recycling-command-buffers"><a class="header" href="#recycling-command-buffers">Recycling command buffers</a></h1>
<blockquote>
<p><span style="display: flex; justify-content: center; margin-bottom: 16px"><img src="dynamic/../images/i_have_no_idea_what_im_doing.jpg" width="256"></span>The previous chapters of this tutorial that are not marked by this disclaimer were directly adapted from <a href="https://github.com/Overv/VulkanTutorial">https://github.com/Overv/VulkanTutorial</a>.<br/><br/>This chapter and the following chapters are instead original creations from someone who is most decidedly not an expert in Vulkan. An authoritative tone has been maintained, but these chapters should be considered a &quot;best effort&quot; by someone still learning Vulkan.<br/><br/>If you have questions, suggestions, or corrections, please <a href="https://github.com/KyleMayes/vulkanalia/issues">open an issue</a>!</p>
</blockquote>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/31_recycling_command_buffers.rs">main.rs</a></p>
<p>When you allocate a command buffer and record commands to it, Vulkan allocates blocks of memory to store information about the command buffer and the commands that have been recorded to it. Now that we want to be able to record different commands each frame, we need to recycle this memory in the same way that in C we need to <code>free</code> memory allocated with <code>malloc</code> once it is no longer in use.</p>
<h2 id="solutions"><a class="header" href="#solutions">Solutions</a></h2>
<p>Vulkan offers <a href="https://github.com/KhronosGroup/Vulkan-Samples/blob/524cdcd27005e7cd56e6694fa41e685519d7dbca/samples/performance/command_buffer_usage/command_buffer_usage_tutorial.md#recycling-strategies">three basic approaches</a> for recycling the memory occupied by a command buffer:</p>
<ol>
<li>Reset the command buffer (which clears the commands recorded to it) and record new commands to the command buffer</li>
<li>Free the command buffer (which returns its memory to the command pool it was allocated from) and allocate a new command buffer</li>
<li>Reset the command pool the command buffer was allocated from (which resets <em>all</em> of the command buffers allocated from the command pool) and record new commands to the command buffer</li>
</ol>
<p>Let's look at what would be required to implement each of these approaches.</p>
<h3 id="1-resetting-command-buffers"><a class="header" href="#1-resetting-command-buffers">1. Resetting command buffers</a></h3>
<p>By default, command buffers cannot be reset and are effectively immutable once they have been recorded. The ability to reset them is an option that must be enabled on our command pool during its creation and will be applied to any command buffers allocated from this command pool. Add the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.CommandPoolCreateFlags.html#associatedconstant.RESET_COMMAND_BUFFER"><code class="hljs">vk::CommandPoolCreateFlags::RESET_COMMAND_BUFFER</code></a> flag to the create info structure for the command pool in <code>create_command_pool</code>.</p>
<pre><code class="language-rust noplaypen">let info = vk::CommandPoolCreateInfo::builder()
    .flags(vk::CommandPoolCreateFlags::RESET_COMMAND_BUFFER)
    .queue_family_index(indices.graphics);

data.command_pool = device.create_command_pool(&amp;info, None)?;
</code></pre>
<p>Next, create a new method for the <code>App</code> struct, <code>update_command_buffer</code>. This method will be called each frame to reset and rerecord the command buffer for the framebuffer that will be used for the current frame.</p>
<pre><code class="language-rust noplaypen">unsafe fn update_command_buffer(&amp;mut self, image_index: usize) -&gt; Result&lt;()&gt; {
    Ok(())
}
</code></pre>
<p>Call the new method from the <code>render</code> method right before the uniform buffers for the frame are updated (or after, the order of these two statements is not important).</p>
<pre><code class="language-rust noplaypen">unsafe fn render(&amp;mut self, window: &amp;Window) -&gt; Result&lt;()&gt; {
    // ...

    self.update_command_buffer(image_index)?;
    self.update_uniform_buffer(image_index)?;

    // ...
}
</code></pre>
<p>Note that we do need to be careful about when we call <code>update_command_buffer</code>. This method will reset the command buffer which could cause serious issues if the command buffer is still being used to render a previously submitted frame. This issue was also discussed in the <a href="dynamic/../uniform/descriptor_set_layout_and_buffer.html#updating-uniform-data"><code>Descriptor set layout and buffer</code> chapter</a> which is why the call to <code>App::update_uniform_buffer</code> is where it is. As discussed in more detail in that chapter, both of these calls only happen after the call to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.wait_for_fences"><code class="hljs">wait_for_fences</code></a> which waits for the GPU to be done with the acquired swapchain image and its associated resources so we are safe to do whatever we want with the command buffer.</p>
<p>In the new method, reset the command buffer with <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.reset_command_buffer"><code class="hljs">reset_command_buffer</code></a>.</p>
<pre><code class="language-rust noplaypen">unsafe fn update_command_buffer(&amp;mut self, image_index: usize) -&gt; Result&lt;()&gt; {
    let command_buffer = self.data.command_buffers[image_index];

    self.device.reset_command_buffer(
        command_buffer,
        vk::CommandBufferResetFlags::empty(),
    )?;

    Ok(())
}
</code></pre>
<p>Once <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.reset_command_buffer"><code class="hljs">reset_command_buffer</code></a> has returned, the command buffer will be reset to its initial state, no different than a new command buffer freshly allocated from a command pool.</p>
<p>Now we can move the command buffer recording code out of <code>create_command_buffers</code> and into <code>update_command_buffer</code>. The loop over the command buffers is no longer necessary since we are only recording one command buffer per frame. Other than that, only a few mechanical changes are needed to migrate this code to our new method (e.g., replacing references to the loop counter <code>i</code> with <code>image_index</code>).</p>
<pre><code class="language-rust noplaypen">unsafe fn update_command_buffer(&amp;mut self, image_index: usize) -&gt; Result&lt;()&gt; {
    // ...

    let model = Mat4::from_axis_angle(
        vec3(0.0, 0.0, 1.0),
        Deg(0.0)
    );

    let model_bytes = &amp;*slice_from_raw_parts(
        &amp;model as *const Mat4 as *const u8,
        size_of::&lt;Mat4&gt;()
    );

    let info = vk::CommandBufferBeginInfo::builder();

    self.device.begin_command_buffer(command_buffer, &amp;info)?;

    let render_area = vk::Rect2D::builder()
        .offset(vk::Offset2D::default())
        .extent(self.data.swapchain_extent);

    let color_clear_value = vk::ClearValue {
        color: vk::ClearColorValue {
            float32: [0.0, 0.0, 0.0, 1.0],
        },
    };

    let depth_clear_value = vk::ClearValue {
        depth_stencil: vk::ClearDepthStencilValue { depth: 1.0, stencil: 0 },
    };

    let clear_values = &amp;[color_clear_value, depth_clear_value];
    let info = vk::RenderPassBeginInfo::builder()
        .render_pass(self.data.render_pass)
        .framebuffer(self.data.framebuffers[image_index])
        .render_area(render_area)
        .clear_values(clear_values);

    self.device.cmd_begin_render_pass(command_buffer, &amp;info, vk::SubpassContents::INLINE);
    self.device.cmd_bind_pipeline(command_buffer, vk::PipelineBindPoint::GRAPHICS, self.data.pipeline);
    self.device.cmd_bind_vertex_buffers(command_buffer, 0, &amp;[self.data.vertex_buffer], &amp;[0]);
    self.device.cmd_bind_index_buffer(command_buffer, self.data.index_buffer, 0, vk::IndexType::UINT32);
    self.device.cmd_bind_descriptor_sets(
        command_buffer,
        vk::PipelineBindPoint::GRAPHICS,
        self.data.pipeline_layout,
        0,
        &amp;[self.data.descriptor_sets[image_index]],
        &amp;[],
    );
    self.device.cmd_push_constants(
        command_buffer,
        self.data.pipeline_layout,
        vk::ShaderStageFlags::VERTEX,
        0,
        model_bytes,
    );
    self.device.cmd_push_constants(
        command_buffer,
        self.data.pipeline_layout,
        vk::ShaderStageFlags::FRAGMENT,
        64,
        &amp;0.25f32.to_ne_bytes()[..],
    );
    self.device.cmd_draw_indexed(command_buffer, self.data.indices.len() as u32, 1, 0, 0, 0);
    self.device.cmd_end_render_pass(command_buffer);

    self.device.end_command_buffer(command_buffer)?;

    Ok(())
}
</code></pre>
<p>With these changes in place, our program can now execute different rendering commands every frame which permits dynamic scenes! Let's exercise this new capability by restoring the rotation of the model to its former glory. Replace the model matrix calculation in <code>App::update_command_buffer</code> with the old calculation that rotates the model over time.</p>
<pre><code class="language-rust noplaypen">let time = self.start.elapsed().as_secs_f32();

let model = Mat4::from_axis_angle(
    vec3(0.0, 0.0, 1.0),
    Deg(90.0) * time
);

let model_bytes = &amp;*slice_from_raw_parts(
    &amp;model as *const Mat4 as *const u8,
    size_of::&lt;Mat4&gt;()
);
</code></pre>
<p>Run the program to see that the model should now be back to rotating now that we are pushing an updated model matrix to the shaders every frame.</p>
<p><img src="dynamic/../images/spinning_ghost_model.png" alt="" /></p>
<p>Lastly, since we are now only submitting our command buffers once before resetting them, we should let Vulkan know this so it can better understand the behavior of our program. This is accomplished by passing the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.CommandBufferUsageFlags.html#associatedconstant.ONE_TIME_SUBMIT"><code class="hljs">vk::CommandBufferUsageFlags::ONE_TIME_SUBMIT</code></a> flag when starting to record a command buffer.</p>
<pre><code class="language-rust noplaypen">let info = vk::CommandBufferBeginInfo::builder()
    .flags(vk::CommandBufferUsageFlags::ONE_TIME_SUBMIT);

self.device.begin_command_buffer(command_buffer, &amp;info)?;
</code></pre>
<p>You might recall we've used this flag before, there should already be a usage of this flag in the <code>begin_single_time_commands</code> function. This flag isn't required by Vulkan for correctness if you are only using command buffers once before resetting or freeing them, but this knowledge may allow the Vulkan driver to better optimize its handling of our single-use command buffers.</p>
<h3 id="2-reallocating-command-buffers"><a class="header" href="#2-reallocating-command-buffers">2. Reallocating command buffers</a></h3>
<p>Next we'll take a look at allocating new command buffers each frame.</p>
<p>Replace the code used to reset the command buffer at the beginning of <code>update_command_buffer</code> with code that replaces the previous command buffer with a new command buffer.</p>
<pre><code class="language-rust noplaypen">unsafe fn update_command_buffer(&amp;mut self, image_index: usize) -&gt; Result&lt;()&gt; {
    let allocate_info = vk::CommandBufferAllocateInfo::builder()
        .command_pool(self.data.command_pool)
        .level(vk::CommandBufferLevel::PRIMARY)
        .command_buffer_count(1);

    let command_buffer = self.device.allocate_command_buffers(&amp;allocate_info)?[0];
    self.data.command_buffers[image_index] = command_buffer;

    // ...
}
</code></pre>
<p>You could now run the program and see that the program works exactly like it did before, but if you do don't leave it running for too long! You may have already noticed that we aren't freeing the previous command buffer before we allocate a new one. If you observe the memory usage of our program after this change you'll see the memory usage start rising alarmingly fast as we rapidly collect thousands of derelict command buffers that are never recycled.</p>
<p>Return the memory used by the previous command buffer to the command pool by freeing it at the beginning of <code>update_command_buffer</code>.</p>
<pre><code class="language-rust noplaypen">unsafe fn update_command_buffer(&amp;mut self, image_index: usize) -&gt; Result&lt;()&gt; {
    let previous = self.data.command_buffers[image_index];
    self.device.free_command_buffers(self.data.command_pool, &amp;[previous]);

    // ...
}
</code></pre>
<p>Now when you run the program you should see stable memory usage instead of the program trying to gobble up all of the RAM on your system as if it thinks it's an Electron application.</p>
<p>We no longer need the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.CommandPoolCreateFlags.html#associatedconstant.RESET_COMMAND_BUFFER"><code class="hljs">vk::CommandPoolCreateFlags::RESET_COMMAND_BUFFER</code></a> flag for our command pool since we aren't resetting command buffers any more. Leaving this flag wouldn't affect the correctness of our program, but it could have a negative performance impact since it forces the command pool to allocate command buffers in such a way that they are resettable.</p>
<p>We'll replace this flag with <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.CommandPoolCreateFlags.html#associatedconstant.TRANSIENT"><code class="hljs">vk::CommandPoolCreateFlags::TRANSIENT</code></a> which tells Vulkan that the command buffers we'll be allocating with this command pool will be &quot;transient&quot;, i.e. short-lived.</p>
<pre><code class="language-rust noplaypen">let info = vk::CommandPoolCreateInfo::builder()
    .flags(vk::CommandPoolCreateFlags::TRANSIENT)
    .queue_family_index(indices.graphics);

data.command_pool = device.create_command_pool(&amp;info, None)?;
</code></pre>
<p>Like <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.CommandBufferUsageFlags.html#associatedconstant.ONE_TIME_SUBMIT"><code class="hljs">vk::CommandBufferUsageFlags::ONE_TIME_SUBMIT</code></a>, this flag does not affect the correctness of our program but it may allow the Vulkan driver to better optimize the handling of our short-lived command buffers.</p>
<h3 id="3-resetting-command-pools"><a class="header" href="#3-resetting-command-pools">3. Resetting command pools</a></h3>
<p>Next we'll look at resetting our entire command pool which will reset all of our active command buffers in one fell swoop.</p>
<p>However, we immediately run into a problem with this approach. We can't reset <em>all</em> of our command buffers each frame because some of them might still be in use! The <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.wait_for_fences"><code class="hljs">wait_for_fences</code></a> call in <code>App::render</code> ensures that we are safe to reset the command buffer associated with the current framebuffer, but there might be other command buffers still in use.</p>
<p>We could continue down this path, but it would prevent our program from having multiple frames in-flight concurrently. This ability is important to maintain because, as discussed back in the <a href="dynamic/../drawing/rendering_and_presentation.html#frames-in-flight"><code>Rendering and presentation</code> chapter</a>, it allows us to better leverage our hardware since the CPU will spend less time waiting on the GPU and vice-versa.</p>
<p>Instead, we will alter our program to maintain a separate command pool for each framebuffer. This way we can freely reset the command pool associated with the current framebuffer without worrying about breaking any previously submitted frames that are still in-flight.</p>
<p>You might think that this is overkill, why maintain separate command pools just so we can reset command buffers one at a time? Wouldn't it be simpler, and probably even faster, to continue freeing or resetting our command buffers each frame? Is this just a pedagogical exercise? Is the author of this tutorial a fraud?</p>
<p>To put these questions on hold for a bit (well maybe not the last one), a sneak preview of the next chapter is that it will involve managing multiple command buffers per frame rather than the single command buffer per frame we've been working with so far. Then it will become simpler, and probably faster, to deallocate all of these command buffers in one go by resetting the command pool instead of deallocating them individually.</p>
<p>We are going to leave the current command pool in place since it will be used for allocating command buffers during initialization. Add a field to <code>AppData</code> to hold one command pool per framebuffer and rename the existing <code>create_command_pool</code> function to <code>create_command_pools</code> to reflect its increased responsibilities.</p>
<pre><code class="language-rust noplaypen">impl App {
    unsafe fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        // ...
        create_command_pools(&amp;instance, &amp;device, &amp;mut data)?;
        // ...
    }
}

struct AppData {
    // ...
    command_pools: Vec&lt;vk::CommandPool&gt;,
    command_buffers: Vec&lt;vk::CommandBuffer&gt;,
    // ...
}

unsafe fn create_command_pools(
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;mut AppData,
) -&gt; Result&lt;()&gt; {
    // ...
}
</code></pre>
<p>Create a new <code>create_command_pool</code> function which will be used to create a command pool for short-lived command buffers that can be submitted to graphics queues.</p>
<pre><code class="language-rust noplaypen">unsafe fn create_command_pool(
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;mut AppData,
) -&gt; Result&lt;vk::CommandPool&gt; {
    let indices = QueueFamilyIndices::get(instance, data, data.physical_device)?;

    let info = vk::CommandPoolCreateInfo::builder()
        .flags(vk::CommandPoolCreateFlags::TRANSIENT)
        .queue_family_index(indices.graphics);

    Ok(device.create_command_pool(&amp;info, None)?)
}
</code></pre>
<p>With this function available, we can easily update <code>create_command_pools</code> to create both our existing global command pool and the new per-framebuffer command pools.</p>
<pre><code class="language-rust noplaypen">unsafe fn create_command_pools(
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;mut AppData,
) -&gt; Result&lt;()&gt; {
    data.command_pool = create_command_pool(instance, device, data)?;

    let num_images = data.swapchain_images.len();
    for _ in 0..num_images {
        let command_pool = create_command_pool(instance, device, data)?;
        data.command_pools.push(command_pool);
    }

    Ok(())
}
</code></pre>
<p>Now we need to create the command buffers using these new per-framebuffer command pools. Update <code>create_command_buffers</code> to use a separate call to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.allocate_command_buffers"><code class="hljs">allocate_command_buffers</code></a> for each command buffer so that each can be associated with one of the per-framebuffer command pools.</p>
<pre><code class="language-rust noplaypen">unsafe fn create_command_buffers(device: &amp;Device, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    let num_images = data.swapchain_images.len();
    for image_index in 0..num_images {
        let allocate_info = vk::CommandBufferAllocateInfo::builder()
            .command_pool(data.command_pools[image_index])
            .level(vk::CommandBufferLevel::PRIMARY)
            .command_buffer_count(1);

        let command_buffer = device.allocate_command_buffers(&amp;allocate_info)?[0];
        data.command_buffers.push(command_buffer);
    }

    Ok(())
}
</code></pre>
<p>Update <code>App::update_command_buffer</code> to reset the per-framebuffer command pool instead of freeing and reallocating the command buffer. This will also reset any command buffers created with this command pool so we don't need to do anything else to be able to reuse the command buffer.</p>
<pre><code class="language-rust noplaypen">unsafe fn update_command_buffer(&amp;mut self, image_index: usize) -&gt; Result&lt;()&gt; {
    let command_pool = self.data.command_pools[image_index];
    self.device.reset_command_pool(command_pool, vk::CommandPoolResetFlags::empty())?;

    let command_buffer = self.data.command_buffers[image_index];

    // ...
}
</code></pre>
<p>Run the program now and make sure that our new command buffer recycling strategy still produces the same result as before. If you have the validation layer enabled, you will be reminded while the program is shutting down that we are not cleaning up these new command pools. Update <code>App::destroy</code> to destroy them.</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy(&amp;mut self) {
    self.destroy_swapchain();
    self.data.command_pools
        .iter()
        .for_each(|p| self.device.destroy_command_pool(*p, None));
    // ...
}
</code></pre>
<p>Finally, delete the call to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.free_command_buffers"><code class="hljs">free_command_buffers</code></a> in <code>App::destroy_swapchain</code>. This call now incorrectly attempts to return the memory assigned to the per-framebuffer command buffers to the global command pool despite the fact that these command buffers are no longer allocated from this command pool. Leaving this code in will most likely result in our program crashing when resizing the window or otherwise forcing a recreation of the swapchain. We no longer need to manage the deletion of individual command buffers since we are now managing this at the command pool level.</p>
<h2 id="conclusion-4"><a class="header" href="#conclusion-4">Conclusion</a></h2>
<p>We've now explored the basic approaches Vulkan offers for recycling command buffers so that we can change the commands our program submits dynamically, whether in response to user input or to some other signal. These approaches can be mixed in any way you could imagine, demonstrating the power and flexibility Vulkan grants to programmers.</p>
<p>If you are feeling a bit overwhelmed about all the possible ways you could go about architecting a Vulkan program with respect to command pools and command buffers, don't worry! The next chapter is going to make things even more complicated.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secondary-command-buffers"><a class="header" href="#secondary-command-buffers">Secondary command buffers</a></h1>
<blockquote>
<p><span style="display: flex; justify-content: center; margin-bottom: 16px"><img src="dynamic/../images/i_have_no_idea_what_im_doing.jpg" width="256"></span>The previous chapters of this tutorial that are not marked by this disclaimer were directly adapted from <a href="https://github.com/Overv/VulkanTutorial">https://github.com/Overv/VulkanTutorial</a>.<br/><br/>This chapter and the following chapters are instead original creations from someone who is most decidedly not an expert in Vulkan. An authoritative tone has been maintained, but these chapters should be considered a &quot;best effort&quot; by someone still learning Vulkan.<br/><br/>If you have questions, suggestions, or corrections, please <a href="https://github.com/KyleMayes/vulkanalia/issues">open an issue</a>!</p>
</blockquote>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/32_secondary_command_buffers.rs">main.rs</a></p>
<p>While our program now submits different commands to be executed every frame, we still haven't quite accomplished our original goal of changing <em>what</em> our program renders dynamically. In this chapter we'll alter our program to support rendering between 1 and 4 instances of the model in response to user input.</p>
<p>We'll accomplish this using <em>secondary command buffers</em>, a Vulkan feature that allows us to build re-usable sequences of commands and then execute those commands from <em>primary command buffers</em>. Secondary command buffers aren't at all necessary to implement this change, but our first time rendering multiple things is a good time to introduce them.</p>
<h2 id="primary-vs-secondary"><a class="header" href="#primary-vs-secondary">Primary vs secondary</a></h2>
<p>All of the command buffers we've used thus far have been primary command buffers, meaning they can be submitted directly to a Vulkan queue to be executed by the device. Secondary command buffers are instead executed indirectly by being called from primary command buffers and may not be submitted to queues.</p>
<p>The usage of secondary command buffers offers two primary advantages:</p>
<ol>
<li>
<p>Secondary command buffers may be allocated and recorded in parallel which allows you to better leverage modern hardware with its panoply of CPU cores</p>
</li>
<li>
<p>The lifetime of secondary command buffers can managed independently of one another so you can have a mixture of long-lived or permanent secondary command buffers that intermingle with frequently updated secondary command buffers which allows you to reduce the number of command buffers you need to create every frame</p>
</li>
</ol>
<p>Both of these points are true for primary command buffers as well, but primary command buffers have a significant limitation that effectively prevents them from fulfilling these use cases. Multiple primary command buffers may not be executed within the same render pass instance meaning that if you wanted to execute multiple primary command buffers for a frame, each primary command buffer would need to start with <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_begin_render_pass"><code class="hljs">cmd_begin_render_pass</code></a> and end with <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_end_render_pass"><code class="hljs">cmd_end_render_pass</code></a>.</p>
<p>This might not sound like a big deal but beginning a render pass instance can be a pretty heavyweight operation and needing to do this many times per frame can destroy performance on some hardware. Secondary command buffers avoid this problem by being able to inherit the render pass instance as well as other state from the primary command buffer it is called from.</p>
<h2 id="multiple-model-instances"><a class="header" href="#multiple-model-instances">Multiple model instances</a></h2>
<p>Let's get started by adding a field to <code>AppData</code> that will contain our new secondary command buffers. We will have multiple secondary command buffers per frame, one for each model instance we are rendering, so this will be a list of lists.</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    command_buffers: Vec&lt;vk::CommandBuffer&gt;,
    secondary_command_buffers: Vec&lt;Vec&lt;vk::CommandBuffer&gt;&gt;,
    // ...
}
</code></pre>
<p>In an application more realistic than the one we are building, the number of secondary command buffers we need to render a frame might vary significantly over time. In addition, we likely wouldn't know the maximum number of secondary command buffers the application needs ahead of time.</p>
<p>We do know the maximum in this case, but we will pretend we don't and adopt an approach closer to what a real-world application would. Instead of allocating secondary command buffers during initialization like we allocate primary command buffers, we will allocate secondary command buffers on-demand. We'll still need to populate the outer <code>Vec</code> with empty lists of secondary command buffers so update <code>create_command_buffers</code> to accomplish this.</p>
<pre><code class="language-rust noplaypen">unsafe fn create_command_buffers(device: &amp;Device, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    // ...

    data.secondary_command_buffers = vec![vec![]; data.swapchain_images.len()];

    Ok(())
}
</code></pre>
<p>Add a new method for the <code>App</code> struct called <code>update_secondary_command_buffer</code> that we'll use to allocate (if necessary) and record a secondary command buffer for one of the 4 model instances we will be rendering. The <code>model_index</code> parameter indicates which of the 4 model instances the secondary command buffer should render.</p>
<pre><code class="language-rust noplaypen">unsafe fn update_secondary_command_buffer(
    &amp;mut self,
    image_index: usize,
    model_index: usize,
) -&gt; Result&lt;vk::CommandBuffer&gt; {
    self.data.secondary_command_buffers.resize_with(image_index + 1, Vec::new);
    let command_buffers = &amp;mut self.data.secondary_command_buffers[image_index];
    while model_index &gt;= command_buffers.len() {
        let allocate_info = vk::CommandBufferAllocateInfo::builder()
            .command_pool(self.data.command_pools[image_index])
            .level(vk::CommandBufferLevel::SECONDARY)
            .command_buffer_count(1);

        let command_buffer = self.device.allocate_command_buffers(&amp;allocate_info)?[0];
        command_buffers.push(command_buffer);
    }

    let command_buffer = command_buffers[model_index];

    let info = vk::CommandBufferBeginInfo::builder();

    self.device.begin_command_buffer(command_buffer, &amp;info)?;

    self.device.end_command_buffer(command_buffer)?;

    Ok(command_buffer)
}
</code></pre>
<p>This code will allocate secondary command buffers for the model instances as they are needed but will reuse them after their initial allocation. Like with the primary command buffers, we can freely use any previously allocated secondary command buffers because we are resetting the command pool they were allocated with.</p>
<p>Before we continue, we need to provide some additional information to Vulkan that is unique to secondary command buffers before recording this command buffer. Create an instance of <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.CommandBufferInheritanceInfo.html"><code class="hljs">vk::CommandBufferInheritanceInfo</code></a> that specifies the render pass, subpass index, and framebuffer the secondary command buffer will be used in conjunction with and then provide that inheritance info to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.begin_command_buffer"><code class="hljs">begin_command_buffer</code></a>.</p>
<pre><code class="language-rust noplaypen">let inheritance_info = vk::CommandBufferInheritanceInfo::builder()
    .render_pass(self.data.render_pass)
    .subpass(0)
    .framebuffer(self.data.framebuffers[image_index]);

let info = vk::CommandBufferBeginInfo::builder()
    .inheritance_info(&amp;inheritance_info);

self.device.begin_command_buffer(command_buffer, &amp;info)?;
</code></pre>
<p>As mentioned previously, secondary command buffers can inherit some state from the primary command buffers they are executed from. This inheritance info describes the command buffer state the secondary command buffer will be compatible with and may validly inherit.</p>
<p>The render pass and subpass index are <em>required</em> to inherit that state, but the framebuffer is only specified here as a potential performance boost. You may omit it, but Vulkan may be able to better optimize the secondary command buffer to render to the specified framebuffer.</p>
<p>This isn't enough to actually inherit the render pass, we need to also provide <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.CommandBufferUsageFlags.html#associatedconstant.RENDER_PASS_CONTINUE"><code class="hljs">vk::CommandBufferUsageFlags::RENDER_PASS_CONTINUE</code></a> to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.begin_command_buffer"><code class="hljs">begin_command_buffer</code></a>. This tells Vulkan that this secondary command buffer will be executed entirely inside a render pass.</p>
<pre><code class="language-rust noplaypen">let info = vk::CommandBufferBeginInfo::builder()
    .flags(vk::CommandBufferUsageFlags::RENDER_PASS_CONTINUE)
    .inheritance_info(&amp;inheritance_info);

self.device.begin_command_buffer(command_buffer, &amp;info)?;
</code></pre>
<p>With inheritance set up, move the code that calculates the push constant values out of <code>App::update_command_buffer</code> and into <code>App::update_secondary_command_buffer</code> after the secondary command buffer is allocated. While you're at it, have the opacity of the model instance depend on the model index to add some variety to our scene, ranging from 25% to 100%.</p>
<pre><code class="language-rust noplaypen">unsafe fn update_secondary_command_buffer(
    &amp;mut self,
    image_index: usize,
    model_index: usize,
) -&gt; Result&lt;vk::CommandBuffer&gt; {
    // ...

    let command_buffer = self.device.allocate_command_buffers(&amp;allocate_info)?[0];

    let time = self.start.elapsed().as_secs_f32();

    let model = Mat4::from_axis_angle(
        vec3(0.0, 0.0, 1.0),
        Deg(90.0) * time
    );

    let model_bytes = &amp;*slice_from_raw_parts(
        &amp;model as *const Mat4 as *const u8,
        size_of::&lt;Mat4&gt;()
    );

    let opacity = (model_index + 1) as f32 * 0.25;
    let opacity_bytes = &amp;opacity.to_ne_bytes()[..];

    // ...
}
</code></pre>
<p>Next we are going to move the rendering commands out of the primary command buffer and into the secondary command buffer. The primary command buffer will still be used to begin and end the render pass instance since it will be inherited by our secondary command buffers, but all of the commands in <code>App::update_command_buffer</code> between (but not including) <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_begin_render_pass"><code class="hljs">cmd_begin_render_pass</code></a> and <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_end_render_pass"><code class="hljs">cmd_end_render_pass</code></a> should be moved into <code>App::update_secondary_command_buffer</code>.</p>
<pre><code class="language-rust noplaypen">unsafe fn update_secondary_command_buffer(
    &amp;mut self,
    image_index: usize,
    model_index: usize,
) -&gt; Result&lt;vk::CommandBuffer&gt; {
    // ...

    self.device.begin_command_buffer(command_buffer, &amp;info)?;

    self.device.cmd_bind_pipeline(command_buffer, vk::PipelineBindPoint::GRAPHICS, self.data.pipeline);
    self.device.cmd_bind_vertex_buffers(command_buffer, 0, &amp;[self.data.vertex_buffer], &amp;[0]);
    self.device.cmd_bind_index_buffer(command_buffer, self.data.index_buffer, 0, vk::IndexType::UINT32);
    self.device.cmd_bind_descriptor_sets(
        command_buffer,
        vk::PipelineBindPoint::GRAPHICS,
        self.data.pipeline_layout,
        0,
        &amp;[self.data.descriptor_sets[image_index]],
        &amp;[],
    );
    self.device.cmd_push_constants(
        command_buffer,
        self.data.pipeline_layout,
        vk::ShaderStageFlags::VERTEX,
        0,
        model_bytes,
    );
    self.device.cmd_push_constants(
        command_buffer,
        self.data.pipeline_layout,
        vk::ShaderStageFlags::FRAGMENT,
        64,
        opacity_bytes,
    );
    self.device.cmd_draw_indexed(command_buffer, self.data.indices.len() as u32, 1, 0, 0, 0);

    self.device.end_command_buffer(command_buffer)?;

    // ...
}
</code></pre>
<p>Now that we can easily create secondary command buffers for rendering the model instance, call our new method in <code>App::update_command_buffers</code> and execute the returned secondary command buffer using <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_execute_commands"><code class="hljs">cmd_execute_commands</code></a>.</p>
<pre><code class="language-rust noplaypen">unsafe fn update_command_buffer(&amp;mut self, image_index: usize) -&gt; Result&lt;()&gt; {
    // ...

    self.device.cmd_begin_render_pass(command_buffer, &amp;info, vk::SubpassContents::INLINE);

    let secondary_command_buffer = self.update_secondary_command_buffer(image_index, 0)?;
    self.device.cmd_execute_commands(command_buffer, &amp;[secondary_command_buffer]);

    self.device.cmd_end_render_pass(command_buffer);

    // ...
}
</code></pre>
<p>This change has invalidated our call to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_begin_render_pass"><code class="hljs">cmd_begin_render_pass</code></a> because we are providing <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SubpassContents.html#associatedconstant.INLINE"><code class="hljs">vk::SubpassContents::INLINE</code></a> which indicates we will be recording rendering commands directly into the primary command buffer. Now that we've moved the rendering commands into the secondary command buffer, we need to use <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.SubpassContents.html#associatedconstant.SECONDARY_COMMAND_BUFFERS"><code class="hljs">vk::SubpassContents::SECONDARY_COMMAND_BUFFERS</code></a>.</p>
<pre><code class="language-rust noplaypen">self.device.cmd_begin_render_pass(
    command_buffer,
    &amp;info,
    vk::SubpassContents::SECONDARY_COMMAND_BUFFERS,
);
</code></pre>
<p>Note that these are mutually exclusive modes, you can't mix secondary command buffers and inline rendering commands in a render pass instance.</p>
<p>If you run the program now, you should see the same ghostly model rotating exactly as it was before. Let's kick it up a notch by rendering 4 instances of the model by creating 4 secondary command buffers and executing them all from the primary command buffer.</p>
<pre><code class="language-rust noplaypen">unsafe fn update_command_buffer(&amp;mut self, image_index: usize) -&gt; Result&lt;()&gt; {
    // ...

    self.device.cmd_begin_render_pass(command_buffer, &amp;info, vk::SubpassContents::SECONDARY_COMMAND_BUFFERS);

    let secondary_command_buffers = (0..4)
        .map(|i| self.update_secondary_command_buffer(image_index, i))
        .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?;
    self.device.cmd_execute_commands(command_buffer, &amp;secondary_command_buffers[..]);

    self.device.cmd_end_render_pass(command_buffer);

    // ...
}
</code></pre>
<p>If you run the program again, you'll see a strange shimmering as the 4 model instances, being rendered at the same coordinates, experience a bad bout of <a href="https://en.wikipedia.org/wiki/Z-fighting">z-fighting</a>.</p>
<p>Update the model matrix calculation in <code>App::update_secondary_command_buffer</code> to translate the models before rotating them according to their model index.</p>
<pre><code class="language-rust noplaypen">let y = (((model_index % 2) as f32) * 2.5) - 1.25;
let z = (((model_index / 2) as f32) * -2.0) + 1.0;

let time = self.start.elapsed().as_secs_f32();

let model = Mat4::from_translation(vec3(0.0, y, z)) * Mat4::from_axis_angle(
    vec3(0.0, 0.0, 1.0),
    Deg(90.0) * time
);
</code></pre>
<p>This code places the model instances in a grid on the Y and Z axes. However, due to the view matrix we're using, the camera is looking at this plane at 45 degree angles so let's update the view matrix in <code>App::update_uniform_buffer</code> to look directly at the YZ plane to better view our model instances.</p>
<pre><code class="language-rust noplaypen">let view = Mat4::look_at_rh(
    point3(6.0, 0.0, 2.0),
    point3(0.0, 0.0, 0.0),
    vec3(0.0, 0.0, 1.0),
);
</code></pre>
<p>With a better vantage point secured, run the program and bask in its glory.</p>
<p><img src="dynamic/../images/4_models.png" alt="" /></p>
<p>Let's knock it up a notch with a blast from our spice weasel by allowing the user to determine how many of these models they want to render. Add a <code>models</code> field to the <code>App</code> struct and initialize it to 1 in the constructor.</p>
<pre><code class="language-rust noplaypen">struct App {
    // ...
    models: usize,
}
</code></pre>
<p>Update the model index range in <code>App::update_command_buffer</code> to range from 0 to the value of the <code>models</code> field.</p>
<pre><code class="language-rust noplaypen">let secondary_command_buffers = (0..self.models)
    .map(|i| self.update_secondary_command_buffer(image_index, i))
    .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?;
</code></pre>
<p>Now that we have all this in place, we just need to increment and decrement the <code>models</code> field in response to user input. Start by importing the following <code>winit</code> types we'll need to handle keyboard input.</p>
<pre><code class="language-rust noplaypen">use winit::event::{ElementState, VirtualKeyCode};
</code></pre>
<p>Finally, add a case to the event match block in the <code>main</code> function that handles key presses and decrements <code>models</code> when the left arrow key is pressed (to a minimum of 1) and increments <code>models</code> when the right arrow key is pressed (to a maximum of 4).</p>
<pre><code class="language-rust noplaypen">match event {
    // ...
    Event::WindowEvent { event, .. } =&gt; match event {
        // ...
        WindowEvent::KeyboardInput { event, .. } =&gt; {
            if event.state == ElementState::Pressed {
                match event.physical_key {
                    PhysicalKey::Code(KeyCode::ArrowLeft) if app.models &gt; 1 =&gt; app.models -= 1,
                    PhysicalKey::Code(KeyCode::ArrowRight) if app.models &lt; 4 =&gt; app.models += 1,
                    _ =&gt; { }
                }
            }
        }
        // ...
    }
    // ...
}
</code></pre>
<p>Run the program and observe how the number of secondary command buffers we are allocating and executing each frame changes as you press the left and right arrow keys.</p>
<p><img src="dynamic/../images/3_models.png" alt="" /></p>
<p>You should now be familiar with the basic tools you can use to efficiently render dynamic frames using Vulkan. There are many ways you can utilize these tools that each have different performance tradeoffs. Future tutorial chapters may explore this more in depth, but parallelizing the work of recording secondary command buffers using multiple threads is a common technique that usually results in significant performance wins on modern hardware.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conclusion-5"><a class="header" href="#conclusion-5">Conclusion</a></h1>
<p>It has taken a lot of work to get to this point, but now you finally have a good base for a Vulkan program. The knowledge of the basic principles of Vulkan that you now possess should be sufficient to start exploring more of the features, like:</p>
<ul>
<li>Instanced rendering</li>
<li>Dynamic uniforms</li>
<li>Separate images and sampler descriptors</li>
<li>Pipeline cache</li>
<li>Multi-threaded command buffer generation</li>
<li>Multiple subpasses</li>
<li>Compute shaders</li>
</ul>
<p>The current program can be extended in many ways, like adding Blinn-Phong lighting, post-processing effects and shadow mapping. You should be able to learn how these effects work from tutorials for other APIs, because despite Vulkan's explicitness, many concepts still work the same.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>



        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
