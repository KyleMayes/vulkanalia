<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Generating mipmaps - Vulkan Tutorial (Rust)</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A Vulkan tutorial for Rust.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../overview.html"><strong aria-hidden="true">2.</strong> Overview</a></li><li class="chapter-item expanded "><a href="../development_environment.html"><strong aria-hidden="true">3.</strong> Development environment</a></li><li class="chapter-item expanded "><a href="../faq.html"><strong aria-hidden="true">4.</strong> FAQ</a></li><li class="chapter-item expanded affix "><li class="part-title">Setup</li><li class="chapter-item expanded "><a href="../setup/base_code.html"><strong aria-hidden="true">5.</strong> Base code</a></li><li class="chapter-item expanded "><a href="../setup/instance.html"><strong aria-hidden="true">6.</strong> Instance</a></li><li class="chapter-item expanded "><a href="../setup/validation_layers.html"><strong aria-hidden="true">7.</strong> Validation layers</a></li><li class="chapter-item expanded "><a href="../setup/physical_devices_and_queue_families.html"><strong aria-hidden="true">8.</strong> Physical devices and queue families</a></li><li class="chapter-item expanded "><a href="../setup/logical_device_and_queues.html"><strong aria-hidden="true">9.</strong> Logical device and queues</a></li><li class="chapter-item expanded affix "><li class="part-title">Presentation</li><li class="chapter-item expanded "><a href="../presentation/window_surface.html"><strong aria-hidden="true">10.</strong> Window surface</a></li><li class="chapter-item expanded "><a href="../presentation/swapchain.html"><strong aria-hidden="true">11.</strong> Swapchain</a></li><li class="chapter-item expanded "><a href="../presentation/image_views.html"><strong aria-hidden="true">12.</strong> Image views</a></li><li class="chapter-item expanded affix "><li class="part-title">Pipeline</li><li class="chapter-item expanded "><a href="../pipeline/introduction.html"><strong aria-hidden="true">13.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../pipeline/shader_modules.html"><strong aria-hidden="true">14.</strong> Shader modules</a></li><li class="chapter-item expanded "><a href="../pipeline/fixed_functions.html"><strong aria-hidden="true">15.</strong> Fixed functions</a></li><li class="chapter-item expanded "><a href="../pipeline/render_passes.html"><strong aria-hidden="true">16.</strong> Render passes</a></li><li class="chapter-item expanded "><a href="../pipeline/conclusion.html"><strong aria-hidden="true">17.</strong> Conclusion</a></li><li class="chapter-item expanded affix "><li class="part-title">Drawing</li><li class="chapter-item expanded "><a href="../drawing/framebuffers.html"><strong aria-hidden="true">18.</strong> Framebuffers</a></li><li class="chapter-item expanded "><a href="../drawing/command_buffers.html"><strong aria-hidden="true">19.</strong> Command buffers</a></li><li class="chapter-item expanded "><a href="../drawing/rendering_and_presentation.html"><strong aria-hidden="true">20.</strong> Rendering and presentation</a></li><li class="chapter-item expanded affix "><li class="part-title">Swapchain</li><li class="chapter-item expanded "><a href="../swapchain/recreation.html"><strong aria-hidden="true">21.</strong> Recreation</a></li><li class="chapter-item expanded affix "><li class="part-title">Vertex buffers</li><li class="chapter-item expanded "><a href="../vertex/vertex_input_description.html"><strong aria-hidden="true">22.</strong> Vertex input description</a></li><li class="chapter-item expanded "><a href="../vertex/vertex_buffer_creation.html"><strong aria-hidden="true">23.</strong> Vertex buffer creation</a></li><li class="chapter-item expanded "><a href="../vertex/staging_buffer.html"><strong aria-hidden="true">24.</strong> Staging buffer</a></li><li class="chapter-item expanded "><a href="../vertex/index_buffer.html"><strong aria-hidden="true">25.</strong> Index buffer</a></li><li class="chapter-item expanded affix "><li class="part-title">Uniform buffers</li><li class="chapter-item expanded "><a href="../uniform/descriptor_set_layout_and_buffer.html"><strong aria-hidden="true">26.</strong> Descriptor set layout and buffer</a></li><li class="chapter-item expanded "><a href="../uniform/descriptor_pool_and_sets.html"><strong aria-hidden="true">27.</strong> Descriptor pool and sets</a></li><li class="chapter-item expanded affix "><li class="part-title">Texture mapping</li><li class="chapter-item expanded "><a href="../texture/images.html"><strong aria-hidden="true">28.</strong> Images</a></li><li class="chapter-item expanded "><a href="../texture/image_view_and_sampler.html"><strong aria-hidden="true">29.</strong> Image view and sampler</a></li><li class="chapter-item expanded "><a href="../texture/combined_image_sampler.html"><strong aria-hidden="true">30.</strong> Combined image sampler</a></li><li class="chapter-item expanded affix "><li class="part-title">Model</li><li class="chapter-item expanded "><a href="../model/depth_buffering.html"><strong aria-hidden="true">31.</strong> Depth buffering</a></li><li class="chapter-item expanded "><a href="../model/loading_models.html"><strong aria-hidden="true">32.</strong> Loading models</a></li><li class="chapter-item expanded affix "><li class="part-title">Rendering quality</li><li class="chapter-item expanded "><a href="../quality/generating_mipmaps.html" class="active"><strong aria-hidden="true">33.</strong> Generating mipmaps</a></li><li class="chapter-item expanded "><a href="../quality/multisampling.html"><strong aria-hidden="true">34.</strong> Multisampling</a></li><li class="chapter-item expanded affix "><li class="part-title">Dynamic scenes</li><li class="chapter-item expanded "><a href="../dynamic/push_constants.html"><strong aria-hidden="true">35.</strong> Push constants</a></li><li class="chapter-item expanded "><a href="../dynamic/recycling_command_buffers.html"><strong aria-hidden="true">36.</strong> Recycling command buffers</a></li><li class="chapter-item expanded "><a href="../dynamic/secondary_command_buffers.html"><strong aria-hidden="true">37.</strong> Secondary command buffers</a></li><li class="chapter-item expanded affix "><li class="part-title">Conclusion</li><li class="chapter-item expanded "><a href="../conclusion.html"><strong aria-hidden="true">38.</strong> Conclusion</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Vulkan Tutorial (Rust)</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/KyleMayes/vulkanalia" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="generating-mipmaps"><a class="header" href="#generating-mipmaps">Generating mipmaps</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/28_mipmapping.rs">main.rs</a></p>
<p>Our program can now load and render 3D models. In this chapter, we will add one more feature, mipmap generation. Mipmaps are widely used in games and rendering software, and Vulkan gives us complete control over how they are created.</p>
<p>Mipmaps are precalculated, downscaled versions of an image. Each new image is half the width and height of the previous one.  Mipmaps are used as a form of <em>Level of Detail</em> or <em>LOD.</em> Objects that are far away from the camera will sample their textures from the smaller mip images. Using smaller images increases the rendering speed and avoids artifacts such as <a href="https://en.wikipedia.org/wiki/Moir%C3%A9_pattern">Moiré patterns</a>. An example of what mipmaps look like:</p>
<p><img src="../images/mipmaps_example.jpg" alt="" /></p>
<h2 id="image-creation"><a class="header" href="#image-creation">Image creation</a></h2>
<p>In Vulkan, each of the mip images is stored in different <em>mip levels</em> of a <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.Image.html"><code class="hljs">vk::Image</code></a>. Mip level 0 is the original image, and the mip levels after level 0 are commonly referred to as the <em>mip chain.</em></p>
<p>The number of mip levels is specified when the <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.Image.html"><code class="hljs">vk::Image</code></a> is created. Up until now, we have always set this value to one. We need to calculate the number of mip levels from the dimensions of the image. First, add an <code>AppData</code> field to store this number:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    mip_levels: u32,
    texture_image: vk::Image,
    // ...
}
</code></pre>
<p>The value for <code>mip_levels</code> can be found once we've loaded the texture in <code>create_texture_image</code>:</p>
<pre><code class="language-rust noplaypen">let image = File::open(&quot;resources/viking_room.png&quot;)?;

let decoder = png::Decoder::new(image);
let mut reader = decoder.read_info()?;

// ...

data.mip_levels = (width.max(height) as f32).log2().floor() as u32 + 1;
</code></pre>
<p>This calculates the number of levels in the mip chain. The <code>max</code> method selects the largest dimension. The <code>log2</code> method calculates how many times that dimension can be divided by 2. The <code>floor</code> method handles cases where the largest dimension is not a power of 2. <code>1</code> is added so that the original image has a mip level.</p>
<p>To use this value, we need to change the <code>create_image</code>, <code>create_image_view</code>, and <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/trait.DeviceV1_4.html#method.transition_image_layout"><code class="hljs">transition_image_layout</code></a> functions to allow us to specify the number of mip levels. Add a <code>mip_levels</code> parameter to the functions:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_image(
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;AppData,
    width: u32,
    height: u32,
    mip_levels: u32,
    format: vk::Format,
    tiling: vk::ImageTiling,
    usage: vk::ImageUsageFlags,
    properties: vk::MemoryPropertyFlags,
) -&gt; Result&lt;(vk::Image, vk::DeviceMemory)&gt; {
    let info = vk::ImageCreateInfo::builder()
        // ...
        .mip_levels(mip_levels)
        // ...

    // ...
}
</code></pre>
<pre><code class="language-rust noplaypen">unsafe fn create_image_view(
    device: &amp;Device,
    image: vk::Image,
    format: vk::Format,
    aspects: vk::ImageAspectFlags,
    mip_levels: u32,
) -&gt; Result&lt;vk::ImageView&gt; {
    let subresource_range = vk::ImageSubresourceRange::builder()
        // ...
        .level_count(mip_levels)
        // ...

    // ...
}
</code></pre>
<pre><code class="language-rust noplaypen">unsafe fn transition_image_layout(
    device: &amp;Device,
    data: &amp;AppData,
    image: vk::Image,
    format: vk::Format,
    old_layout: vk::ImageLayout,
    new_layout: vk::ImageLayout,
    mip_levels: u32,
) -&gt; Result&lt;()&gt; {
    // ...

    let subresource = vk::ImageSubresourceRange::builder()
        // ...
        .level_count(mip_levels)
        // ...

    // ...
}
</code></pre>
<p>Update all calls to these functions to use the right values:</p>
<blockquote>
<p>Note: Be sure to use a value of <code>1</code> for all of the images and image views except the image and image view that is for the texture.</p>
</blockquote>
<pre><code class="language-rust noplaypen">let (depth_image, depth_image_memory) = create_image(
    instance,
    device,
    data,
    data.swapchain_extent.width,
    data.swapchain_extent.height,
    1,
    format,
    vk::ImageTiling::OPTIMAL,
    vk::ImageUsageFlags::DEPTH_STENCIL_ATTACHMENT,
    vk::MemoryPropertyFlags::DEVICE_LOCAL,
)?;

// ...

let (texture_image, texture_image_memory) = create_image(
    instance,
    device,
    data,
    width,
    height,
    data.mip_levels,
    vk::Format::R8G8B8A8_SRGB,
    vk::ImageTiling::OPTIMAL,
    vk::ImageUsageFlags::SAMPLED | vk::ImageUsageFlags::TRANSFER_DST,
    vk::MemoryPropertyFlags::DEVICE_LOCAL,
)?;
</code></pre>
<pre><code class="language-rust noplaypen">create_image_view(
    device,
    *i,
    data.swapchain_format,
    vk::ImageAspectFlags::COLOR,
    1,
)

// ...

data.depth_image_view = create_image_view(
    device,
    data.depth_image,
    format,
    vk::ImageAspectFlags::DEPTH,
    1,
)?;

// ...

data.texture_image_view = create_image_view(
    device,
    data.texture_image,
    vk::Format::R8G8B8A8_SRGB,
    vk::ImageAspectFlags::COLOR,
    data.mip_levels,
)?;
</code></pre>
<pre><code class="language-rust noplaypen">transition_image_layout(
    device,
    data,
    data.texture_image,
    vk::Format::R8G8B8A8_SRGB,
    vk::ImageLayout::UNDEFINED,
    vk::ImageLayout::TRANSFER_DST_OPTIMAL,
    data.mip_levels,
)?;

// ...

transition_image_layout(
    device,
    data,
    data.texture_image,
    vk::Format::R8G8B8A8_SRGB,
    vk::ImageLayout::TRANSFER_DST_OPTIMAL,
    vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL,
    data.mip_levels,
)?;
</code></pre>
<h2 id="generating-mipmaps-1"><a class="header" href="#generating-mipmaps-1">Generating Mipmaps</a></h2>
<p>Our texture image now has multiple mip levels, but the staging buffer can only be used to fill mip level 0. The other levels are still undefined. To fill these levels we need to generate the data from the single level that we have. We will use the <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_blit_image"><code class="hljs">cmd_blit_image</code></a> command. This command performs copying, scaling, and filtering operations. We will call this multiple times to <em>blit</em> data to each level of our texture image.</p>
<p><a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_blit_image"><code class="hljs">cmd_blit_image</code></a> is considered a transfer operation, so we must inform Vulkan that we intend to use the texture image as both the source and destination of a transfer. Add <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.ImageUsageFlags.html#associatedconstant.TRANSFER_SRC"><code class="hljs">vk::ImageUsageFlags::TRANSFER_SRC</code></a> to the texture image's usage flags in <code>create_texture_image</code>:</p>
<pre><code class="language-rust noplaypen">let (texture_image, texture_image_memory) = create_image(
    instance,
    device,
    data,
    width,
    height,
    data.mip_levels,
    vk::Format::R8G8B8A8_SRGB,
    vk::ImageTiling::OPTIMAL,
    vk::ImageUsageFlags::SAMPLED
        | vk::ImageUsageFlags::TRANSFER_DST
        | vk::ImageUsageFlags::TRANSFER_SRC,
    vk::MemoryPropertyFlags::DEVICE_LOCAL,
)?;
</code></pre>
<p>Like other image operations, <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_blit_image"><code class="hljs">cmd_blit_image</code></a> depends on the layout of the image it operates on. We could transition the entire image to <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.GENERAL"><code class="hljs">vk::ImageLayout::GENERAL</code></a>, but this will most likely be slow. For optimal performance, the source image should be in <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.TRANSFER_SRC_OPTIMAL"><code class="hljs">vk::ImageLayout::TRANSFER_SRC_OPTIMAL</code></a> and the destination image should be in <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.TRANSFER_DST_OPTIMAL"><code class="hljs">vk::ImageLayout::TRANSFER_DST_OPTIMAL</code></a>. Vulkan allows us to transition each mip level of an image independently. Each blit will only deal with two mip levels at a time, so we can transition each level into the optimal layout between blits commands.</p>
<p><a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/trait.DeviceV1_4.html#method.transition_image_layout"><code class="hljs">transition_image_layout</code></a> only performs layout transitions on the entire image, so we'll need to write a few more pipeline barrier commands. Remove the existing transition to <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.SHADER_READ_ONLY_OPTIMAL"><code class="hljs">vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL</code></a> in <code>create_texture_image</code>.</p>
<p>This will leave each level of the texture image in <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.TRANSFER_DST_OPTIMAL"><code class="hljs">vk::ImageLayout::TRANSFER_DST_OPTIMAL</code></a>. Each level will be transitioned to <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.SHADER_READ_ONLY_OPTIMAL"><code class="hljs">vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL</code></a> after the blit command reading from it is finished.</p>
<p>We're now going to write the function that generates the mipmaps:</p>
<pre><code class="language-rust noplaypen">unsafe fn generate_mipmaps(
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;AppData,
    image: vk::Image,
    width: u32,
    height: u32,
    mip_levels: u32,
) -&gt; Result&lt;()&gt; {
    let command_buffer = begin_single_time_commands(device, data)?;

    let subresource = vk::ImageSubresourceRange::builder()
        .aspect_mask(vk::ImageAspectFlags::COLOR)
        .base_array_layer(0)
        .layer_count(1)
        .level_count(1);

    let mut barrier = vk::ImageMemoryBarrier::builder()
        .image(image)
        .src_queue_family_index(vk::QUEUE_FAMILY_IGNORED)
        .dst_queue_family_index(vk::QUEUE_FAMILY_IGNORED)
        .subresource_range(subresource);

    end_single_time_commands(device, data, command_buffer)?;

    Ok(())
}
</code></pre>
<p>We're going to make several transitions, so we'll reuse this <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.ImageMemoryBarrier.html"><code class="hljs">vk::ImageMemoryBarrier</code></a> (which is why it is defined as mutable). The fields set above will remain the same for all barriers. <code>subresource_range.mip_level</code>, <code>old_layout</code>, <code>new_layout</code>, <code>src_access_mask</code>, and <code>dst_access_mask</code> will be changed for each transition.</p>
<pre><code class="language-rust noplaypen">let mut mip_width = width;
let mut mip_height = height;

for i in 1..mip_levels {
}
</code></pre>
<p>This loop will record each of the <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_blit_image"><code class="hljs">cmd_blit_image</code></a> commands. Note that the range index starts at 1, not 0.</p>
<pre><code class="language-rust noplaypen">barrier.subresource_range.base_mip_level = i - 1;
barrier.old_layout = vk::ImageLayout::TRANSFER_DST_OPTIMAL;
barrier.new_layout = vk::ImageLayout::TRANSFER_SRC_OPTIMAL;
barrier.src_access_mask = vk::AccessFlags::TRANSFER_WRITE;
barrier.dst_access_mask = vk::AccessFlags::TRANSFER_READ;

device.cmd_pipeline_barrier(
    command_buffer,
    vk::PipelineStageFlags::TRANSFER,
    vk::PipelineStageFlags::TRANSFER,
    vk::DependencyFlags::empty(),
    &amp;[] as &amp;[vk::MemoryBarrier],
    &amp;[] as &amp;[vk::BufferMemoryBarrier],
    &amp;[barrier],
);
</code></pre>
<p>First, we transition level <code>i - 1</code> to <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.TRANSFER_SRC_OPTIMAL"><code class="hljs">vk::ImageLayout::TRANSFER_SRC_OPTIMAL</code></a>. This transition will wait for level <code>i - 1</code> to be filled, either from the previous blit command, or from <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_copy_buffer_to_image"><code class="hljs">cmd_copy_buffer_to_image</code></a>. The current blit command will wait on this transition.</p>
<pre><code class="language-rust noplaypen">let src_subresource = vk::ImageSubresourceLayers::builder()
    .aspect_mask(vk::ImageAspectFlags::COLOR)
    .mip_level(i - 1)
    .base_array_layer(0)
    .layer_count(1);

let dst_subresource = vk::ImageSubresourceLayers::builder()
    .aspect_mask(vk::ImageAspectFlags::COLOR)
    .mip_level(i)
    .base_array_layer(0)
    .layer_count(1);

let blit = vk::ImageBlit::builder()
    .src_offsets([
        vk::Offset3D { x: 0, y: 0, z: 0 },
        vk::Offset3D {
            x: mip_width as i32,
            y: mip_height as i32,
            z: 1,
        },
    ])
    .src_subresource(src_subresource)
    .dst_offsets([
        vk::Offset3D { x: 0, y: 0, z: 0 },
        vk::Offset3D {
            x: (if mip_width &gt; 1 { mip_width / 2 } else { 1 }) as i32,
            y: (if mip_height &gt; 1 { mip_height / 2 } else { 1 }) as i32,
            z: 1,
        },
    ])
    .dst_subresource(dst_subresource);
</code></pre>
<p>Next, we specify the regions that will be used in the blit operation. The source mip level is <code>i - 1</code> and the destination mip level is <code>i</code>. The two elements of the <code>src_offsets</code> array determine the 3D region that data will be blitted from. <code>dst_offsets</code> determines the region that data will be blitted to. The X and Y dimensions of the <code>dst_offsets[1]</code> are divided by two since each mip level is half the size of the previous level. The Z dimension of <code>src_offsets[1]</code> and <code>dst_offsets[1]</code> must be 1, since a 2D image has a depth of 1.</p>
<pre><code class="language-rust noplaypen">device.cmd_blit_image(
    command_buffer,
    image,
    vk::ImageLayout::TRANSFER_SRC_OPTIMAL,
    image,
    vk::ImageLayout::TRANSFER_DST_OPTIMAL,
    &amp;[blit],
    vk::Filter::LINEAR,
);
</code></pre>
<p>Now, we record the blit command. Note that <code>image</code> is used for both the <code>stc_image</code> and <code>dst_image</code> parameters. This is because we're blitting between different levels of the same image. The source mip level was just transitioned to <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.TRANSFER_SRC_OPTIMAL"><code class="hljs">vk::ImageLayout::TRANSFER_SRC_OPTIMAL</code></a> and the destination level is still in <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.TRANSFER_DST_OPTIMAL"><code class="hljs">vk::ImageLayout::TRANSFER_DST_OPTIMAL</code></a> from <code>create_texture_image</code>.</p>
<p>Beware if you are using a dedicated transfer queue (as suggested in the <code>Vertex buffers</code> chapter): <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_blit_image"><code class="hljs">cmd_blit_image</code></a> must be submitted to a queue with graphics capability.</p>
<p>The last parameter allows us to specify a <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.Filter.html"><code class="hljs">vk::Filter</code></a> to use in the blit. We have the same filtering options here that we had when making the <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.Sampler.html"><code class="hljs">vk::Sampler</code></a>. We use the <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.Filter.html#associatedconstant.LINEAR"><code class="hljs">vk::Filter::LINEAR</code></a> to enable interpolation.</p>
<pre><code class="language-rust noplaypen">barrier.old_layout = vk::ImageLayout::TRANSFER_SRC_OPTIMAL;
barrier.new_layout = vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL;
barrier.src_access_mask = vk::AccessFlags::TRANSFER_READ;
barrier.dst_access_mask = vk::AccessFlags::SHADER_READ;

device.cmd_pipeline_barrier(
    command_buffer,
    vk::PipelineStageFlags::TRANSFER,
    vk::PipelineStageFlags::FRAGMENT_SHADER,
    vk::DependencyFlags::empty(),
    &amp;[] as &amp;[vk::MemoryBarrier],
    &amp;[] as &amp;[vk::BufferMemoryBarrier],
    &amp;[barrier],
);
</code></pre>
<p>This barrier transitions mip level <code>i - 1</code> to <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.SHADER_READ_ONLY_OPTIMAL"><code class="hljs">vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL</code></a>. This transition waits on the current blit command to finish. All sampling operations will wait on this transition to finish.</p>
<pre><code class="language-rust noplaypen">if mip_width &gt; 1 {
    mip_width /= 2;
}

if mip_height &gt; 1 {
    mip_height /= 2;
}
</code></pre>
<p>At the end of the loop, we divide the current mip dimensions by two. We check each dimension before the division to ensure that dimension never becomes 0. This handles cases where the image is not square, since one of the mip dimensions would reach 1 before the other dimension. When this happens, that dimension should remain 1 for all remaining levels.</p>
<pre><code class="language-rust noplaypen">barrier.subresource_range.base_mip_level = mip_levels - 1;
barrier.old_layout = vk::ImageLayout::TRANSFER_DST_OPTIMAL;
barrier.new_layout = vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL;
barrier.src_access_mask = vk::AccessFlags::TRANSFER_WRITE;
barrier.dst_access_mask = vk::AccessFlags::SHADER_READ;

device.cmd_pipeline_barrier(
    command_buffer,
    vk::PipelineStageFlags::TRANSFER,
    vk::PipelineStageFlags::FRAGMENT_SHADER,
    vk::DependencyFlags::empty(),
    &amp;[] as &amp;[vk::MemoryBarrier],
    &amp;[] as &amp;[vk::BufferMemoryBarrier],
    &amp;[barrier],
);

end_single_time_commands(device, data, command_buffer)?;
</code></pre>
<p>Before we end the command buffer, we insert one more pipeline barrier. This barrier transitions the last mip level from <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.TRANSFER_DST_OPTIMAL"><code class="hljs">vk::ImageLayout::TRANSFER_DST_OPTIMAL</code></a> to <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.SHADER_READ_ONLY_OPTIMAL"><code class="hljs">vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL</code></a>. This wasn't handled by the loop, since the last mip level is never blitted from.</p>
<p>Finally, add the call to <code>generate_mipmaps</code> at the end of <code>create_texture_image</code>:</p>
<pre><code class="language-rust noplaypen">generate_mipmaps(
    instance,
    device,
    data,
    data.texture_image,
    width,
    height,
    data.mip_levels,
)?;
</code></pre>
<p>Our texture image's mipmaps are now completely filled.</p>
<h2 id="linear-filtering-support"><a class="header" href="#linear-filtering-support">Linear filtering support</a></h2>
<p>It is very convenient to use a built-in command like <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_blit_image"><code class="hljs">cmd_blit_image</code></a> to generate all the mip levels, but unfortunately it is not guaranteed to be supported on all platforms. It requires the texture image format we use to support linear filtering, which can be checked with the <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/trait.InstanceV1_0.html#method.get_physical_device_format_properties"><code class="hljs">get_physical_device_format_properties</code></a> command. We will add a check to the <code>generate_mipmaps</code> function for this.</p>
<p>First add an additional parameter that specifies the image format:</p>
<pre><code class="language-rust noplaypen">generate_mipmaps(
    instance,
    device,
    data,
    data.texture_image,
    vk::Format::R8G8B8A8_SRGB,
    width,
    height,
    data.mip_levels,
)?;

// ...

unsafe fn generate_mipmaps(
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;AppData,
    image: vk::Image,
    format: vk::Format,
    width: u32,
    height: u32,
    mip_levels: u32,
) -&gt; Result&lt;()&gt; {
    // ...
}
</code></pre>
<p>In the <code>generate_mipmaps</code> function, use <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/trait.InstanceV1_0.html#method.get_physical_device_format_properties"><code class="hljs">get_physical_device_format_properties</code></a> to request the properties of the texture image format and check that linear filtering is supported:</p>
<pre><code class="language-rust noplaypen">if !instance
    .get_physical_device_format_properties(data.physical_device, format)
    .optimal_tiling_features
    .contains(vk::FormatFeatureFlags::SAMPLED_IMAGE_FILTER_LINEAR)
{
    return Err(anyhow!(&quot;Texture image format does not support linear blitting!&quot;));
}
</code></pre>
<p>The <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.FormatProperties.html"><code class="hljs">vk::FormatProperties</code></a> struct has three fields named <code>linear_tiling_features</code>, <code>optimal_tiling_features</code>, and <code>buffer_features</code> that each describe how the format can be used depending on the way it is used. We create a texture image with the optimal tiling format, so we need to check <code>optimal_tiling_features</code>. Support for the linear filtering feature can be checked with <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.FormatFeatureFlags.html#associatedconstant.SAMPLED_IMAGE_FILTER_LINEAR"><code class="hljs">vk::FormatFeatureFlags::SAMPLED_IMAGE_FILTER_LINEAR</code></a>.</p>
<p>There are two alternatives in the case where this is not supported. You could implement a function that searches common texture image formats for one that <em>does</em> support linear blitting, or you could implement the mipmap generation in your software. Each mip level can then be loaded into the image in the same way that you loaded the original image.</p>
<p>It should be noted that it is uncommon in practice to generate the mipmap levels at runtime anyway. Usually they are pregenerated and stored in the texture file alongside the base level to improve loading speed. Implementing resizing in software and loading multiple levels from a file is left as an exercise to the reader.</p>
<h2 id="sampler"><a class="header" href="#sampler">Sampler</a></h2>
<p>While the <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.Image.html"><code class="hljs">vk::Image</code></a> holds the mipmap data, <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.Sampler.html"><code class="hljs">vk::Sampler</code></a> controls how that data is read while rendering. Vulkan allows us to specify <code>min_lod</code>, <code>max_lod</code>, <code>mip_lod_bias</code>, and <code>mipmap_mode</code> (&quot;LOD&quot; means &quot;Level of Detail&quot;). When a texture is sampled, the sampler selects a mip level according to the following pseudocode:</p>
<pre><code class="language-rust noplaypen">// Smaller when the object is close, may be negative.
let mut lod = get_lod_level_from_screen_size();

lod = clamp(lod + mip_lod_bias, min_lod, max_lod);

// Clamped to the number of mip levels in the texture.
let level = clamp(floor(lod), 0, texture.mip_levels - 1);

let color = if mipmap_mode == vk::SamplerMipmapMode::NEAREST {
    sample(level)
} else {
    blend(sample(level), sample(level + 1))
};
</code></pre>
<p>If <code>sampler_info.mipmap_mode</code> is <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.SamplerMipmapMode.html#associatedconstant.NEAREST"><code class="hljs">vk::SamplerMipmapMode::NEAREST</code></a>, <code>lod</code> selects the mip level to sample from. If the mipmap mode is <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.SamplerMipmapMode.html#associatedconstant.LINEAR"><code class="hljs">vk::SamplerMipmapMode::LINEAR</code></a>, <code>lod</code> is used to select two mip levels to be sampled. Those levels are sampled and the results are linearly blended.</p>
<p>The sample operation is also affected by <code>lod</code>:</p>
<pre><code class="language-rust noplaypen">let color = if lod &lt;= 0 {
    read_texture(uv, mag_filter)
} else {
    read_texture(uv, min_filter)
};
</code></pre>
<p>If the object is close to the camera, <code>mag_filter</code> is used as the filter. If the object is further from the camera, <code>min_filter</code> is used. Normally, <code>lod</code> is non-negative, and is only 0 when close the camera. <code>mip_lod_bias</code> lets us force Vulkan to use lower <code>lod</code> and <code>level</code> than it would normally use.</p>
<p>To see the results of this chapter, we need to choose values for our <code>texture_sampler</code>. We've already set the <code>min_filter</code> and <code>mag_filter</code> to use <a href="https://docs.rs/vulkanalia/0.30.0/vulkanalia/vk/struct.Filter.html#associatedconstant.LINEAR"><code class="hljs">vk::Filter::LINEAR</code></a>. We just need to choose values for <code>min_lod</code>, <code>max_lod</code>, <code>mip_lod_bias</code>, and <code>mipmap_mode</code>.</p>
<pre><code class="language-rust noplaypen">unsafe fn create_texture_sampler(device: &amp;Device, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    let info = vk::SamplerCreateInfo::builder()
        // ...
        .mipmap_mode(vk::SamplerMipmapMode::LINEAR)
        .min_lod(0.0)       // Optional.
        .max_lod(data.mip_levels as f32)
        .mip_lod_bias(0.0); // Optional.

    data.texture_sampler = device.create_sampler(&amp;info, None)?;

    Ok(())
}
</code></pre>
<p>To allow the full range of mip levels to be used, we set <code>min_lod</code> to <code>0.0</code> and <code>max_lod</code> to the number of mip levels. We have no reason to change the <code>lod</code> value, so we set <code>mip_lod_bias</code> to 0.0f.</p>
<p>Now run your program and you should see the following:</p>
<p><img src="../images/mipmaps.png" alt="" /></p>
<p>It's not a dramatic difference, since our scene is so simple. There are subtle differences if you look closely (it will be much easier to spot differences if you open the below image in a separate tab so you can see it at full size).</p>
<p><img src="../images/mipmaps_comparison.png" alt="" /></p>
<p>One of most noticeable differences is the axe head. With mipmaps, the borders between the dark gray and light gray areas have been smoothed. Without mipmaps, these borders are much sharper. The differences are clear in this image which shows the axe head with and without mipmapping at 8x magnification (without any filtering so the pixels are simply expanded).</p>
<p><img src="../images/mipmaps_comparison_axe.png" alt="" /></p>
<p>You can play around with the sampler settings to see how they affect mipmapping. For example, by changing <code>min_lod</code>, you can force the sampler to not use the lowest mip levels:</p>
<pre><code class="language-rust noplaypen">.min_lod(data.mip_levels as f32 / 2.0)
</code></pre>
<p>These settings will produce this image:</p>
<p><img src="../images/highmipmaps.png" alt="" /></p>
<p>This is how higher mip levels will be used when objects are further away from the camera.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../model/loading_models.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../quality/multisampling.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../model/loading_models.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../quality/multisampling.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>



        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
