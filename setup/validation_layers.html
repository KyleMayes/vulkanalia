<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Validation layers - Vulkan Tutorial (Rust)</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A Vulkan tutorial for Rust.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../overview.html"><strong aria-hidden="true">2.</strong> Overview</a></li><li class="chapter-item expanded "><a href="../development_environment.html"><strong aria-hidden="true">3.</strong> Development environment</a></li><li class="chapter-item expanded "><a href="../faq.html"><strong aria-hidden="true">4.</strong> FAQ</a></li><li class="chapter-item expanded affix "><li class="part-title">Setup</li><li class="chapter-item expanded "><a href="../setup/base_code.html"><strong aria-hidden="true">5.</strong> Base code</a></li><li class="chapter-item expanded "><a href="../setup/instance.html"><strong aria-hidden="true">6.</strong> Instance</a></li><li class="chapter-item expanded "><a href="../setup/validation_layers.html" class="active"><strong aria-hidden="true">7.</strong> Validation layers</a></li><li class="chapter-item expanded "><a href="../setup/physical_devices_and_queue_families.html"><strong aria-hidden="true">8.</strong> Physical devices and queue families</a></li><li class="chapter-item expanded "><a href="../setup/logical_device_and_queues.html"><strong aria-hidden="true">9.</strong> Logical device and queues</a></li><li class="chapter-item expanded affix "><li class="part-title">Presentation</li><li class="chapter-item expanded "><a href="../presentation/window_surface.html"><strong aria-hidden="true">10.</strong> Window surface</a></li><li class="chapter-item expanded "><a href="../presentation/swapchain.html"><strong aria-hidden="true">11.</strong> Swapchain</a></li><li class="chapter-item expanded "><a href="../presentation/image_views.html"><strong aria-hidden="true">12.</strong> Image views</a></li><li class="chapter-item expanded affix "><li class="part-title">Pipeline</li><li class="chapter-item expanded "><a href="../pipeline/introduction.html"><strong aria-hidden="true">13.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../pipeline/shader_modules.html"><strong aria-hidden="true">14.</strong> Shader modules</a></li><li class="chapter-item expanded "><a href="../pipeline/fixed_functions.html"><strong aria-hidden="true">15.</strong> Fixed functions</a></li><li class="chapter-item expanded "><a href="../pipeline/render_passes.html"><strong aria-hidden="true">16.</strong> Render passes</a></li><li class="chapter-item expanded "><a href="../pipeline/conclusion.html"><strong aria-hidden="true">17.</strong> Conclusion</a></li><li class="chapter-item expanded affix "><li class="part-title">Drawing</li><li class="chapter-item expanded "><a href="../drawing/framebuffers.html"><strong aria-hidden="true">18.</strong> Framebuffers</a></li><li class="chapter-item expanded "><a href="../drawing/command_buffers.html"><strong aria-hidden="true">19.</strong> Command buffers</a></li><li class="chapter-item expanded "><a href="../drawing/rendering_and_presentation.html"><strong aria-hidden="true">20.</strong> Rendering and presentation</a></li><li class="chapter-item expanded affix "><li class="part-title">Swapchain</li><li class="chapter-item expanded "><a href="../swapchain/recreation.html"><strong aria-hidden="true">21.</strong> Recreation</a></li><li class="chapter-item expanded affix "><li class="part-title">Vertex buffers</li><li class="chapter-item expanded "><a href="../vertex/vertex_input_description.html"><strong aria-hidden="true">22.</strong> Vertex input description</a></li><li class="chapter-item expanded "><a href="../vertex/vertex_buffer_creation.html"><strong aria-hidden="true">23.</strong> Vertex buffer creation</a></li><li class="chapter-item expanded "><a href="../vertex/staging_buffer.html"><strong aria-hidden="true">24.</strong> Staging buffer</a></li><li class="chapter-item expanded "><a href="../vertex/index_buffer.html"><strong aria-hidden="true">25.</strong> Index buffer</a></li><li class="chapter-item expanded affix "><li class="part-title">Uniform buffers</li><li class="chapter-item expanded "><a href="../uniform/descriptor_set_layout_and_buffer.html"><strong aria-hidden="true">26.</strong> Descriptor set layout and buffer</a></li><li class="chapter-item expanded "><a href="../uniform/descriptor_pool_and_sets.html"><strong aria-hidden="true">27.</strong> Descriptor pool and sets</a></li><li class="chapter-item expanded affix "><li class="part-title">Texture mapping</li><li class="chapter-item expanded "><a href="../texture/images.html"><strong aria-hidden="true">28.</strong> Images</a></li><li class="chapter-item expanded "><a href="../texture/image_view_and_sampler.html"><strong aria-hidden="true">29.</strong> Image view and sampler</a></li><li class="chapter-item expanded "><a href="../texture/combined_image_sampler.html"><strong aria-hidden="true">30.</strong> Combined image sampler</a></li><li class="chapter-item expanded affix "><li class="part-title">Model</li><li class="chapter-item expanded "><a href="../model/depth_buffering.html"><strong aria-hidden="true">31.</strong> Depth buffering</a></li><li class="chapter-item expanded "><a href="../model/loading_models.html"><strong aria-hidden="true">32.</strong> Loading models</a></li><li class="chapter-item expanded affix "><li class="part-title">Rendering quality</li><li class="chapter-item expanded "><a href="../quality/generating_mipmaps.html"><strong aria-hidden="true">33.</strong> Generating mipmaps</a></li><li class="chapter-item expanded "><a href="../quality/multisampling.html"><strong aria-hidden="true">34.</strong> Multisampling</a></li><li class="chapter-item expanded affix "><li class="part-title">Dynamic scenes</li><li class="chapter-item expanded "><a href="../dynamic/push_constants.html"><strong aria-hidden="true">35.</strong> Push constants</a></li><li class="chapter-item expanded "><a href="../dynamic/recycling_command_buffers.html"><strong aria-hidden="true">36.</strong> Recycling command buffers</a></li><li class="chapter-item expanded "><a href="../dynamic/secondary_command_buffers.html"><strong aria-hidden="true">37.</strong> Secondary command buffers</a></li><li class="chapter-item expanded affix "><li class="part-title">Conclusion</li><li class="chapter-item expanded "><a href="../conclusion.html"><strong aria-hidden="true">38.</strong> Conclusion</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Vulkan Tutorial (Rust)</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/KyleMayes/vulkanalia" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="validation-layers"><a class="header" href="#validation-layers">Validation layers</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/02_validation_layers.rs">main.rs</a></p>
<p>The Vulkan API is designed around the idea of minimal driver overhead and one of the manifestations of that goal is that there is very limited error checking in the API by default. Even mistakes as simple as setting enumerations to incorrect values are generally not explicitly handled and will simply result in crashes or undefined behavior. Because Vulkan requires you to be very explicit about everything you're doing, it's easy to make many small mistakes like using a new GPU feature and forgetting to request it at logical device creation time.</p>
<p>However, that doesn't mean that these checks can't be added to the API. Vulkan introduces an elegant system for this known as validation layers. Validation layers are optional components that hook into Vulkan function calls to apply additional operations. Common operations in validation layers are:</p>
<ul>
<li>Checking the values of parameters against the specification to detect misuse</li>
<li>Tracking creation and destruction of objects to find resource leaks</li>
<li>Checking thread safety by tracking the threads that calls originate from</li>
<li>Logging every call and its parameters to the standard output</li>
<li>Tracing Vulkan calls for profiling and replaying</li>
</ul>
<p>Here's an example of what the implementation of a function in a diagnostics validation layer could look like (in C):</p>
<pre><code class="language-c">VkResult vkCreateInstance(
    const VkInstanceCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkInstance* instance
) {
    if (pCreateInfo == nullptr || instance == nullptr) {
        log(&quot;Null pointer passed to required parameter!&quot;);
        return VK_ERROR_INITIALIZATION_FAILED;
    }

    return real_vkCreateInstance(pCreateInfo, pAllocator, instance);
}
</code></pre>
<p>These validation layers can be freely stacked to include all the debugging functionality that you're interested in. You can simply enable validation layers for debug builds and completely disable them for release builds, which gives you the best of both worlds!</p>
<p>Vulkan does not come with any validation layers built-in, but the LunarG Vulkan SDK provides a nice set of layers that check for common errors. They're also completely <a href="https://github.com/KhronosGroup/Vulkan-ValidationLayers">open source</a>, so you can check which kind of mistakes they check for and contribute. Using the validation layers is the best way to avoid your application breaking on different drivers by accidentally relying on undefined behavior.</p>
<p>Validation layers can only be used if they have been installed onto the system. For example, the LunarG validation layers are only available on PCs with the Vulkan SDK installed.</p>
<p>There were formerly two different types of validation layers in Vulkan: instance and device specific. The idea was that instance layers would only check calls related to global Vulkan objects like instances, and device specific layers would only check calls related to a specific GPU. Device specific layers have now been deprecated, which means that instance validation layers apply to all Vulkan calls. The specification document still recommends that you enable validation layers at device level as well for compatibility, which is required by some implementations. We'll simply specify the same layers as the instance at logical device level, which we'll see later on.</p>
<p>Before we get started, we'll need some new imports for this chapter:</p>
<pre><code class="language-rust noplaypen">use std::collections::HashSet;
use std::ffi::CStr;
use std::os::raw::c_void;

// Note: This trait was called `ExtDebugUtilsExtension` in versions of `vulkanalia` prior to `v0.31.0`.
use vulkanalia::vk::ExtDebugUtilsExtensionInstanceCommands;
</code></pre>
<p><code>HashSet</code> will be used for storing and querying supported layers and the other imports will be used in the function we will be writing to log messages from the validation layer with the exception of <code>vk::ExtDebugUtilsExtensionInstanceCommands</code> which provides the command wrappers for managing debugging functionality.</p>
<h2 id="using-validation-layers"><a class="header" href="#using-validation-layers">Using validation layers</a></h2>
<p>In this section we'll see how to enable the standard diagnostics layers provided by the Vulkan SDK. Just like extensions, validation layers need to be enabled by specifying their name. All of the useful standard validation is bundled into a layer included in the SDK that is known as <code>VK_LAYER_KHRONOS_validation</code>.</p>
<p>Let's first add two configuration variables to the program to specify the layers to enable and whether to enable them or not. I've chosen to base that value on whether the program is being compiled in debug mode or not.</p>
<pre><code class="language-rust noplaypen">const VALIDATION_ENABLED: bool =
    cfg!(debug_assertions);

const VALIDATION_LAYER: vk::ExtensionName =
    vk::ExtensionName::from_bytes(b&quot;VK_LAYER_KHRONOS_validation&quot;);
</code></pre>
<p>We'll add some new code to our <code>create_instance</code> function that collects the supported instance layers into a <code>HashSet</code>, checks that the validation layer is available, and creates a list of layer names containing the validation layer. This code should go right below where the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ApplicationInfo.html"><code class="hljs">vk::ApplicationInfo</code></a> struct is built:</p>
<pre><code class="language-rust noplaypen">let available_layers = entry
    .enumerate_instance_layer_properties()?
    .iter()
    .map(|l| l.layer_name)
    .collect::&lt;HashSet&lt;_&gt;&gt;();

if VALIDATION_ENABLED &amp;&amp; !available_layers.contains(&amp;VALIDATION_LAYER) {
    return Err(anyhow!(&quot;Validation layer requested but not supported.&quot;));
}

let layers = if VALIDATION_ENABLED {
    vec![VALIDATION_LAYER.as_ptr()]
} else {
    Vec::new()
};
</code></pre>
<p>Then you'll need to specify the requested layers in <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.InstanceCreateInfo.html"><code class="hljs">vk::InstanceCreateInfo</code></a> by adding a call to the <code>enabled_layer_names</code> builder method:</p>
<pre><code class="language-rust noplaypen">let info = vk::InstanceCreateInfo::builder()
    .application_info(&amp;application_info)
    .enabled_layer_names(&amp;layers)
    .enabled_extension_names(&amp;extensions)
    .flags(flags);
</code></pre>
<p>Now run the program in debug mode and ensure that the <code>Validation layer requested but not supported.</code> error does not occur. If it does, then have a look at the FAQ. If you get past that check, then <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.EntryV1_0.html#method.create_instance"><code class="hljs">create_instance</code></a> should never return a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ErrorCode.html#associatedconstant.LAYER_NOT_PRESENT"><code class="hljs">vk::ErrorCode::LAYER_NOT_PRESENT</code></a> error code but you should still run the program to be sure.</p>
<h2 id="message-callback"><a class="header" href="#message-callback">Message callback</a></h2>
<p>The validation layers will print debug messages to the standard output by default, but we can also handle them ourselves by providing an explicit callback in our program. This will also allow you to decide which kind of messages you would like to see, because not all are necessarily (fatal) errors. If you don't want to do that right now then you may skip to the last section in this chapter.</p>
<p>To set up a callback in the program to handle messages and the associated details, we have to set up a debug messenger with a callback using the <a href="https://www.khronos.org/registry/vulkan/specs/latest/man/html/VK_EXT_debug_utils.html"><code class="hljs">VK_EXT_debug_utils</code></a> extension.</p>
<p>We'll add some more code to our <code>create_instance</code> function. This time we'll modify the <code>extensions</code> list to be mutable and then add the debug utilities extension to the list when the validation layer is enabled:</p>
<pre><code class="language-rust noplaypen">let mut extensions = vk_window::get_required_instance_extensions(window)
    .iter()
    .map(|e| e.as_ptr())
    .collect::&lt;Vec&lt;_&gt;&gt;();

if VALIDATION_ENABLED {
    extensions.push(vk::EXT_DEBUG_UTILS_EXTENSION.name.as_ptr());
}
</code></pre>
<p><code>vulkanalia</code> provides a collection of metadata for each Vulkan extension. In this case we just need the name of the extension to load, so we add the value of the <code>name</code> field of the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/constant.EXT_DEBUG_UTILS_EXTENSION.html"><code class="hljs">vk::EXT_DEBUG_UTILS_EXTENSION</code></a> struct constant to our list of desired extension names.</p>
<p>Run the program to make sure you don't receive a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ErrorCode.html#associatedconstant.EXTENSION_NOT_PRESENT"><code class="hljs">vk::ErrorCode::EXTENSION_NOT_PRESENT</code></a> error code. We don't really need to check for the existence of this extension, because it should be implied by the availability of the validation layers.</p>
<p>Now let's see what a debug callback function looks like. Add a new <code>extern &quot;system&quot;</code> function called <code>debug_callback</code> that matches the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/type.PFN_vkDebugUtilsMessengerCallbackEXT.html"><code class="hljs">vk::PFN_vkDebugUtilsMessengerCallbackEXT</code></a> prototype. The <code>extern &quot;system&quot;</code> is necessary to allow Vulkan to call our Rust function.</p>
<pre><code class="language-rust noplaypen">extern &quot;system&quot; fn debug_callback(
    severity: vk::DebugUtilsMessageSeverityFlagsEXT,
    type_: vk::DebugUtilsMessageTypeFlagsEXT,
    data: *const vk::DebugUtilsMessengerCallbackDataEXT,
    _: *mut c_void,
) -&gt; vk::Bool32 {
    let data = unsafe { *data };
    let message = unsafe { CStr::from_ptr(data.message) }.to_string_lossy();

    if severity &gt;= vk::DebugUtilsMessageSeverityFlagsEXT::ERROR {
        error!(&quot;({:?}) {}&quot;, type_, message);
    } else if severity &gt;= vk::DebugUtilsMessageSeverityFlagsEXT::WARNING {
        warn!(&quot;({:?}) {}&quot;, type_, message);
    } else if severity &gt;= vk::DebugUtilsMessageSeverityFlagsEXT::INFO {
        debug!(&quot;({:?}) {}&quot;, type_, message);
    } else {
        trace!(&quot;({:?}) {}&quot;, type_, message);
    }

    vk::FALSE
}
</code></pre>
<p>The first parameter specifies the severity of the message, which is one of the following flags:</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DebugUtilsMessageSeverityFlagsEXT.html#associatedconstant.VERBOSE"><code class="hljs">vk::DebugUtilsMessageSeverityFlagsEXT::VERBOSE</code></a> – Diagnostic message</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DebugUtilsMessageSeverityFlagsEXT.html#associatedconstant.INFO"><code class="hljs">vk::DebugUtilsMessageSeverityFlagsEXT::INFO</code></a> – Informational message like the creation of a resource</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DebugUtilsMessageSeverityFlagsEXT.html#associatedconstant.WARNING"><code class="hljs">vk::DebugUtilsMessageSeverityFlagsEXT::WARNING</code></a> – Message about behavior that is not necessarily an error, but very likely a bug in your application</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DebugUtilsMessageSeverityFlagsEXT.html#associatedconstant.ERROR"><code class="hljs">vk::DebugUtilsMessageSeverityFlagsEXT::ERROR</code></a> – Message about behavior that is invalid and may cause crashes</li>
</ul>
<p>The values of this enumeration are set up in such a way that you can use a comparison operation to check if a message is equal or worse compared to some level of severity which we use here to decide on which <code>log</code> macro is appropriate to use when logging the message.</p>
<p>The <code>type_</code> parameter can have the following values:</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DebugUtilsMessageTypeFlagsEXT.html#associatedconstant.GENERAL"><code class="hljs">vk::DebugUtilsMessageTypeFlagsEXT::GENERAL</code></a> – Some event has happened that is unrelated to the specification or performance</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DebugUtilsMessageTypeFlagsEXT.html#associatedconstant.VALIDATION"><code class="hljs">vk::DebugUtilsMessageTypeFlagsEXT::VALIDATION</code></a> – Something has happened that violates the specification or indicates a possible mistake</li>
<li><a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DebugUtilsMessageTypeFlagsEXT.html#associatedconstant.PERFORMANCE"><code class="hljs">vk::DebugUtilsMessageTypeFlagsEXT::PERFORMANCE</code></a> – Potential non-optimal use of Vulkan</li>
</ul>
<p>The <code>data</code> parameter refers to a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DebugUtilsMessengerCallbackDataEXT.html"><code class="hljs">vk::DebugUtilsMessengerCallbackDataEXT</code></a> struct containing the details of the message itself, with the most important members being:</p>
<ul>
<li><code>message</code> – The debug message as a null-terminated string (<code>*const c_char</code>)</li>
<li><code>objects</code> – Array of Vulkan object handles related to the message</li>
<li><code>object_count</code> – Number of objects in array</li>
</ul>
<p>Finally, the last parameter, here ignored as <code>_</code>, contains a pointer that was specified during the setup of the callback and allows you to pass your own data to it.</p>
<p>The callback returns a (Vulkan) boolean that indicates if the Vulkan call that triggered the validation layer message should be aborted. If the callback returns true, then the call is aborted with the <code>vk::ErrorCode::VALIDATION_FAILED_EXT</code> error code. This is normally only used to test the validation layers themselves, so you should always return <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/constant.FALSE.html"><code class="hljs">vk::FALSE</code></a>.</p>
<p>All that remains now is telling Vulkan about the callback function. Perhaps somewhat surprisingly, even the debug callback in Vulkan is managed with a handle that needs to be explicitly created and destroyed. Such a callback is part of a debug messenger and you can have as many of them as you want. Add a field to the <code>AppData</code> struct:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    messenger: vk::DebugUtilsMessengerEXT,
}
</code></pre>
<p>Now modify the signature and end of the <code>create_instance</code> function to look like this:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_instance(
    window: &amp;Window,
    entry: &amp;Entry,
    data: &amp;mut AppData
) -&gt; Result&lt;Instance&gt; {
    // ...

    let instance = entry.create_instance(&amp;info, None)?;

    if VALIDATION_ENABLED {
        let debug_info = vk::DebugUtilsMessengerCreateInfoEXT::builder()
            .message_severity(vk::DebugUtilsMessageSeverityFlagsEXT::all())
            .message_type(
                vk::DebugUtilsMessageTypeFlagsEXT::GENERAL
                    | vk::DebugUtilsMessageTypeFlagsEXT::VALIDATION
                    | vk::DebugUtilsMessageTypeFlagsEXT::PERFORMANCE,
            )
            .user_callback(Some(debug_callback));

        data.messenger = instance.create_debug_utils_messenger_ext(&amp;debug_info, None)?;
    }

    Ok(instance)
}
</code></pre>
<blockquote>
<p><strong>Note:</strong> Calling the <code>all</code> static method on a set of Vulkan flags (e.g., <code>vk::DebugUtilsMessageSeverityFlagsEXT::all()</code> as in the above code) will, as the name implies, return a set of flags containing all of the flags of that type known by <code>vulkanalia</code>. A complete set of flags may contain flags that are only valid when certain extensions are enabled or flags added by a newer version of Vulkan than the one you are using/targeting.</p>
<p>In the above code we've explicitly listed the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DebugUtilsMessageTypeFlagsEXT.html"><code class="hljs">vk::DebugUtilsMessageTypeFlagsEXT</code></a> flags we want because that set of flags contains a flag (<a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DebugUtilsMessageTypeFlagsEXT.html#associatedconstant.DEVICE_ADDRESS_BINDING"><code class="hljs">vk::DebugUtilsMessageTypeFlagsEXT::DEVICE_ADDRESS_BINDING</code></a>) that is only valid when <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_device_address_binding_report.html">a certain extension is enabled</a>.</p>
<p>In most cases using unsupported flags shouldn't cause any errors or changes in the behavior of your application, but it definitely will result in validation errors if you have the validation layers enabled (as we are aiming to do in this chapter).</p>
</blockquote>
<p>We have first extracted our Vulkan instance out of the return expression so we can use it to add our debug callback.</p>
<p>Then we construct a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DebugUtilsMessengerCreateInfoEXT.html"><code class="hljs">vk::DebugUtilsMessengerCreateInfoEXT</code></a> struct which provides information about our debug callback and how it will be called.</p>
<p>The <code>message_severity</code> field allows you to specify all the types of severities you would like your callback to be called for. I've requested that messages of all severity be included. This would normally produce a lot of verbose general debug info but we can filter that out using a log level when we are not interested in it.</p>
<p>Similarly the <code>message_type</code> field lets you filter which types of messages your callback is notified about. I've simply enabled all types here. You can always disable some if they're not useful to you.</p>
<p>Finally, the <code>user_callback</code> field specifies the callback function. You can optionally pass a mutable reference to the <code>user_data</code> field which will be passed along to the callback function via the final parameter. You could use this to pass a pointer to the <code>AppData</code> struct, for example.</p>
<p>Lastly we call <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.ExtDebugUtilsExtension.html#method.create_debug_utils_messenger_ext"><code class="hljs">create_debug_utils_messenger_ext</code></a> to register our debug callback with the Vulkan instance.</p>
<p>Since our <code>create_instance</code> function takes an <code>AppData</code> reference now, we'll also need to update <code>App</code> and <code>App::create</code>:</p>
<blockquote>
<p><strong>Note:</strong> <code>AppData::default()</code> will use the implementation of the <a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code> trait</a> generated by the presence of <code>#[derive(Default)]</code> on the <code>AppData</code> struct. This will result in containers like <code>Vec</code> being initialized to empty lists and Vulkan handles like <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DebugUtilsMessengerEXT.html"><code class="hljs">vk::DebugUtilsMessengerEXT</code></a> being initialized to null handles. If Vulkan handles are not initialized properly before they are used, the validation layers we are enabling in this chapter should let us know exactly what we missed.</p>
</blockquote>
<pre><code class="language-rust noplaypen">struct App {
    entry: Entry,
    instance: Instance,
    data: AppData,
}

impl App {
    unsafe fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        // ...
        let mut data = AppData::default();
        let instance = create_instance(window, &amp;entry, &amp;mut data)?;
        Ok(Self { entry, instance, data })
    }
}
</code></pre>
<p>The <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DebugUtilsMessengerEXT.html"><code class="hljs">vk::DebugUtilsMessengerEXT</code></a> object we created needs to cleaned up before our app exits. We'll do this in <code>App::destroy</code> before we destroy the instance:</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy(&amp;mut self) {
    if VALIDATION_ENABLED {
        self.instance.destroy_debug_utils_messenger_ext(self.data.messenger, None);
    }

    self.instance.destroy_instance(None);
}
</code></pre>
<h2 id="debugging-instance-creation-and-destruction"><a class="header" href="#debugging-instance-creation-and-destruction">Debugging instance creation and destruction</a></h2>
<p>Although we've now added debugging with validation layers to the program we're not covering everything quite yet. The <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.ExtDebugUtilsExtension.html#method.create_debug_utils_messenger_ext"><code class="hljs">create_debug_utils_messenger_ext</code></a> call requires a valid instance to have been created and <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.ExtDebugUtilsExtension.html#method.destroy_debug_utils_messenger_ext"><code class="hljs">destroy_debug_utils_messenger_ext</code></a> must be called before the instance is destroyed. This currently leaves us unable to debug any issues in the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.EntryV1_0.html#method.create_instance"><code class="hljs">create_instance</code></a> and <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.InstanceV1_0.html#method.destroy_instance"><code class="hljs">destroy_instance</code></a> calls.</p>
<p>However, if you closely read the <a href="https://github.com/KhronosGroup/Vulkan-Docs/blob/77d9f42e075e6a483a37351c14c5e9e3122f9113/appendices/VK_EXT_debug_utils.txt#L84-L91">extension documentation</a>, you'll see that there is a way to create a separate debug utils messenger specifically for those two function calls. It requires you to simply pass a pointer to a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DebugUtilsMessengerCreateInfoEXT.html"><code class="hljs">vk::DebugUtilsMessengerCreateInfoEXT</code></a> struct in the <code>next</code> extension field of <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.InstanceCreateInfo.html"><code class="hljs">vk::InstanceCreateInfo</code></a>. Before we do this, let's first discuss how extending structs works in Vulkan.</p>
<p>The <code>s_type</code> field that is present on many Vulkan structs was briefly mentioned in the <a href="../overview.html#builders">Builders section</a> of the Overview chapter. It was said that this field must be set to the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.StructureType.html"><code class="hljs">vk::StructureType</code></a> variant indicating the type of the struct (e.g., <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.StructureType.html#associatedconstant.APPLICATION_INFO"><code class="hljs">vk::StructureType::APPLICATION_INFO</code></a> for a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.ApplicationInfo.html"><code class="hljs">vk::ApplicationInfo</code></a> struct).</p>
<p>You may have wondered what the purpose of this field is: doesn't Vulkan already know the type of structs passed to its commands? The purpose of this field is wrapped up with the purpose of the <code>next</code> field that always accompanies the <code>s_type</code> field in Vulkan structs: the ability to <em>extend</em> a Vulkan struct with other Vulkan structs.</p>
<p>The <code>next</code> field in a Vulkan struct may be used to specify a <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#fundamentals-validusage-pNext">structure pointer chain</a>. <code>next</code> can be either be null or a pointer to a Vulkan struct that is permitted by Vulkan to extend the struct. Each struct in this chain of structs is used to provide additional information to the Vulkan command the root structure is passed to. This feature of Vulkan allows for extending the functionality of Vulkan commands without breaking backwards compabilitity.</p>
<p>When you pass such a chain of structs to a Vulkan command, it must iterate through the structs to collect all of the information from the structs. Because of this, Vulkan can't know the type of each structure in the chain, hence the need for the <code>s_type</code> field.</p>
<p>The builders provided by <code>vulkanalia</code> allow for easily building these pointer chains in a type-safe manner. For example, take a look at the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.InstanceCreateInfoBuilder.html"><code class="hljs">vk::InstanceCreateInfoBuilder</code></a> builder, specifically the <code>push_next</code> method. This method allows adding any Vulkan struct for which the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.ExtendsInstanceCreateInfo.html"><code class="hljs">vk::ExtendsInstanceCreateInfo</code></a> trait is implemented for to the pointer chain for a <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.InstanceCreateInfo.html"><code class="hljs">vk::InstanceCreateInfo</code></a>.</p>
<p>One such struct is <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DebugUtilsMessengerCreateInfoEXT.html"><code class="hljs">vk::DebugUtilsMessengerCreateInfoEXT</code></a>, which we will now use to extend our <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.InstanceCreateInfo.html"><code class="hljs">vk::InstanceCreateInfo</code></a> struct to set up our debug callback. To do this we'll continue to modify our <code>create_instance</code> function. This time we'll make the <code>info</code> struct mutable so we can modify its pointer chain before moving the <code>debug_info</code> struct, now also mutable, below it so we can push it onto <code>info</code>'s pointer chain:</p>
<pre><code class="language-rust noplaypen">let mut info = vk::InstanceCreateInfo::builder()
    .application_info(&amp;application_info)
    .enabled_layer_names(&amp;layers)
    .enabled_extension_names(&amp;extensions)
    .flags(flags);

let mut debug_info = vk::DebugUtilsMessengerCreateInfoEXT::builder()
    .message_severity(vk::DebugUtilsMessageSeverityFlagsEXT::all())
    .message_type(
        vk::DebugUtilsMessageTypeFlagsEXT::GENERAL
            | vk::DebugUtilsMessageTypeFlagsEXT::VALIDATION
            | vk::DebugUtilsMessageTypeFlagsEXT::PERFORMANCE,
    )
    .user_callback(Some(debug_callback));

if VALIDATION_ENABLED {
    info = info.push_next(&amp;mut debug_info);
}
</code></pre>
<blockquote>
<p><strong>Note:</strong> It might seem redundant to use the same debug info with the same severity, type, and callback to both call <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.ExtDebugUtilsExtension.html#method.create_debug_utils_messenger_ext"><code class="hljs">create_debug_utils_messenger_ext</code></a> <em>and</em> add as an extension to the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.InstanceCreateInfo.html"><code class="hljs">vk::InstanceCreateInfo</code></a> instance. However, these two usages serve different purposes. The usage here (adding the debug info to <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.InstanceCreateInfo.html"><code class="hljs">vk::InstanceCreateInfo</code></a>) sets up debugging <em>during the creation and destruction of the instance</em>. Calling <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.ExtDebugUtilsExtension.html#method.create_debug_utils_messenger_ext"><code class="hljs">create_debug_utils_messenger_ext</code></a> sets up persistent debugging for <em>everything else</em>. See the paragraph starting &quot;To capture events that occur while creating or destroying an instance&quot; in the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap4.html#VkInstanceCreateInfo">relevant chapter of the Vulkan specification</a>.</p>
</blockquote>
<p><code>debug_info</code> needs to be defined outside of the conditional since it needs to live until we are done calling <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/trait.EntryV1_0.html#method.create_instance"><code class="hljs">create_instance</code></a>. Fortunately we can rely on the Rust compiler to protect us from pushing a struct that doesn't live long enough onto a pointer chain due to the lifetimes defined for the <code>vulkanalia</code> builders.</p>
<p>Now we should be able to run our program and see logs from our debug callback, but first we'll need to set the <code>RUST_LOG</code> environment variable so that <code>pretty_env_logger</code> will enable the log levels we are interested in. Initially set the log level to <code>debug</code> so we can be sure it is working, here is an example on Windows (PowerShell):</p>
<p><img src="../images/validation_layer_test.png" alt="" /></p>
<p>If everything is working you shouldn't see any warning or error messages. Going forward you will probably want to increase the minimum log level to <code>info</code> using <code>RUST_LOG</code> to reduce the verbosity of the logs unless you are trying to debug an error.</p>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>There are a lot more settings for the behavior of validation layers than just the flags specified in the <a href="https://docs.rs/vulkanalia/0.34.0/vulkanalia/vk/struct.DebugUtilsMessengerCreateInfoEXT.html"><code class="hljs">vk::DebugUtilsMessengerCreateInfoEXT</code></a> struct. Browse to the Vulkan SDK and go to the <code>Config</code> directory. There you will find a <code>vk_layer_settings.txt</code> file that explains how to configure the layers.</p>
<p>To configure the layer settings for your own application, copy the file to the working directory of your project's executable and follow the instructions to set the desired behavior. However, for the remainder of this tutorial I'll assume that you're using the default settings.</p>
<p>Throughout this tutorial I'll be making a couple of intentional mistakes to show you how helpful the validation layers are with catching them and to teach you how important it is to know exactly what you're doing with Vulkan. Now it's time to look at Vulkan devices in the system.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../setup/instance.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../setup/physical_devices_and_queue_families.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../setup/instance.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../setup/physical_devices_and_queue_families.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>



        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
