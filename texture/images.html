<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Images - Vulkan Tutorial (Rust)</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A Vulkan tutorial for Rust.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../overview.html"><strong aria-hidden="true">2.</strong> Overview</a></li><li class="chapter-item expanded "><a href="../development_environment.html"><strong aria-hidden="true">3.</strong> Development environment</a></li><li class="chapter-item expanded "><a href="../faq.html"><strong aria-hidden="true">4.</strong> FAQ</a></li><li class="chapter-item expanded affix "><li class="part-title">Setup</li><li class="chapter-item expanded "><a href="../setup/base_code.html"><strong aria-hidden="true">5.</strong> Base code</a></li><li class="chapter-item expanded "><a href="../setup/instance.html"><strong aria-hidden="true">6.</strong> Instance</a></li><li class="chapter-item expanded "><a href="../setup/validation_layers.html"><strong aria-hidden="true">7.</strong> Validation layers</a></li><li class="chapter-item expanded "><a href="../setup/physical_devices_and_queue_families.html"><strong aria-hidden="true">8.</strong> Physical devices and queue families</a></li><li class="chapter-item expanded "><a href="../setup/logical_device_and_queues.html"><strong aria-hidden="true">9.</strong> Logical device and queues</a></li><li class="chapter-item expanded affix "><li class="part-title">Presentation</li><li class="chapter-item expanded "><a href="../presentation/window_surface.html"><strong aria-hidden="true">10.</strong> Window surface</a></li><li class="chapter-item expanded "><a href="../presentation/swapchain.html"><strong aria-hidden="true">11.</strong> Swapchain</a></li><li class="chapter-item expanded "><a href="../presentation/image_views.html"><strong aria-hidden="true">12.</strong> Image views</a></li><li class="chapter-item expanded affix "><li class="part-title">Pipeline</li><li class="chapter-item expanded "><a href="../pipeline/introduction.html"><strong aria-hidden="true">13.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../pipeline/shader_modules.html"><strong aria-hidden="true">14.</strong> Shader modules</a></li><li class="chapter-item expanded "><a href="../pipeline/fixed_functions.html"><strong aria-hidden="true">15.</strong> Fixed functions</a></li><li class="chapter-item expanded "><a href="../pipeline/render_passes.html"><strong aria-hidden="true">16.</strong> Render passes</a></li><li class="chapter-item expanded "><a href="../pipeline/conclusion.html"><strong aria-hidden="true">17.</strong> Conclusion</a></li><li class="chapter-item expanded affix "><li class="part-title">Drawing</li><li class="chapter-item expanded "><a href="../drawing/framebuffers.html"><strong aria-hidden="true">18.</strong> Framebuffers</a></li><li class="chapter-item expanded "><a href="../drawing/command_buffers.html"><strong aria-hidden="true">19.</strong> Command buffers</a></li><li class="chapter-item expanded "><a href="../drawing/rendering_and_presentation.html"><strong aria-hidden="true">20.</strong> Rendering and presentation</a></li><li class="chapter-item expanded affix "><li class="part-title">Swapchain</li><li class="chapter-item expanded "><a href="../swapchain/recreation.html"><strong aria-hidden="true">21.</strong> Recreation</a></li><li class="chapter-item expanded affix "><li class="part-title">Vertex buffers</li><li class="chapter-item expanded "><a href="../vertex/vertex_input_description.html"><strong aria-hidden="true">22.</strong> Vertex input description</a></li><li class="chapter-item expanded "><a href="../vertex/vertex_buffer_creation.html"><strong aria-hidden="true">23.</strong> Vertex buffer creation</a></li><li class="chapter-item expanded "><a href="../vertex/staging_buffer.html"><strong aria-hidden="true">24.</strong> Staging buffer</a></li><li class="chapter-item expanded "><a href="../vertex/index_buffer.html"><strong aria-hidden="true">25.</strong> Index buffer</a></li><li class="chapter-item expanded affix "><li class="part-title">Uniform buffers</li><li class="chapter-item expanded "><a href="../uniform/descriptor_set_layout_and_buffer.html"><strong aria-hidden="true">26.</strong> Descriptor set layout and buffer</a></li><li class="chapter-item expanded "><a href="../uniform/descriptor_pool_and_sets.html"><strong aria-hidden="true">27.</strong> Descriptor pool and sets</a></li><li class="chapter-item expanded affix "><li class="part-title">Texture mapping</li><li class="chapter-item expanded "><a href="../texture/images.html" class="active"><strong aria-hidden="true">28.</strong> Images</a></li><li class="chapter-item expanded "><a href="../texture/image_view_and_sampler.html"><strong aria-hidden="true">29.</strong> Image view and sampler</a></li><li class="chapter-item expanded "><a href="../texture/combined_image_sampler.html"><strong aria-hidden="true">30.</strong> Combined image sampler</a></li><li class="chapter-item expanded affix "><li class="part-title">Model</li><li class="chapter-item expanded "><a href="../model/depth_buffering.html"><strong aria-hidden="true">31.</strong> Depth buffering</a></li><li class="chapter-item expanded "><a href="../model/loading_models.html"><strong aria-hidden="true">32.</strong> Loading models</a></li><li class="chapter-item expanded affix "><li class="part-title">Rendering quality</li><li class="chapter-item expanded "><a href="../quality/generating_mipmaps.html"><strong aria-hidden="true">33.</strong> Generating mipmaps</a></li><li class="chapter-item expanded "><a href="../quality/multisampling.html"><strong aria-hidden="true">34.</strong> Multisampling</a></li><li class="chapter-item expanded affix "><li class="part-title">Dynamic scenes</li><li class="chapter-item expanded "><a href="../dynamic/push_constants.html"><strong aria-hidden="true">35.</strong> Push constants</a></li><li class="chapter-item expanded "><a href="../dynamic/recycling_command_buffers.html"><strong aria-hidden="true">36.</strong> Recycling command buffers</a></li><li class="chapter-item expanded "><a href="../dynamic/secondary_command_buffers.html"><strong aria-hidden="true">37.</strong> Secondary command buffers</a></li><li class="chapter-item expanded affix "><li class="part-title">Conclusion</li><li class="chapter-item expanded "><a href="../conclusion.html"><strong aria-hidden="true">38.</strong> Conclusion</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Vulkan Tutorial (Rust)</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/KyleMayes/vulkanalia" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="images"><a class="header" href="#images">Images</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/23_texture_image.rs">main.rs</a></p>
<p>The geometry has been colored using per-vertex colors so far, which is a rather limited approach. In this part of the tutorial we're going to implement texture mapping to make the geometry look more interesting. This will also allow us to load and draw basic 3D models in a future chapter.</p>
<p>Adding a texture to our application will involve the following steps:</p>
<ul>
<li>Create an image object backed by device memory</li>
<li>Fill it with pixels from an image file</li>
<li>Create an image sampler</li>
<li>Add a combined image sampler descriptor to sample colors from the texture</li>
</ul>
<p>We've already worked with image objects before, but those were automatically created by the swapchain extension. This time we'll have to create one by ourselves. Creating an image and filling it with data is similar to vertex buffer creation. We'll start by creating a staging resource and filling it with pixel data and then we copy this to the final image object that we'll use for rendering. Although it is possible to create a staging image for this purpose, Vulkan also allows you to copy pixels from a <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.Buffer.html"><code class="hljs">vk::Buffer</code></a> to an image and the API for this is actually <a href="https://developer.nvidia.com/vulkan-memory-management">faster on some hardware</a>. We'll first create this buffer and fill it with pixel values, and then we'll create an image to copy the pixels to. Creating an image is not very different from creating buffers. It involves querying the memory requirements, allocating device memory and binding it, just like we've seen before.</p>
<p>However, there is something extra that we'll have to take care of when working with images. Images can have different <em>layouts</em> that affect how the pixels are organized in memory. Due to the way graphics hardware works, simply storing the pixels row by row may not lead to the best performance, for example. When performing any operation on images, you must make sure that they have the layout that is optimal for use in that operation. We've actually already seen some of these layouts when we specified the render pass:</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.PRESENT_SRC_KHR"><code class="hljs">vk::ImageLayout::PRESENT_SRC_KHR</code></a> – Optimal for presentation </li>
<li><a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.COLOR_ATTACHMENT_OPTIMAL"><code class="hljs">vk::ImageLayout::COLOR_ATTACHMENT_OPTIMAL</code></a> – Optimal as attachment for writing colors from the fragment shader </li>
<li><a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.TRANSFER_SRC_OPTIMAL"><code class="hljs">vk::ImageLayout::TRANSFER_SRC_OPTIMAL</code></a> – Optimal as source in a transfer operation, like <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_copy_image_to_buffer"><code class="hljs">cmd_copy_image_to_buffer</code></a> </li>
<li><a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.TRANSFER_DST_OPTIMAL"><code class="hljs">vk::ImageLayout::TRANSFER_DST_OPTIMAL</code></a> – Optimal as destination in a transfer operation, like <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_copy_buffer_to_image"><code class="hljs">cmd_copy_buffer_to_image</code></a> </li>
<li><a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.SHADER_READ_ONLY_OPTIMAL"><code class="hljs">vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL</code></a> – Optimal for sampling from a shader </li>
</ul>
<p>One of the most common ways to transition the layout of an image is a <em>pipeline barrier</em>. Pipeline barriers are primarily used for synchronizing access to resources, like making sure that an image was written to before it is read, but they can also be used to transition layouts. In this chapter we'll see how pipeline barriers are used for this purpose. Barriers can additionally be used to transfer queue family ownership when using <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.SharingMode.html#associatedconstant.EXCLUSIVE"><code class="hljs">vk::SharingMode::EXCLUSIVE</code></a>.</p>
<h2 id="image-library"><a class="header" href="#image-library">Image library</a></h2>
<p>There are many libraries available for loading images, and you can even write your own code to load simple formats like BMP and PPM. In this tutorial we'll be using the <a href="https://crates.io/crates/png"><code>png</code></a> crate which you should have already added to your program's dependencies.</p>
<h2 id="loading-an-image"><a class="header" href="#loading-an-image">Loading an image</a></h2>
<p>We'll need to open the image file, so add the following import:</p>
<pre><code class="language-rust noplaypen">use std::fs::File;
</code></pre>
<p>Create a new function <code>create_texture_image</code> where we'll load an image and upload it into a Vulkan image object. We're going to use command buffers, so it should be called after <code>create_command_pool</code>.</p>
<pre><code class="language-rust noplaypen">impl App {
    unsafe fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        // ...
        create_command_pool(&amp;instance, &amp;device, &amp;mut data)?;
        create_texture_image(&amp;instance, &amp;device, &amp;mut data)?;
        // ...
    }
}

unsafe fn create_texture_image(
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;mut AppData,
) -&gt; Result&lt;()&gt; {
    Ok(())
}
</code></pre>
<p>Create a new directory <code>resources</code> next to the <code>shaders</code> directory to store texture images in. We're going to load an image called <code>texture.png</code> from that directory. I've chosen to use the following <a href="https://pixabay.com/en/statue-sculpture-fig-historically-1275469/">CC0 licensed image</a> resized to 512 x 512 pixels, but feel free to pick any PNG image (with an alpha channel) you want.</p>
<p><img src="../images/texture.png" alt="" /></p>
<p>Loading an image with this library is really easy:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_texture_image(
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;mut AppData,
) -&gt; Result&lt;()&gt; {
    let image = File::open(&quot;resources/texture.png&quot;)?;

    let decoder = png::Decoder::new(image);
    let mut reader = decoder.read_info()?;

    let mut pixels = vec![0;  reader.info().raw_bytes()];
    reader.next_frame(&amp;mut pixels)?;

    let size = reader.info().raw_bytes() as u64;
    let (width, height) = reader.info().size();

    Ok(())
}
</code></pre>
<p>This code will populate the <code>pixels</code> list with the pixels data with 4 bytes per pixel which will result in a total of <code>width * height * 4</code> values. Note that the <code>png</code> crate <a href="https://github.com/image-rs/image-png/issues/239">does not have support for converting RGB images into RGBA images (at the time of writing)</a> and the following code is expecting the pixel data to have an alpha channel. As a result you will need to make sure you use PNG images with alpha channels (such as the above image).</p>
<h2 id="staging-buffer"><a class="header" href="#staging-buffer">Staging buffer</a></h2>
<p>We're now going to create a buffer in host visible memory so that we can use <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/trait.DeviceV1_0.html#method.map_memory"><code class="hljs">map_memory</code></a> and copy the pixels to it. The buffer should be in host visible memory so that we can map it and it should be usable as a transfer source so that we can copy it to an image later on:</p>
<pre><code class="language-rust noplaypen">let (staging_buffer, staging_buffer_memory) = create_buffer(
    instance,
    device,
    data,
    size,
    vk::BufferUsageFlags::TRANSFER_SRC,
    vk::MemoryPropertyFlags::HOST_COHERENT | vk::MemoryPropertyFlags::HOST_VISIBLE,
)?;
</code></pre>
<p>We can then directly copy the pixel values that we got from the image loading library to the buffer:</p>
<pre><code class="language-rust noplaypen">let memory = device.map_memory(
    staging_buffer_memory,
    0,
    size,
    vk::MemoryMapFlags::empty(),
)?;

memcpy(pixels.as_ptr(), memory.cast(), pixels.len());

device.unmap_memory(staging_buffer_memory);
</code></pre>
<h2 id="texture-image"><a class="header" href="#texture-image">Texture Image</a></h2>
<p>Although we could set up the shader to access the pixel values in the buffer, it's better to use image objects in Vulkan for this purpose. Image objects will make it easier and faster to retrieve colors by allowing us to use 2D coordinates, for one. Pixels within an image object are known as texels and we'll use that name from this point on. Add the following new <code>AppData</code> fields:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    texture_image: vk::Image,
    texture_image_memory: vk::DeviceMemory,
}
</code></pre>
<p>The parameters for an image are specified in a <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.ImageCreateInfo.html"><code class="hljs">vk::ImageCreateInfo</code></a> struct:</p>
<pre><code class="language-rust noplaypen">let info = vk::ImageCreateInfo::builder()
    .image_type(vk::ImageType::_2D)
    .extent(vk::Extent3D { width, height, depth: 1 })
    .mip_levels(1)
    .array_layers(1)
    // continued...
</code></pre>
<p>The image type, specified in the <code>image_type</code> field, tells Vulkan with what kind of coordinate system the texels in the image are going to be addressed. It is possible to create 1D, 2D and 3D images. One dimensional images can be used to store an array of data or gradient, two dimensional images are mainly used for textures, and three dimensional images can be used to store voxel volumes, for example. The <code>extent</code> field specifies the dimensions of the image, basically how many texels there are on each axis. That's why <code>depth</code> must be <code>1</code> instead of <code>0</code>. Our texture will not be an array and we won't be using mipmapping for now.</p>
<pre><code class="language-rust noplaypen">    .format(vk::Format::R8G8B8A8_SRGB)
</code></pre>
<p>Vulkan supports many possible image formats, but we should use the same format for the texels as the pixels in the buffer, otherwise the copy operation will fail.</p>
<pre><code class="language-rust noplaypen">    .tiling(vk::ImageTiling::OPTIMAL)
</code></pre>
<p>The <code>tiling</code> field can have one of two values:</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.ImageTiling.html#associatedconstant.LINEAR"><code class="hljs">vk::ImageTiling::LINEAR</code></a> – Texels are laid out in row-major order like our <code>pixels</code> array</li>
<li><a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.ImageTiling.html#associatedconstant.OPTIMAL"><code class="hljs">vk::ImageTiling::OPTIMAL</code></a> – Texels are laid out in an implementation defined order for optimal access</li>
</ul>
<p>Unlike the layout of an image, the tiling mode cannot be changed at a later time. If you want to be able to directly access texels in the memory of the image, then you must use <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.ImageTiling.html#associatedconstant.LINEAR"><code class="hljs">vk::ImageTiling::LINEAR</code></a>. We will be using a staging buffer instead of a staging image, so this won't be necessary. We will be using <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.ImageTiling.html#associatedconstant.OPTIMAL"><code class="hljs">vk::ImageTiling::OPTIMAL</code></a> for efficient access from the shader.</p>
<pre><code class="language-rust noplaypen">    .initial_layout(vk::ImageLayout::UNDEFINED)
</code></pre>
<p>There are only two possible values for the <code>initial_layout</code> of an image:</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.UNDEFINED"><code class="hljs">vk::ImageLayout::UNDEFINED</code></a> – Not usable by the GPU and the very first transition will discard the texels.</li>
<li><a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.PREINITIALIZED"><code class="hljs">vk::ImageLayout::PREINITIALIZED</code></a> – Not usable by the GPU, but the first transition will preserve the texels.</li>
</ul>
<p>There are few situations where it is necessary for the texels to be preserved during the first transition. One example, however, would be if you wanted to use an image as a staging image in combination with the <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.ImageTiling.html#associatedconstant.LINEAR"><code class="hljs">vk::ImageTiling::LINEAR</code></a> layout. In that case, you'd want to upload the texel data to it and then transition the image to be a transfer source without losing the data. In our case, however, we're first going to transition the image to be a transfer destination and then copy texel data to it from a buffer object, so we don't need this property and can safely use <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.UNDEFINED"><code class="hljs">vk::ImageLayout::UNDEFINED</code></a>.</p>
<pre><code class="language-rust noplaypen">    .usage(vk::ImageUsageFlags::SAMPLED | vk::ImageUsageFlags::TRANSFER_DST)
</code></pre>
<p>The <code>usage</code> field has the same semantics as the one during buffer creation. The image is going to be used as destination for the buffer copy, so it should be set up as a transfer destination. We also want to be able to access the image from the shader to color our mesh, so the usage should include <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.ImageUsageFlags.html#associatedconstant.SAMPLED"><code class="hljs">vk::ImageUsageFlags::SAMPLED</code></a>.</p>
<pre><code class="language-rust noplaypen">    .sharing_mode(vk::SharingMode::EXCLUSIVE)
</code></pre>
<p>The image will only be used by one queue family: the one that supports graphics (and therefore also) transfer operations.</p>
<pre><code class="language-rust noplaypen">    .samples(vk::SampleCountFlags::_1)
</code></pre>
<p>The <code>samples</code> flag is related to multisampling. This is only relevant for images that will be used as attachments, so stick to one sample. </p>
<pre><code class="language-rust noplaypen">    .flags(vk::ImageCreateFlags::empty()); // Optional.
</code></pre>
<p>There are also some optional flags for images that allow controlling more advanced properties for things like sparse images. Sparse images are images where only certain regions are actually backed by memory. If you were using a 3D texture for a voxel terrain, for example, then you could use this to avoid allocating memory to store large volumes of &quot;air&quot; values. We won't be using it in this tutorial, so you can omit the builder method for this field which will set it to the default (an empty set of flags).</p>
<pre><code class="language-c++">data.texture_image = device.create_image(&amp;info, None)?;
</code></pre>
<p>The image is created using <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/trait.DeviceV1_0.html#method.create_image"><code class="hljs">create_image</code></a>, which doesn't have any particularly noteworthy parameters. It is possible that the <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.Format.html#associatedconstant.R8G8B8A8_SRGB"><code class="hljs">vk::Format::R8G8B8A8_SRGB</code></a> format is not supported by the graphics hardware. You should have a list of acceptable alternatives and go with the best one that is supported. However, support for this particular format is so widespread that we'll skip this step. Using different formats would also require annoying conversions. We will get back to this in the depth buffer chapter, where we'll implement such a system.</p>
<pre><code class="language-rust noplaypen">let requirements = device.get_image_memory_requirements(data.texture_image);

let info = vk::MemoryAllocateInfo::builder()
    .allocation_size(requirements.size)
    .memory_type_index(get_memory_type_index(
        instance,
        data,
        vk::MemoryPropertyFlags::DEVICE_LOCAL,
        requirements,
    )?);

data.texture_image_memory = device.allocate_memory(&amp;info, None)?;

device.bind_image_memory(data.texture_image, data.texture_image_memory, 0)?;
</code></pre>
<p>Allocating memory for an image works in exactly the same way as allocating memory for a buffer. Use <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/trait.DeviceV1_0.html#method.get_image_memory_requirements"><code class="hljs">get_image_memory_requirements</code></a> instead of <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/trait.DeviceV1_0.html#method.get_buffer_memory_requirements"><code class="hljs">get_buffer_memory_requirements</code></a>, and use <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/trait.DeviceV1_0.html#method.bind_image_memory"><code class="hljs">bind_image_memory</code></a> instead of <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/trait.DeviceV1_0.html#method.bind_buffer_memory"><code class="hljs">bind_buffer_memory</code></a>.</p>
<p>This function is already getting quite large and there'll be a need to create more images in later chapters, so we should abstract image creation into a <code>create_image</code> function, like we did for buffers. Create the function and move the image object creation and memory allocation to it:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_image(
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;AppData,
    width: u32,
    height: u32,
    format: vk::Format,
    tiling: vk::ImageTiling,
    usage: vk::ImageUsageFlags,
    properties: vk::MemoryPropertyFlags,
) -&gt; Result&lt;(vk::Image, vk::DeviceMemory)&gt; {
    let info = vk::ImageCreateInfo::builder()
        .image_type(vk::ImageType::_2D)
        .extent(vk::Extent3D {
            width,
            height,
            depth: 1,
        })
        .mip_levels(1)
        .array_layers(1)
        .format(format)
        .tiling(tiling)
        .initial_layout(vk::ImageLayout::UNDEFINED)
        .usage(usage)
        .samples(vk::SampleCountFlags::_1)
        .sharing_mode(vk::SharingMode::EXCLUSIVE);

    let image = device.create_image(&amp;info, None)?;

    let requirements = device.get_image_memory_requirements(image);

    let info = vk::MemoryAllocateInfo::builder()
        .allocation_size(requirements.size)
        .memory_type_index(get_memory_type_index(
            instance,
            data,
            properties,
            requirements,
        )?);

    let image_memory = device.allocate_memory(&amp;info, None)?;

    device.bind_image_memory(image, image_memory, 0)?;

    Ok((image, image_memory))
}
</code></pre>
<p>I've made the width, height, format, tiling mode, usage, and memory properties parameters, because these will all vary between the images we'll be creating throughout this tutorial.</p>
<p>The <code>create_texture_image</code> function can now be simplified to:</p>
<pre><code class="language-rust noplaypen">unsafe fn create_texture_image(
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;mut AppData,
) -&gt; Result&lt;()&gt; {
    let image = File::open(&quot;resources/texture.png&quot;)?;

    let decoder = png::Decoder::new(image);
    let mut reader = decoder.read_info()?;

    let mut pixels = vec![0;  reader.info().raw_bytes()];
    reader.next_frame(&amp;mut pixels)?;

    let size = reader.info().raw_bytes() as u64;
    let (width, height) = reader.info().size();

    let (staging_buffer, staging_buffer_memory) = create_buffer(
        instance,
        device,
        data,
        size,
        vk::BufferUsageFlags::TRANSFER_SRC,
        vk::MemoryPropertyFlags::HOST_COHERENT | vk::MemoryPropertyFlags::HOST_VISIBLE,
    )?;

    let memory = device.map_memory(
        staging_buffer_memory,
        0,
        size,
        vk::MemoryMapFlags::empty(),
    )?;

    memcpy(pixels.as_ptr(), memory.cast(), pixels.len());

    device.unmap_memory(staging_buffer_memory);

    let (texture_image, texture_image_memory) = create_image(
        instance,
        device,
        data,
        width,
        height,
        vk::Format::R8G8B8A8_SRGB,
        vk::ImageTiling::OPTIMAL,
        vk::ImageUsageFlags::SAMPLED | vk::ImageUsageFlags::TRANSFER_DST,
        vk::MemoryPropertyFlags::DEVICE_LOCAL,
    )?;

    data.texture_image = texture_image;
    data.texture_image_memory = texture_image_memory;

    Ok(())
}
</code></pre>
<h2 id="layout-transitions"><a class="header" href="#layout-transitions">Layout transitions</a></h2>
<p>The function we're going to write now involves recording and executing a command buffer again, so now's a good time to move that logic into a helper function or two:</p>
<pre><code class="language-rust noplaypen">unsafe fn begin_single_time_commands(
    device: &amp;Device,
    data: &amp;AppData,
) -&gt; Result&lt;vk::CommandBuffer&gt; {
    let info = vk::CommandBufferAllocateInfo::builder()
        .level(vk::CommandBufferLevel::PRIMARY)
        .command_pool(data.command_pool)
        .command_buffer_count(1);

    let command_buffer = device.allocate_command_buffers(&amp;info)?[0];

    let info = vk::CommandBufferBeginInfo::builder()
        .flags(vk::CommandBufferUsageFlags::ONE_TIME_SUBMIT);

    device.begin_command_buffer(command_buffer, &amp;info)?;

    Ok(command_buffer)
}

unsafe fn end_single_time_commands(
    device: &amp;Device,
    data: &amp;AppData,
    command_buffer: vk::CommandBuffer,
) -&gt; Result&lt;()&gt; {
    device.end_command_buffer(command_buffer)?;

    let command_buffers = &amp;[command_buffer];
    let info = vk::SubmitInfo::builder()
        .command_buffers(command_buffers);

    device.queue_submit(data.graphics_queue, &amp;[info], vk::Fence::null())?;
    device.queue_wait_idle(data.graphics_queue)?;

    device.free_command_buffers(data.command_pool, &amp;[command_buffer]);

    Ok(())
}
</code></pre>
<p>The code for these functions is based on the existing code in <code>copy_buffer</code>. You can now simplify that function to:</p>
<pre><code class="language-rust noplaypen">unsafe fn copy_buffer(
    device: &amp;Device,
    data: &amp;AppData,
    source: vk::Buffer,
    destination: vk::Buffer,
    size: vk::DeviceSize,
) -&gt; Result&lt;()&gt; {
    let command_buffer = begin_single_time_commands(device, data)?;

    let regions = vk::BufferCopy::builder().size(size);
    device.cmd_copy_buffer(command_buffer, source, destination, &amp;[regions]);

    end_single_time_commands(device, data, command_buffer)?;

    Ok(())
}
</code></pre>
<p>If we were still using buffers, then we could now write a function to record and execute <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_copy_buffer_to_image"><code class="hljs">cmd_copy_buffer_to_image</code></a> to finish the job, but this command requires the image to be in the right layout first. Create a new function to handle layout transitions:</p>
<pre><code class="language-rust noplaypen">unsafe fn transition_image_layout(
    device: &amp;Device,
    data: &amp;AppData,
    image: vk::Image,
    format: vk::Format,
    old_layout: vk::ImageLayout,
    new_layout: vk::ImageLayout,
) -&gt; Result&lt;()&gt; {
    let command_buffer = begin_single_time_commands(device, data)?;

    end_single_time_commands(device, data, command_buffer)?;

    Ok(())
}
</code></pre>
<p>One of the most common ways to perform layout transitions is using an <em>image memory barrier</em>. A pipeline barrier like that is generally used to synchronize access to resources, like ensuring that a write to a buffer completes before reading from it, but it can also be used to transition image layouts and transfer queue family ownership when <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.SharingMode.html#associatedconstant.EXCLUSIVE"><code class="hljs">vk::SharingMode::EXCLUSIVE</code></a> is used. There is an equivalent <em>buffer memory barrier</em> to do this for buffers.</p>
<pre><code class="language-rust noplaypen">let barrier = vk::ImageMemoryBarrier::builder()
    .old_layout(old_layout)
    .new_layout(new_layout)
    // continued...
</code></pre>
<p>The first two fields specify layout transition. It is possible to use <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.UNDEFINED"><code class="hljs">vk::ImageLayout::UNDEFINED</code></a> as <code>old_layout</code> if you don't care about the existing contents of the image.</p>
<pre><code class="language-rust noplaypen">    .src_queue_family_index(vk::QUEUE_FAMILY_IGNORED)
    .dst_queue_family_index(vk::QUEUE_FAMILY_IGNORED)
</code></pre>
<p>If you are using the barrier to transfer queue family ownership, then these two fields should be the indices of the queue families. They must be set to <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/constant.QUEUE_FAMILY_IGNORED.html"><code class="hljs">vk::QUEUE_FAMILY_IGNORED</code></a> if you don't want to do this (not the default value!).</p>
<pre><code class="language-rust noplaypen">    .image(image)
    .subresource_range(subresource)
</code></pre>
<p>The <code>image</code> and <code>subresource_range</code> specify the image that is affected and the specific part of the image. We'll need to define <code>subresource</code> before our image memory barrier:</p>
<pre><code class="language-rust noplaypen">let subresource = vk::ImageSubresourceRange::builder()
    .aspect_mask(vk::ImageAspectFlags::COLOR)
    .base_mip_level(0)
    .level_count(1)
    .base_array_layer(0)
    .layer_count(1);
</code></pre>
<p>Our image is not an array and does not have mipmapping levels, so only one level and layer are specified.</p>
<pre><code class="language-rust noplaypen">    .src_access_mask(vk::AccessFlags::empty())  // TODO
    .dst_access_mask(vk::AccessFlags::empty()); // TODO
</code></pre>
<p>Barriers are primarily used for synchronization purposes, so you must specify which types of operations that involve the resource must happen before the barrier, and which operations that involve the resource must wait on the barrier. We need to do that despite already using <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/trait.DeviceV1_0.html#method.queue_wait_idle"><code class="hljs">queue_wait_idle</code></a> to manually synchronize. The right values depend on the old and new layout, so we'll get back to this once we've figured out which transitions we're going to use.</p>
<pre><code class="language-rust noplaypen">device.cmd_pipeline_barrier(
    command_buffer,
    vk::PipelineStageFlags::empty(), // TODO
    vk::PipelineStageFlags::empty(), // TODO
    vk::DependencyFlags::empty(),
    &amp;[] as &amp;[vk::MemoryBarrier],
    &amp;[] as &amp;[vk::BufferMemoryBarrier],
    &amp;[barrier],
);
</code></pre>
<p>All types of pipeline barriers are submitted using the same function. The first parameter after the command buffer specifies in which pipeline stage the operations occur that should happen before the barrier. The second parameter specifies the pipeline stage in which operations will wait on the barrier. The pipeline stages that you are allowed to specify before and after the barrier depend on how you use the resource before and after the barrier. The allowed values are listed in <a href="https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-types-supported">this table</a> of the specification. For example, if you're going to read from a uniform after the barrier, you would specify a usage of <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.AccessFlags.html#associatedconstant.UNIFORM_READ"><code class="hljs">vk::AccessFlags::UNIFORM_READ</code></a> and the earliest shader that will read from the uniform as pipeline stage, for example <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.PipelineStageFlags.html#associatedconstant.FRAGMENT_SHADER"><code class="hljs">vk::PipelineStageFlags::FRAGMENT_SHADER</code></a>. It would not make sense to specify a non-shader pipeline stage for this type of usage and the validation layers will warn you when you specify a pipeline stage that does not match the type of usage.</p>
<p>The fourth parameter is either an empty set of <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.DependencyFlags.html"><code class="hljs">vk::DependencyFlags</code></a> or <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.DependencyFlags.html#associatedconstant.BY_REGION"><code class="hljs">vk::DependencyFlags::BY_REGION</code></a>. The latter turns the barrier into a per-region condition. That means that the implementation is allowed to already begin reading from the parts of a resource that were written so far, for example.</p>
<p>The last three parameters reference slices of pipeline barriers of the three available types: memory barriers, buffer memory barriers, and image memory barriers like the one we're using here. Note that we're not using the <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.Format.html"><code class="hljs">vk::Format</code></a> parameter yet, but we'll be using that one for special transitions in the depth buffer chapter.</p>
<h2 id="copying-buffer-to-image"><a class="header" href="#copying-buffer-to-image">Copying buffer to image</a></h2>
<p>Before we get back to <code>create_texture_image</code>, we're going to write one more helper function: <code>copy_buffer_to_image</code>:</p>
<pre><code class="language-rust noplaypen">unsafe fn copy_buffer_to_image(
    device: &amp;Device,
    data: &amp;AppData,
    buffer: vk::Buffer,
    image: vk::Image,
    width: u32,
    height: u32,
) -&gt; Result&lt;()&gt; {
    let command_buffer = begin_single_time_commands(device, data)?;

    end_single_time_commands(device, data, command_buffer)?;

    Ok(())
}
</code></pre>
<p>Just like with buffer copies, you need to specify which part of the buffer is going to be copied to which part of the image. This happens through <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.BufferImageCopy.html"><code class="hljs">vk::BufferImageCopy</code></a> structs:</p>
<pre><code class="language-rust noplaypen">let subresource = vk::ImageSubresourceLayers::builder()
    .aspect_mask(vk::ImageAspectFlags::COLOR)
    .mip_level(0)
    .base_array_layer(0)
    .layer_count(1);

let region = vk::BufferImageCopy::builder()
    .buffer_offset(0)
    .buffer_row_length(0)
    .buffer_image_height(0)
    .image_subresource(subresource)
    .image_offset(vk::Offset3D { x: 0, y: 0, z: 0 })
    .image_extent(vk::Extent3D { width, height, depth: 1 });
</code></pre>
<p>Most of these fields are self-explanatory. The <code>buffer_offset</code> specifies the byte offset in the buffer at which the pixel values start. The <code>buffer_row_length</code> and <code>buffer_image_height</code> fields specify how the pixels are laid out in memory. For example, you could have some padding bytes between rows of the image. Specifying <code>0</code> for both indicates that the pixels are simply tightly packed like they are in our case. The <code>image_subresource</code>, <code>image_offset</code> and <code>image_extent</code> fields indicate to which part of the image we want to copy the pixels.</p>
<p>Buffer to image copy operations are enqueued using the <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_copy_buffer_to_image"><code class="hljs">cmd_copy_buffer_to_image</code></a> function:</p>
<pre><code class="language-rust noplaypen">device.cmd_copy_buffer_to_image(
    command_buffer,
    buffer,
    image,
    vk::ImageLayout::TRANSFER_DST_OPTIMAL,
    &amp;[region],
);
</code></pre>
<p>The fourth parameter indicates which layout the image is currently using. I'm assuming here that the image has already been transitioned to the layout that is optimal for copying pixels to. Right now we're only copying one chunk of pixels to the whole image, but it's possible to specify an array of <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.BufferImageCopy.html"><code class="hljs">vk::BufferImageCopy</code></a> to perform many different copies from this buffer to the image in one operation.</p>
<h2 id="preparing-the-texture-image"><a class="header" href="#preparing-the-texture-image">Preparing the texture image</a></h2>
<p>We now have all of the tools we need to finish setting up the texture image, so we're going back to the <code>create_texture_image</code> function. The last thing we did there was creating the texture image. The next step is to copy the staging buffer to the texture image. This involves two steps:</p>
<ul>
<li>Transition the texture image to <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.TRANSFER_DST_OPTIMAL"><code class="hljs">vk::ImageLayout::TRANSFER_DST_OPTIMAL</code></a> </li>
<li>Execute the buffer to image copy operation</li>
</ul>
<p>This is easy to do with the functions we just created:</p>
<pre><code class="language-rust noplaypen">transition_image_layout(
    device,
    data,
    data.texture_image,
    vk::Format::R8G8B8A8_SRGB,
    vk::ImageLayout::UNDEFINED,
    vk::ImageLayout::TRANSFER_DST_OPTIMAL,
)?;

copy_buffer_to_image(
    device,
    data,
    staging_buffer,
    data.texture_image,
    width,
    height,
)?;
</code></pre>
<p>The image was created with the <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.UNDEFINED"><code class="hljs">vk::ImageLayout::UNDEFINED</code></a> layout, so that one should be specified as old layout when transitioning <code>texture_image</code>. Remember that we can do this because we don't care about its contents before performing the copy operation.</p>
<p>To be able to start sampling from the texture image in the shader, we need one last transition to prepare it for shader access:</p>
<pre><code class="language-rust noplaypen">transition_image_layout(
    device,
    data,
    data.texture_image,
    vk::Format::R8G8B8A8_SRGB,
    vk::ImageLayout::TRANSFER_DST_OPTIMAL,
    vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL,
)?;
</code></pre>
<h2 id="transition-barrier-masks"><a class="header" href="#transition-barrier-masks">Transition barrier masks</a></h2>
<p>If you run your application with validation layers enabled now, then you'll see that it complains about the access masks and pipeline stages in <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/trait.DeviceV1_4.html#method.transition_image_layout"><code class="hljs">transition_image_layout</code></a> being invalid. We still need to set those based on the layouts in the transition.</p>
<p>There are two transitions we need to handle:</p>
<ul>
<li>Undefined → transfer destination – transfer writes that don't need to wait on anything</li>
<li>Transfer destination → shader reading – shader reads should wait on transfer writes, specifically the shader reads in the fragment shader, because that's where we're going to use the texture</li>
</ul>
<p>These rules are specified using the following access masks and pipeline stages which should be added at the beginning of <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/trait.DeviceV1_4.html#method.transition_image_layout"><code class="hljs">transition_image_layout</code></a>:</p>
<pre><code class="language-rust noplaypen">let (
    src_access_mask,
    dst_access_mask,
    src_stage_mask,
    dst_stage_mask,
) = match (old_layout, new_layout) {
    (vk::ImageLayout::UNDEFINED, vk::ImageLayout::TRANSFER_DST_OPTIMAL) =&gt; (
        vk::AccessFlags::empty(),
        vk::AccessFlags::TRANSFER_WRITE,
        vk::PipelineStageFlags::TOP_OF_PIPE,
        vk::PipelineStageFlags::TRANSFER,
    ),
    (vk::ImageLayout::TRANSFER_DST_OPTIMAL, vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL) =&gt; (
        vk::AccessFlags::TRANSFER_WRITE,
        vk::AccessFlags::SHADER_READ,
        vk::PipelineStageFlags::TRANSFER,
        vk::PipelineStageFlags::FRAGMENT_SHADER,
    ),
    _ =&gt; return Err(anyhow!(&quot;Unsupported image layout transition!&quot;)),
};
</code></pre>
<p>Then update the <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.ImageMemoryBarrier.html"><code class="hljs">vk::ImageMemoryBarrier</code></a> struct and the <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/trait.DeviceV1_0.html#method.cmd_pipeline_barrier"><code class="hljs">cmd_pipeline_barrier</code></a> call with the access flags and pipeline stage masks:</p>
<pre><code class="language-rust noplaypen">let barrier = vk::ImageMemoryBarrier::builder()
    .old_layout(old_layout)
    .new_layout(new_layout)
    .src_queue_family_index(vk::QUEUE_FAMILY_IGNORED)
    .dst_queue_family_index(vk::QUEUE_FAMILY_IGNORED)
    .image(image)
    .subresource_range(subresource)
    .src_access_mask(src_access_mask)
    .dst_access_mask(dst_access_mask);

device.cmd_pipeline_barrier(
    command_buffer,
    src_stage_mask,
    dst_stage_mask,
    vk::DependencyFlags::empty(),
    &amp;[] as &amp;[vk::MemoryBarrier],
    &amp;[] as &amp;[vk::BufferMemoryBarrier],
    &amp;[barrier],
);
</code></pre>
<p>As you can see in the aforementioned table, transfer writes must occur in the pipeline transfer stage. Since the writes don't have to wait on anything, you may specify an empty access mask and the earliest possible pipeline stage <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.PipelineStageFlags.html#associatedconstant.TOP_OF_PIPE"><code class="hljs">vk::PipelineStageFlags::TOP_OF_PIPE</code></a> for the pre-barrier operations. It should be noted that <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.PipelineStageFlags.html#associatedconstant.TRANSFER"><code class="hljs">vk::PipelineStageFlags::TRANSFER</code></a> is not a <em>real</em> stage within the graphics and compute pipelines. It is more of a pseudo-stage where transfers happen. See <a href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/VkPipelineStageFlagBits.html">the documentation</a> for more information and other examples of pseudo-stages.</p>
<p>The image will be written in the same pipeline stage and subsequently read by the fragment shader, which is why we specify shader reading access in the fragment shader pipeline stage.</p>
<p>If we need to do more transitions in the future, then we'll extend the function. The application should now run successfully, although there are of course no visual changes yet.</p>
<p>One thing to note is that command buffer submission results in implicit <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.AccessFlags.html#associatedconstant.HOST_WRITE"><code class="hljs">vk::AccessFlags::HOST_WRITE</code></a> synchronization at the beginning. Since the <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/trait.DeviceV1_4.html#method.transition_image_layout"><code class="hljs">transition_image_layout</code></a> function executes a command buffer with only a single command, you could use this implicit synchronization and set <code>src_access_mask</code> to <code>vk::AccessFlags::empty()</code> if you ever needed a <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.AccessFlags.html#associatedconstant.HOST_WRITE"><code class="hljs">vk::AccessFlags::HOST_WRITE</code></a> dependency in a layout transition. It's up to you if you want to be explicit about it or not, but I'm personally not a fan of relying on these OpenGL-like &quot;hidden&quot; operations.</p>
<p>There is actually a special type of image layout that supports all operations, <a href="https://docs.rs/vulkanalia/0.25.0/vulkanalia/vk/struct.ImageLayout.html#associatedconstant.GENERAL"><code class="hljs">vk::ImageLayout::GENERAL</code></a>. The problem with it, of course, is that it doesn't necessarily offer the best performance for any operation. It is required for some special cases, like using an image as both input and output, or for reading an image after it has left the preinitialized layout.</p>
<p>All of the helper functions that submit commands so far have been set up to execute synchronously by waiting for the queue to become idle. For practical applications it is recommended to combine these operations in a single command buffer and execute them asynchronously for higher throughput, especially the transitions and copy in the <code>create_texture_image</code> function. Try to experiment with this by creating a <code>setup_command_buffer</code> that the helper functions record commands into, and add a <code>flush_setup_commands</code> to execute the commands that have been recorded so far. It's best to do this after the texture mapping works to check if the texture resources are still set up correctly.</p>
<h2 id="cleanup"><a class="header" href="#cleanup">Cleanup</a></h2>
<p>Finish the <code>create_texture_image</code> function by cleaning up the staging buffer and its memory at the end:</p>
<pre><code class="language-rust noplaypen">device.destroy_buffer(staging_buffer, None);
device.free_memory(staging_buffer_memory, None);
</code></pre>
<p>The main texture image is used until the end of the program:</p>
<pre><code class="language-rust noplaypen">unsafe fn destroy(&amp;mut self) {
    self.destroy_swapchain();
    self.device.destroy_image(self.data.texture_image, None);
    self.device.free_memory(self.data.texture_image_memory, None);
    // ...
}
</code></pre>
<p>The image now contains the texture, but we still need a way to access it from the graphics pipeline. We'll work on that in the next chapter.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../uniform/descriptor_pool_and_sets.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../texture/image_view_and_sampler.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../uniform/descriptor_pool_and_sets.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../texture/image_view_and_sampler.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>



        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
