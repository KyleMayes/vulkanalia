// SPDX-License-Identifier: Apache-2.0

// DO NOT EDIT.
//
// This file has been generated by the Kotlin project in the `generator`
// directory from a Vulkan API registry.

#![allow(
    non_camel_case_types,
    non_snake_case,
    clippy::bad_bit_mask,
    clippy::let_unit_value,
    clippy::missing_safety_doc,
    clippy::missing_transmute_annotations,
    clippy::needless_lifetimes,
    clippy::too_many_arguments,
    clippy::type_complexity,
    clippy::unnecessary_cast,
    clippy::upper_case_acronyms,
    clippy::useless_transmute
)]

use core::ffi::{c_char, c_int, c_void};
use core::mem;

use super::*;

/// Loaded Vulkan device commands.
#[derive(Copy, Clone)]
pub struct DeviceCommands {
    pub acquire_full_screen_exclusive_mode_ext: PFN_vkAcquireFullScreenExclusiveModeEXT,
    pub acquire_next_image2_khr: PFN_vkAcquireNextImage2KHR,
    pub acquire_next_image_khr: PFN_vkAcquireNextImageKHR,
    pub acquire_performance_configuration_intel: PFN_vkAcquirePerformanceConfigurationINTEL,
    pub acquire_profiling_lock_khr: PFN_vkAcquireProfilingLockKHR,
    pub acquire_winrt_display_nv: PFN_vkAcquireWinrtDisplayNV,
    pub allocate_command_buffers: PFN_vkAllocateCommandBuffers,
    pub allocate_descriptor_sets: PFN_vkAllocateDescriptorSets,
    pub allocate_memory: PFN_vkAllocateMemory,
    pub anti_lag_update_amd: PFN_vkAntiLagUpdateAMD,
    pub begin_command_buffer: PFN_vkBeginCommandBuffer,
    pub bind_acceleration_structure_memory_nv: PFN_vkBindAccelerationStructureMemoryNV,
    pub bind_buffer_memory: PFN_vkBindBufferMemory,
    pub bind_buffer_memory2: PFN_vkBindBufferMemory2,
    pub bind_buffer_memory2_khr: PFN_vkBindBufferMemory2KHR,
    pub bind_data_graph_pipeline_session_memory_arm: PFN_vkBindDataGraphPipelineSessionMemoryARM,
    pub bind_image_memory: PFN_vkBindImageMemory,
    pub bind_image_memory2: PFN_vkBindImageMemory2,
    pub bind_image_memory2_khr: PFN_vkBindImageMemory2KHR,
    pub bind_optical_flow_session_image_nv: PFN_vkBindOpticalFlowSessionImageNV,
    pub bind_tensor_memory_arm: PFN_vkBindTensorMemoryARM,
    pub bind_video_session_memory_khr: PFN_vkBindVideoSessionMemoryKHR,
    pub build_acceleration_structures_khr: PFN_vkBuildAccelerationStructuresKHR,
    pub build_micromaps_ext: PFN_vkBuildMicromapsEXT,
    pub cmd_begin_conditional_rendering_ext: PFN_vkCmdBeginConditionalRenderingEXT,
    pub cmd_begin_per_tile_execution_qcom: PFN_vkCmdBeginPerTileExecutionQCOM,
    pub cmd_begin_query: PFN_vkCmdBeginQuery,
    pub cmd_begin_query_indexed_ext: PFN_vkCmdBeginQueryIndexedEXT,
    pub cmd_begin_render_pass: PFN_vkCmdBeginRenderPass,
    pub cmd_begin_render_pass2: PFN_vkCmdBeginRenderPass2,
    pub cmd_begin_render_pass2_khr: PFN_vkCmdBeginRenderPass2KHR,
    pub cmd_begin_rendering: PFN_vkCmdBeginRendering,
    pub cmd_begin_rendering_khr: PFN_vkCmdBeginRenderingKHR,
    pub cmd_begin_transform_feedback_ext: PFN_vkCmdBeginTransformFeedbackEXT,
    pub cmd_begin_video_coding_khr: PFN_vkCmdBeginVideoCodingKHR,
    pub cmd_bind_descriptor_buffer_embedded_samplers2_ext:
        PFN_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT,
    pub cmd_bind_descriptor_buffer_embedded_samplers_ext:
        PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT,
    pub cmd_bind_descriptor_buffers_ext: PFN_vkCmdBindDescriptorBuffersEXT,
    pub cmd_bind_descriptor_sets: PFN_vkCmdBindDescriptorSets,
    pub cmd_bind_descriptor_sets2: PFN_vkCmdBindDescriptorSets2,
    pub cmd_bind_descriptor_sets2_khr: PFN_vkCmdBindDescriptorSets2KHR,
    pub cmd_bind_index_buffer: PFN_vkCmdBindIndexBuffer,
    pub cmd_bind_index_buffer2: PFN_vkCmdBindIndexBuffer2,
    pub cmd_bind_index_buffer2_khr: PFN_vkCmdBindIndexBuffer2KHR,
    pub cmd_bind_invocation_mask_huawei: PFN_vkCmdBindInvocationMaskHUAWEI,
    pub cmd_bind_pipeline: PFN_vkCmdBindPipeline,
    pub cmd_bind_pipeline_shader_group_nv: PFN_vkCmdBindPipelineShaderGroupNV,
    pub cmd_bind_shaders_ext: PFN_vkCmdBindShadersEXT,
    pub cmd_bind_shading_rate_image_nv: PFN_vkCmdBindShadingRateImageNV,
    pub cmd_bind_tile_memory_qcom: PFN_vkCmdBindTileMemoryQCOM,
    pub cmd_bind_transform_feedback_buffers_ext: PFN_vkCmdBindTransformFeedbackBuffersEXT,
    pub cmd_bind_vertex_buffers: PFN_vkCmdBindVertexBuffers,
    pub cmd_bind_vertex_buffers2: PFN_vkCmdBindVertexBuffers2,
    pub cmd_bind_vertex_buffers2_ext: PFN_vkCmdBindVertexBuffers2EXT,
    pub cmd_blit_image: PFN_vkCmdBlitImage,
    pub cmd_blit_image2: PFN_vkCmdBlitImage2,
    pub cmd_blit_image2_khr: PFN_vkCmdBlitImage2KHR,
    pub cmd_build_acceleration_structure_nv: PFN_vkCmdBuildAccelerationStructureNV,
    pub cmd_build_acceleration_structures_indirect_khr:
        PFN_vkCmdBuildAccelerationStructuresIndirectKHR,
    pub cmd_build_acceleration_structures_khr: PFN_vkCmdBuildAccelerationStructuresKHR,
    pub cmd_build_cluster_acceleration_structure_indirect_nv:
        PFN_vkCmdBuildClusterAccelerationStructureIndirectNV,
    pub cmd_build_micromaps_ext: PFN_vkCmdBuildMicromapsEXT,
    pub cmd_build_partitioned_acceleration_structures_nv:
        PFN_vkCmdBuildPartitionedAccelerationStructuresNV,
    pub cmd_clear_attachments: PFN_vkCmdClearAttachments,
    pub cmd_clear_color_image: PFN_vkCmdClearColorImage,
    pub cmd_clear_depth_stencil_image: PFN_vkCmdClearDepthStencilImage,
    pub cmd_control_video_coding_khr: PFN_vkCmdControlVideoCodingKHR,
    pub cmd_convert_cooperative_vector_matrix_nv: PFN_vkCmdConvertCooperativeVectorMatrixNV,
    pub cmd_copy_acceleration_structure_khr: PFN_vkCmdCopyAccelerationStructureKHR,
    pub cmd_copy_acceleration_structure_nv: PFN_vkCmdCopyAccelerationStructureNV,
    pub cmd_copy_acceleration_structure_to_memory_khr:
        PFN_vkCmdCopyAccelerationStructureToMemoryKHR,
    pub cmd_copy_buffer: PFN_vkCmdCopyBuffer,
    pub cmd_copy_buffer2: PFN_vkCmdCopyBuffer2,
    pub cmd_copy_buffer2_khr: PFN_vkCmdCopyBuffer2KHR,
    pub cmd_copy_buffer_to_image: PFN_vkCmdCopyBufferToImage,
    pub cmd_copy_buffer_to_image2: PFN_vkCmdCopyBufferToImage2,
    pub cmd_copy_buffer_to_image2_khr: PFN_vkCmdCopyBufferToImage2KHR,
    pub cmd_copy_image: PFN_vkCmdCopyImage,
    pub cmd_copy_image2: PFN_vkCmdCopyImage2,
    pub cmd_copy_image2_khr: PFN_vkCmdCopyImage2KHR,
    pub cmd_copy_image_to_buffer: PFN_vkCmdCopyImageToBuffer,
    pub cmd_copy_image_to_buffer2: PFN_vkCmdCopyImageToBuffer2,
    pub cmd_copy_image_to_buffer2_khr: PFN_vkCmdCopyImageToBuffer2KHR,
    pub cmd_copy_memory_indirect_nv: PFN_vkCmdCopyMemoryIndirectNV,
    pub cmd_copy_memory_to_acceleration_structure_khr:
        PFN_vkCmdCopyMemoryToAccelerationStructureKHR,
    pub cmd_copy_memory_to_image_indirect_nv: PFN_vkCmdCopyMemoryToImageIndirectNV,
    pub cmd_copy_memory_to_micromap_ext: PFN_vkCmdCopyMemoryToMicromapEXT,
    pub cmd_copy_micromap_ext: PFN_vkCmdCopyMicromapEXT,
    pub cmd_copy_micromap_to_memory_ext: PFN_vkCmdCopyMicromapToMemoryEXT,
    pub cmd_copy_query_pool_results: PFN_vkCmdCopyQueryPoolResults,
    pub cmd_copy_tensor_arm: PFN_vkCmdCopyTensorARM,
    pub cmd_cu_launch_kernel_nvx: PFN_vkCmdCuLaunchKernelNVX,
    pub cmd_cuda_launch_kernel_nv: PFN_vkCmdCudaLaunchKernelNV,
    pub cmd_debug_marker_begin_ext: PFN_vkCmdDebugMarkerBeginEXT,
    pub cmd_debug_marker_end_ext: PFN_vkCmdDebugMarkerEndEXT,
    pub cmd_debug_marker_insert_ext: PFN_vkCmdDebugMarkerInsertEXT,
    pub cmd_decode_video_khr: PFN_vkCmdDecodeVideoKHR,
    pub cmd_decompress_memory_indirect_count_nv: PFN_vkCmdDecompressMemoryIndirectCountNV,
    pub cmd_decompress_memory_nv: PFN_vkCmdDecompressMemoryNV,
    pub cmd_dispatch: PFN_vkCmdDispatch,
    pub cmd_dispatch_base: PFN_vkCmdDispatchBase,
    pub cmd_dispatch_base_khr: PFN_vkCmdDispatchBaseKHR,
    pub cmd_dispatch_data_graph_arm: PFN_vkCmdDispatchDataGraphARM,
    pub cmd_dispatch_graph_amdx: PFN_vkCmdDispatchGraphAMDX,
    pub cmd_dispatch_graph_indirect_amdx: PFN_vkCmdDispatchGraphIndirectAMDX,
    pub cmd_dispatch_graph_indirect_count_amdx: PFN_vkCmdDispatchGraphIndirectCountAMDX,
    pub cmd_dispatch_indirect: PFN_vkCmdDispatchIndirect,
    pub cmd_dispatch_tile_qcom: PFN_vkCmdDispatchTileQCOM,
    pub cmd_draw: PFN_vkCmdDraw,
    pub cmd_draw_cluster_huawei: PFN_vkCmdDrawClusterHUAWEI,
    pub cmd_draw_cluster_indirect_huawei: PFN_vkCmdDrawClusterIndirectHUAWEI,
    pub cmd_draw_indexed: PFN_vkCmdDrawIndexed,
    pub cmd_draw_indexed_indirect: PFN_vkCmdDrawIndexedIndirect,
    pub cmd_draw_indexed_indirect_count: PFN_vkCmdDrawIndexedIndirectCount,
    pub cmd_draw_indexed_indirect_count_amd: PFN_vkCmdDrawIndexedIndirectCountAMD,
    pub cmd_draw_indexed_indirect_count_khr: PFN_vkCmdDrawIndexedIndirectCountKHR,
    pub cmd_draw_indirect: PFN_vkCmdDrawIndirect,
    pub cmd_draw_indirect_byte_count_ext: PFN_vkCmdDrawIndirectByteCountEXT,
    pub cmd_draw_indirect_count: PFN_vkCmdDrawIndirectCount,
    pub cmd_draw_indirect_count_amd: PFN_vkCmdDrawIndirectCountAMD,
    pub cmd_draw_indirect_count_khr: PFN_vkCmdDrawIndirectCountKHR,
    pub cmd_draw_mesh_tasks_ext: PFN_vkCmdDrawMeshTasksEXT,
    pub cmd_draw_mesh_tasks_indirect_count_ext: PFN_vkCmdDrawMeshTasksIndirectCountEXT,
    pub cmd_draw_mesh_tasks_indirect_count_nv: PFN_vkCmdDrawMeshTasksIndirectCountNV,
    pub cmd_draw_mesh_tasks_indirect_ext: PFN_vkCmdDrawMeshTasksIndirectEXT,
    pub cmd_draw_mesh_tasks_indirect_nv: PFN_vkCmdDrawMeshTasksIndirectNV,
    pub cmd_draw_mesh_tasks_nv: PFN_vkCmdDrawMeshTasksNV,
    pub cmd_draw_multi_ext: PFN_vkCmdDrawMultiEXT,
    pub cmd_draw_multi_indexed_ext: PFN_vkCmdDrawMultiIndexedEXT,
    pub cmd_encode_video_khr: PFN_vkCmdEncodeVideoKHR,
    pub cmd_end_conditional_rendering_ext: PFN_vkCmdEndConditionalRenderingEXT,
    pub cmd_end_per_tile_execution_qcom: PFN_vkCmdEndPerTileExecutionQCOM,
    pub cmd_end_query: PFN_vkCmdEndQuery,
    pub cmd_end_query_indexed_ext: PFN_vkCmdEndQueryIndexedEXT,
    pub cmd_end_render_pass: PFN_vkCmdEndRenderPass,
    pub cmd_end_render_pass2: PFN_vkCmdEndRenderPass2,
    pub cmd_end_render_pass2_khr: PFN_vkCmdEndRenderPass2KHR,
    pub cmd_end_rendering: PFN_vkCmdEndRendering,
    pub cmd_end_rendering2_ext: PFN_vkCmdEndRendering2EXT,
    pub cmd_end_rendering_khr: PFN_vkCmdEndRenderingKHR,
    pub cmd_end_transform_feedback_ext: PFN_vkCmdEndTransformFeedbackEXT,
    pub cmd_end_video_coding_khr: PFN_vkCmdEndVideoCodingKHR,
    pub cmd_execute_commands: PFN_vkCmdExecuteCommands,
    pub cmd_execute_generated_commands_ext: PFN_vkCmdExecuteGeneratedCommandsEXT,
    pub cmd_execute_generated_commands_nv: PFN_vkCmdExecuteGeneratedCommandsNV,
    pub cmd_fill_buffer: PFN_vkCmdFillBuffer,
    pub cmd_initialize_graph_scratch_memory_amdx: PFN_vkCmdInitializeGraphScratchMemoryAMDX,
    pub cmd_next_subpass: PFN_vkCmdNextSubpass,
    pub cmd_next_subpass2: PFN_vkCmdNextSubpass2,
    pub cmd_next_subpass2_khr: PFN_vkCmdNextSubpass2KHR,
    pub cmd_optical_flow_execute_nv: PFN_vkCmdOpticalFlowExecuteNV,
    pub cmd_pipeline_barrier: PFN_vkCmdPipelineBarrier,
    pub cmd_pipeline_barrier2: PFN_vkCmdPipelineBarrier2,
    pub cmd_pipeline_barrier2_khr: PFN_vkCmdPipelineBarrier2KHR,
    pub cmd_preprocess_generated_commands_ext: PFN_vkCmdPreprocessGeneratedCommandsEXT,
    pub cmd_preprocess_generated_commands_nv: PFN_vkCmdPreprocessGeneratedCommandsNV,
    pub cmd_push_constants: PFN_vkCmdPushConstants,
    pub cmd_push_constants2: PFN_vkCmdPushConstants2,
    pub cmd_push_constants2_khr: PFN_vkCmdPushConstants2KHR,
    pub cmd_push_descriptor_set: PFN_vkCmdPushDescriptorSet,
    pub cmd_push_descriptor_set2: PFN_vkCmdPushDescriptorSet2,
    pub cmd_push_descriptor_set2_khr: PFN_vkCmdPushDescriptorSet2KHR,
    pub cmd_push_descriptor_set_khr: PFN_vkCmdPushDescriptorSetKHR,
    pub cmd_push_descriptor_set_with_template: PFN_vkCmdPushDescriptorSetWithTemplate,
    pub cmd_push_descriptor_set_with_template2: PFN_vkCmdPushDescriptorSetWithTemplate2,
    pub cmd_push_descriptor_set_with_template2_khr: PFN_vkCmdPushDescriptorSetWithTemplate2KHR,
    pub cmd_push_descriptor_set_with_template_khr: PFN_vkCmdPushDescriptorSetWithTemplateKHR,
    pub cmd_refresh_objects_khr: PFN_vkCmdRefreshObjectsKHR,
    pub cmd_reset_event: PFN_vkCmdResetEvent,
    pub cmd_reset_event2: PFN_vkCmdResetEvent2,
    pub cmd_reset_event2_khr: PFN_vkCmdResetEvent2KHR,
    pub cmd_reset_query_pool: PFN_vkCmdResetQueryPool,
    pub cmd_resolve_image: PFN_vkCmdResolveImage,
    pub cmd_resolve_image2: PFN_vkCmdResolveImage2,
    pub cmd_resolve_image2_khr: PFN_vkCmdResolveImage2KHR,
    pub cmd_set_alpha_to_coverage_enable_ext: PFN_vkCmdSetAlphaToCoverageEnableEXT,
    pub cmd_set_alpha_to_one_enable_ext: PFN_vkCmdSetAlphaToOneEnableEXT,
    pub cmd_set_attachment_feedback_loop_enable_ext: PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT,
    pub cmd_set_blend_constants: PFN_vkCmdSetBlendConstants,
    pub cmd_set_checkpoint_nv: PFN_vkCmdSetCheckpointNV,
    pub cmd_set_coarse_sample_order_nv: PFN_vkCmdSetCoarseSampleOrderNV,
    pub cmd_set_color_blend_advanced_ext: PFN_vkCmdSetColorBlendAdvancedEXT,
    pub cmd_set_color_blend_enable_ext: PFN_vkCmdSetColorBlendEnableEXT,
    pub cmd_set_color_blend_equation_ext: PFN_vkCmdSetColorBlendEquationEXT,
    pub cmd_set_color_write_enable_ext: PFN_vkCmdSetColorWriteEnableEXT,
    pub cmd_set_color_write_mask_ext: PFN_vkCmdSetColorWriteMaskEXT,
    pub cmd_set_conservative_rasterization_mode_ext: PFN_vkCmdSetConservativeRasterizationModeEXT,
    pub cmd_set_coverage_modulation_mode_nv: PFN_vkCmdSetCoverageModulationModeNV,
    pub cmd_set_coverage_modulation_table_enable_nv: PFN_vkCmdSetCoverageModulationTableEnableNV,
    pub cmd_set_coverage_modulation_table_nv: PFN_vkCmdSetCoverageModulationTableNV,
    pub cmd_set_coverage_reduction_mode_nv: PFN_vkCmdSetCoverageReductionModeNV,
    pub cmd_set_coverage_to_color_enable_nv: PFN_vkCmdSetCoverageToColorEnableNV,
    pub cmd_set_coverage_to_color_location_nv: PFN_vkCmdSetCoverageToColorLocationNV,
    pub cmd_set_cull_mode: PFN_vkCmdSetCullMode,
    pub cmd_set_cull_mode_ext: PFN_vkCmdSetCullModeEXT,
    pub cmd_set_depth_bias: PFN_vkCmdSetDepthBias,
    pub cmd_set_depth_bias2_ext: PFN_vkCmdSetDepthBias2EXT,
    pub cmd_set_depth_bias_enable: PFN_vkCmdSetDepthBiasEnable,
    pub cmd_set_depth_bias_enable_ext: PFN_vkCmdSetDepthBiasEnableEXT,
    pub cmd_set_depth_bounds: PFN_vkCmdSetDepthBounds,
    pub cmd_set_depth_bounds_test_enable: PFN_vkCmdSetDepthBoundsTestEnable,
    pub cmd_set_depth_bounds_test_enable_ext: PFN_vkCmdSetDepthBoundsTestEnableEXT,
    pub cmd_set_depth_clamp_enable_ext: PFN_vkCmdSetDepthClampEnableEXT,
    pub cmd_set_depth_clamp_range_ext: PFN_vkCmdSetDepthClampRangeEXT,
    pub cmd_set_depth_clip_enable_ext: PFN_vkCmdSetDepthClipEnableEXT,
    pub cmd_set_depth_clip_negative_one_to_one_ext: PFN_vkCmdSetDepthClipNegativeOneToOneEXT,
    pub cmd_set_depth_compare_op: PFN_vkCmdSetDepthCompareOp,
    pub cmd_set_depth_compare_op_ext: PFN_vkCmdSetDepthCompareOpEXT,
    pub cmd_set_depth_test_enable: PFN_vkCmdSetDepthTestEnable,
    pub cmd_set_depth_test_enable_ext: PFN_vkCmdSetDepthTestEnableEXT,
    pub cmd_set_depth_write_enable: PFN_vkCmdSetDepthWriteEnable,
    pub cmd_set_depth_write_enable_ext: PFN_vkCmdSetDepthWriteEnableEXT,
    pub cmd_set_descriptor_buffer_offsets2_ext: PFN_vkCmdSetDescriptorBufferOffsets2EXT,
    pub cmd_set_descriptor_buffer_offsets_ext: PFN_vkCmdSetDescriptorBufferOffsetsEXT,
    pub cmd_set_device_mask: PFN_vkCmdSetDeviceMask,
    pub cmd_set_device_mask_khr: PFN_vkCmdSetDeviceMaskKHR,
    pub cmd_set_discard_rectangle_ext: PFN_vkCmdSetDiscardRectangleEXT,
    pub cmd_set_discard_rectangle_enable_ext: PFN_vkCmdSetDiscardRectangleEnableEXT,
    pub cmd_set_discard_rectangle_mode_ext: PFN_vkCmdSetDiscardRectangleModeEXT,
    pub cmd_set_event: PFN_vkCmdSetEvent,
    pub cmd_set_event2: PFN_vkCmdSetEvent2,
    pub cmd_set_event2_khr: PFN_vkCmdSetEvent2KHR,
    pub cmd_set_exclusive_scissor_enable_nv: PFN_vkCmdSetExclusiveScissorEnableNV,
    pub cmd_set_exclusive_scissor_nv: PFN_vkCmdSetExclusiveScissorNV,
    pub cmd_set_extra_primitive_overestimation_size_ext:
        PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT,
    pub cmd_set_fragment_shading_rate_enum_nv: PFN_vkCmdSetFragmentShadingRateEnumNV,
    pub cmd_set_fragment_shading_rate_khr: PFN_vkCmdSetFragmentShadingRateKHR,
    pub cmd_set_front_face: PFN_vkCmdSetFrontFace,
    pub cmd_set_front_face_ext: PFN_vkCmdSetFrontFaceEXT,
    pub cmd_set_line_rasterization_mode_ext: PFN_vkCmdSetLineRasterizationModeEXT,
    pub cmd_set_line_stipple: PFN_vkCmdSetLineStipple,
    pub cmd_set_line_stipple_ext: PFN_vkCmdSetLineStippleEXT,
    pub cmd_set_line_stipple_enable_ext: PFN_vkCmdSetLineStippleEnableEXT,
    pub cmd_set_line_stipple_khr: PFN_vkCmdSetLineStippleKHR,
    pub cmd_set_line_width: PFN_vkCmdSetLineWidth,
    pub cmd_set_logic_op_ext: PFN_vkCmdSetLogicOpEXT,
    pub cmd_set_logic_op_enable_ext: PFN_vkCmdSetLogicOpEnableEXT,
    pub cmd_set_patch_control_points_ext: PFN_vkCmdSetPatchControlPointsEXT,
    pub cmd_set_performance_marker_intel: PFN_vkCmdSetPerformanceMarkerINTEL,
    pub cmd_set_performance_override_intel: PFN_vkCmdSetPerformanceOverrideINTEL,
    pub cmd_set_performance_stream_marker_intel: PFN_vkCmdSetPerformanceStreamMarkerINTEL,
    pub cmd_set_polygon_mode_ext: PFN_vkCmdSetPolygonModeEXT,
    pub cmd_set_primitive_restart_enable: PFN_vkCmdSetPrimitiveRestartEnable,
    pub cmd_set_primitive_restart_enable_ext: PFN_vkCmdSetPrimitiveRestartEnableEXT,
    pub cmd_set_primitive_topology: PFN_vkCmdSetPrimitiveTopology,
    pub cmd_set_primitive_topology_ext: PFN_vkCmdSetPrimitiveTopologyEXT,
    pub cmd_set_provoking_vertex_mode_ext: PFN_vkCmdSetProvokingVertexModeEXT,
    pub cmd_set_rasterization_samples_ext: PFN_vkCmdSetRasterizationSamplesEXT,
    pub cmd_set_rasterization_stream_ext: PFN_vkCmdSetRasterizationStreamEXT,
    pub cmd_set_rasterizer_discard_enable: PFN_vkCmdSetRasterizerDiscardEnable,
    pub cmd_set_rasterizer_discard_enable_ext: PFN_vkCmdSetRasterizerDiscardEnableEXT,
    pub cmd_set_ray_tracing_pipeline_stack_size_khr: PFN_vkCmdSetRayTracingPipelineStackSizeKHR,
    pub cmd_set_rendering_attachment_locations: PFN_vkCmdSetRenderingAttachmentLocations,
    pub cmd_set_rendering_attachment_locations_khr: PFN_vkCmdSetRenderingAttachmentLocationsKHR,
    pub cmd_set_rendering_input_attachment_indices: PFN_vkCmdSetRenderingInputAttachmentIndices,
    pub cmd_set_rendering_input_attachment_indices_khr:
        PFN_vkCmdSetRenderingInputAttachmentIndicesKHR,
    pub cmd_set_representative_fragment_test_enable_nv:
        PFN_vkCmdSetRepresentativeFragmentTestEnableNV,
    pub cmd_set_sample_locations_ext: PFN_vkCmdSetSampleLocationsEXT,
    pub cmd_set_sample_locations_enable_ext: PFN_vkCmdSetSampleLocationsEnableEXT,
    pub cmd_set_sample_mask_ext: PFN_vkCmdSetSampleMaskEXT,
    pub cmd_set_scissor: PFN_vkCmdSetScissor,
    pub cmd_set_scissor_with_count: PFN_vkCmdSetScissorWithCount,
    pub cmd_set_scissor_with_count_ext: PFN_vkCmdSetScissorWithCountEXT,
    pub cmd_set_shading_rate_image_enable_nv: PFN_vkCmdSetShadingRateImageEnableNV,
    pub cmd_set_stencil_compare_mask: PFN_vkCmdSetStencilCompareMask,
    pub cmd_set_stencil_op: PFN_vkCmdSetStencilOp,
    pub cmd_set_stencil_op_ext: PFN_vkCmdSetStencilOpEXT,
    pub cmd_set_stencil_reference: PFN_vkCmdSetStencilReference,
    pub cmd_set_stencil_test_enable: PFN_vkCmdSetStencilTestEnable,
    pub cmd_set_stencil_test_enable_ext: PFN_vkCmdSetStencilTestEnableEXT,
    pub cmd_set_stencil_write_mask: PFN_vkCmdSetStencilWriteMask,
    pub cmd_set_tessellation_domain_origin_ext: PFN_vkCmdSetTessellationDomainOriginEXT,
    pub cmd_set_vertex_input_ext: PFN_vkCmdSetVertexInputEXT,
    pub cmd_set_viewport: PFN_vkCmdSetViewport,
    pub cmd_set_viewport_shading_rate_palette_nv: PFN_vkCmdSetViewportShadingRatePaletteNV,
    pub cmd_set_viewport_swizzle_nv: PFN_vkCmdSetViewportSwizzleNV,
    pub cmd_set_viewport_w_scaling_enable_nv: PFN_vkCmdSetViewportWScalingEnableNV,
    pub cmd_set_viewport_w_scaling_nv: PFN_vkCmdSetViewportWScalingNV,
    pub cmd_set_viewport_with_count: PFN_vkCmdSetViewportWithCount,
    pub cmd_set_viewport_with_count_ext: PFN_vkCmdSetViewportWithCountEXT,
    pub cmd_subpass_shading_huawei: PFN_vkCmdSubpassShadingHUAWEI,
    pub cmd_trace_rays_indirect2_khr: PFN_vkCmdTraceRaysIndirect2KHR,
    pub cmd_trace_rays_indirect_khr: PFN_vkCmdTraceRaysIndirectKHR,
    pub cmd_trace_rays_khr: PFN_vkCmdTraceRaysKHR,
    pub cmd_trace_rays_nv: PFN_vkCmdTraceRaysNV,
    pub cmd_update_buffer: PFN_vkCmdUpdateBuffer,
    pub cmd_update_pipeline_indirect_buffer_nv: PFN_vkCmdUpdatePipelineIndirectBufferNV,
    pub cmd_wait_events: PFN_vkCmdWaitEvents,
    pub cmd_wait_events2: PFN_vkCmdWaitEvents2,
    pub cmd_wait_events2_khr: PFN_vkCmdWaitEvents2KHR,
    pub cmd_write_acceleration_structures_properties_khr:
        PFN_vkCmdWriteAccelerationStructuresPropertiesKHR,
    pub cmd_write_acceleration_structures_properties_nv:
        PFN_vkCmdWriteAccelerationStructuresPropertiesNV,
    pub cmd_write_buffer_marker2_amd: PFN_vkCmdWriteBufferMarker2AMD,
    pub cmd_write_buffer_marker_amd: PFN_vkCmdWriteBufferMarkerAMD,
    pub cmd_write_micromaps_properties_ext: PFN_vkCmdWriteMicromapsPropertiesEXT,
    pub cmd_write_timestamp: PFN_vkCmdWriteTimestamp,
    pub cmd_write_timestamp2: PFN_vkCmdWriteTimestamp2,
    pub cmd_write_timestamp2_khr: PFN_vkCmdWriteTimestamp2KHR,
    pub compile_deferred_nv: PFN_vkCompileDeferredNV,
    pub convert_cooperative_vector_matrix_nv: PFN_vkConvertCooperativeVectorMatrixNV,
    pub copy_acceleration_structure_khr: PFN_vkCopyAccelerationStructureKHR,
    pub copy_acceleration_structure_to_memory_khr: PFN_vkCopyAccelerationStructureToMemoryKHR,
    pub copy_image_to_image: PFN_vkCopyImageToImage,
    pub copy_image_to_image_ext: PFN_vkCopyImageToImageEXT,
    pub copy_image_to_memory: PFN_vkCopyImageToMemory,
    pub copy_image_to_memory_ext: PFN_vkCopyImageToMemoryEXT,
    pub copy_memory_to_acceleration_structure_khr: PFN_vkCopyMemoryToAccelerationStructureKHR,
    pub copy_memory_to_image: PFN_vkCopyMemoryToImage,
    pub copy_memory_to_image_ext: PFN_vkCopyMemoryToImageEXT,
    pub copy_memory_to_micromap_ext: PFN_vkCopyMemoryToMicromapEXT,
    pub copy_micromap_ext: PFN_vkCopyMicromapEXT,
    pub copy_micromap_to_memory_ext: PFN_vkCopyMicromapToMemoryEXT,
    pub create_acceleration_structure_khr: PFN_vkCreateAccelerationStructureKHR,
    pub create_acceleration_structure_nv: PFN_vkCreateAccelerationStructureNV,
    pub create_buffer: PFN_vkCreateBuffer,
    pub create_buffer_collection_fuchsia: PFN_vkCreateBufferCollectionFUCHSIA,
    pub create_buffer_view: PFN_vkCreateBufferView,
    pub create_command_pool: PFN_vkCreateCommandPool,
    pub create_compute_pipelines: PFN_vkCreateComputePipelines,
    pub create_cu_function_nvx: PFN_vkCreateCuFunctionNVX,
    pub create_cu_module_nvx: PFN_vkCreateCuModuleNVX,
    pub create_cuda_function_nv: PFN_vkCreateCudaFunctionNV,
    pub create_cuda_module_nv: PFN_vkCreateCudaModuleNV,
    pub create_data_graph_pipeline_session_arm: PFN_vkCreateDataGraphPipelineSessionARM,
    pub create_data_graph_pipelines_arm: PFN_vkCreateDataGraphPipelinesARM,
    pub create_deferred_operation_khr: PFN_vkCreateDeferredOperationKHR,
    pub create_descriptor_pool: PFN_vkCreateDescriptorPool,
    pub create_descriptor_set_layout: PFN_vkCreateDescriptorSetLayout,
    pub create_descriptor_update_template: PFN_vkCreateDescriptorUpdateTemplate,
    pub create_descriptor_update_template_khr: PFN_vkCreateDescriptorUpdateTemplateKHR,
    pub create_event: PFN_vkCreateEvent,
    pub create_execution_graph_pipelines_amdx: PFN_vkCreateExecutionGraphPipelinesAMDX,
    pub create_external_compute_queue_nv: PFN_vkCreateExternalComputeQueueNV,
    pub create_fence: PFN_vkCreateFence,
    pub create_framebuffer: PFN_vkCreateFramebuffer,
    pub create_graphics_pipelines: PFN_vkCreateGraphicsPipelines,
    pub create_image: PFN_vkCreateImage,
    pub create_image_view: PFN_vkCreateImageView,
    pub create_indirect_commands_layout_ext: PFN_vkCreateIndirectCommandsLayoutEXT,
    pub create_indirect_commands_layout_nv: PFN_vkCreateIndirectCommandsLayoutNV,
    pub create_indirect_execution_set_ext: PFN_vkCreateIndirectExecutionSetEXT,
    pub create_micromap_ext: PFN_vkCreateMicromapEXT,
    pub create_optical_flow_session_nv: PFN_vkCreateOpticalFlowSessionNV,
    pub create_pipeline_binaries_khr: PFN_vkCreatePipelineBinariesKHR,
    pub create_pipeline_cache: PFN_vkCreatePipelineCache,
    pub create_pipeline_layout: PFN_vkCreatePipelineLayout,
    pub create_private_data_slot: PFN_vkCreatePrivateDataSlot,
    pub create_private_data_slot_ext: PFN_vkCreatePrivateDataSlotEXT,
    pub create_query_pool: PFN_vkCreateQueryPool,
    pub create_ray_tracing_pipelines_khr: PFN_vkCreateRayTracingPipelinesKHR,
    pub create_ray_tracing_pipelines_nv: PFN_vkCreateRayTracingPipelinesNV,
    pub create_render_pass: PFN_vkCreateRenderPass,
    pub create_render_pass2: PFN_vkCreateRenderPass2,
    pub create_render_pass2_khr: PFN_vkCreateRenderPass2KHR,
    pub create_sampler: PFN_vkCreateSampler,
    pub create_sampler_ycbcr_conversion: PFN_vkCreateSamplerYcbcrConversion,
    pub create_sampler_ycbcr_conversion_khr: PFN_vkCreateSamplerYcbcrConversionKHR,
    pub create_semaphore: PFN_vkCreateSemaphore,
    pub create_semaphore_sci_sync_pool_nv: PFN_vkCreateSemaphoreSciSyncPoolNV,
    pub create_shader_module: PFN_vkCreateShaderModule,
    pub create_shaders_ext: PFN_vkCreateShadersEXT,
    pub create_shared_swapchains_khr: PFN_vkCreateSharedSwapchainsKHR,
    pub create_swapchain_khr: PFN_vkCreateSwapchainKHR,
    pub create_tensor_arm: PFN_vkCreateTensorARM,
    pub create_tensor_view_arm: PFN_vkCreateTensorViewARM,
    pub create_validation_cache_ext: PFN_vkCreateValidationCacheEXT,
    pub create_video_session_khr: PFN_vkCreateVideoSessionKHR,
    pub create_video_session_parameters_khr: PFN_vkCreateVideoSessionParametersKHR,
    pub debug_marker_set_object_name_ext: PFN_vkDebugMarkerSetObjectNameEXT,
    pub debug_marker_set_object_tag_ext: PFN_vkDebugMarkerSetObjectTagEXT,
    pub deferred_operation_join_khr: PFN_vkDeferredOperationJoinKHR,
    pub destroy_acceleration_structure_khr: PFN_vkDestroyAccelerationStructureKHR,
    pub destroy_acceleration_structure_nv: PFN_vkDestroyAccelerationStructureNV,
    pub destroy_buffer: PFN_vkDestroyBuffer,
    pub destroy_buffer_collection_fuchsia: PFN_vkDestroyBufferCollectionFUCHSIA,
    pub destroy_buffer_view: PFN_vkDestroyBufferView,
    pub destroy_command_pool: PFN_vkDestroyCommandPool,
    pub destroy_cu_function_nvx: PFN_vkDestroyCuFunctionNVX,
    pub destroy_cu_module_nvx: PFN_vkDestroyCuModuleNVX,
    pub destroy_cuda_function_nv: PFN_vkDestroyCudaFunctionNV,
    pub destroy_cuda_module_nv: PFN_vkDestroyCudaModuleNV,
    pub destroy_data_graph_pipeline_session_arm: PFN_vkDestroyDataGraphPipelineSessionARM,
    pub destroy_deferred_operation_khr: PFN_vkDestroyDeferredOperationKHR,
    pub destroy_descriptor_pool: PFN_vkDestroyDescriptorPool,
    pub destroy_descriptor_set_layout: PFN_vkDestroyDescriptorSetLayout,
    pub destroy_descriptor_update_template: PFN_vkDestroyDescriptorUpdateTemplate,
    pub destroy_descriptor_update_template_khr: PFN_vkDestroyDescriptorUpdateTemplateKHR,
    pub destroy_device: PFN_vkDestroyDevice,
    pub destroy_event: PFN_vkDestroyEvent,
    pub destroy_external_compute_queue_nv: PFN_vkDestroyExternalComputeQueueNV,
    pub destroy_fence: PFN_vkDestroyFence,
    pub destroy_framebuffer: PFN_vkDestroyFramebuffer,
    pub destroy_image: PFN_vkDestroyImage,
    pub destroy_image_view: PFN_vkDestroyImageView,
    pub destroy_indirect_commands_layout_ext: PFN_vkDestroyIndirectCommandsLayoutEXT,
    pub destroy_indirect_commands_layout_nv: PFN_vkDestroyIndirectCommandsLayoutNV,
    pub destroy_indirect_execution_set_ext: PFN_vkDestroyIndirectExecutionSetEXT,
    pub destroy_micromap_ext: PFN_vkDestroyMicromapEXT,
    pub destroy_optical_flow_session_nv: PFN_vkDestroyOpticalFlowSessionNV,
    pub destroy_pipeline: PFN_vkDestroyPipeline,
    pub destroy_pipeline_binary_khr: PFN_vkDestroyPipelineBinaryKHR,
    pub destroy_pipeline_cache: PFN_vkDestroyPipelineCache,
    pub destroy_pipeline_layout: PFN_vkDestroyPipelineLayout,
    pub destroy_private_data_slot: PFN_vkDestroyPrivateDataSlot,
    pub destroy_private_data_slot_ext: PFN_vkDestroyPrivateDataSlotEXT,
    pub destroy_query_pool: PFN_vkDestroyQueryPool,
    pub destroy_render_pass: PFN_vkDestroyRenderPass,
    pub destroy_sampler: PFN_vkDestroySampler,
    pub destroy_sampler_ycbcr_conversion: PFN_vkDestroySamplerYcbcrConversion,
    pub destroy_sampler_ycbcr_conversion_khr: PFN_vkDestroySamplerYcbcrConversionKHR,
    pub destroy_semaphore: PFN_vkDestroySemaphore,
    pub destroy_semaphore_sci_sync_pool_nv: PFN_vkDestroySemaphoreSciSyncPoolNV,
    pub destroy_shader_ext: PFN_vkDestroyShaderEXT,
    pub destroy_shader_module: PFN_vkDestroyShaderModule,
    pub destroy_swapchain_khr: PFN_vkDestroySwapchainKHR,
    pub destroy_tensor_arm: PFN_vkDestroyTensorARM,
    pub destroy_tensor_view_arm: PFN_vkDestroyTensorViewARM,
    pub destroy_validation_cache_ext: PFN_vkDestroyValidationCacheEXT,
    pub destroy_video_session_khr: PFN_vkDestroyVideoSessionKHR,
    pub destroy_video_session_parameters_khr: PFN_vkDestroyVideoSessionParametersKHR,
    pub device_wait_idle: PFN_vkDeviceWaitIdle,
    pub display_power_control_ext: PFN_vkDisplayPowerControlEXT,
    pub end_command_buffer: PFN_vkEndCommandBuffer,
    pub enumerate_physical_device_queue_family_performance_query_counters_khr:
        PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR,
    pub export_metal_objects_ext: PFN_vkExportMetalObjectsEXT,
    pub flush_mapped_memory_ranges: PFN_vkFlushMappedMemoryRanges,
    pub free_command_buffers: PFN_vkFreeCommandBuffers,
    pub free_descriptor_sets: PFN_vkFreeDescriptorSets,
    pub free_memory: PFN_vkFreeMemory,
    pub get_acceleration_structure_build_sizes_khr: PFN_vkGetAccelerationStructureBuildSizesKHR,
    pub get_acceleration_structure_device_address_khr:
        PFN_vkGetAccelerationStructureDeviceAddressKHR,
    pub get_acceleration_structure_handle_nv: PFN_vkGetAccelerationStructureHandleNV,
    pub get_acceleration_structure_memory_requirements_nv:
        PFN_vkGetAccelerationStructureMemoryRequirementsNV,
    pub get_acceleration_structure_opaque_capture_descriptor_data_ext:
        PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT,
    pub get_android_hardware_buffer_properties_android:
        PFN_vkGetAndroidHardwareBufferPropertiesANDROID,
    pub get_buffer_collection_properties_fuchsia: PFN_vkGetBufferCollectionPropertiesFUCHSIA,
    pub get_buffer_device_address: PFN_vkGetBufferDeviceAddress,
    pub get_buffer_device_address_ext: PFN_vkGetBufferDeviceAddressEXT,
    pub get_buffer_device_address_khr: PFN_vkGetBufferDeviceAddressKHR,
    pub get_buffer_memory_requirements: PFN_vkGetBufferMemoryRequirements,
    pub get_buffer_memory_requirements2: PFN_vkGetBufferMemoryRequirements2,
    pub get_buffer_memory_requirements2_khr: PFN_vkGetBufferMemoryRequirements2KHR,
    pub get_buffer_opaque_capture_address: PFN_vkGetBufferOpaqueCaptureAddress,
    pub get_buffer_opaque_capture_address_khr: PFN_vkGetBufferOpaqueCaptureAddressKHR,
    pub get_buffer_opaque_capture_descriptor_data_ext:
        PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT,
    pub get_calibrated_timestamps_ext: PFN_vkGetCalibratedTimestampsEXT,
    pub get_calibrated_timestamps_khr: PFN_vkGetCalibratedTimestampsKHR,
    pub get_cluster_acceleration_structure_build_sizes_nv:
        PFN_vkGetClusterAccelerationStructureBuildSizesNV,
    pub get_cuda_module_cache_nv: PFN_vkGetCudaModuleCacheNV,
    pub get_data_graph_pipeline_available_properties_arm:
        PFN_vkGetDataGraphPipelineAvailablePropertiesARM,
    pub get_data_graph_pipeline_properties_arm: PFN_vkGetDataGraphPipelinePropertiesARM,
    pub get_data_graph_pipeline_session_bind_point_requirements_arm:
        PFN_vkGetDataGraphPipelineSessionBindPointRequirementsARM,
    pub get_data_graph_pipeline_session_memory_requirements_arm:
        PFN_vkGetDataGraphPipelineSessionMemoryRequirementsARM,
    pub get_deferred_operation_max_concurrency_khr: PFN_vkGetDeferredOperationMaxConcurrencyKHR,
    pub get_deferred_operation_result_khr: PFN_vkGetDeferredOperationResultKHR,
    pub get_descriptor_ext: PFN_vkGetDescriptorEXT,
    pub get_descriptor_set_host_mapping_valve: PFN_vkGetDescriptorSetHostMappingVALVE,
    pub get_descriptor_set_layout_binding_offset_ext: PFN_vkGetDescriptorSetLayoutBindingOffsetEXT,
    pub get_descriptor_set_layout_host_mapping_info_valve:
        PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE,
    pub get_descriptor_set_layout_size_ext: PFN_vkGetDescriptorSetLayoutSizeEXT,
    pub get_descriptor_set_layout_support: PFN_vkGetDescriptorSetLayoutSupport,
    pub get_descriptor_set_layout_support_khr: PFN_vkGetDescriptorSetLayoutSupportKHR,
    pub get_device_acceleration_structure_compatibility_khr:
        PFN_vkGetDeviceAccelerationStructureCompatibilityKHR,
    pub get_device_buffer_memory_requirements: PFN_vkGetDeviceBufferMemoryRequirements,
    pub get_device_buffer_memory_requirements_khr: PFN_vkGetDeviceBufferMemoryRequirementsKHR,
    pub get_device_fault_info_ext: PFN_vkGetDeviceFaultInfoEXT,
    pub get_device_group_peer_memory_features: PFN_vkGetDeviceGroupPeerMemoryFeatures,
    pub get_device_group_peer_memory_features_khr: PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR,
    pub get_device_group_present_capabilities_khr: PFN_vkGetDeviceGroupPresentCapabilitiesKHR,
    pub get_device_group_surface_present_modes2_ext: PFN_vkGetDeviceGroupSurfacePresentModes2EXT,
    pub get_device_group_surface_present_modes_khr: PFN_vkGetDeviceGroupSurfacePresentModesKHR,
    pub get_device_image_memory_requirements: PFN_vkGetDeviceImageMemoryRequirements,
    pub get_device_image_memory_requirements_khr: PFN_vkGetDeviceImageMemoryRequirementsKHR,
    pub get_device_image_sparse_memory_requirements: PFN_vkGetDeviceImageSparseMemoryRequirements,
    pub get_device_image_sparse_memory_requirements_khr:
        PFN_vkGetDeviceImageSparseMemoryRequirementsKHR,
    pub get_device_image_subresource_layout: PFN_vkGetDeviceImageSubresourceLayout,
    pub get_device_image_subresource_layout_khr: PFN_vkGetDeviceImageSubresourceLayoutKHR,
    pub get_device_memory_commitment: PFN_vkGetDeviceMemoryCommitment,
    pub get_device_memory_opaque_capture_address: PFN_vkGetDeviceMemoryOpaqueCaptureAddress,
    pub get_device_memory_opaque_capture_address_khr: PFN_vkGetDeviceMemoryOpaqueCaptureAddressKHR,
    pub get_device_micromap_compatibility_ext: PFN_vkGetDeviceMicromapCompatibilityEXT,
    pub get_device_queue: PFN_vkGetDeviceQueue,
    pub get_device_queue2: PFN_vkGetDeviceQueue2,
    pub get_device_subpass_shading_max_workgroup_size_huawei:
        PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI,
    pub get_device_tensor_memory_requirements_arm: PFN_vkGetDeviceTensorMemoryRequirementsARM,
    pub get_dynamic_rendering_tile_properties_qcom: PFN_vkGetDynamicRenderingTilePropertiesQCOM,
    pub get_encoded_video_session_parameters_khr: PFN_vkGetEncodedVideoSessionParametersKHR,
    pub get_event_status: PFN_vkGetEventStatus,
    pub get_execution_graph_pipeline_node_index_amdx: PFN_vkGetExecutionGraphPipelineNodeIndexAMDX,
    pub get_execution_graph_pipeline_scratch_size_amdx:
        PFN_vkGetExecutionGraphPipelineScratchSizeAMDX,
    pub get_external_compute_queue_data_nv: PFN_vkGetExternalComputeQueueDataNV,
    pub get_fence_fd_khr: PFN_vkGetFenceFdKHR,
    pub get_fence_sci_sync_fence_nv: PFN_vkGetFenceSciSyncFenceNV,
    pub get_fence_sci_sync_obj_nv: PFN_vkGetFenceSciSyncObjNV,
    pub get_fence_status: PFN_vkGetFenceStatus,
    pub get_fence_win32_handle_khr: PFN_vkGetFenceWin32HandleKHR,
    pub get_framebuffer_tile_properties_qcom: PFN_vkGetFramebufferTilePropertiesQCOM,
    pub get_generated_commands_memory_requirements_ext:
        PFN_vkGetGeneratedCommandsMemoryRequirementsEXT,
    pub get_generated_commands_memory_requirements_nv:
        PFN_vkGetGeneratedCommandsMemoryRequirementsNV,
    pub get_image_drm_format_modifier_properties_ext: PFN_vkGetImageDrmFormatModifierPropertiesEXT,
    pub get_image_memory_requirements: PFN_vkGetImageMemoryRequirements,
    pub get_image_memory_requirements2: PFN_vkGetImageMemoryRequirements2,
    pub get_image_memory_requirements2_khr: PFN_vkGetImageMemoryRequirements2KHR,
    pub get_image_opaque_capture_descriptor_data_ext: PFN_vkGetImageOpaqueCaptureDescriptorDataEXT,
    pub get_image_sparse_memory_requirements: PFN_vkGetImageSparseMemoryRequirements,
    pub get_image_sparse_memory_requirements2: PFN_vkGetImageSparseMemoryRequirements2,
    pub get_image_sparse_memory_requirements2_khr: PFN_vkGetImageSparseMemoryRequirements2KHR,
    pub get_image_subresource_layout: PFN_vkGetImageSubresourceLayout,
    pub get_image_subresource_layout2: PFN_vkGetImageSubresourceLayout2,
    pub get_image_subresource_layout2_ext: PFN_vkGetImageSubresourceLayout2EXT,
    pub get_image_subresource_layout2_khr: PFN_vkGetImageSubresourceLayout2KHR,
    pub get_image_view_address_nvx: PFN_vkGetImageViewAddressNVX,
    pub get_image_view_handle64_nvx: PFN_vkGetImageViewHandle64NVX,
    pub get_image_view_handle_nvx: PFN_vkGetImageViewHandleNVX,
    pub get_image_view_opaque_capture_descriptor_data_ext:
        PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT,
    pub get_latency_timings_nv: PFN_vkGetLatencyTimingsNV,
    pub get_memory_android_hardware_buffer_android: PFN_vkGetMemoryAndroidHardwareBufferANDROID,
    pub get_memory_fd_khr: PFN_vkGetMemoryFdKHR,
    pub get_memory_fd_properties_khr: PFN_vkGetMemoryFdPropertiesKHR,
    pub get_memory_host_pointer_properties_ext: PFN_vkGetMemoryHostPointerPropertiesEXT,
    pub get_memory_metal_handle_ext: PFN_vkGetMemoryMetalHandleEXT,
    pub get_memory_metal_handle_properties_ext: PFN_vkGetMemoryMetalHandlePropertiesEXT,
    pub get_memory_remote_address_nv: PFN_vkGetMemoryRemoteAddressNV,
    pub get_memory_sci_buf_nv: PFN_vkGetMemorySciBufNV,
    pub get_memory_win32_handle_khr: PFN_vkGetMemoryWin32HandleKHR,
    pub get_memory_win32_handle_nv: PFN_vkGetMemoryWin32HandleNV,
    pub get_memory_win32_handle_properties_khr: PFN_vkGetMemoryWin32HandlePropertiesKHR,
    pub get_memory_zircon_handle_fuchsia: PFN_vkGetMemoryZirconHandleFUCHSIA,
    pub get_memory_zircon_handle_properties_fuchsia: PFN_vkGetMemoryZirconHandlePropertiesFUCHSIA,
    pub get_micromap_build_sizes_ext: PFN_vkGetMicromapBuildSizesEXT,
    pub get_partitioned_acceleration_structures_build_sizes_nv:
        PFN_vkGetPartitionedAccelerationStructuresBuildSizesNV,
    pub get_past_presentation_timing_google: PFN_vkGetPastPresentationTimingGOOGLE,
    pub get_performance_parameter_intel: PFN_vkGetPerformanceParameterINTEL,
    pub get_physical_device_calibrateable_time_domains_ext:
        PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT,
    pub get_physical_device_calibrateable_time_domains_khr:
        PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR,
    pub get_physical_device_cooperative_matrix_flexible_dimensions_properties_nv:
        PFN_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV,
    pub get_physical_device_cooperative_matrix_properties_khr:
        PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR,
    pub get_physical_device_cooperative_matrix_properties_nv:
        PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV,
    pub get_physical_device_cooperative_vector_properties_nv:
        PFN_vkGetPhysicalDeviceCooperativeVectorPropertiesNV,
    pub get_physical_device_external_memory_sci_buf_properties_nv:
        PFN_vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV,
    pub get_physical_device_external_tensor_properties_arm:
        PFN_vkGetPhysicalDeviceExternalTensorPropertiesARM,
    pub get_physical_device_fragment_shading_rates_khr:
        PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR,
    pub get_physical_device_multisample_properties_ext:
        PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT,
    pub get_physical_device_optical_flow_image_formats_nv:
        PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV,
    pub get_physical_device_present_rectangles_khr: PFN_vkGetPhysicalDevicePresentRectanglesKHR,
    pub get_physical_device_queue_family_data_graph_processing_engine_properties_arm:
        PFN_vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM,
    pub get_physical_device_queue_family_data_graph_properties_arm:
        PFN_vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM,
    pub get_physical_device_queue_family_performance_query_passes_khr:
        PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR,
    pub get_physical_device_refreshable_object_types_khr:
        PFN_vkGetPhysicalDeviceRefreshableObjectTypesKHR,
    pub get_physical_device_sci_buf_attributes_nv: PFN_vkGetPhysicalDeviceSciBufAttributesNV,
    pub get_physical_device_sci_sync_attributes_nv: PFN_vkGetPhysicalDeviceSciSyncAttributesNV,
    pub get_physical_device_supported_framebuffer_mixed_samples_combinations_nv:
        PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV,
    pub get_physical_device_surface_present_modes2_ext:
        PFN_vkGetPhysicalDeviceSurfacePresentModes2EXT,
    pub get_physical_device_tool_properties_ext: PFN_vkGetPhysicalDeviceToolPropertiesEXT,
    pub get_physical_device_video_capabilities_khr: PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR,
    pub get_physical_device_video_encode_quality_level_properties_khr:
        PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR,
    pub get_physical_device_video_format_properties_khr:
        PFN_vkGetPhysicalDeviceVideoFormatPropertiesKHR,
    pub get_pipeline_binary_data_khr: PFN_vkGetPipelineBinaryDataKHR,
    pub get_pipeline_cache_data: PFN_vkGetPipelineCacheData,
    pub get_pipeline_executable_internal_representations_khr:
        PFN_vkGetPipelineExecutableInternalRepresentationsKHR,
    pub get_pipeline_executable_properties_khr: PFN_vkGetPipelineExecutablePropertiesKHR,
    pub get_pipeline_executable_statistics_khr: PFN_vkGetPipelineExecutableStatisticsKHR,
    pub get_pipeline_indirect_device_address_nv: PFN_vkGetPipelineIndirectDeviceAddressNV,
    pub get_pipeline_indirect_memory_requirements_nv: PFN_vkGetPipelineIndirectMemoryRequirementsNV,
    pub get_pipeline_key_khr: PFN_vkGetPipelineKeyKHR,
    pub get_pipeline_properties_ext: PFN_vkGetPipelinePropertiesEXT,
    pub get_private_data: PFN_vkGetPrivateData,
    pub get_private_data_ext: PFN_vkGetPrivateDataEXT,
    pub get_query_pool_results: PFN_vkGetQueryPoolResults,
    pub get_queue_checkpoint_data2_nv: PFN_vkGetQueueCheckpointData2NV,
    pub get_queue_checkpoint_data_nv: PFN_vkGetQueueCheckpointDataNV,
    pub get_ray_tracing_capture_replay_shader_group_handles_khr:
        PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR,
    pub get_ray_tracing_shader_group_handles_khr: PFN_vkGetRayTracingShaderGroupHandlesKHR,
    pub get_ray_tracing_shader_group_handles_nv: PFN_vkGetRayTracingShaderGroupHandlesNV,
    pub get_ray_tracing_shader_group_stack_size_khr: PFN_vkGetRayTracingShaderGroupStackSizeKHR,
    pub get_refresh_cycle_duration_google: PFN_vkGetRefreshCycleDurationGOOGLE,
    pub get_render_area_granularity: PFN_vkGetRenderAreaGranularity,
    pub get_rendering_area_granularity: PFN_vkGetRenderingAreaGranularity,
    pub get_rendering_area_granularity_khr: PFN_vkGetRenderingAreaGranularityKHR,
    pub get_sampler_opaque_capture_descriptor_data_ext:
        PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT,
    pub get_screen_buffer_properties_qnx: PFN_vkGetScreenBufferPropertiesQNX,
    pub get_semaphore_counter_value: PFN_vkGetSemaphoreCounterValue,
    pub get_semaphore_counter_value_khr: PFN_vkGetSemaphoreCounterValueKHR,
    pub get_semaphore_fd_khr: PFN_vkGetSemaphoreFdKHR,
    pub get_semaphore_sci_sync_obj_nv: PFN_vkGetSemaphoreSciSyncObjNV,
    pub get_semaphore_win32_handle_khr: PFN_vkGetSemaphoreWin32HandleKHR,
    pub get_semaphore_zircon_handle_fuchsia: PFN_vkGetSemaphoreZirconHandleFUCHSIA,
    pub get_shader_binary_data_ext: PFN_vkGetShaderBinaryDataEXT,
    pub get_shader_info_amd: PFN_vkGetShaderInfoAMD,
    pub get_shader_module_create_info_identifier_ext: PFN_vkGetShaderModuleCreateInfoIdentifierEXT,
    pub get_shader_module_identifier_ext: PFN_vkGetShaderModuleIdentifierEXT,
    pub get_swapchain_counter_ext: PFN_vkGetSwapchainCounterEXT,
    pub get_swapchain_images_khr: PFN_vkGetSwapchainImagesKHR,
    pub get_swapchain_status_khr: PFN_vkGetSwapchainStatusKHR,
    pub get_tensor_memory_requirements_arm: PFN_vkGetTensorMemoryRequirementsARM,
    pub get_tensor_opaque_capture_descriptor_data_arm:
        PFN_vkGetTensorOpaqueCaptureDescriptorDataARM,
    pub get_tensor_view_opaque_capture_descriptor_data_arm:
        PFN_vkGetTensorViewOpaqueCaptureDescriptorDataARM,
    pub get_validation_cache_data_ext: PFN_vkGetValidationCacheDataEXT,
    pub get_video_session_memory_requirements_khr: PFN_vkGetVideoSessionMemoryRequirementsKHR,
    pub get_winrt_display_nv: PFN_vkGetWinrtDisplayNV,
    pub import_fence_fd_khr: PFN_vkImportFenceFdKHR,
    pub import_fence_sci_sync_fence_nv: PFN_vkImportFenceSciSyncFenceNV,
    pub import_fence_sci_sync_obj_nv: PFN_vkImportFenceSciSyncObjNV,
    pub import_fence_win32_handle_khr: PFN_vkImportFenceWin32HandleKHR,
    pub import_semaphore_fd_khr: PFN_vkImportSemaphoreFdKHR,
    pub import_semaphore_sci_sync_obj_nv: PFN_vkImportSemaphoreSciSyncObjNV,
    pub import_semaphore_win32_handle_khr: PFN_vkImportSemaphoreWin32HandleKHR,
    pub import_semaphore_zircon_handle_fuchsia: PFN_vkImportSemaphoreZirconHandleFUCHSIA,
    pub initialize_performance_api_intel: PFN_vkInitializePerformanceApiINTEL,
    pub invalidate_mapped_memory_ranges: PFN_vkInvalidateMappedMemoryRanges,
    pub latency_sleep_nv: PFN_vkLatencySleepNV,
    pub map_memory: PFN_vkMapMemory,
    pub map_memory2: PFN_vkMapMemory2,
    pub map_memory2_khr: PFN_vkMapMemory2KHR,
    pub merge_pipeline_caches: PFN_vkMergePipelineCaches,
    pub merge_validation_caches_ext: PFN_vkMergeValidationCachesEXT,
    pub queue_bind_sparse: PFN_vkQueueBindSparse,
    pub queue_notify_out_of_band_nv: PFN_vkQueueNotifyOutOfBandNV,
    pub queue_present_khr: PFN_vkQueuePresentKHR,
    pub queue_set_performance_configuration_intel: PFN_vkQueueSetPerformanceConfigurationINTEL,
    pub queue_submit: PFN_vkQueueSubmit,
    pub queue_submit2: PFN_vkQueueSubmit2,
    pub queue_submit2_khr: PFN_vkQueueSubmit2KHR,
    pub queue_wait_idle: PFN_vkQueueWaitIdle,
    pub register_device_event_ext: PFN_vkRegisterDeviceEventEXT,
    pub register_display_event_ext: PFN_vkRegisterDisplayEventEXT,
    pub release_captured_pipeline_data_khr: PFN_vkReleaseCapturedPipelineDataKHR,
    pub release_full_screen_exclusive_mode_ext: PFN_vkReleaseFullScreenExclusiveModeEXT,
    pub release_performance_configuration_intel: PFN_vkReleasePerformanceConfigurationINTEL,
    pub release_profiling_lock_khr: PFN_vkReleaseProfilingLockKHR,
    pub release_swapchain_images_ext: PFN_vkReleaseSwapchainImagesEXT,
    pub release_swapchain_images_khr: PFN_vkReleaseSwapchainImagesKHR,
    pub reset_command_buffer: PFN_vkResetCommandBuffer,
    pub reset_command_pool: PFN_vkResetCommandPool,
    pub reset_descriptor_pool: PFN_vkResetDescriptorPool,
    pub reset_event: PFN_vkResetEvent,
    pub reset_fences: PFN_vkResetFences,
    pub reset_query_pool: PFN_vkResetQueryPool,
    pub reset_query_pool_ext: PFN_vkResetQueryPoolEXT,
    pub set_buffer_collection_buffer_constraints_fuchsia:
        PFN_vkSetBufferCollectionBufferConstraintsFUCHSIA,
    pub set_buffer_collection_image_constraints_fuchsia:
        PFN_vkSetBufferCollectionImageConstraintsFUCHSIA,
    pub set_device_memory_priority_ext: PFN_vkSetDeviceMemoryPriorityEXT,
    pub set_event: PFN_vkSetEvent,
    pub set_hdr_metadata_ext: PFN_vkSetHdrMetadataEXT,
    pub set_latency_marker_nv: PFN_vkSetLatencyMarkerNV,
    pub set_latency_sleep_mode_nv: PFN_vkSetLatencySleepModeNV,
    pub set_local_dimming_amd: PFN_vkSetLocalDimmingAMD,
    pub set_private_data: PFN_vkSetPrivateData,
    pub set_private_data_ext: PFN_vkSetPrivateDataEXT,
    pub signal_semaphore: PFN_vkSignalSemaphore,
    pub signal_semaphore_khr: PFN_vkSignalSemaphoreKHR,
    pub transition_image_layout: PFN_vkTransitionImageLayout,
    pub transition_image_layout_ext: PFN_vkTransitionImageLayoutEXT,
    pub trim_command_pool: PFN_vkTrimCommandPool,
    pub trim_command_pool_khr: PFN_vkTrimCommandPoolKHR,
    pub uninitialize_performance_api_intel: PFN_vkUninitializePerformanceApiINTEL,
    pub unmap_memory: PFN_vkUnmapMemory,
    pub unmap_memory2: PFN_vkUnmapMemory2,
    pub unmap_memory2_khr: PFN_vkUnmapMemory2KHR,
    pub update_descriptor_set_with_template: PFN_vkUpdateDescriptorSetWithTemplate,
    pub update_descriptor_set_with_template_khr: PFN_vkUpdateDescriptorSetWithTemplateKHR,
    pub update_descriptor_sets: PFN_vkUpdateDescriptorSets,
    pub update_indirect_execution_set_pipeline_ext: PFN_vkUpdateIndirectExecutionSetPipelineEXT,
    pub update_indirect_execution_set_shader_ext: PFN_vkUpdateIndirectExecutionSetShaderEXT,
    pub update_video_session_parameters_khr: PFN_vkUpdateVideoSessionParametersKHR,
    pub wait_for_fences: PFN_vkWaitForFences,
    pub wait_for_present2_khr: PFN_vkWaitForPresent2KHR,
    pub wait_for_present_khr: PFN_vkWaitForPresentKHR,
    pub wait_semaphores: PFN_vkWaitSemaphores,
    pub wait_semaphores_khr: PFN_vkWaitSemaphoresKHR,
    pub write_acceleration_structures_properties_khr:
        PFN_vkWriteAccelerationStructuresPropertiesKHR,
    pub write_micromaps_properties_ext: PFN_vkWriteMicromapsPropertiesEXT,
}

impl DeviceCommands {
    #[inline]
    pub unsafe fn load(
        mut instance_loader: impl FnMut(*const c_char) -> Option<unsafe extern "system" fn()>,
        mut loader: impl FnMut(*const c_char) -> Option<unsafe extern "system" fn()>,
    ) -> Self {
        Self {
            acquire_full_screen_exclusive_mode_ext: {
                let value = loader(c"vkAcquireFullScreenExclusiveModeEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _swapchain: SwapchainKHR,
                    ) -> Result {
                        panic!("could not load vkAcquireFullScreenExclusiveModeEXT")
                    }
                    fallback
                }
            },
            acquire_next_image2_khr: {
                let value = loader(c"vkAcquireNextImage2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _acquire_info: *const AcquireNextImageInfoKHR,
                        _image_index: *mut u32,
                    ) -> Result {
                        panic!("could not load vkAcquireNextImage2KHR")
                    }
                    fallback
                }
            },
            acquire_next_image_khr: {
                let value = loader(c"vkAcquireNextImageKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _swapchain: SwapchainKHR,
                        _timeout: u64,
                        _semaphore: Semaphore,
                        _fence: Fence,
                        _image_index: *mut u32,
                    ) -> Result {
                        panic!("could not load vkAcquireNextImageKHR")
                    }
                    fallback
                }
            },
            acquire_performance_configuration_intel: {
                let value = loader(c"vkAcquirePerformanceConfigurationINTEL".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _acquire_info: *const PerformanceConfigurationAcquireInfoINTEL,
                        _configuration: *mut PerformanceConfigurationINTEL,
                    ) -> Result {
                        panic!("could not load vkAcquirePerformanceConfigurationINTEL")
                    }
                    fallback
                }
            },
            acquire_profiling_lock_khr: {
                let value = loader(c"vkAcquireProfilingLockKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const AcquireProfilingLockInfoKHR,
                    ) -> Result {
                        panic!("could not load vkAcquireProfilingLockKHR")
                    }
                    fallback
                }
            },
            acquire_winrt_display_nv: {
                let value = instance_loader(c"vkAcquireWinrtDisplayNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _display: DisplayKHR,
                    ) -> Result {
                        panic!("could not load vkAcquireWinrtDisplayNV")
                    }
                    fallback
                }
            },
            allocate_command_buffers: {
                let value = loader(c"vkAllocateCommandBuffers".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _allocate_info: *const CommandBufferAllocateInfo,
                        _command_buffers: *mut CommandBuffer,
                    ) -> Result {
                        panic!("could not load vkAllocateCommandBuffers")
                    }
                    fallback
                }
            },
            allocate_descriptor_sets: {
                let value = loader(c"vkAllocateDescriptorSets".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _allocate_info: *const DescriptorSetAllocateInfo,
                        _descriptor_sets: *mut DescriptorSet,
                    ) -> Result {
                        panic!("could not load vkAllocateDescriptorSets")
                    }
                    fallback
                }
            },
            allocate_memory: {
                let value = loader(c"vkAllocateMemory".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _allocate_info: *const MemoryAllocateInfo,
                        _allocator: *const AllocationCallbacks,
                        _memory: *mut DeviceMemory,
                    ) -> Result {
                        panic!("could not load vkAllocateMemory")
                    }
                    fallback
                }
            },
            anti_lag_update_amd: {
                let value = loader(c"vkAntiLagUpdateAMD".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _data: *const AntiLagDataAMD,
                    ) {
                        panic!("could not load vkAntiLagUpdateAMD")
                    }
                    fallback
                }
            },
            begin_command_buffer: {
                let value = loader(c"vkBeginCommandBuffer".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _begin_info: *const CommandBufferBeginInfo,
                    ) -> Result {
                        panic!("could not load vkBeginCommandBuffer")
                    }
                    fallback
                }
            },
            bind_acceleration_structure_memory_nv: {
                let value = loader(c"vkBindAccelerationStructureMemoryNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _bind_info_count: u32,
                        _bind_infos: *const BindAccelerationStructureMemoryInfoNV,
                    ) -> Result {
                        panic!("could not load vkBindAccelerationStructureMemoryNV")
                    }
                    fallback
                }
            },
            bind_buffer_memory: {
                let value = loader(c"vkBindBufferMemory".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _buffer: Buffer,
                        _memory: DeviceMemory,
                        _memory_offset: DeviceSize,
                    ) -> Result {
                        panic!("could not load vkBindBufferMemory")
                    }
                    fallback
                }
            },
            bind_buffer_memory2: {
                let value = loader(c"vkBindBufferMemory2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _bind_info_count: u32,
                        _bind_infos: *const BindBufferMemoryInfo,
                    ) -> Result {
                        panic!("could not load vkBindBufferMemory2")
                    }
                    fallback
                }
            },
            bind_buffer_memory2_khr: {
                let value = loader(c"vkBindBufferMemory2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _bind_info_count: u32,
                        _bind_infos: *const BindBufferMemoryInfo,
                    ) -> Result {
                        panic!("could not load vkBindBufferMemory2KHR")
                    }
                    fallback
                }
            },
            bind_data_graph_pipeline_session_memory_arm: {
                let value = loader(c"vkBindDataGraphPipelineSessionMemoryARM".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _bind_info_count: u32,
                        _bind_infos: *const BindDataGraphPipelineSessionMemoryInfoARM,
                    ) -> Result {
                        panic!("could not load vkBindDataGraphPipelineSessionMemoryARM")
                    }
                    fallback
                }
            },
            bind_image_memory: {
                let value = loader(c"vkBindImageMemory".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _image: Image,
                        _memory: DeviceMemory,
                        _memory_offset: DeviceSize,
                    ) -> Result {
                        panic!("could not load vkBindImageMemory")
                    }
                    fallback
                }
            },
            bind_image_memory2: {
                let value = loader(c"vkBindImageMemory2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _bind_info_count: u32,
                        _bind_infos: *const BindImageMemoryInfo,
                    ) -> Result {
                        panic!("could not load vkBindImageMemory2")
                    }
                    fallback
                }
            },
            bind_image_memory2_khr: {
                let value = loader(c"vkBindImageMemory2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _bind_info_count: u32,
                        _bind_infos: *const BindImageMemoryInfo,
                    ) -> Result {
                        panic!("could not load vkBindImageMemory2KHR")
                    }
                    fallback
                }
            },
            bind_optical_flow_session_image_nv: {
                let value = loader(c"vkBindOpticalFlowSessionImageNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _session: OpticalFlowSessionNV,
                        _binding_point: OpticalFlowSessionBindingPointNV,
                        _view: ImageView,
                        _layout: ImageLayout,
                    ) -> Result {
                        panic!("could not load vkBindOpticalFlowSessionImageNV")
                    }
                    fallback
                }
            },
            bind_tensor_memory_arm: {
                let value = loader(c"vkBindTensorMemoryARM".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _bind_info_count: u32,
                        _bind_infos: *const BindTensorMemoryInfoARM,
                    ) -> Result {
                        panic!("could not load vkBindTensorMemoryARM")
                    }
                    fallback
                }
            },
            bind_video_session_memory_khr: {
                let value = loader(c"vkBindVideoSessionMemoryKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _video_session: VideoSessionKHR,
                        _bind_session_memory_info_count: u32,
                        _bind_session_memory_infos: *const BindVideoSessionMemoryInfoKHR,
                    ) -> Result {
                        panic!("could not load vkBindVideoSessionMemoryKHR")
                    }
                    fallback
                }
            },
            build_acceleration_structures_khr: {
                let value = loader(c"vkBuildAccelerationStructuresKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _deferred_operation: DeferredOperationKHR,
                        _info_count: u32,
                        _infos: *const AccelerationStructureBuildGeometryInfoKHR,
                        _build_range_infos: *const *const AccelerationStructureBuildRangeInfoKHR,
                    ) -> Result {
                        panic!("could not load vkBuildAccelerationStructuresKHR")
                    }
                    fallback
                }
            },
            build_micromaps_ext: {
                let value = loader(c"vkBuildMicromapsEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _deferred_operation: DeferredOperationKHR,
                        _info_count: u32,
                        _infos: *const MicromapBuildInfoEXT,
                    ) -> Result {
                        panic!("could not load vkBuildMicromapsEXT")
                    }
                    fallback
                }
            },
            cmd_begin_conditional_rendering_ext: {
                let value = loader(c"vkCmdBeginConditionalRenderingEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _conditional_rendering_begin: *const ConditionalRenderingBeginInfoEXT,
                    ) {
                        panic!("could not load vkCmdBeginConditionalRenderingEXT")
                    }
                    fallback
                }
            },
            cmd_begin_per_tile_execution_qcom: {
                let value = loader(c"vkCmdBeginPerTileExecutionQCOM".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _per_tile_begin_info: *const PerTileBeginInfoQCOM,
                    ) {
                        panic!("could not load vkCmdBeginPerTileExecutionQCOM")
                    }
                    fallback
                }
            },
            cmd_begin_query: {
                let value = loader(c"vkCmdBeginQuery".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _query_pool: QueryPool,
                        _query: u32,
                        _flags: QueryControlFlags,
                    ) {
                        panic!("could not load vkCmdBeginQuery")
                    }
                    fallback
                }
            },
            cmd_begin_query_indexed_ext: {
                let value = loader(c"vkCmdBeginQueryIndexedEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _query_pool: QueryPool,
                        _query: u32,
                        _flags: QueryControlFlags,
                        _index: u32,
                    ) {
                        panic!("could not load vkCmdBeginQueryIndexedEXT")
                    }
                    fallback
                }
            },
            cmd_begin_render_pass: {
                let value = loader(c"vkCmdBeginRenderPass".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _render_pass_begin: *const RenderPassBeginInfo,
                        _contents: SubpassContents,
                    ) {
                        panic!("could not load vkCmdBeginRenderPass")
                    }
                    fallback
                }
            },
            cmd_begin_render_pass2: {
                let value = loader(c"vkCmdBeginRenderPass2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _render_pass_begin: *const RenderPassBeginInfo,
                        _subpass_begin_info: *const SubpassBeginInfo,
                    ) {
                        panic!("could not load vkCmdBeginRenderPass2")
                    }
                    fallback
                }
            },
            cmd_begin_render_pass2_khr: {
                let value = loader(c"vkCmdBeginRenderPass2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _render_pass_begin: *const RenderPassBeginInfo,
                        _subpass_begin_info: *const SubpassBeginInfo,
                    ) {
                        panic!("could not load vkCmdBeginRenderPass2KHR")
                    }
                    fallback
                }
            },
            cmd_begin_rendering: {
                let value = loader(c"vkCmdBeginRendering".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _rendering_info: *const RenderingInfo,
                    ) {
                        panic!("could not load vkCmdBeginRendering")
                    }
                    fallback
                }
            },
            cmd_begin_rendering_khr: {
                let value = loader(c"vkCmdBeginRenderingKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _rendering_info: *const RenderingInfo,
                    ) {
                        panic!("could not load vkCmdBeginRenderingKHR")
                    }
                    fallback
                }
            },
            cmd_begin_transform_feedback_ext: {
                let value = loader(c"vkCmdBeginTransformFeedbackEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _first_counter_buffer: u32,
                        _counter_buffer_count: u32,
                        _counter_buffers: *const Buffer,
                        _counter_buffer_offsets: *const DeviceSize,
                    ) {
                        panic!("could not load vkCmdBeginTransformFeedbackEXT")
                    }
                    fallback
                }
            },
            cmd_begin_video_coding_khr: {
                let value = loader(c"vkCmdBeginVideoCodingKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _begin_info: *const VideoBeginCodingInfoKHR,
                    ) {
                        panic!("could not load vkCmdBeginVideoCodingKHR")
                    }
                    fallback
                }
            },
            cmd_bind_descriptor_buffer_embedded_samplers2_ext: {
                let value = loader(c"vkCmdBindDescriptorBufferEmbeddedSamplers2EXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _bind_descriptor_buffer_embedded_samplers_info: *const BindDescriptorBufferEmbeddedSamplersInfoEXT,
                    ) {
                        panic!("could not load vkCmdBindDescriptorBufferEmbeddedSamplers2EXT")
                    }
                    fallback
                }
            },
            cmd_bind_descriptor_buffer_embedded_samplers_ext: {
                let value = loader(c"vkCmdBindDescriptorBufferEmbeddedSamplersEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _pipeline_bind_point: PipelineBindPoint,
                        _layout: PipelineLayout,
                        _set: u32,
                    ) {
                        panic!("could not load vkCmdBindDescriptorBufferEmbeddedSamplersEXT")
                    }
                    fallback
                }
            },
            cmd_bind_descriptor_buffers_ext: {
                let value = loader(c"vkCmdBindDescriptorBuffersEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _buffer_count: u32,
                        _binding_infos: *const DescriptorBufferBindingInfoEXT,
                    ) {
                        panic!("could not load vkCmdBindDescriptorBuffersEXT")
                    }
                    fallback
                }
            },
            cmd_bind_descriptor_sets: {
                let value = loader(c"vkCmdBindDescriptorSets".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _pipeline_bind_point: PipelineBindPoint,
                        _layout: PipelineLayout,
                        _first_set: u32,
                        _descriptor_set_count: u32,
                        _descriptor_sets: *const DescriptorSet,
                        _dynamic_offset_count: u32,
                        _dynamic_offsets: *const u32,
                    ) {
                        panic!("could not load vkCmdBindDescriptorSets")
                    }
                    fallback
                }
            },
            cmd_bind_descriptor_sets2: {
                let value = loader(c"vkCmdBindDescriptorSets2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _bind_descriptor_sets_info: *const BindDescriptorSetsInfo,
                    ) {
                        panic!("could not load vkCmdBindDescriptorSets2")
                    }
                    fallback
                }
            },
            cmd_bind_descriptor_sets2_khr: {
                let value = loader(c"vkCmdBindDescriptorSets2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _bind_descriptor_sets_info: *const BindDescriptorSetsInfo,
                    ) {
                        panic!("could not load vkCmdBindDescriptorSets2KHR")
                    }
                    fallback
                }
            },
            cmd_bind_index_buffer: {
                let value = loader(c"vkCmdBindIndexBuffer".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _buffer: Buffer,
                        _offset: DeviceSize,
                        _index_type: IndexType,
                    ) {
                        panic!("could not load vkCmdBindIndexBuffer")
                    }
                    fallback
                }
            },
            cmd_bind_index_buffer2: {
                let value = loader(c"vkCmdBindIndexBuffer2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _buffer: Buffer,
                        _offset: DeviceSize,
                        _size: DeviceSize,
                        _index_type: IndexType,
                    ) {
                        panic!("could not load vkCmdBindIndexBuffer2")
                    }
                    fallback
                }
            },
            cmd_bind_index_buffer2_khr: {
                let value = loader(c"vkCmdBindIndexBuffer2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _buffer: Buffer,
                        _offset: DeviceSize,
                        _size: DeviceSize,
                        _index_type: IndexType,
                    ) {
                        panic!("could not load vkCmdBindIndexBuffer2KHR")
                    }
                    fallback
                }
            },
            cmd_bind_invocation_mask_huawei: {
                let value = loader(c"vkCmdBindInvocationMaskHUAWEI".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _image_view: ImageView,
                        _image_layout: ImageLayout,
                    ) {
                        panic!("could not load vkCmdBindInvocationMaskHUAWEI")
                    }
                    fallback
                }
            },
            cmd_bind_pipeline: {
                let value = loader(c"vkCmdBindPipeline".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _pipeline_bind_point: PipelineBindPoint,
                        _pipeline: Pipeline,
                    ) {
                        panic!("could not load vkCmdBindPipeline")
                    }
                    fallback
                }
            },
            cmd_bind_pipeline_shader_group_nv: {
                let value = loader(c"vkCmdBindPipelineShaderGroupNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _pipeline_bind_point: PipelineBindPoint,
                        _pipeline: Pipeline,
                        _group_index: u32,
                    ) {
                        panic!("could not load vkCmdBindPipelineShaderGroupNV")
                    }
                    fallback
                }
            },
            cmd_bind_shaders_ext: {
                let value = loader(c"vkCmdBindShadersEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _stage_count: u32,
                        _stages: *const ShaderStageFlags,
                        _shaders: *const ShaderEXT,
                    ) {
                        panic!("could not load vkCmdBindShadersEXT")
                    }
                    fallback
                }
            },
            cmd_bind_shading_rate_image_nv: {
                let value = loader(c"vkCmdBindShadingRateImageNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _image_view: ImageView,
                        _image_layout: ImageLayout,
                    ) {
                        panic!("could not load vkCmdBindShadingRateImageNV")
                    }
                    fallback
                }
            },
            cmd_bind_tile_memory_qcom: {
                let value = loader(c"vkCmdBindTileMemoryQCOM".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _tile_memory_bind_info: *const TileMemoryBindInfoQCOM,
                    ) {
                        panic!("could not load vkCmdBindTileMemoryQCOM")
                    }
                    fallback
                }
            },
            cmd_bind_transform_feedback_buffers_ext: {
                let value = loader(c"vkCmdBindTransformFeedbackBuffersEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _first_binding: u32,
                        _binding_count: u32,
                        _buffers: *const Buffer,
                        _offsets: *const DeviceSize,
                        _sizes: *const DeviceSize,
                    ) {
                        panic!("could not load vkCmdBindTransformFeedbackBuffersEXT")
                    }
                    fallback
                }
            },
            cmd_bind_vertex_buffers: {
                let value = loader(c"vkCmdBindVertexBuffers".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _first_binding: u32,
                        _binding_count: u32,
                        _buffers: *const Buffer,
                        _offsets: *const DeviceSize,
                    ) {
                        panic!("could not load vkCmdBindVertexBuffers")
                    }
                    fallback
                }
            },
            cmd_bind_vertex_buffers2: {
                let value = loader(c"vkCmdBindVertexBuffers2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _first_binding: u32,
                        _binding_count: u32,
                        _buffers: *const Buffer,
                        _offsets: *const DeviceSize,
                        _sizes: *const DeviceSize,
                        _strides: *const DeviceSize,
                    ) {
                        panic!("could not load vkCmdBindVertexBuffers2")
                    }
                    fallback
                }
            },
            cmd_bind_vertex_buffers2_ext: {
                let value = loader(c"vkCmdBindVertexBuffers2EXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _first_binding: u32,
                        _binding_count: u32,
                        _buffers: *const Buffer,
                        _offsets: *const DeviceSize,
                        _sizes: *const DeviceSize,
                        _strides: *const DeviceSize,
                    ) {
                        panic!("could not load vkCmdBindVertexBuffers2EXT")
                    }
                    fallback
                }
            },
            cmd_blit_image: {
                let value = loader(c"vkCmdBlitImage".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _src_image: Image,
                        _src_image_layout: ImageLayout,
                        _dst_image: Image,
                        _dst_image_layout: ImageLayout,
                        _region_count: u32,
                        _regions: *const ImageBlit,
                        _filter: Filter,
                    ) {
                        panic!("could not load vkCmdBlitImage")
                    }
                    fallback
                }
            },
            cmd_blit_image2: {
                let value = loader(c"vkCmdBlitImage2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _blit_image_info: *const BlitImageInfo2,
                    ) {
                        panic!("could not load vkCmdBlitImage2")
                    }
                    fallback
                }
            },
            cmd_blit_image2_khr: {
                let value = loader(c"vkCmdBlitImage2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _blit_image_info: *const BlitImageInfo2,
                    ) {
                        panic!("could not load vkCmdBlitImage2KHR")
                    }
                    fallback
                }
            },
            cmd_build_acceleration_structure_nv: {
                let value = loader(c"vkCmdBuildAccelerationStructureNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _info: *const AccelerationStructureInfoNV,
                        _instance_data: Buffer,
                        _instance_offset: DeviceSize,
                        _update: Bool32,
                        _dst: AccelerationStructureNV,
                        _src: AccelerationStructureNV,
                        _scratch: Buffer,
                        _scratch_offset: DeviceSize,
                    ) {
                        panic!("could not load vkCmdBuildAccelerationStructureNV")
                    }
                    fallback
                }
            },
            cmd_build_acceleration_structures_indirect_khr: {
                let value = loader(c"vkCmdBuildAccelerationStructuresIndirectKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _info_count: u32,
                        _infos: *const AccelerationStructureBuildGeometryInfoKHR,
                        _indirect_device_addresses: *const DeviceAddress,
                        _indirect_strides: *const u32,
                        _max_primitive_counts: *const *const u32,
                    ) {
                        panic!("could not load vkCmdBuildAccelerationStructuresIndirectKHR")
                    }
                    fallback
                }
            },
            cmd_build_acceleration_structures_khr: {
                let value = loader(c"vkCmdBuildAccelerationStructuresKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _info_count: u32,
                        _infos: *const AccelerationStructureBuildGeometryInfoKHR,
                        _build_range_infos: *const *const AccelerationStructureBuildRangeInfoKHR,
                    ) {
                        panic!("could not load vkCmdBuildAccelerationStructuresKHR")
                    }
                    fallback
                }
            },
            cmd_build_cluster_acceleration_structure_indirect_nv: {
                let value = loader(c"vkCmdBuildClusterAccelerationStructureIndirectNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _command_infos: *const ClusterAccelerationStructureCommandsInfoNV,
                    ) {
                        panic!("could not load vkCmdBuildClusterAccelerationStructureIndirectNV")
                    }
                    fallback
                }
            },
            cmd_build_micromaps_ext: {
                let value = loader(c"vkCmdBuildMicromapsEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _info_count: u32,
                        _infos: *const MicromapBuildInfoEXT,
                    ) {
                        panic!("could not load vkCmdBuildMicromapsEXT")
                    }
                    fallback
                }
            },
            cmd_build_partitioned_acceleration_structures_nv: {
                let value = loader(c"vkCmdBuildPartitionedAccelerationStructuresNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _build_info: *const BuildPartitionedAccelerationStructureInfoNV,
                    ) {
                        panic!("could not load vkCmdBuildPartitionedAccelerationStructuresNV")
                    }
                    fallback
                }
            },
            cmd_clear_attachments: {
                let value = loader(c"vkCmdClearAttachments".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _attachment_count: u32,
                        _attachments: *const ClearAttachment,
                        _rect_count: u32,
                        _rects: *const ClearRect,
                    ) {
                        panic!("could not load vkCmdClearAttachments")
                    }
                    fallback
                }
            },
            cmd_clear_color_image: {
                let value = loader(c"vkCmdClearColorImage".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _image: Image,
                        _image_layout: ImageLayout,
                        _color: *const ClearColorValue,
                        _range_count: u32,
                        _ranges: *const ImageSubresourceRange,
                    ) {
                        panic!("could not load vkCmdClearColorImage")
                    }
                    fallback
                }
            },
            cmd_clear_depth_stencil_image: {
                let value = loader(c"vkCmdClearDepthStencilImage".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _image: Image,
                        _image_layout: ImageLayout,
                        _depth_stencil: *const ClearDepthStencilValue,
                        _range_count: u32,
                        _ranges: *const ImageSubresourceRange,
                    ) {
                        panic!("could not load vkCmdClearDepthStencilImage")
                    }
                    fallback
                }
            },
            cmd_control_video_coding_khr: {
                let value = loader(c"vkCmdControlVideoCodingKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _coding_control_info: *const VideoCodingControlInfoKHR,
                    ) {
                        panic!("could not load vkCmdControlVideoCodingKHR")
                    }
                    fallback
                }
            },
            cmd_convert_cooperative_vector_matrix_nv: {
                let value = loader(c"vkCmdConvertCooperativeVectorMatrixNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _info_count: u32,
                        _infos: *const ConvertCooperativeVectorMatrixInfoNV,
                    ) {
                        panic!("could not load vkCmdConvertCooperativeVectorMatrixNV")
                    }
                    fallback
                }
            },
            cmd_copy_acceleration_structure_khr: {
                let value = loader(c"vkCmdCopyAccelerationStructureKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _info: *const CopyAccelerationStructureInfoKHR,
                    ) {
                        panic!("could not load vkCmdCopyAccelerationStructureKHR")
                    }
                    fallback
                }
            },
            cmd_copy_acceleration_structure_nv: {
                let value = loader(c"vkCmdCopyAccelerationStructureNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _dst: AccelerationStructureNV,
                        _src: AccelerationStructureNV,
                        _mode: CopyAccelerationStructureModeKHR,
                    ) {
                        panic!("could not load vkCmdCopyAccelerationStructureNV")
                    }
                    fallback
                }
            },
            cmd_copy_acceleration_structure_to_memory_khr: {
                let value = loader(c"vkCmdCopyAccelerationStructureToMemoryKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _info: *const CopyAccelerationStructureToMemoryInfoKHR,
                    ) {
                        panic!("could not load vkCmdCopyAccelerationStructureToMemoryKHR")
                    }
                    fallback
                }
            },
            cmd_copy_buffer: {
                let value = loader(c"vkCmdCopyBuffer".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _src_buffer: Buffer,
                        _dst_buffer: Buffer,
                        _region_count: u32,
                        _regions: *const BufferCopy,
                    ) {
                        panic!("could not load vkCmdCopyBuffer")
                    }
                    fallback
                }
            },
            cmd_copy_buffer2: {
                let value = loader(c"vkCmdCopyBuffer2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _copy_buffer_info: *const CopyBufferInfo2,
                    ) {
                        panic!("could not load vkCmdCopyBuffer2")
                    }
                    fallback
                }
            },
            cmd_copy_buffer2_khr: {
                let value = loader(c"vkCmdCopyBuffer2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _copy_buffer_info: *const CopyBufferInfo2,
                    ) {
                        panic!("could not load vkCmdCopyBuffer2KHR")
                    }
                    fallback
                }
            },
            cmd_copy_buffer_to_image: {
                let value = loader(c"vkCmdCopyBufferToImage".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _src_buffer: Buffer,
                        _dst_image: Image,
                        _dst_image_layout: ImageLayout,
                        _region_count: u32,
                        _regions: *const BufferImageCopy,
                    ) {
                        panic!("could not load vkCmdCopyBufferToImage")
                    }
                    fallback
                }
            },
            cmd_copy_buffer_to_image2: {
                let value = loader(c"vkCmdCopyBufferToImage2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _copy_buffer_to_image_info: *const CopyBufferToImageInfo2,
                    ) {
                        panic!("could not load vkCmdCopyBufferToImage2")
                    }
                    fallback
                }
            },
            cmd_copy_buffer_to_image2_khr: {
                let value = loader(c"vkCmdCopyBufferToImage2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _copy_buffer_to_image_info: *const CopyBufferToImageInfo2,
                    ) {
                        panic!("could not load vkCmdCopyBufferToImage2KHR")
                    }
                    fallback
                }
            },
            cmd_copy_image: {
                let value = loader(c"vkCmdCopyImage".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _src_image: Image,
                        _src_image_layout: ImageLayout,
                        _dst_image: Image,
                        _dst_image_layout: ImageLayout,
                        _region_count: u32,
                        _regions: *const ImageCopy,
                    ) {
                        panic!("could not load vkCmdCopyImage")
                    }
                    fallback
                }
            },
            cmd_copy_image2: {
                let value = loader(c"vkCmdCopyImage2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _copy_image_info: *const CopyImageInfo2,
                    ) {
                        panic!("could not load vkCmdCopyImage2")
                    }
                    fallback
                }
            },
            cmd_copy_image2_khr: {
                let value = loader(c"vkCmdCopyImage2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _copy_image_info: *const CopyImageInfo2,
                    ) {
                        panic!("could not load vkCmdCopyImage2KHR")
                    }
                    fallback
                }
            },
            cmd_copy_image_to_buffer: {
                let value = loader(c"vkCmdCopyImageToBuffer".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _src_image: Image,
                        _src_image_layout: ImageLayout,
                        _dst_buffer: Buffer,
                        _region_count: u32,
                        _regions: *const BufferImageCopy,
                    ) {
                        panic!("could not load vkCmdCopyImageToBuffer")
                    }
                    fallback
                }
            },
            cmd_copy_image_to_buffer2: {
                let value = loader(c"vkCmdCopyImageToBuffer2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _copy_image_to_buffer_info: *const CopyImageToBufferInfo2,
                    ) {
                        panic!("could not load vkCmdCopyImageToBuffer2")
                    }
                    fallback
                }
            },
            cmd_copy_image_to_buffer2_khr: {
                let value = loader(c"vkCmdCopyImageToBuffer2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _copy_image_to_buffer_info: *const CopyImageToBufferInfo2,
                    ) {
                        panic!("could not load vkCmdCopyImageToBuffer2KHR")
                    }
                    fallback
                }
            },
            cmd_copy_memory_indirect_nv: {
                let value = loader(c"vkCmdCopyMemoryIndirectNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _copy_buffer_address: DeviceAddress,
                        _copy_count: u32,
                        _stride: u32,
                    ) {
                        panic!("could not load vkCmdCopyMemoryIndirectNV")
                    }
                    fallback
                }
            },
            cmd_copy_memory_to_acceleration_structure_khr: {
                let value = loader(c"vkCmdCopyMemoryToAccelerationStructureKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _info: *const CopyMemoryToAccelerationStructureInfoKHR,
                    ) {
                        panic!("could not load vkCmdCopyMemoryToAccelerationStructureKHR")
                    }
                    fallback
                }
            },
            cmd_copy_memory_to_image_indirect_nv: {
                let value = loader(c"vkCmdCopyMemoryToImageIndirectNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _copy_buffer_address: DeviceAddress,
                        _copy_count: u32,
                        _stride: u32,
                        _dst_image: Image,
                        _dst_image_layout: ImageLayout,
                        _image_subresources: *const ImageSubresourceLayers,
                    ) {
                        panic!("could not load vkCmdCopyMemoryToImageIndirectNV")
                    }
                    fallback
                }
            },
            cmd_copy_memory_to_micromap_ext: {
                let value = loader(c"vkCmdCopyMemoryToMicromapEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _info: *const CopyMemoryToMicromapInfoEXT,
                    ) {
                        panic!("could not load vkCmdCopyMemoryToMicromapEXT")
                    }
                    fallback
                }
            },
            cmd_copy_micromap_ext: {
                let value = loader(c"vkCmdCopyMicromapEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _info: *const CopyMicromapInfoEXT,
                    ) {
                        panic!("could not load vkCmdCopyMicromapEXT")
                    }
                    fallback
                }
            },
            cmd_copy_micromap_to_memory_ext: {
                let value = loader(c"vkCmdCopyMicromapToMemoryEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _info: *const CopyMicromapToMemoryInfoEXT,
                    ) {
                        panic!("could not load vkCmdCopyMicromapToMemoryEXT")
                    }
                    fallback
                }
            },
            cmd_copy_query_pool_results: {
                let value = loader(c"vkCmdCopyQueryPoolResults".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _query_pool: QueryPool,
                        _first_query: u32,
                        _query_count: u32,
                        _dst_buffer: Buffer,
                        _dst_offset: DeviceSize,
                        _stride: DeviceSize,
                        _flags: QueryResultFlags,
                    ) {
                        panic!("could not load vkCmdCopyQueryPoolResults")
                    }
                    fallback
                }
            },
            cmd_copy_tensor_arm: {
                let value = loader(c"vkCmdCopyTensorARM".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _copy_tensor_info: *const CopyTensorInfoARM,
                    ) {
                        panic!("could not load vkCmdCopyTensorARM")
                    }
                    fallback
                }
            },
            cmd_cu_launch_kernel_nvx: {
                let value = loader(c"vkCmdCuLaunchKernelNVX".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _launch_info: *const CuLaunchInfoNVX,
                    ) {
                        panic!("could not load vkCmdCuLaunchKernelNVX")
                    }
                    fallback
                }
            },
            cmd_cuda_launch_kernel_nv: {
                let value = loader(c"vkCmdCudaLaunchKernelNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _launch_info: *const CudaLaunchInfoNV,
                    ) {
                        panic!("could not load vkCmdCudaLaunchKernelNV")
                    }
                    fallback
                }
            },
            cmd_debug_marker_begin_ext: {
                let value = loader(c"vkCmdDebugMarkerBeginEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _marker_info: *const DebugMarkerMarkerInfoEXT,
                    ) {
                        panic!("could not load vkCmdDebugMarkerBeginEXT")
                    }
                    fallback
                }
            },
            cmd_debug_marker_end_ext: {
                let value = loader(c"vkCmdDebugMarkerEndEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(_command_buffer: CommandBuffer) {
                        panic!("could not load vkCmdDebugMarkerEndEXT")
                    }
                    fallback
                }
            },
            cmd_debug_marker_insert_ext: {
                let value = loader(c"vkCmdDebugMarkerInsertEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _marker_info: *const DebugMarkerMarkerInfoEXT,
                    ) {
                        panic!("could not load vkCmdDebugMarkerInsertEXT")
                    }
                    fallback
                }
            },
            cmd_decode_video_khr: {
                let value = loader(c"vkCmdDecodeVideoKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _decode_info: *const VideoDecodeInfoKHR,
                    ) {
                        panic!("could not load vkCmdDecodeVideoKHR")
                    }
                    fallback
                }
            },
            cmd_decompress_memory_indirect_count_nv: {
                let value = loader(c"vkCmdDecompressMemoryIndirectCountNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _indirect_commands_address: DeviceAddress,
                        _indirect_commands_count_address: DeviceAddress,
                        _stride: u32,
                    ) {
                        panic!("could not load vkCmdDecompressMemoryIndirectCountNV")
                    }
                    fallback
                }
            },
            cmd_decompress_memory_nv: {
                let value = loader(c"vkCmdDecompressMemoryNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _decompress_region_count: u32,
                        _decompress_memory_regions: *const DecompressMemoryRegionNV,
                    ) {
                        panic!("could not load vkCmdDecompressMemoryNV")
                    }
                    fallback
                }
            },
            cmd_dispatch: {
                let value = loader(c"vkCmdDispatch".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _group_count_x: u32,
                        _group_count_y: u32,
                        _group_count_z: u32,
                    ) {
                        panic!("could not load vkCmdDispatch")
                    }
                    fallback
                }
            },
            cmd_dispatch_base: {
                let value = loader(c"vkCmdDispatchBase".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _base_group_x: u32,
                        _base_group_y: u32,
                        _base_group_z: u32,
                        _group_count_x: u32,
                        _group_count_y: u32,
                        _group_count_z: u32,
                    ) {
                        panic!("could not load vkCmdDispatchBase")
                    }
                    fallback
                }
            },
            cmd_dispatch_base_khr: {
                let value = loader(c"vkCmdDispatchBaseKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _base_group_x: u32,
                        _base_group_y: u32,
                        _base_group_z: u32,
                        _group_count_x: u32,
                        _group_count_y: u32,
                        _group_count_z: u32,
                    ) {
                        panic!("could not load vkCmdDispatchBaseKHR")
                    }
                    fallback
                }
            },
            cmd_dispatch_data_graph_arm: {
                let value = loader(c"vkCmdDispatchDataGraphARM".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _session: DataGraphPipelineSessionARM,
                        _info: *const DataGraphPipelineDispatchInfoARM,
                    ) {
                        panic!("could not load vkCmdDispatchDataGraphARM")
                    }
                    fallback
                }
            },
            cmd_dispatch_graph_amdx: {
                let value = loader(c"vkCmdDispatchGraphAMDX".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _scratch: DeviceAddress,
                        _scratch_size: DeviceSize,
                        _count_info: *const DispatchGraphCountInfoAMDX,
                    ) {
                        panic!("could not load vkCmdDispatchGraphAMDX")
                    }
                    fallback
                }
            },
            cmd_dispatch_graph_indirect_amdx: {
                let value = loader(c"vkCmdDispatchGraphIndirectAMDX".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _scratch: DeviceAddress,
                        _scratch_size: DeviceSize,
                        _count_info: *const DispatchGraphCountInfoAMDX,
                    ) {
                        panic!("could not load vkCmdDispatchGraphIndirectAMDX")
                    }
                    fallback
                }
            },
            cmd_dispatch_graph_indirect_count_amdx: {
                let value = loader(c"vkCmdDispatchGraphIndirectCountAMDX".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _scratch: DeviceAddress,
                        _scratch_size: DeviceSize,
                        _count_info: DeviceAddress,
                    ) {
                        panic!("could not load vkCmdDispatchGraphIndirectCountAMDX")
                    }
                    fallback
                }
            },
            cmd_dispatch_indirect: {
                let value = loader(c"vkCmdDispatchIndirect".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _buffer: Buffer,
                        _offset: DeviceSize,
                    ) {
                        panic!("could not load vkCmdDispatchIndirect")
                    }
                    fallback
                }
            },
            cmd_dispatch_tile_qcom: {
                let value = loader(c"vkCmdDispatchTileQCOM".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _dispatch_tile_info: *const DispatchTileInfoQCOM,
                    ) {
                        panic!("could not load vkCmdDispatchTileQCOM")
                    }
                    fallback
                }
            },
            cmd_draw: {
                let value = loader(c"vkCmdDraw".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _vertex_count: u32,
                        _instance_count: u32,
                        _first_vertex: u32,
                        _first_instance: u32,
                    ) {
                        panic!("could not load vkCmdDraw")
                    }
                    fallback
                }
            },
            cmd_draw_cluster_huawei: {
                let value = loader(c"vkCmdDrawClusterHUAWEI".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _group_count_x: u32,
                        _group_count_y: u32,
                        _group_count_z: u32,
                    ) {
                        panic!("could not load vkCmdDrawClusterHUAWEI")
                    }
                    fallback
                }
            },
            cmd_draw_cluster_indirect_huawei: {
                let value = loader(c"vkCmdDrawClusterIndirectHUAWEI".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _buffer: Buffer,
                        _offset: DeviceSize,
                    ) {
                        panic!("could not load vkCmdDrawClusterIndirectHUAWEI")
                    }
                    fallback
                }
            },
            cmd_draw_indexed: {
                let value = loader(c"vkCmdDrawIndexed".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _index_count: u32,
                        _instance_count: u32,
                        _first_index: u32,
                        _vertex_offset: i32,
                        _first_instance: u32,
                    ) {
                        panic!("could not load vkCmdDrawIndexed")
                    }
                    fallback
                }
            },
            cmd_draw_indexed_indirect: {
                let value = loader(c"vkCmdDrawIndexedIndirect".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _buffer: Buffer,
                        _offset: DeviceSize,
                        _draw_count: u32,
                        _stride: u32,
                    ) {
                        panic!("could not load vkCmdDrawIndexedIndirect")
                    }
                    fallback
                }
            },
            cmd_draw_indexed_indirect_count: {
                let value = loader(c"vkCmdDrawIndexedIndirectCount".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _buffer: Buffer,
                        _offset: DeviceSize,
                        _count_buffer: Buffer,
                        _count_buffer_offset: DeviceSize,
                        _max_draw_count: u32,
                        _stride: u32,
                    ) {
                        panic!("could not load vkCmdDrawIndexedIndirectCount")
                    }
                    fallback
                }
            },
            cmd_draw_indexed_indirect_count_amd: {
                let value = loader(c"vkCmdDrawIndexedIndirectCountAMD".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _buffer: Buffer,
                        _offset: DeviceSize,
                        _count_buffer: Buffer,
                        _count_buffer_offset: DeviceSize,
                        _max_draw_count: u32,
                        _stride: u32,
                    ) {
                        panic!("could not load vkCmdDrawIndexedIndirectCountAMD")
                    }
                    fallback
                }
            },
            cmd_draw_indexed_indirect_count_khr: {
                let value = loader(c"vkCmdDrawIndexedIndirectCountKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _buffer: Buffer,
                        _offset: DeviceSize,
                        _count_buffer: Buffer,
                        _count_buffer_offset: DeviceSize,
                        _max_draw_count: u32,
                        _stride: u32,
                    ) {
                        panic!("could not load vkCmdDrawIndexedIndirectCountKHR")
                    }
                    fallback
                }
            },
            cmd_draw_indirect: {
                let value = loader(c"vkCmdDrawIndirect".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _buffer: Buffer,
                        _offset: DeviceSize,
                        _draw_count: u32,
                        _stride: u32,
                    ) {
                        panic!("could not load vkCmdDrawIndirect")
                    }
                    fallback
                }
            },
            cmd_draw_indirect_byte_count_ext: {
                let value = loader(c"vkCmdDrawIndirectByteCountEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _instance_count: u32,
                        _first_instance: u32,
                        _counter_buffer: Buffer,
                        _counter_buffer_offset: DeviceSize,
                        _counter_offset: u32,
                        _vertex_stride: u32,
                    ) {
                        panic!("could not load vkCmdDrawIndirectByteCountEXT")
                    }
                    fallback
                }
            },
            cmd_draw_indirect_count: {
                let value = loader(c"vkCmdDrawIndirectCount".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _buffer: Buffer,
                        _offset: DeviceSize,
                        _count_buffer: Buffer,
                        _count_buffer_offset: DeviceSize,
                        _max_draw_count: u32,
                        _stride: u32,
                    ) {
                        panic!("could not load vkCmdDrawIndirectCount")
                    }
                    fallback
                }
            },
            cmd_draw_indirect_count_amd: {
                let value = loader(c"vkCmdDrawIndirectCountAMD".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _buffer: Buffer,
                        _offset: DeviceSize,
                        _count_buffer: Buffer,
                        _count_buffer_offset: DeviceSize,
                        _max_draw_count: u32,
                        _stride: u32,
                    ) {
                        panic!("could not load vkCmdDrawIndirectCountAMD")
                    }
                    fallback
                }
            },
            cmd_draw_indirect_count_khr: {
                let value = loader(c"vkCmdDrawIndirectCountKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _buffer: Buffer,
                        _offset: DeviceSize,
                        _count_buffer: Buffer,
                        _count_buffer_offset: DeviceSize,
                        _max_draw_count: u32,
                        _stride: u32,
                    ) {
                        panic!("could not load vkCmdDrawIndirectCountKHR")
                    }
                    fallback
                }
            },
            cmd_draw_mesh_tasks_ext: {
                let value = loader(c"vkCmdDrawMeshTasksEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _group_count_x: u32,
                        _group_count_y: u32,
                        _group_count_z: u32,
                    ) {
                        panic!("could not load vkCmdDrawMeshTasksEXT")
                    }
                    fallback
                }
            },
            cmd_draw_mesh_tasks_indirect_count_ext: {
                let value = loader(c"vkCmdDrawMeshTasksIndirectCountEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _buffer: Buffer,
                        _offset: DeviceSize,
                        _count_buffer: Buffer,
                        _count_buffer_offset: DeviceSize,
                        _max_draw_count: u32,
                        _stride: u32,
                    ) {
                        panic!("could not load vkCmdDrawMeshTasksIndirectCountEXT")
                    }
                    fallback
                }
            },
            cmd_draw_mesh_tasks_indirect_count_nv: {
                let value = loader(c"vkCmdDrawMeshTasksIndirectCountNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _buffer: Buffer,
                        _offset: DeviceSize,
                        _count_buffer: Buffer,
                        _count_buffer_offset: DeviceSize,
                        _max_draw_count: u32,
                        _stride: u32,
                    ) {
                        panic!("could not load vkCmdDrawMeshTasksIndirectCountNV")
                    }
                    fallback
                }
            },
            cmd_draw_mesh_tasks_indirect_ext: {
                let value = loader(c"vkCmdDrawMeshTasksIndirectEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _buffer: Buffer,
                        _offset: DeviceSize,
                        _draw_count: u32,
                        _stride: u32,
                    ) {
                        panic!("could not load vkCmdDrawMeshTasksIndirectEXT")
                    }
                    fallback
                }
            },
            cmd_draw_mesh_tasks_indirect_nv: {
                let value = loader(c"vkCmdDrawMeshTasksIndirectNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _buffer: Buffer,
                        _offset: DeviceSize,
                        _draw_count: u32,
                        _stride: u32,
                    ) {
                        panic!("could not load vkCmdDrawMeshTasksIndirectNV")
                    }
                    fallback
                }
            },
            cmd_draw_mesh_tasks_nv: {
                let value = loader(c"vkCmdDrawMeshTasksNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _task_count: u32,
                        _first_task: u32,
                    ) {
                        panic!("could not load vkCmdDrawMeshTasksNV")
                    }
                    fallback
                }
            },
            cmd_draw_multi_ext: {
                let value = loader(c"vkCmdDrawMultiEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _draw_count: u32,
                        _vertex_info: *const MultiDrawInfoEXT,
                        _instance_count: u32,
                        _first_instance: u32,
                        _stride: u32,
                    ) {
                        panic!("could not load vkCmdDrawMultiEXT")
                    }
                    fallback
                }
            },
            cmd_draw_multi_indexed_ext: {
                let value = loader(c"vkCmdDrawMultiIndexedEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _draw_count: u32,
                        _index_info: *const MultiDrawIndexedInfoEXT,
                        _instance_count: u32,
                        _first_instance: u32,
                        _stride: u32,
                        _vertex_offset: *const i32,
                    ) {
                        panic!("could not load vkCmdDrawMultiIndexedEXT")
                    }
                    fallback
                }
            },
            cmd_encode_video_khr: {
                let value = loader(c"vkCmdEncodeVideoKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _encode_info: *const VideoEncodeInfoKHR,
                    ) {
                        panic!("could not load vkCmdEncodeVideoKHR")
                    }
                    fallback
                }
            },
            cmd_end_conditional_rendering_ext: {
                let value = loader(c"vkCmdEndConditionalRenderingEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(_command_buffer: CommandBuffer) {
                        panic!("could not load vkCmdEndConditionalRenderingEXT")
                    }
                    fallback
                }
            },
            cmd_end_per_tile_execution_qcom: {
                let value = loader(c"vkCmdEndPerTileExecutionQCOM".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _per_tile_end_info: *const PerTileEndInfoQCOM,
                    ) {
                        panic!("could not load vkCmdEndPerTileExecutionQCOM")
                    }
                    fallback
                }
            },
            cmd_end_query: {
                let value = loader(c"vkCmdEndQuery".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _query_pool: QueryPool,
                        _query: u32,
                    ) {
                        panic!("could not load vkCmdEndQuery")
                    }
                    fallback
                }
            },
            cmd_end_query_indexed_ext: {
                let value = loader(c"vkCmdEndQueryIndexedEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _query_pool: QueryPool,
                        _query: u32,
                        _index: u32,
                    ) {
                        panic!("could not load vkCmdEndQueryIndexedEXT")
                    }
                    fallback
                }
            },
            cmd_end_render_pass: {
                let value = loader(c"vkCmdEndRenderPass".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(_command_buffer: CommandBuffer) {
                        panic!("could not load vkCmdEndRenderPass")
                    }
                    fallback
                }
            },
            cmd_end_render_pass2: {
                let value = loader(c"vkCmdEndRenderPass2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _subpass_end_info: *const SubpassEndInfo,
                    ) {
                        panic!("could not load vkCmdEndRenderPass2")
                    }
                    fallback
                }
            },
            cmd_end_render_pass2_khr: {
                let value = loader(c"vkCmdEndRenderPass2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _subpass_end_info: *const SubpassEndInfo,
                    ) {
                        panic!("could not load vkCmdEndRenderPass2KHR")
                    }
                    fallback
                }
            },
            cmd_end_rendering: {
                let value = loader(c"vkCmdEndRendering".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(_command_buffer: CommandBuffer) {
                        panic!("could not load vkCmdEndRendering")
                    }
                    fallback
                }
            },
            cmd_end_rendering2_ext: {
                let value = loader(c"vkCmdEndRendering2EXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _rendering_end_info: *const RenderingEndInfoEXT,
                    ) {
                        panic!("could not load vkCmdEndRendering2EXT")
                    }
                    fallback
                }
            },
            cmd_end_rendering_khr: {
                let value = loader(c"vkCmdEndRenderingKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(_command_buffer: CommandBuffer) {
                        panic!("could not load vkCmdEndRenderingKHR")
                    }
                    fallback
                }
            },
            cmd_end_transform_feedback_ext: {
                let value = loader(c"vkCmdEndTransformFeedbackEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _first_counter_buffer: u32,
                        _counter_buffer_count: u32,
                        _counter_buffers: *const Buffer,
                        _counter_buffer_offsets: *const DeviceSize,
                    ) {
                        panic!("could not load vkCmdEndTransformFeedbackEXT")
                    }
                    fallback
                }
            },
            cmd_end_video_coding_khr: {
                let value = loader(c"vkCmdEndVideoCodingKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _end_coding_info: *const VideoEndCodingInfoKHR,
                    ) {
                        panic!("could not load vkCmdEndVideoCodingKHR")
                    }
                    fallback
                }
            },
            cmd_execute_commands: {
                let value = loader(c"vkCmdExecuteCommands".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _command_buffer_count: u32,
                        _command_buffers: *const CommandBuffer,
                    ) {
                        panic!("could not load vkCmdExecuteCommands")
                    }
                    fallback
                }
            },
            cmd_execute_generated_commands_ext: {
                let value = loader(c"vkCmdExecuteGeneratedCommandsEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _is_preprocessed: Bool32,
                        _generated_commands_info: *const GeneratedCommandsInfoEXT,
                    ) {
                        panic!("could not load vkCmdExecuteGeneratedCommandsEXT")
                    }
                    fallback
                }
            },
            cmd_execute_generated_commands_nv: {
                let value = loader(c"vkCmdExecuteGeneratedCommandsNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _is_preprocessed: Bool32,
                        _generated_commands_info: *const GeneratedCommandsInfoNV,
                    ) {
                        panic!("could not load vkCmdExecuteGeneratedCommandsNV")
                    }
                    fallback
                }
            },
            cmd_fill_buffer: {
                let value = loader(c"vkCmdFillBuffer".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _dst_buffer: Buffer,
                        _dst_offset: DeviceSize,
                        _size: DeviceSize,
                        _data: u32,
                    ) {
                        panic!("could not load vkCmdFillBuffer")
                    }
                    fallback
                }
            },
            cmd_initialize_graph_scratch_memory_amdx: {
                let value = loader(c"vkCmdInitializeGraphScratchMemoryAMDX".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _execution_graph: Pipeline,
                        _scratch: DeviceAddress,
                        _scratch_size: DeviceSize,
                    ) {
                        panic!("could not load vkCmdInitializeGraphScratchMemoryAMDX")
                    }
                    fallback
                }
            },
            cmd_next_subpass: {
                let value = loader(c"vkCmdNextSubpass".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _contents: SubpassContents,
                    ) {
                        panic!("could not load vkCmdNextSubpass")
                    }
                    fallback
                }
            },
            cmd_next_subpass2: {
                let value = loader(c"vkCmdNextSubpass2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _subpass_begin_info: *const SubpassBeginInfo,
                        _subpass_end_info: *const SubpassEndInfo,
                    ) {
                        panic!("could not load vkCmdNextSubpass2")
                    }
                    fallback
                }
            },
            cmd_next_subpass2_khr: {
                let value = loader(c"vkCmdNextSubpass2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _subpass_begin_info: *const SubpassBeginInfo,
                        _subpass_end_info: *const SubpassEndInfo,
                    ) {
                        panic!("could not load vkCmdNextSubpass2KHR")
                    }
                    fallback
                }
            },
            cmd_optical_flow_execute_nv: {
                let value = loader(c"vkCmdOpticalFlowExecuteNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _session: OpticalFlowSessionNV,
                        _execute_info: *const OpticalFlowExecuteInfoNV,
                    ) {
                        panic!("could not load vkCmdOpticalFlowExecuteNV")
                    }
                    fallback
                }
            },
            cmd_pipeline_barrier: {
                let value = loader(c"vkCmdPipelineBarrier".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _src_stage_mask: PipelineStageFlags,
                        _dst_stage_mask: PipelineStageFlags,
                        _dependency_flags: DependencyFlags,
                        _memory_barrier_count: u32,
                        _memory_barriers: *const MemoryBarrier,
                        _buffer_memory_barrier_count: u32,
                        _buffer_memory_barriers: *const BufferMemoryBarrier,
                        _image_memory_barrier_count: u32,
                        _image_memory_barriers: *const ImageMemoryBarrier,
                    ) {
                        panic!("could not load vkCmdPipelineBarrier")
                    }
                    fallback
                }
            },
            cmd_pipeline_barrier2: {
                let value = loader(c"vkCmdPipelineBarrier2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _dependency_info: *const DependencyInfo,
                    ) {
                        panic!("could not load vkCmdPipelineBarrier2")
                    }
                    fallback
                }
            },
            cmd_pipeline_barrier2_khr: {
                let value = loader(c"vkCmdPipelineBarrier2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _dependency_info: *const DependencyInfo,
                    ) {
                        panic!("could not load vkCmdPipelineBarrier2KHR")
                    }
                    fallback
                }
            },
            cmd_preprocess_generated_commands_ext: {
                let value = loader(c"vkCmdPreprocessGeneratedCommandsEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _generated_commands_info: *const GeneratedCommandsInfoEXT,
                        _state_command_buffer: CommandBuffer,
                    ) {
                        panic!("could not load vkCmdPreprocessGeneratedCommandsEXT")
                    }
                    fallback
                }
            },
            cmd_preprocess_generated_commands_nv: {
                let value = loader(c"vkCmdPreprocessGeneratedCommandsNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _generated_commands_info: *const GeneratedCommandsInfoNV,
                    ) {
                        panic!("could not load vkCmdPreprocessGeneratedCommandsNV")
                    }
                    fallback
                }
            },
            cmd_push_constants: {
                let value = loader(c"vkCmdPushConstants".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _layout: PipelineLayout,
                        _stage_flags: ShaderStageFlags,
                        _offset: u32,
                        _size: u32,
                        _values: *const c_void,
                    ) {
                        panic!("could not load vkCmdPushConstants")
                    }
                    fallback
                }
            },
            cmd_push_constants2: {
                let value = loader(c"vkCmdPushConstants2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _push_constants_info: *const PushConstantsInfo,
                    ) {
                        panic!("could not load vkCmdPushConstants2")
                    }
                    fallback
                }
            },
            cmd_push_constants2_khr: {
                let value = loader(c"vkCmdPushConstants2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _push_constants_info: *const PushConstantsInfo,
                    ) {
                        panic!("could not load vkCmdPushConstants2KHR")
                    }
                    fallback
                }
            },
            cmd_push_descriptor_set: {
                let value = loader(c"vkCmdPushDescriptorSet".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _pipeline_bind_point: PipelineBindPoint,
                        _layout: PipelineLayout,
                        _set: u32,
                        _descriptor_write_count: u32,
                        _descriptor_writes: *const WriteDescriptorSet,
                    ) {
                        panic!("could not load vkCmdPushDescriptorSet")
                    }
                    fallback
                }
            },
            cmd_push_descriptor_set2: {
                let value = loader(c"vkCmdPushDescriptorSet2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _push_descriptor_set_info: *const PushDescriptorSetInfo,
                    ) {
                        panic!("could not load vkCmdPushDescriptorSet2")
                    }
                    fallback
                }
            },
            cmd_push_descriptor_set2_khr: {
                let value = loader(c"vkCmdPushDescriptorSet2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _push_descriptor_set_info: *const PushDescriptorSetInfo,
                    ) {
                        panic!("could not load vkCmdPushDescriptorSet2KHR")
                    }
                    fallback
                }
            },
            cmd_push_descriptor_set_khr: {
                let value = loader(c"vkCmdPushDescriptorSetKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _pipeline_bind_point: PipelineBindPoint,
                        _layout: PipelineLayout,
                        _set: u32,
                        _descriptor_write_count: u32,
                        _descriptor_writes: *const WriteDescriptorSet,
                    ) {
                        panic!("could not load vkCmdPushDescriptorSetKHR")
                    }
                    fallback
                }
            },
            cmd_push_descriptor_set_with_template: {
                let value = loader(c"vkCmdPushDescriptorSetWithTemplate".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _descriptor_update_template: DescriptorUpdateTemplate,
                        _layout: PipelineLayout,
                        _set: u32,
                        _data: *const c_void,
                    ) {
                        panic!("could not load vkCmdPushDescriptorSetWithTemplate")
                    }
                    fallback
                }
            },
            cmd_push_descriptor_set_with_template2: {
                let value = loader(c"vkCmdPushDescriptorSetWithTemplate2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _push_descriptor_set_with_template_info: *const PushDescriptorSetWithTemplateInfo,
                    ) {
                        panic!("could not load vkCmdPushDescriptorSetWithTemplate2")
                    }
                    fallback
                }
            },
            cmd_push_descriptor_set_with_template2_khr: {
                let value = loader(c"vkCmdPushDescriptorSetWithTemplate2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _push_descriptor_set_with_template_info: *const PushDescriptorSetWithTemplateInfo,
                    ) {
                        panic!("could not load vkCmdPushDescriptorSetWithTemplate2KHR")
                    }
                    fallback
                }
            },
            cmd_push_descriptor_set_with_template_khr: {
                let value = loader(c"vkCmdPushDescriptorSetWithTemplateKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _descriptor_update_template: DescriptorUpdateTemplate,
                        _layout: PipelineLayout,
                        _set: u32,
                        _data: *const c_void,
                    ) {
                        panic!("could not load vkCmdPushDescriptorSetWithTemplateKHR")
                    }
                    fallback
                }
            },
            cmd_refresh_objects_khr: {
                let value = loader(c"vkCmdRefreshObjectsKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _refresh_objects: *const RefreshObjectListKHR,
                    ) {
                        panic!("could not load vkCmdRefreshObjectsKHR")
                    }
                    fallback
                }
            },
            cmd_reset_event: {
                let value = loader(c"vkCmdResetEvent".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _event: Event,
                        _stage_mask: PipelineStageFlags,
                    ) {
                        panic!("could not load vkCmdResetEvent")
                    }
                    fallback
                }
            },
            cmd_reset_event2: {
                let value = loader(c"vkCmdResetEvent2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _event: Event,
                        _stage_mask: PipelineStageFlags2,
                    ) {
                        panic!("could not load vkCmdResetEvent2")
                    }
                    fallback
                }
            },
            cmd_reset_event2_khr: {
                let value = loader(c"vkCmdResetEvent2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _event: Event,
                        _stage_mask: PipelineStageFlags2,
                    ) {
                        panic!("could not load vkCmdResetEvent2KHR")
                    }
                    fallback
                }
            },
            cmd_reset_query_pool: {
                let value = loader(c"vkCmdResetQueryPool".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _query_pool: QueryPool,
                        _first_query: u32,
                        _query_count: u32,
                    ) {
                        panic!("could not load vkCmdResetQueryPool")
                    }
                    fallback
                }
            },
            cmd_resolve_image: {
                let value = loader(c"vkCmdResolveImage".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _src_image: Image,
                        _src_image_layout: ImageLayout,
                        _dst_image: Image,
                        _dst_image_layout: ImageLayout,
                        _region_count: u32,
                        _regions: *const ImageResolve,
                    ) {
                        panic!("could not load vkCmdResolveImage")
                    }
                    fallback
                }
            },
            cmd_resolve_image2: {
                let value = loader(c"vkCmdResolveImage2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _resolve_image_info: *const ResolveImageInfo2,
                    ) {
                        panic!("could not load vkCmdResolveImage2")
                    }
                    fallback
                }
            },
            cmd_resolve_image2_khr: {
                let value = loader(c"vkCmdResolveImage2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _resolve_image_info: *const ResolveImageInfo2,
                    ) {
                        panic!("could not load vkCmdResolveImage2KHR")
                    }
                    fallback
                }
            },
            cmd_set_alpha_to_coverage_enable_ext: {
                let value = loader(c"vkCmdSetAlphaToCoverageEnableEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _alpha_to_coverage_enable: Bool32,
                    ) {
                        panic!("could not load vkCmdSetAlphaToCoverageEnableEXT")
                    }
                    fallback
                }
            },
            cmd_set_alpha_to_one_enable_ext: {
                let value = loader(c"vkCmdSetAlphaToOneEnableEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _alpha_to_one_enable: Bool32,
                    ) {
                        panic!("could not load vkCmdSetAlphaToOneEnableEXT")
                    }
                    fallback
                }
            },
            cmd_set_attachment_feedback_loop_enable_ext: {
                let value = loader(c"vkCmdSetAttachmentFeedbackLoopEnableEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _aspect_mask: ImageAspectFlags,
                    ) {
                        panic!("could not load vkCmdSetAttachmentFeedbackLoopEnableEXT")
                    }
                    fallback
                }
            },
            cmd_set_blend_constants: {
                let value = loader(c"vkCmdSetBlendConstants".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _blend_constants: *const f32,
                    ) {
                        panic!("could not load vkCmdSetBlendConstants")
                    }
                    fallback
                }
            },
            cmd_set_checkpoint_nv: {
                let value = loader(c"vkCmdSetCheckpointNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _checkpoint_marker: *const c_void,
                    ) {
                        panic!("could not load vkCmdSetCheckpointNV")
                    }
                    fallback
                }
            },
            cmd_set_coarse_sample_order_nv: {
                let value = loader(c"vkCmdSetCoarseSampleOrderNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _sample_order_type: CoarseSampleOrderTypeNV,
                        _custom_sample_order_count: u32,
                        _custom_sample_orders: *const CoarseSampleOrderCustomNV,
                    ) {
                        panic!("could not load vkCmdSetCoarseSampleOrderNV")
                    }
                    fallback
                }
            },
            cmd_set_color_blend_advanced_ext: {
                let value = loader(c"vkCmdSetColorBlendAdvancedEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _first_attachment: u32,
                        _attachment_count: u32,
                        _color_blend_advanced: *const ColorBlendAdvancedEXT,
                    ) {
                        panic!("could not load vkCmdSetColorBlendAdvancedEXT")
                    }
                    fallback
                }
            },
            cmd_set_color_blend_enable_ext: {
                let value = loader(c"vkCmdSetColorBlendEnableEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _first_attachment: u32,
                        _attachment_count: u32,
                        _color_blend_enables: *const Bool32,
                    ) {
                        panic!("could not load vkCmdSetColorBlendEnableEXT")
                    }
                    fallback
                }
            },
            cmd_set_color_blend_equation_ext: {
                let value = loader(c"vkCmdSetColorBlendEquationEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _first_attachment: u32,
                        _attachment_count: u32,
                        _color_blend_equations: *const ColorBlendEquationEXT,
                    ) {
                        panic!("could not load vkCmdSetColorBlendEquationEXT")
                    }
                    fallback
                }
            },
            cmd_set_color_write_enable_ext: {
                let value = loader(c"vkCmdSetColorWriteEnableEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _attachment_count: u32,
                        _color_write_enables: *const Bool32,
                    ) {
                        panic!("could not load vkCmdSetColorWriteEnableEXT")
                    }
                    fallback
                }
            },
            cmd_set_color_write_mask_ext: {
                let value = loader(c"vkCmdSetColorWriteMaskEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _first_attachment: u32,
                        _attachment_count: u32,
                        _color_write_masks: *const ColorComponentFlags,
                    ) {
                        panic!("could not load vkCmdSetColorWriteMaskEXT")
                    }
                    fallback
                }
            },
            cmd_set_conservative_rasterization_mode_ext: {
                let value = loader(c"vkCmdSetConservativeRasterizationModeEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _conservative_rasterization_mode: ConservativeRasterizationModeEXT,
                    ) {
                        panic!("could not load vkCmdSetConservativeRasterizationModeEXT")
                    }
                    fallback
                }
            },
            cmd_set_coverage_modulation_mode_nv: {
                let value = loader(c"vkCmdSetCoverageModulationModeNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _coverage_modulation_mode: CoverageModulationModeNV,
                    ) {
                        panic!("could not load vkCmdSetCoverageModulationModeNV")
                    }
                    fallback
                }
            },
            cmd_set_coverage_modulation_table_enable_nv: {
                let value = loader(c"vkCmdSetCoverageModulationTableEnableNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _coverage_modulation_table_enable: Bool32,
                    ) {
                        panic!("could not load vkCmdSetCoverageModulationTableEnableNV")
                    }
                    fallback
                }
            },
            cmd_set_coverage_modulation_table_nv: {
                let value = loader(c"vkCmdSetCoverageModulationTableNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _coverage_modulation_table_count: u32,
                        _coverage_modulation_table: *const f32,
                    ) {
                        panic!("could not load vkCmdSetCoverageModulationTableNV")
                    }
                    fallback
                }
            },
            cmd_set_coverage_reduction_mode_nv: {
                let value = loader(c"vkCmdSetCoverageReductionModeNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _coverage_reduction_mode: CoverageReductionModeNV,
                    ) {
                        panic!("could not load vkCmdSetCoverageReductionModeNV")
                    }
                    fallback
                }
            },
            cmd_set_coverage_to_color_enable_nv: {
                let value = loader(c"vkCmdSetCoverageToColorEnableNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _coverage_to_color_enable: Bool32,
                    ) {
                        panic!("could not load vkCmdSetCoverageToColorEnableNV")
                    }
                    fallback
                }
            },
            cmd_set_coverage_to_color_location_nv: {
                let value = loader(c"vkCmdSetCoverageToColorLocationNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _coverage_to_color_location: u32,
                    ) {
                        panic!("could not load vkCmdSetCoverageToColorLocationNV")
                    }
                    fallback
                }
            },
            cmd_set_cull_mode: {
                let value = loader(c"vkCmdSetCullMode".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _cull_mode: CullModeFlags,
                    ) {
                        panic!("could not load vkCmdSetCullMode")
                    }
                    fallback
                }
            },
            cmd_set_cull_mode_ext: {
                let value = loader(c"vkCmdSetCullModeEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _cull_mode: CullModeFlags,
                    ) {
                        panic!("could not load vkCmdSetCullModeEXT")
                    }
                    fallback
                }
            },
            cmd_set_depth_bias: {
                let value = loader(c"vkCmdSetDepthBias".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _depth_bias_constant_factor: f32,
                        _depth_bias_clamp: f32,
                        _depth_bias_slope_factor: f32,
                    ) {
                        panic!("could not load vkCmdSetDepthBias")
                    }
                    fallback
                }
            },
            cmd_set_depth_bias2_ext: {
                let value = loader(c"vkCmdSetDepthBias2EXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _depth_bias_info: *const DepthBiasInfoEXT,
                    ) {
                        panic!("could not load vkCmdSetDepthBias2EXT")
                    }
                    fallback
                }
            },
            cmd_set_depth_bias_enable: {
                let value = loader(c"vkCmdSetDepthBiasEnable".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _depth_bias_enable: Bool32,
                    ) {
                        panic!("could not load vkCmdSetDepthBiasEnable")
                    }
                    fallback
                }
            },
            cmd_set_depth_bias_enable_ext: {
                let value = loader(c"vkCmdSetDepthBiasEnableEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _depth_bias_enable: Bool32,
                    ) {
                        panic!("could not load vkCmdSetDepthBiasEnableEXT")
                    }
                    fallback
                }
            },
            cmd_set_depth_bounds: {
                let value = loader(c"vkCmdSetDepthBounds".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _min_depth_bounds: f32,
                        _max_depth_bounds: f32,
                    ) {
                        panic!("could not load vkCmdSetDepthBounds")
                    }
                    fallback
                }
            },
            cmd_set_depth_bounds_test_enable: {
                let value = loader(c"vkCmdSetDepthBoundsTestEnable".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _depth_bounds_test_enable: Bool32,
                    ) {
                        panic!("could not load vkCmdSetDepthBoundsTestEnable")
                    }
                    fallback
                }
            },
            cmd_set_depth_bounds_test_enable_ext: {
                let value = loader(c"vkCmdSetDepthBoundsTestEnableEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _depth_bounds_test_enable: Bool32,
                    ) {
                        panic!("could not load vkCmdSetDepthBoundsTestEnableEXT")
                    }
                    fallback
                }
            },
            cmd_set_depth_clamp_enable_ext: {
                let value = loader(c"vkCmdSetDepthClampEnableEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _depth_clamp_enable: Bool32,
                    ) {
                        panic!("could not load vkCmdSetDepthClampEnableEXT")
                    }
                    fallback
                }
            },
            cmd_set_depth_clamp_range_ext: {
                let value = loader(c"vkCmdSetDepthClampRangeEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _depth_clamp_mode: DepthClampModeEXT,
                        _depth_clamp_range: *const DepthClampRangeEXT,
                    ) {
                        panic!("could not load vkCmdSetDepthClampRangeEXT")
                    }
                    fallback
                }
            },
            cmd_set_depth_clip_enable_ext: {
                let value = loader(c"vkCmdSetDepthClipEnableEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _depth_clip_enable: Bool32,
                    ) {
                        panic!("could not load vkCmdSetDepthClipEnableEXT")
                    }
                    fallback
                }
            },
            cmd_set_depth_clip_negative_one_to_one_ext: {
                let value = loader(c"vkCmdSetDepthClipNegativeOneToOneEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _negative_one_to_one: Bool32,
                    ) {
                        panic!("could not load vkCmdSetDepthClipNegativeOneToOneEXT")
                    }
                    fallback
                }
            },
            cmd_set_depth_compare_op: {
                let value = loader(c"vkCmdSetDepthCompareOp".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _depth_compare_op: CompareOp,
                    ) {
                        panic!("could not load vkCmdSetDepthCompareOp")
                    }
                    fallback
                }
            },
            cmd_set_depth_compare_op_ext: {
                let value = loader(c"vkCmdSetDepthCompareOpEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _depth_compare_op: CompareOp,
                    ) {
                        panic!("could not load vkCmdSetDepthCompareOpEXT")
                    }
                    fallback
                }
            },
            cmd_set_depth_test_enable: {
                let value = loader(c"vkCmdSetDepthTestEnable".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _depth_test_enable: Bool32,
                    ) {
                        panic!("could not load vkCmdSetDepthTestEnable")
                    }
                    fallback
                }
            },
            cmd_set_depth_test_enable_ext: {
                let value = loader(c"vkCmdSetDepthTestEnableEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _depth_test_enable: Bool32,
                    ) {
                        panic!("could not load vkCmdSetDepthTestEnableEXT")
                    }
                    fallback
                }
            },
            cmd_set_depth_write_enable: {
                let value = loader(c"vkCmdSetDepthWriteEnable".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _depth_write_enable: Bool32,
                    ) {
                        panic!("could not load vkCmdSetDepthWriteEnable")
                    }
                    fallback
                }
            },
            cmd_set_depth_write_enable_ext: {
                let value = loader(c"vkCmdSetDepthWriteEnableEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _depth_write_enable: Bool32,
                    ) {
                        panic!("could not load vkCmdSetDepthWriteEnableEXT")
                    }
                    fallback
                }
            },
            cmd_set_descriptor_buffer_offsets2_ext: {
                let value = loader(c"vkCmdSetDescriptorBufferOffsets2EXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _set_descriptor_buffer_offsets_info: *const SetDescriptorBufferOffsetsInfoEXT,
                    ) {
                        panic!("could not load vkCmdSetDescriptorBufferOffsets2EXT")
                    }
                    fallback
                }
            },
            cmd_set_descriptor_buffer_offsets_ext: {
                let value = loader(c"vkCmdSetDescriptorBufferOffsetsEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _pipeline_bind_point: PipelineBindPoint,
                        _layout: PipelineLayout,
                        _first_set: u32,
                        _set_count: u32,
                        _buffer_indices: *const u32,
                        _offsets: *const DeviceSize,
                    ) {
                        panic!("could not load vkCmdSetDescriptorBufferOffsetsEXT")
                    }
                    fallback
                }
            },
            cmd_set_device_mask: {
                let value = loader(c"vkCmdSetDeviceMask".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _device_mask: u32,
                    ) {
                        panic!("could not load vkCmdSetDeviceMask")
                    }
                    fallback
                }
            },
            cmd_set_device_mask_khr: {
                let value = loader(c"vkCmdSetDeviceMaskKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _device_mask: u32,
                    ) {
                        panic!("could not load vkCmdSetDeviceMaskKHR")
                    }
                    fallback
                }
            },
            cmd_set_discard_rectangle_ext: {
                let value = loader(c"vkCmdSetDiscardRectangleEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _first_discard_rectangle: u32,
                        _discard_rectangle_count: u32,
                        _discard_rectangles: *const Rect2D,
                    ) {
                        panic!("could not load vkCmdSetDiscardRectangleEXT")
                    }
                    fallback
                }
            },
            cmd_set_discard_rectangle_enable_ext: {
                let value = loader(c"vkCmdSetDiscardRectangleEnableEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _discard_rectangle_enable: Bool32,
                    ) {
                        panic!("could not load vkCmdSetDiscardRectangleEnableEXT")
                    }
                    fallback
                }
            },
            cmd_set_discard_rectangle_mode_ext: {
                let value = loader(c"vkCmdSetDiscardRectangleModeEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _discard_rectangle_mode: DiscardRectangleModeEXT,
                    ) {
                        panic!("could not load vkCmdSetDiscardRectangleModeEXT")
                    }
                    fallback
                }
            },
            cmd_set_event: {
                let value = loader(c"vkCmdSetEvent".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _event: Event,
                        _stage_mask: PipelineStageFlags,
                    ) {
                        panic!("could not load vkCmdSetEvent")
                    }
                    fallback
                }
            },
            cmd_set_event2: {
                let value = loader(c"vkCmdSetEvent2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _event: Event,
                        _dependency_info: *const DependencyInfo,
                    ) {
                        panic!("could not load vkCmdSetEvent2")
                    }
                    fallback
                }
            },
            cmd_set_event2_khr: {
                let value = loader(c"vkCmdSetEvent2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _event: Event,
                        _dependency_info: *const DependencyInfo,
                    ) {
                        panic!("could not load vkCmdSetEvent2KHR")
                    }
                    fallback
                }
            },
            cmd_set_exclusive_scissor_enable_nv: {
                let value = loader(c"vkCmdSetExclusiveScissorEnableNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _first_exclusive_scissor: u32,
                        _exclusive_scissor_count: u32,
                        _exclusive_scissor_enables: *const Bool32,
                    ) {
                        panic!("could not load vkCmdSetExclusiveScissorEnableNV")
                    }
                    fallback
                }
            },
            cmd_set_exclusive_scissor_nv: {
                let value = loader(c"vkCmdSetExclusiveScissorNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _first_exclusive_scissor: u32,
                        _exclusive_scissor_count: u32,
                        _exclusive_scissors: *const Rect2D,
                    ) {
                        panic!("could not load vkCmdSetExclusiveScissorNV")
                    }
                    fallback
                }
            },
            cmd_set_extra_primitive_overestimation_size_ext: {
                let value = loader(c"vkCmdSetExtraPrimitiveOverestimationSizeEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _extra_primitive_overestimation_size: f32,
                    ) {
                        panic!("could not load vkCmdSetExtraPrimitiveOverestimationSizeEXT")
                    }
                    fallback
                }
            },
            cmd_set_fragment_shading_rate_enum_nv: {
                let value = loader(c"vkCmdSetFragmentShadingRateEnumNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _shading_rate: FragmentShadingRateNV,
                        _combiner_ops: *const FragmentShadingRateCombinerOpKHR,
                    ) {
                        panic!("could not load vkCmdSetFragmentShadingRateEnumNV")
                    }
                    fallback
                }
            },
            cmd_set_fragment_shading_rate_khr: {
                let value = loader(c"vkCmdSetFragmentShadingRateKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _fragment_size: *const Extent2D,
                        _combiner_ops: *const FragmentShadingRateCombinerOpKHR,
                    ) {
                        panic!("could not load vkCmdSetFragmentShadingRateKHR")
                    }
                    fallback
                }
            },
            cmd_set_front_face: {
                let value = loader(c"vkCmdSetFrontFace".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _front_face: FrontFace,
                    ) {
                        panic!("could not load vkCmdSetFrontFace")
                    }
                    fallback
                }
            },
            cmd_set_front_face_ext: {
                let value = loader(c"vkCmdSetFrontFaceEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _front_face: FrontFace,
                    ) {
                        panic!("could not load vkCmdSetFrontFaceEXT")
                    }
                    fallback
                }
            },
            cmd_set_line_rasterization_mode_ext: {
                let value = loader(c"vkCmdSetLineRasterizationModeEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _line_rasterization_mode: LineRasterizationModeEXT,
                    ) {
                        panic!("could not load vkCmdSetLineRasterizationModeEXT")
                    }
                    fallback
                }
            },
            cmd_set_line_stipple: {
                let value = loader(c"vkCmdSetLineStipple".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _line_stipple_factor: u32,
                        _line_stipple_pattern: u16,
                    ) {
                        panic!("could not load vkCmdSetLineStipple")
                    }
                    fallback
                }
            },
            cmd_set_line_stipple_ext: {
                let value = loader(c"vkCmdSetLineStippleEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _line_stipple_factor: u32,
                        _line_stipple_pattern: u16,
                    ) {
                        panic!("could not load vkCmdSetLineStippleEXT")
                    }
                    fallback
                }
            },
            cmd_set_line_stipple_enable_ext: {
                let value = loader(c"vkCmdSetLineStippleEnableEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _stippled_line_enable: Bool32,
                    ) {
                        panic!("could not load vkCmdSetLineStippleEnableEXT")
                    }
                    fallback
                }
            },
            cmd_set_line_stipple_khr: {
                let value = loader(c"vkCmdSetLineStippleKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _line_stipple_factor: u32,
                        _line_stipple_pattern: u16,
                    ) {
                        panic!("could not load vkCmdSetLineStippleKHR")
                    }
                    fallback
                }
            },
            cmd_set_line_width: {
                let value = loader(c"vkCmdSetLineWidth".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _line_width: f32,
                    ) {
                        panic!("could not load vkCmdSetLineWidth")
                    }
                    fallback
                }
            },
            cmd_set_logic_op_ext: {
                let value = loader(c"vkCmdSetLogicOpEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _logic_op: LogicOp,
                    ) {
                        panic!("could not load vkCmdSetLogicOpEXT")
                    }
                    fallback
                }
            },
            cmd_set_logic_op_enable_ext: {
                let value = loader(c"vkCmdSetLogicOpEnableEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _logic_op_enable: Bool32,
                    ) {
                        panic!("could not load vkCmdSetLogicOpEnableEXT")
                    }
                    fallback
                }
            },
            cmd_set_patch_control_points_ext: {
                let value = loader(c"vkCmdSetPatchControlPointsEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _patch_control_points: u32,
                    ) {
                        panic!("could not load vkCmdSetPatchControlPointsEXT")
                    }
                    fallback
                }
            },
            cmd_set_performance_marker_intel: {
                let value = loader(c"vkCmdSetPerformanceMarkerINTEL".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _marker_info: *const PerformanceMarkerInfoINTEL,
                    ) -> Result {
                        panic!("could not load vkCmdSetPerformanceMarkerINTEL")
                    }
                    fallback
                }
            },
            cmd_set_performance_override_intel: {
                let value = loader(c"vkCmdSetPerformanceOverrideINTEL".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _override_info: *const PerformanceOverrideInfoINTEL,
                    ) -> Result {
                        panic!("could not load vkCmdSetPerformanceOverrideINTEL")
                    }
                    fallback
                }
            },
            cmd_set_performance_stream_marker_intel: {
                let value = loader(c"vkCmdSetPerformanceStreamMarkerINTEL".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _marker_info: *const PerformanceStreamMarkerInfoINTEL,
                    ) -> Result {
                        panic!("could not load vkCmdSetPerformanceStreamMarkerINTEL")
                    }
                    fallback
                }
            },
            cmd_set_polygon_mode_ext: {
                let value = loader(c"vkCmdSetPolygonModeEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _polygon_mode: PolygonMode,
                    ) {
                        panic!("could not load vkCmdSetPolygonModeEXT")
                    }
                    fallback
                }
            },
            cmd_set_primitive_restart_enable: {
                let value = loader(c"vkCmdSetPrimitiveRestartEnable".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _primitive_restart_enable: Bool32,
                    ) {
                        panic!("could not load vkCmdSetPrimitiveRestartEnable")
                    }
                    fallback
                }
            },
            cmd_set_primitive_restart_enable_ext: {
                let value = loader(c"vkCmdSetPrimitiveRestartEnableEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _primitive_restart_enable: Bool32,
                    ) {
                        panic!("could not load vkCmdSetPrimitiveRestartEnableEXT")
                    }
                    fallback
                }
            },
            cmd_set_primitive_topology: {
                let value = loader(c"vkCmdSetPrimitiveTopology".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _primitive_topology: PrimitiveTopology,
                    ) {
                        panic!("could not load vkCmdSetPrimitiveTopology")
                    }
                    fallback
                }
            },
            cmd_set_primitive_topology_ext: {
                let value = loader(c"vkCmdSetPrimitiveTopologyEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _primitive_topology: PrimitiveTopology,
                    ) {
                        panic!("could not load vkCmdSetPrimitiveTopologyEXT")
                    }
                    fallback
                }
            },
            cmd_set_provoking_vertex_mode_ext: {
                let value = loader(c"vkCmdSetProvokingVertexModeEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _provoking_vertex_mode: ProvokingVertexModeEXT,
                    ) {
                        panic!("could not load vkCmdSetProvokingVertexModeEXT")
                    }
                    fallback
                }
            },
            cmd_set_rasterization_samples_ext: {
                let value = loader(c"vkCmdSetRasterizationSamplesEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _rasterization_samples: SampleCountFlags,
                    ) {
                        panic!("could not load vkCmdSetRasterizationSamplesEXT")
                    }
                    fallback
                }
            },
            cmd_set_rasterization_stream_ext: {
                let value = loader(c"vkCmdSetRasterizationStreamEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _rasterization_stream: u32,
                    ) {
                        panic!("could not load vkCmdSetRasterizationStreamEXT")
                    }
                    fallback
                }
            },
            cmd_set_rasterizer_discard_enable: {
                let value = loader(c"vkCmdSetRasterizerDiscardEnable".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _rasterizer_discard_enable: Bool32,
                    ) {
                        panic!("could not load vkCmdSetRasterizerDiscardEnable")
                    }
                    fallback
                }
            },
            cmd_set_rasterizer_discard_enable_ext: {
                let value = loader(c"vkCmdSetRasterizerDiscardEnableEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _rasterizer_discard_enable: Bool32,
                    ) {
                        panic!("could not load vkCmdSetRasterizerDiscardEnableEXT")
                    }
                    fallback
                }
            },
            cmd_set_ray_tracing_pipeline_stack_size_khr: {
                let value = loader(c"vkCmdSetRayTracingPipelineStackSizeKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _pipeline_stack_size: u32,
                    ) {
                        panic!("could not load vkCmdSetRayTracingPipelineStackSizeKHR")
                    }
                    fallback
                }
            },
            cmd_set_rendering_attachment_locations: {
                let value = loader(c"vkCmdSetRenderingAttachmentLocations".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _location_info: *const RenderingAttachmentLocationInfo,
                    ) {
                        panic!("could not load vkCmdSetRenderingAttachmentLocations")
                    }
                    fallback
                }
            },
            cmd_set_rendering_attachment_locations_khr: {
                let value = loader(c"vkCmdSetRenderingAttachmentLocationsKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _location_info: *const RenderingAttachmentLocationInfo,
                    ) {
                        panic!("could not load vkCmdSetRenderingAttachmentLocationsKHR")
                    }
                    fallback
                }
            },
            cmd_set_rendering_input_attachment_indices: {
                let value = loader(c"vkCmdSetRenderingInputAttachmentIndices".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _input_attachment_index_info: *const RenderingInputAttachmentIndexInfo,
                    ) {
                        panic!("could not load vkCmdSetRenderingInputAttachmentIndices")
                    }
                    fallback
                }
            },
            cmd_set_rendering_input_attachment_indices_khr: {
                let value = loader(c"vkCmdSetRenderingInputAttachmentIndicesKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _input_attachment_index_info: *const RenderingInputAttachmentIndexInfo,
                    ) {
                        panic!("could not load vkCmdSetRenderingInputAttachmentIndicesKHR")
                    }
                    fallback
                }
            },
            cmd_set_representative_fragment_test_enable_nv: {
                let value = loader(c"vkCmdSetRepresentativeFragmentTestEnableNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _representative_fragment_test_enable: Bool32,
                    ) {
                        panic!("could not load vkCmdSetRepresentativeFragmentTestEnableNV")
                    }
                    fallback
                }
            },
            cmd_set_sample_locations_ext: {
                let value = loader(c"vkCmdSetSampleLocationsEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _sample_locations_info: *const SampleLocationsInfoEXT,
                    ) {
                        panic!("could not load vkCmdSetSampleLocationsEXT")
                    }
                    fallback
                }
            },
            cmd_set_sample_locations_enable_ext: {
                let value = loader(c"vkCmdSetSampleLocationsEnableEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _sample_locations_enable: Bool32,
                    ) {
                        panic!("could not load vkCmdSetSampleLocationsEnableEXT")
                    }
                    fallback
                }
            },
            cmd_set_sample_mask_ext: {
                let value = loader(c"vkCmdSetSampleMaskEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _samples: SampleCountFlags,
                        _sample_mask: *const SampleMask,
                    ) {
                        panic!("could not load vkCmdSetSampleMaskEXT")
                    }
                    fallback
                }
            },
            cmd_set_scissor: {
                let value = loader(c"vkCmdSetScissor".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _first_scissor: u32,
                        _scissor_count: u32,
                        _scissors: *const Rect2D,
                    ) {
                        panic!("could not load vkCmdSetScissor")
                    }
                    fallback
                }
            },
            cmd_set_scissor_with_count: {
                let value = loader(c"vkCmdSetScissorWithCount".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _scissor_count: u32,
                        _scissors: *const Rect2D,
                    ) {
                        panic!("could not load vkCmdSetScissorWithCount")
                    }
                    fallback
                }
            },
            cmd_set_scissor_with_count_ext: {
                let value = loader(c"vkCmdSetScissorWithCountEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _scissor_count: u32,
                        _scissors: *const Rect2D,
                    ) {
                        panic!("could not load vkCmdSetScissorWithCountEXT")
                    }
                    fallback
                }
            },
            cmd_set_shading_rate_image_enable_nv: {
                let value = loader(c"vkCmdSetShadingRateImageEnableNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _shading_rate_image_enable: Bool32,
                    ) {
                        panic!("could not load vkCmdSetShadingRateImageEnableNV")
                    }
                    fallback
                }
            },
            cmd_set_stencil_compare_mask: {
                let value = loader(c"vkCmdSetStencilCompareMask".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _face_mask: StencilFaceFlags,
                        _compare_mask: u32,
                    ) {
                        panic!("could not load vkCmdSetStencilCompareMask")
                    }
                    fallback
                }
            },
            cmd_set_stencil_op: {
                let value = loader(c"vkCmdSetStencilOp".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _face_mask: StencilFaceFlags,
                        _fail_op: StencilOp,
                        _pass_op: StencilOp,
                        _depth_fail_op: StencilOp,
                        _compare_op: CompareOp,
                    ) {
                        panic!("could not load vkCmdSetStencilOp")
                    }
                    fallback
                }
            },
            cmd_set_stencil_op_ext: {
                let value = loader(c"vkCmdSetStencilOpEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _face_mask: StencilFaceFlags,
                        _fail_op: StencilOp,
                        _pass_op: StencilOp,
                        _depth_fail_op: StencilOp,
                        _compare_op: CompareOp,
                    ) {
                        panic!("could not load vkCmdSetStencilOpEXT")
                    }
                    fallback
                }
            },
            cmd_set_stencil_reference: {
                let value = loader(c"vkCmdSetStencilReference".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _face_mask: StencilFaceFlags,
                        _reference: u32,
                    ) {
                        panic!("could not load vkCmdSetStencilReference")
                    }
                    fallback
                }
            },
            cmd_set_stencil_test_enable: {
                let value = loader(c"vkCmdSetStencilTestEnable".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _stencil_test_enable: Bool32,
                    ) {
                        panic!("could not load vkCmdSetStencilTestEnable")
                    }
                    fallback
                }
            },
            cmd_set_stencil_test_enable_ext: {
                let value = loader(c"vkCmdSetStencilTestEnableEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _stencil_test_enable: Bool32,
                    ) {
                        panic!("could not load vkCmdSetStencilTestEnableEXT")
                    }
                    fallback
                }
            },
            cmd_set_stencil_write_mask: {
                let value = loader(c"vkCmdSetStencilWriteMask".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _face_mask: StencilFaceFlags,
                        _write_mask: u32,
                    ) {
                        panic!("could not load vkCmdSetStencilWriteMask")
                    }
                    fallback
                }
            },
            cmd_set_tessellation_domain_origin_ext: {
                let value = loader(c"vkCmdSetTessellationDomainOriginEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _domain_origin: TessellationDomainOrigin,
                    ) {
                        panic!("could not load vkCmdSetTessellationDomainOriginEXT")
                    }
                    fallback
                }
            },
            cmd_set_vertex_input_ext: {
                let value = loader(c"vkCmdSetVertexInputEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _vertex_binding_description_count: u32,
                        _vertex_binding_descriptions: *const VertexInputBindingDescription2EXT,
                        _vertex_attribute_description_count: u32,
                        _vertex_attribute_descriptions: *const VertexInputAttributeDescription2EXT,
                    ) {
                        panic!("could not load vkCmdSetVertexInputEXT")
                    }
                    fallback
                }
            },
            cmd_set_viewport: {
                let value = loader(c"vkCmdSetViewport".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _first_viewport: u32,
                        _viewport_count: u32,
                        _viewports: *const Viewport,
                    ) {
                        panic!("could not load vkCmdSetViewport")
                    }
                    fallback
                }
            },
            cmd_set_viewport_shading_rate_palette_nv: {
                let value = loader(c"vkCmdSetViewportShadingRatePaletteNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _first_viewport: u32,
                        _viewport_count: u32,
                        _shading_rate_palettes: *const ShadingRatePaletteNV,
                    ) {
                        panic!("could not load vkCmdSetViewportShadingRatePaletteNV")
                    }
                    fallback
                }
            },
            cmd_set_viewport_swizzle_nv: {
                let value = loader(c"vkCmdSetViewportSwizzleNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _first_viewport: u32,
                        _viewport_count: u32,
                        _viewport_swizzles: *const ViewportSwizzleNV,
                    ) {
                        panic!("could not load vkCmdSetViewportSwizzleNV")
                    }
                    fallback
                }
            },
            cmd_set_viewport_w_scaling_enable_nv: {
                let value = loader(c"vkCmdSetViewportWScalingEnableNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _viewport_w_scaling_enable: Bool32,
                    ) {
                        panic!("could not load vkCmdSetViewportWScalingEnableNV")
                    }
                    fallback
                }
            },
            cmd_set_viewport_w_scaling_nv: {
                let value = loader(c"vkCmdSetViewportWScalingNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _first_viewport: u32,
                        _viewport_count: u32,
                        _viewport_w_scalings: *const ViewportWScalingNV,
                    ) {
                        panic!("could not load vkCmdSetViewportWScalingNV")
                    }
                    fallback
                }
            },
            cmd_set_viewport_with_count: {
                let value = loader(c"vkCmdSetViewportWithCount".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _viewport_count: u32,
                        _viewports: *const Viewport,
                    ) {
                        panic!("could not load vkCmdSetViewportWithCount")
                    }
                    fallback
                }
            },
            cmd_set_viewport_with_count_ext: {
                let value = loader(c"vkCmdSetViewportWithCountEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _viewport_count: u32,
                        _viewports: *const Viewport,
                    ) {
                        panic!("could not load vkCmdSetViewportWithCountEXT")
                    }
                    fallback
                }
            },
            cmd_subpass_shading_huawei: {
                let value = loader(c"vkCmdSubpassShadingHUAWEI".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(_command_buffer: CommandBuffer) {
                        panic!("could not load vkCmdSubpassShadingHUAWEI")
                    }
                    fallback
                }
            },
            cmd_trace_rays_indirect2_khr: {
                let value = loader(c"vkCmdTraceRaysIndirect2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _indirect_device_address: DeviceAddress,
                    ) {
                        panic!("could not load vkCmdTraceRaysIndirect2KHR")
                    }
                    fallback
                }
            },
            cmd_trace_rays_indirect_khr: {
                let value = loader(c"vkCmdTraceRaysIndirectKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _raygen_shader_binding_table: *const StridedDeviceAddressRegionKHR,
                        _miss_shader_binding_table: *const StridedDeviceAddressRegionKHR,
                        _hit_shader_binding_table: *const StridedDeviceAddressRegionKHR,
                        _callable_shader_binding_table: *const StridedDeviceAddressRegionKHR,
                        _indirect_device_address: DeviceAddress,
                    ) {
                        panic!("could not load vkCmdTraceRaysIndirectKHR")
                    }
                    fallback
                }
            },
            cmd_trace_rays_khr: {
                let value = loader(c"vkCmdTraceRaysKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _raygen_shader_binding_table: *const StridedDeviceAddressRegionKHR,
                        _miss_shader_binding_table: *const StridedDeviceAddressRegionKHR,
                        _hit_shader_binding_table: *const StridedDeviceAddressRegionKHR,
                        _callable_shader_binding_table: *const StridedDeviceAddressRegionKHR,
                        _width: u32,
                        _height: u32,
                        _depth: u32,
                    ) {
                        panic!("could not load vkCmdTraceRaysKHR")
                    }
                    fallback
                }
            },
            cmd_trace_rays_nv: {
                let value = loader(c"vkCmdTraceRaysNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _raygen_shader_binding_table_buffer: Buffer,
                        _raygen_shader_binding_offset: DeviceSize,
                        _miss_shader_binding_table_buffer: Buffer,
                        _miss_shader_binding_offset: DeviceSize,
                        _miss_shader_binding_stride: DeviceSize,
                        _hit_shader_binding_table_buffer: Buffer,
                        _hit_shader_binding_offset: DeviceSize,
                        _hit_shader_binding_stride: DeviceSize,
                        _callable_shader_binding_table_buffer: Buffer,
                        _callable_shader_binding_offset: DeviceSize,
                        _callable_shader_binding_stride: DeviceSize,
                        _width: u32,
                        _height: u32,
                        _depth: u32,
                    ) {
                        panic!("could not load vkCmdTraceRaysNV")
                    }
                    fallback
                }
            },
            cmd_update_buffer: {
                let value = loader(c"vkCmdUpdateBuffer".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _dst_buffer: Buffer,
                        _dst_offset: DeviceSize,
                        _data_size: DeviceSize,
                        _data: *const c_void,
                    ) {
                        panic!("could not load vkCmdUpdateBuffer")
                    }
                    fallback
                }
            },
            cmd_update_pipeline_indirect_buffer_nv: {
                let value = loader(c"vkCmdUpdatePipelineIndirectBufferNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _pipeline_bind_point: PipelineBindPoint,
                        _pipeline: Pipeline,
                    ) {
                        panic!("could not load vkCmdUpdatePipelineIndirectBufferNV")
                    }
                    fallback
                }
            },
            cmd_wait_events: {
                let value = loader(c"vkCmdWaitEvents".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _event_count: u32,
                        _events: *const Event,
                        _src_stage_mask: PipelineStageFlags,
                        _dst_stage_mask: PipelineStageFlags,
                        _memory_barrier_count: u32,
                        _memory_barriers: *const MemoryBarrier,
                        _buffer_memory_barrier_count: u32,
                        _buffer_memory_barriers: *const BufferMemoryBarrier,
                        _image_memory_barrier_count: u32,
                        _image_memory_barriers: *const ImageMemoryBarrier,
                    ) {
                        panic!("could not load vkCmdWaitEvents")
                    }
                    fallback
                }
            },
            cmd_wait_events2: {
                let value = loader(c"vkCmdWaitEvents2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _event_count: u32,
                        _events: *const Event,
                        _dependency_infos: *const DependencyInfo,
                    ) {
                        panic!("could not load vkCmdWaitEvents2")
                    }
                    fallback
                }
            },
            cmd_wait_events2_khr: {
                let value = loader(c"vkCmdWaitEvents2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _event_count: u32,
                        _events: *const Event,
                        _dependency_infos: *const DependencyInfo,
                    ) {
                        panic!("could not load vkCmdWaitEvents2KHR")
                    }
                    fallback
                }
            },
            cmd_write_acceleration_structures_properties_khr: {
                let value = loader(c"vkCmdWriteAccelerationStructuresPropertiesKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _acceleration_structure_count: u32,
                        _acceleration_structures: *const AccelerationStructureKHR,
                        _query_type: QueryType,
                        _query_pool: QueryPool,
                        _first_query: u32,
                    ) {
                        panic!("could not load vkCmdWriteAccelerationStructuresPropertiesKHR")
                    }
                    fallback
                }
            },
            cmd_write_acceleration_structures_properties_nv: {
                let value = loader(c"vkCmdWriteAccelerationStructuresPropertiesNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _acceleration_structure_count: u32,
                        _acceleration_structures: *const AccelerationStructureNV,
                        _query_type: QueryType,
                        _query_pool: QueryPool,
                        _first_query: u32,
                    ) {
                        panic!("could not load vkCmdWriteAccelerationStructuresPropertiesNV")
                    }
                    fallback
                }
            },
            cmd_write_buffer_marker2_amd: {
                let value = loader(c"vkCmdWriteBufferMarker2AMD".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _stage: PipelineStageFlags2,
                        _dst_buffer: Buffer,
                        _dst_offset: DeviceSize,
                        _marker: u32,
                    ) {
                        panic!("could not load vkCmdWriteBufferMarker2AMD")
                    }
                    fallback
                }
            },
            cmd_write_buffer_marker_amd: {
                let value = loader(c"vkCmdWriteBufferMarkerAMD".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _pipeline_stage: PipelineStageFlags,
                        _dst_buffer: Buffer,
                        _dst_offset: DeviceSize,
                        _marker: u32,
                    ) {
                        panic!("could not load vkCmdWriteBufferMarkerAMD")
                    }
                    fallback
                }
            },
            cmd_write_micromaps_properties_ext: {
                let value = loader(c"vkCmdWriteMicromapsPropertiesEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _micromap_count: u32,
                        _micromaps: *const MicromapEXT,
                        _query_type: QueryType,
                        _query_pool: QueryPool,
                        _first_query: u32,
                    ) {
                        panic!("could not load vkCmdWriteMicromapsPropertiesEXT")
                    }
                    fallback
                }
            },
            cmd_write_timestamp: {
                let value = loader(c"vkCmdWriteTimestamp".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _pipeline_stage: PipelineStageFlags,
                        _query_pool: QueryPool,
                        _query: u32,
                    ) {
                        panic!("could not load vkCmdWriteTimestamp")
                    }
                    fallback
                }
            },
            cmd_write_timestamp2: {
                let value = loader(c"vkCmdWriteTimestamp2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _stage: PipelineStageFlags2,
                        _query_pool: QueryPool,
                        _query: u32,
                    ) {
                        panic!("could not load vkCmdWriteTimestamp2")
                    }
                    fallback
                }
            },
            cmd_write_timestamp2_khr: {
                let value = loader(c"vkCmdWriteTimestamp2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _stage: PipelineStageFlags2,
                        _query_pool: QueryPool,
                        _query: u32,
                    ) {
                        panic!("could not load vkCmdWriteTimestamp2KHR")
                    }
                    fallback
                }
            },
            compile_deferred_nv: {
                let value = loader(c"vkCompileDeferredNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _pipeline: Pipeline,
                        _shader: u32,
                    ) -> Result {
                        panic!("could not load vkCompileDeferredNV")
                    }
                    fallback
                }
            },
            convert_cooperative_vector_matrix_nv: {
                let value = loader(c"vkConvertCooperativeVectorMatrixNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const ConvertCooperativeVectorMatrixInfoNV,
                    ) -> Result {
                        panic!("could not load vkConvertCooperativeVectorMatrixNV")
                    }
                    fallback
                }
            },
            copy_acceleration_structure_khr: {
                let value = loader(c"vkCopyAccelerationStructureKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _deferred_operation: DeferredOperationKHR,
                        _info: *const CopyAccelerationStructureInfoKHR,
                    ) -> Result {
                        panic!("could not load vkCopyAccelerationStructureKHR")
                    }
                    fallback
                }
            },
            copy_acceleration_structure_to_memory_khr: {
                let value = loader(c"vkCopyAccelerationStructureToMemoryKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _deferred_operation: DeferredOperationKHR,
                        _info: *const CopyAccelerationStructureToMemoryInfoKHR,
                    ) -> Result {
                        panic!("could not load vkCopyAccelerationStructureToMemoryKHR")
                    }
                    fallback
                }
            },
            copy_image_to_image: {
                let value = loader(c"vkCopyImageToImage".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _copy_image_to_image_info: *const CopyImageToImageInfo,
                    ) -> Result {
                        panic!("could not load vkCopyImageToImage")
                    }
                    fallback
                }
            },
            copy_image_to_image_ext: {
                let value = loader(c"vkCopyImageToImageEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _copy_image_to_image_info: *const CopyImageToImageInfo,
                    ) -> Result {
                        panic!("could not load vkCopyImageToImageEXT")
                    }
                    fallback
                }
            },
            copy_image_to_memory: {
                let value = loader(c"vkCopyImageToMemory".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _copy_image_to_memory_info: *const CopyImageToMemoryInfo,
                    ) -> Result {
                        panic!("could not load vkCopyImageToMemory")
                    }
                    fallback
                }
            },
            copy_image_to_memory_ext: {
                let value = loader(c"vkCopyImageToMemoryEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _copy_image_to_memory_info: *const CopyImageToMemoryInfo,
                    ) -> Result {
                        panic!("could not load vkCopyImageToMemoryEXT")
                    }
                    fallback
                }
            },
            copy_memory_to_acceleration_structure_khr: {
                let value = loader(c"vkCopyMemoryToAccelerationStructureKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _deferred_operation: DeferredOperationKHR,
                        _info: *const CopyMemoryToAccelerationStructureInfoKHR,
                    ) -> Result {
                        panic!("could not load vkCopyMemoryToAccelerationStructureKHR")
                    }
                    fallback
                }
            },
            copy_memory_to_image: {
                let value = loader(c"vkCopyMemoryToImage".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _copy_memory_to_image_info: *const CopyMemoryToImageInfo,
                    ) -> Result {
                        panic!("could not load vkCopyMemoryToImage")
                    }
                    fallback
                }
            },
            copy_memory_to_image_ext: {
                let value = loader(c"vkCopyMemoryToImageEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _copy_memory_to_image_info: *const CopyMemoryToImageInfo,
                    ) -> Result {
                        panic!("could not load vkCopyMemoryToImageEXT")
                    }
                    fallback
                }
            },
            copy_memory_to_micromap_ext: {
                let value = loader(c"vkCopyMemoryToMicromapEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _deferred_operation: DeferredOperationKHR,
                        _info: *const CopyMemoryToMicromapInfoEXT,
                    ) -> Result {
                        panic!("could not load vkCopyMemoryToMicromapEXT")
                    }
                    fallback
                }
            },
            copy_micromap_ext: {
                let value = loader(c"vkCopyMicromapEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _deferred_operation: DeferredOperationKHR,
                        _info: *const CopyMicromapInfoEXT,
                    ) -> Result {
                        panic!("could not load vkCopyMicromapEXT")
                    }
                    fallback
                }
            },
            copy_micromap_to_memory_ext: {
                let value = loader(c"vkCopyMicromapToMemoryEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _deferred_operation: DeferredOperationKHR,
                        _info: *const CopyMicromapToMemoryInfoEXT,
                    ) -> Result {
                        panic!("could not load vkCopyMicromapToMemoryEXT")
                    }
                    fallback
                }
            },
            create_acceleration_structure_khr: {
                let value = loader(c"vkCreateAccelerationStructureKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const AccelerationStructureCreateInfoKHR,
                        _allocator: *const AllocationCallbacks,
                        _acceleration_structure: *mut AccelerationStructureKHR,
                    ) -> Result {
                        panic!("could not load vkCreateAccelerationStructureKHR")
                    }
                    fallback
                }
            },
            create_acceleration_structure_nv: {
                let value = loader(c"vkCreateAccelerationStructureNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const AccelerationStructureCreateInfoNV,
                        _allocator: *const AllocationCallbacks,
                        _acceleration_structure: *mut AccelerationStructureNV,
                    ) -> Result {
                        panic!("could not load vkCreateAccelerationStructureNV")
                    }
                    fallback
                }
            },
            create_buffer: {
                let value = loader(c"vkCreateBuffer".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const BufferCreateInfo,
                        _allocator: *const AllocationCallbacks,
                        _buffer: *mut Buffer,
                    ) -> Result {
                        panic!("could not load vkCreateBuffer")
                    }
                    fallback
                }
            },
            create_buffer_collection_fuchsia: {
                let value = loader(c"vkCreateBufferCollectionFUCHSIA".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const BufferCollectionCreateInfoFUCHSIA,
                        _allocator: *const AllocationCallbacks,
                        _collection: *mut BufferCollectionFUCHSIA,
                    ) -> Result {
                        panic!("could not load vkCreateBufferCollectionFUCHSIA")
                    }
                    fallback
                }
            },
            create_buffer_view: {
                let value = loader(c"vkCreateBufferView".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const BufferViewCreateInfo,
                        _allocator: *const AllocationCallbacks,
                        _view: *mut BufferView,
                    ) -> Result {
                        panic!("could not load vkCreateBufferView")
                    }
                    fallback
                }
            },
            create_command_pool: {
                let value = loader(c"vkCreateCommandPool".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const CommandPoolCreateInfo,
                        _allocator: *const AllocationCallbacks,
                        _command_pool: *mut CommandPool,
                    ) -> Result {
                        panic!("could not load vkCreateCommandPool")
                    }
                    fallback
                }
            },
            create_compute_pipelines: {
                let value = loader(c"vkCreateComputePipelines".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _pipeline_cache: PipelineCache,
                        _create_info_count: u32,
                        _create_infos: *const ComputePipelineCreateInfo,
                        _allocator: *const AllocationCallbacks,
                        _pipelines: *mut Pipeline,
                    ) -> Result {
                        panic!("could not load vkCreateComputePipelines")
                    }
                    fallback
                }
            },
            create_cu_function_nvx: {
                let value = loader(c"vkCreateCuFunctionNVX".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const CuFunctionCreateInfoNVX,
                        _allocator: *const AllocationCallbacks,
                        _function: *mut CuFunctionNVX,
                    ) -> Result {
                        panic!("could not load vkCreateCuFunctionNVX")
                    }
                    fallback
                }
            },
            create_cu_module_nvx: {
                let value = loader(c"vkCreateCuModuleNVX".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const CuModuleCreateInfoNVX,
                        _allocator: *const AllocationCallbacks,
                        _module: *mut CuModuleNVX,
                    ) -> Result {
                        panic!("could not load vkCreateCuModuleNVX")
                    }
                    fallback
                }
            },
            create_cuda_function_nv: {
                let value = loader(c"vkCreateCudaFunctionNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const CudaFunctionCreateInfoNV,
                        _allocator: *const AllocationCallbacks,
                        _function: *mut CudaFunctionNV,
                    ) -> Result {
                        panic!("could not load vkCreateCudaFunctionNV")
                    }
                    fallback
                }
            },
            create_cuda_module_nv: {
                let value = loader(c"vkCreateCudaModuleNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const CudaModuleCreateInfoNV,
                        _allocator: *const AllocationCallbacks,
                        _module: *mut CudaModuleNV,
                    ) -> Result {
                        panic!("could not load vkCreateCudaModuleNV")
                    }
                    fallback
                }
            },
            create_data_graph_pipeline_session_arm: {
                let value = loader(c"vkCreateDataGraphPipelineSessionARM".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const DataGraphPipelineSessionCreateInfoARM,
                        _allocator: *const AllocationCallbacks,
                        _session: *mut DataGraphPipelineSessionARM,
                    ) -> Result {
                        panic!("could not load vkCreateDataGraphPipelineSessionARM")
                    }
                    fallback
                }
            },
            create_data_graph_pipelines_arm: {
                let value = loader(c"vkCreateDataGraphPipelinesARM".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _deferred_operation: DeferredOperationKHR,
                        _pipeline_cache: PipelineCache,
                        _create_info_count: u32,
                        _create_infos: *const DataGraphPipelineCreateInfoARM,
                        _allocator: *const AllocationCallbacks,
                        _pipelines: *mut Pipeline,
                    ) -> Result {
                        panic!("could not load vkCreateDataGraphPipelinesARM")
                    }
                    fallback
                }
            },
            create_deferred_operation_khr: {
                let value = loader(c"vkCreateDeferredOperationKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _allocator: *const AllocationCallbacks,
                        _deferred_operation: *mut DeferredOperationKHR,
                    ) -> Result {
                        panic!("could not load vkCreateDeferredOperationKHR")
                    }
                    fallback
                }
            },
            create_descriptor_pool: {
                let value = loader(c"vkCreateDescriptorPool".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const DescriptorPoolCreateInfo,
                        _allocator: *const AllocationCallbacks,
                        _descriptor_pool: *mut DescriptorPool,
                    ) -> Result {
                        panic!("could not load vkCreateDescriptorPool")
                    }
                    fallback
                }
            },
            create_descriptor_set_layout: {
                let value = loader(c"vkCreateDescriptorSetLayout".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const DescriptorSetLayoutCreateInfo,
                        _allocator: *const AllocationCallbacks,
                        _set_layout: *mut DescriptorSetLayout,
                    ) -> Result {
                        panic!("could not load vkCreateDescriptorSetLayout")
                    }
                    fallback
                }
            },
            create_descriptor_update_template: {
                let value = loader(c"vkCreateDescriptorUpdateTemplate".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const DescriptorUpdateTemplateCreateInfo,
                        _allocator: *const AllocationCallbacks,
                        _descriptor_update_template: *mut DescriptorUpdateTemplate,
                    ) -> Result {
                        panic!("could not load vkCreateDescriptorUpdateTemplate")
                    }
                    fallback
                }
            },
            create_descriptor_update_template_khr: {
                let value = loader(c"vkCreateDescriptorUpdateTemplateKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const DescriptorUpdateTemplateCreateInfo,
                        _allocator: *const AllocationCallbacks,
                        _descriptor_update_template: *mut DescriptorUpdateTemplate,
                    ) -> Result {
                        panic!("could not load vkCreateDescriptorUpdateTemplateKHR")
                    }
                    fallback
                }
            },
            create_event: {
                let value = loader(c"vkCreateEvent".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const EventCreateInfo,
                        _allocator: *const AllocationCallbacks,
                        _event: *mut Event,
                    ) -> Result {
                        panic!("could not load vkCreateEvent")
                    }
                    fallback
                }
            },
            create_execution_graph_pipelines_amdx: {
                let value = loader(c"vkCreateExecutionGraphPipelinesAMDX".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _pipeline_cache: PipelineCache,
                        _create_info_count: u32,
                        _create_infos: *const ExecutionGraphPipelineCreateInfoAMDX,
                        _allocator: *const AllocationCallbacks,
                        _pipelines: *mut Pipeline,
                    ) -> Result {
                        panic!("could not load vkCreateExecutionGraphPipelinesAMDX")
                    }
                    fallback
                }
            },
            create_external_compute_queue_nv: {
                let value = loader(c"vkCreateExternalComputeQueueNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const ExternalComputeQueueCreateInfoNV,
                        _allocator: *const AllocationCallbacks,
                        _external_queue: *mut ExternalComputeQueueNV,
                    ) -> Result {
                        panic!("could not load vkCreateExternalComputeQueueNV")
                    }
                    fallback
                }
            },
            create_fence: {
                let value = loader(c"vkCreateFence".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const FenceCreateInfo,
                        _allocator: *const AllocationCallbacks,
                        _fence: *mut Fence,
                    ) -> Result {
                        panic!("could not load vkCreateFence")
                    }
                    fallback
                }
            },
            create_framebuffer: {
                let value = loader(c"vkCreateFramebuffer".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const FramebufferCreateInfo,
                        _allocator: *const AllocationCallbacks,
                        _framebuffer: *mut Framebuffer,
                    ) -> Result {
                        panic!("could not load vkCreateFramebuffer")
                    }
                    fallback
                }
            },
            create_graphics_pipelines: {
                let value = loader(c"vkCreateGraphicsPipelines".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _pipeline_cache: PipelineCache,
                        _create_info_count: u32,
                        _create_infos: *const GraphicsPipelineCreateInfo,
                        _allocator: *const AllocationCallbacks,
                        _pipelines: *mut Pipeline,
                    ) -> Result {
                        panic!("could not load vkCreateGraphicsPipelines")
                    }
                    fallback
                }
            },
            create_image: {
                let value = loader(c"vkCreateImage".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const ImageCreateInfo,
                        _allocator: *const AllocationCallbacks,
                        _image: *mut Image,
                    ) -> Result {
                        panic!("could not load vkCreateImage")
                    }
                    fallback
                }
            },
            create_image_view: {
                let value = loader(c"vkCreateImageView".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const ImageViewCreateInfo,
                        _allocator: *const AllocationCallbacks,
                        _view: *mut ImageView,
                    ) -> Result {
                        panic!("could not load vkCreateImageView")
                    }
                    fallback
                }
            },
            create_indirect_commands_layout_ext: {
                let value = loader(c"vkCreateIndirectCommandsLayoutEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const IndirectCommandsLayoutCreateInfoEXT,
                        _allocator: *const AllocationCallbacks,
                        _indirect_commands_layout: *mut IndirectCommandsLayoutEXT,
                    ) -> Result {
                        panic!("could not load vkCreateIndirectCommandsLayoutEXT")
                    }
                    fallback
                }
            },
            create_indirect_commands_layout_nv: {
                let value = loader(c"vkCreateIndirectCommandsLayoutNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const IndirectCommandsLayoutCreateInfoNV,
                        _allocator: *const AllocationCallbacks,
                        _indirect_commands_layout: *mut IndirectCommandsLayoutNV,
                    ) -> Result {
                        panic!("could not load vkCreateIndirectCommandsLayoutNV")
                    }
                    fallback
                }
            },
            create_indirect_execution_set_ext: {
                let value = loader(c"vkCreateIndirectExecutionSetEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const IndirectExecutionSetCreateInfoEXT,
                        _allocator: *const AllocationCallbacks,
                        _indirect_execution_set: *mut IndirectExecutionSetEXT,
                    ) -> Result {
                        panic!("could not load vkCreateIndirectExecutionSetEXT")
                    }
                    fallback
                }
            },
            create_micromap_ext: {
                let value = loader(c"vkCreateMicromapEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const MicromapCreateInfoEXT,
                        _allocator: *const AllocationCallbacks,
                        _micromap: *mut MicromapEXT,
                    ) -> Result {
                        panic!("could not load vkCreateMicromapEXT")
                    }
                    fallback
                }
            },
            create_optical_flow_session_nv: {
                let value = loader(c"vkCreateOpticalFlowSessionNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const OpticalFlowSessionCreateInfoNV,
                        _allocator: *const AllocationCallbacks,
                        _session: *mut OpticalFlowSessionNV,
                    ) -> Result {
                        panic!("could not load vkCreateOpticalFlowSessionNV")
                    }
                    fallback
                }
            },
            create_pipeline_binaries_khr: {
                let value = loader(c"vkCreatePipelineBinariesKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const PipelineBinaryCreateInfoKHR,
                        _allocator: *const AllocationCallbacks,
                        _binaries: *mut PipelineBinaryHandlesInfoKHR,
                    ) -> Result {
                        panic!("could not load vkCreatePipelineBinariesKHR")
                    }
                    fallback
                }
            },
            create_pipeline_cache: {
                let value = loader(c"vkCreatePipelineCache".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const PipelineCacheCreateInfo,
                        _allocator: *const AllocationCallbacks,
                        _pipeline_cache: *mut PipelineCache,
                    ) -> Result {
                        panic!("could not load vkCreatePipelineCache")
                    }
                    fallback
                }
            },
            create_pipeline_layout: {
                let value = loader(c"vkCreatePipelineLayout".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const PipelineLayoutCreateInfo,
                        _allocator: *const AllocationCallbacks,
                        _pipeline_layout: *mut PipelineLayout,
                    ) -> Result {
                        panic!("could not load vkCreatePipelineLayout")
                    }
                    fallback
                }
            },
            create_private_data_slot: {
                let value = loader(c"vkCreatePrivateDataSlot".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const PrivateDataSlotCreateInfo,
                        _allocator: *const AllocationCallbacks,
                        _private_data_slot: *mut PrivateDataSlot,
                    ) -> Result {
                        panic!("could not load vkCreatePrivateDataSlot")
                    }
                    fallback
                }
            },
            create_private_data_slot_ext: {
                let value = loader(c"vkCreatePrivateDataSlotEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const PrivateDataSlotCreateInfo,
                        _allocator: *const AllocationCallbacks,
                        _private_data_slot: *mut PrivateDataSlot,
                    ) -> Result {
                        panic!("could not load vkCreatePrivateDataSlotEXT")
                    }
                    fallback
                }
            },
            create_query_pool: {
                let value = loader(c"vkCreateQueryPool".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const QueryPoolCreateInfo,
                        _allocator: *const AllocationCallbacks,
                        _query_pool: *mut QueryPool,
                    ) -> Result {
                        panic!("could not load vkCreateQueryPool")
                    }
                    fallback
                }
            },
            create_ray_tracing_pipelines_khr: {
                let value = loader(c"vkCreateRayTracingPipelinesKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _deferred_operation: DeferredOperationKHR,
                        _pipeline_cache: PipelineCache,
                        _create_info_count: u32,
                        _create_infos: *const RayTracingPipelineCreateInfoKHR,
                        _allocator: *const AllocationCallbacks,
                        _pipelines: *mut Pipeline,
                    ) -> Result {
                        panic!("could not load vkCreateRayTracingPipelinesKHR")
                    }
                    fallback
                }
            },
            create_ray_tracing_pipelines_nv: {
                let value = loader(c"vkCreateRayTracingPipelinesNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _pipeline_cache: PipelineCache,
                        _create_info_count: u32,
                        _create_infos: *const RayTracingPipelineCreateInfoNV,
                        _allocator: *const AllocationCallbacks,
                        _pipelines: *mut Pipeline,
                    ) -> Result {
                        panic!("could not load vkCreateRayTracingPipelinesNV")
                    }
                    fallback
                }
            },
            create_render_pass: {
                let value = loader(c"vkCreateRenderPass".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const RenderPassCreateInfo,
                        _allocator: *const AllocationCallbacks,
                        _render_pass: *mut RenderPass,
                    ) -> Result {
                        panic!("could not load vkCreateRenderPass")
                    }
                    fallback
                }
            },
            create_render_pass2: {
                let value = loader(c"vkCreateRenderPass2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const RenderPassCreateInfo2,
                        _allocator: *const AllocationCallbacks,
                        _render_pass: *mut RenderPass,
                    ) -> Result {
                        panic!("could not load vkCreateRenderPass2")
                    }
                    fallback
                }
            },
            create_render_pass2_khr: {
                let value = loader(c"vkCreateRenderPass2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const RenderPassCreateInfo2,
                        _allocator: *const AllocationCallbacks,
                        _render_pass: *mut RenderPass,
                    ) -> Result {
                        panic!("could not load vkCreateRenderPass2KHR")
                    }
                    fallback
                }
            },
            create_sampler: {
                let value = loader(c"vkCreateSampler".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const SamplerCreateInfo,
                        _allocator: *const AllocationCallbacks,
                        _sampler: *mut Sampler,
                    ) -> Result {
                        panic!("could not load vkCreateSampler")
                    }
                    fallback
                }
            },
            create_sampler_ycbcr_conversion: {
                let value = loader(c"vkCreateSamplerYcbcrConversion".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const SamplerYcbcrConversionCreateInfo,
                        _allocator: *const AllocationCallbacks,
                        _ycbcr_conversion: *mut SamplerYcbcrConversion,
                    ) -> Result {
                        panic!("could not load vkCreateSamplerYcbcrConversion")
                    }
                    fallback
                }
            },
            create_sampler_ycbcr_conversion_khr: {
                let value = loader(c"vkCreateSamplerYcbcrConversionKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const SamplerYcbcrConversionCreateInfo,
                        _allocator: *const AllocationCallbacks,
                        _ycbcr_conversion: *mut SamplerYcbcrConversion,
                    ) -> Result {
                        panic!("could not load vkCreateSamplerYcbcrConversionKHR")
                    }
                    fallback
                }
            },
            create_semaphore: {
                let value = loader(c"vkCreateSemaphore".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const SemaphoreCreateInfo,
                        _allocator: *const AllocationCallbacks,
                        _semaphore: *mut Semaphore,
                    ) -> Result {
                        panic!("could not load vkCreateSemaphore")
                    }
                    fallback
                }
            },
            create_semaphore_sci_sync_pool_nv: {
                let value = loader(c"vkCreateSemaphoreSciSyncPoolNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const SemaphoreSciSyncPoolCreateInfoNV,
                        _allocator: *const AllocationCallbacks,
                        _semaphore_pool: *mut SemaphoreSciSyncPoolNV,
                    ) -> Result {
                        panic!("could not load vkCreateSemaphoreSciSyncPoolNV")
                    }
                    fallback
                }
            },
            create_shader_module: {
                let value = loader(c"vkCreateShaderModule".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const ShaderModuleCreateInfo,
                        _allocator: *const AllocationCallbacks,
                        _shader_module: *mut ShaderModule,
                    ) -> Result {
                        panic!("could not load vkCreateShaderModule")
                    }
                    fallback
                }
            },
            create_shaders_ext: {
                let value = loader(c"vkCreateShadersEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info_count: u32,
                        _create_infos: *const ShaderCreateInfoEXT,
                        _allocator: *const AllocationCallbacks,
                        _shaders: *mut ShaderEXT,
                    ) -> Result {
                        panic!("could not load vkCreateShadersEXT")
                    }
                    fallback
                }
            },
            create_shared_swapchains_khr: {
                let value = loader(c"vkCreateSharedSwapchainsKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _swapchain_count: u32,
                        _create_infos: *const SwapchainCreateInfoKHR,
                        _allocator: *const AllocationCallbacks,
                        _swapchains: *mut SwapchainKHR,
                    ) -> Result {
                        panic!("could not load vkCreateSharedSwapchainsKHR")
                    }
                    fallback
                }
            },
            create_swapchain_khr: {
                let value = loader(c"vkCreateSwapchainKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const SwapchainCreateInfoKHR,
                        _allocator: *const AllocationCallbacks,
                        _swapchain: *mut SwapchainKHR,
                    ) -> Result {
                        panic!("could not load vkCreateSwapchainKHR")
                    }
                    fallback
                }
            },
            create_tensor_arm: {
                let value = loader(c"vkCreateTensorARM".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const TensorCreateInfoARM,
                        _allocator: *const AllocationCallbacks,
                        _tensor: *mut TensorARM,
                    ) -> Result {
                        panic!("could not load vkCreateTensorARM")
                    }
                    fallback
                }
            },
            create_tensor_view_arm: {
                let value = loader(c"vkCreateTensorViewARM".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const TensorViewCreateInfoARM,
                        _allocator: *const AllocationCallbacks,
                        _view: *mut TensorViewARM,
                    ) -> Result {
                        panic!("could not load vkCreateTensorViewARM")
                    }
                    fallback
                }
            },
            create_validation_cache_ext: {
                let value = loader(c"vkCreateValidationCacheEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const ValidationCacheCreateInfoEXT,
                        _allocator: *const AllocationCallbacks,
                        _validation_cache: *mut ValidationCacheEXT,
                    ) -> Result {
                        panic!("could not load vkCreateValidationCacheEXT")
                    }
                    fallback
                }
            },
            create_video_session_khr: {
                let value = loader(c"vkCreateVideoSessionKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const VideoSessionCreateInfoKHR,
                        _allocator: *const AllocationCallbacks,
                        _video_session: *mut VideoSessionKHR,
                    ) -> Result {
                        panic!("could not load vkCreateVideoSessionKHR")
                    }
                    fallback
                }
            },
            create_video_session_parameters_khr: {
                let value = loader(c"vkCreateVideoSessionParametersKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const VideoSessionParametersCreateInfoKHR,
                        _allocator: *const AllocationCallbacks,
                        _video_session_parameters: *mut VideoSessionParametersKHR,
                    ) -> Result {
                        panic!("could not load vkCreateVideoSessionParametersKHR")
                    }
                    fallback
                }
            },
            debug_marker_set_object_name_ext: {
                let value = loader(c"vkDebugMarkerSetObjectNameEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _name_info: *const DebugMarkerObjectNameInfoEXT,
                    ) -> Result {
                        panic!("could not load vkDebugMarkerSetObjectNameEXT")
                    }
                    fallback
                }
            },
            debug_marker_set_object_tag_ext: {
                let value = loader(c"vkDebugMarkerSetObjectTagEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _tag_info: *const DebugMarkerObjectTagInfoEXT,
                    ) -> Result {
                        panic!("could not load vkDebugMarkerSetObjectTagEXT")
                    }
                    fallback
                }
            },
            deferred_operation_join_khr: {
                let value = loader(c"vkDeferredOperationJoinKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _operation: DeferredOperationKHR,
                    ) -> Result {
                        panic!("could not load vkDeferredOperationJoinKHR")
                    }
                    fallback
                }
            },
            destroy_acceleration_structure_khr: {
                let value = loader(c"vkDestroyAccelerationStructureKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _acceleration_structure: AccelerationStructureKHR,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyAccelerationStructureKHR")
                    }
                    fallback
                }
            },
            destroy_acceleration_structure_nv: {
                let value = loader(c"vkDestroyAccelerationStructureNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _acceleration_structure: AccelerationStructureNV,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyAccelerationStructureNV")
                    }
                    fallback
                }
            },
            destroy_buffer: {
                let value = loader(c"vkDestroyBuffer".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _buffer: Buffer,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyBuffer")
                    }
                    fallback
                }
            },
            destroy_buffer_collection_fuchsia: {
                let value = loader(c"vkDestroyBufferCollectionFUCHSIA".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _collection: BufferCollectionFUCHSIA,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyBufferCollectionFUCHSIA")
                    }
                    fallback
                }
            },
            destroy_buffer_view: {
                let value = loader(c"vkDestroyBufferView".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _buffer_view: BufferView,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyBufferView")
                    }
                    fallback
                }
            },
            destroy_command_pool: {
                let value = loader(c"vkDestroyCommandPool".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _command_pool: CommandPool,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyCommandPool")
                    }
                    fallback
                }
            },
            destroy_cu_function_nvx: {
                let value = loader(c"vkDestroyCuFunctionNVX".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _function: CuFunctionNVX,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyCuFunctionNVX")
                    }
                    fallback
                }
            },
            destroy_cu_module_nvx: {
                let value = loader(c"vkDestroyCuModuleNVX".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _module: CuModuleNVX,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyCuModuleNVX")
                    }
                    fallback
                }
            },
            destroy_cuda_function_nv: {
                let value = loader(c"vkDestroyCudaFunctionNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _function: CudaFunctionNV,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyCudaFunctionNV")
                    }
                    fallback
                }
            },
            destroy_cuda_module_nv: {
                let value = loader(c"vkDestroyCudaModuleNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _module: CudaModuleNV,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyCudaModuleNV")
                    }
                    fallback
                }
            },
            destroy_data_graph_pipeline_session_arm: {
                let value = loader(c"vkDestroyDataGraphPipelineSessionARM".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _session: DataGraphPipelineSessionARM,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyDataGraphPipelineSessionARM")
                    }
                    fallback
                }
            },
            destroy_deferred_operation_khr: {
                let value = loader(c"vkDestroyDeferredOperationKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _operation: DeferredOperationKHR,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyDeferredOperationKHR")
                    }
                    fallback
                }
            },
            destroy_descriptor_pool: {
                let value = loader(c"vkDestroyDescriptorPool".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _descriptor_pool: DescriptorPool,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyDescriptorPool")
                    }
                    fallback
                }
            },
            destroy_descriptor_set_layout: {
                let value = loader(c"vkDestroyDescriptorSetLayout".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _descriptor_set_layout: DescriptorSetLayout,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyDescriptorSetLayout")
                    }
                    fallback
                }
            },
            destroy_descriptor_update_template: {
                let value = loader(c"vkDestroyDescriptorUpdateTemplate".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _descriptor_update_template: DescriptorUpdateTemplate,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyDescriptorUpdateTemplate")
                    }
                    fallback
                }
            },
            destroy_descriptor_update_template_khr: {
                let value = loader(c"vkDestroyDescriptorUpdateTemplateKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _descriptor_update_template: DescriptorUpdateTemplate,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyDescriptorUpdateTemplateKHR")
                    }
                    fallback
                }
            },
            destroy_device: {
                let value = loader(c"vkDestroyDevice".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyDevice")
                    }
                    fallback
                }
            },
            destroy_event: {
                let value = loader(c"vkDestroyEvent".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _event: Event,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyEvent")
                    }
                    fallback
                }
            },
            destroy_external_compute_queue_nv: {
                let value = loader(c"vkDestroyExternalComputeQueueNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _external_queue: ExternalComputeQueueNV,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyExternalComputeQueueNV")
                    }
                    fallback
                }
            },
            destroy_fence: {
                let value = loader(c"vkDestroyFence".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _fence: Fence,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyFence")
                    }
                    fallback
                }
            },
            destroy_framebuffer: {
                let value = loader(c"vkDestroyFramebuffer".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _framebuffer: Framebuffer,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyFramebuffer")
                    }
                    fallback
                }
            },
            destroy_image: {
                let value = loader(c"vkDestroyImage".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _image: Image,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyImage")
                    }
                    fallback
                }
            },
            destroy_image_view: {
                let value = loader(c"vkDestroyImageView".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _image_view: ImageView,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyImageView")
                    }
                    fallback
                }
            },
            destroy_indirect_commands_layout_ext: {
                let value = loader(c"vkDestroyIndirectCommandsLayoutEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _indirect_commands_layout: IndirectCommandsLayoutEXT,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyIndirectCommandsLayoutEXT")
                    }
                    fallback
                }
            },
            destroy_indirect_commands_layout_nv: {
                let value = loader(c"vkDestroyIndirectCommandsLayoutNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _indirect_commands_layout: IndirectCommandsLayoutNV,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyIndirectCommandsLayoutNV")
                    }
                    fallback
                }
            },
            destroy_indirect_execution_set_ext: {
                let value = loader(c"vkDestroyIndirectExecutionSetEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _indirect_execution_set: IndirectExecutionSetEXT,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyIndirectExecutionSetEXT")
                    }
                    fallback
                }
            },
            destroy_micromap_ext: {
                let value = loader(c"vkDestroyMicromapEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _micromap: MicromapEXT,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyMicromapEXT")
                    }
                    fallback
                }
            },
            destroy_optical_flow_session_nv: {
                let value = loader(c"vkDestroyOpticalFlowSessionNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _session: OpticalFlowSessionNV,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyOpticalFlowSessionNV")
                    }
                    fallback
                }
            },
            destroy_pipeline: {
                let value = loader(c"vkDestroyPipeline".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _pipeline: Pipeline,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyPipeline")
                    }
                    fallback
                }
            },
            destroy_pipeline_binary_khr: {
                let value = loader(c"vkDestroyPipelineBinaryKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _pipeline_binary: PipelineBinaryKHR,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyPipelineBinaryKHR")
                    }
                    fallback
                }
            },
            destroy_pipeline_cache: {
                let value = loader(c"vkDestroyPipelineCache".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _pipeline_cache: PipelineCache,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyPipelineCache")
                    }
                    fallback
                }
            },
            destroy_pipeline_layout: {
                let value = loader(c"vkDestroyPipelineLayout".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _pipeline_layout: PipelineLayout,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyPipelineLayout")
                    }
                    fallback
                }
            },
            destroy_private_data_slot: {
                let value = loader(c"vkDestroyPrivateDataSlot".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _private_data_slot: PrivateDataSlot,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyPrivateDataSlot")
                    }
                    fallback
                }
            },
            destroy_private_data_slot_ext: {
                let value = loader(c"vkDestroyPrivateDataSlotEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _private_data_slot: PrivateDataSlot,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyPrivateDataSlotEXT")
                    }
                    fallback
                }
            },
            destroy_query_pool: {
                let value = loader(c"vkDestroyQueryPool".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _query_pool: QueryPool,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyQueryPool")
                    }
                    fallback
                }
            },
            destroy_render_pass: {
                let value = loader(c"vkDestroyRenderPass".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _render_pass: RenderPass,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyRenderPass")
                    }
                    fallback
                }
            },
            destroy_sampler: {
                let value = loader(c"vkDestroySampler".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _sampler: Sampler,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroySampler")
                    }
                    fallback
                }
            },
            destroy_sampler_ycbcr_conversion: {
                let value = loader(c"vkDestroySamplerYcbcrConversion".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _ycbcr_conversion: SamplerYcbcrConversion,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroySamplerYcbcrConversion")
                    }
                    fallback
                }
            },
            destroy_sampler_ycbcr_conversion_khr: {
                let value = loader(c"vkDestroySamplerYcbcrConversionKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _ycbcr_conversion: SamplerYcbcrConversion,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroySamplerYcbcrConversionKHR")
                    }
                    fallback
                }
            },
            destroy_semaphore: {
                let value = loader(c"vkDestroySemaphore".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _semaphore: Semaphore,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroySemaphore")
                    }
                    fallback
                }
            },
            destroy_semaphore_sci_sync_pool_nv: {
                let value = loader(c"vkDestroySemaphoreSciSyncPoolNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _semaphore_pool: SemaphoreSciSyncPoolNV,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroySemaphoreSciSyncPoolNV")
                    }
                    fallback
                }
            },
            destroy_shader_ext: {
                let value = loader(c"vkDestroyShaderEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _shader: ShaderEXT,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyShaderEXT")
                    }
                    fallback
                }
            },
            destroy_shader_module: {
                let value = loader(c"vkDestroyShaderModule".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _shader_module: ShaderModule,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyShaderModule")
                    }
                    fallback
                }
            },
            destroy_swapchain_khr: {
                let value = loader(c"vkDestroySwapchainKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _swapchain: SwapchainKHR,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroySwapchainKHR")
                    }
                    fallback
                }
            },
            destroy_tensor_arm: {
                let value = loader(c"vkDestroyTensorARM".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _tensor: TensorARM,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyTensorARM")
                    }
                    fallback
                }
            },
            destroy_tensor_view_arm: {
                let value = loader(c"vkDestroyTensorViewARM".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _tensor_view: TensorViewARM,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyTensorViewARM")
                    }
                    fallback
                }
            },
            destroy_validation_cache_ext: {
                let value = loader(c"vkDestroyValidationCacheEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _validation_cache: ValidationCacheEXT,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyValidationCacheEXT")
                    }
                    fallback
                }
            },
            destroy_video_session_khr: {
                let value = loader(c"vkDestroyVideoSessionKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _video_session: VideoSessionKHR,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyVideoSessionKHR")
                    }
                    fallback
                }
            },
            destroy_video_session_parameters_khr: {
                let value = loader(c"vkDestroyVideoSessionParametersKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _video_session_parameters: VideoSessionParametersKHR,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyVideoSessionParametersKHR")
                    }
                    fallback
                }
            },
            device_wait_idle: {
                let value = loader(c"vkDeviceWaitIdle".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(_device: Device) -> Result {
                        panic!("could not load vkDeviceWaitIdle")
                    }
                    fallback
                }
            },
            display_power_control_ext: {
                let value = loader(c"vkDisplayPowerControlEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _display: DisplayKHR,
                        _display_power_info: *const DisplayPowerInfoEXT,
                    ) -> Result {
                        panic!("could not load vkDisplayPowerControlEXT")
                    }
                    fallback
                }
            },
            end_command_buffer: {
                let value = loader(c"vkEndCommandBuffer".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(_command_buffer: CommandBuffer) -> Result {
                        panic!("could not load vkEndCommandBuffer")
                    }
                    fallback
                }
            },
            enumerate_physical_device_queue_family_performance_query_counters_khr: {
                let value = instance_loader(
                    c"vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR".as_ptr(),
                );
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _queue_family_index: u32,
                        _counter_count: *mut u32,
                        _counters: *mut PerformanceCounterKHR,
                        _counter_descriptions: *mut PerformanceCounterDescriptionKHR,
                    ) -> Result {
                        panic!("could not load vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR")
                    }
                    fallback
                }
            },
            export_metal_objects_ext: {
                let value = loader(c"vkExportMetalObjectsEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _metal_objects_info: *mut ExportMetalObjectsInfoEXT,
                    ) {
                        panic!("could not load vkExportMetalObjectsEXT")
                    }
                    fallback
                }
            },
            flush_mapped_memory_ranges: {
                let value = loader(c"vkFlushMappedMemoryRanges".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _memory_range_count: u32,
                        _memory_ranges: *const MappedMemoryRange,
                    ) -> Result {
                        panic!("could not load vkFlushMappedMemoryRanges")
                    }
                    fallback
                }
            },
            free_command_buffers: {
                let value = loader(c"vkFreeCommandBuffers".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _command_pool: CommandPool,
                        _command_buffer_count: u32,
                        _command_buffers: *const CommandBuffer,
                    ) {
                        panic!("could not load vkFreeCommandBuffers")
                    }
                    fallback
                }
            },
            free_descriptor_sets: {
                let value = loader(c"vkFreeDescriptorSets".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _descriptor_pool: DescriptorPool,
                        _descriptor_set_count: u32,
                        _descriptor_sets: *const DescriptorSet,
                    ) -> Result {
                        panic!("could not load vkFreeDescriptorSets")
                    }
                    fallback
                }
            },
            free_memory: {
                let value = loader(c"vkFreeMemory".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _memory: DeviceMemory,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkFreeMemory")
                    }
                    fallback
                }
            },
            get_acceleration_structure_build_sizes_khr: {
                let value = loader(c"vkGetAccelerationStructureBuildSizesKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _build_type: AccelerationStructureBuildTypeKHR,
                        _build_info: *const AccelerationStructureBuildGeometryInfoKHR,
                        _max_primitive_counts: *const u32,
                        _size_info: *mut AccelerationStructureBuildSizesInfoKHR,
                    ) {
                        panic!("could not load vkGetAccelerationStructureBuildSizesKHR")
                    }
                    fallback
                }
            },
            get_acceleration_structure_device_address_khr: {
                let value = loader(c"vkGetAccelerationStructureDeviceAddressKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const AccelerationStructureDeviceAddressInfoKHR,
                    ) -> DeviceAddress {
                        panic!("could not load vkGetAccelerationStructureDeviceAddressKHR")
                    }
                    fallback
                }
            },
            get_acceleration_structure_handle_nv: {
                let value = loader(c"vkGetAccelerationStructureHandleNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _acceleration_structure: AccelerationStructureNV,
                        _data_size: usize,
                        _data: *mut c_void,
                    ) -> Result {
                        panic!("could not load vkGetAccelerationStructureHandleNV")
                    }
                    fallback
                }
            },
            get_acceleration_structure_memory_requirements_nv: {
                let value = loader(c"vkGetAccelerationStructureMemoryRequirementsNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const AccelerationStructureMemoryRequirementsInfoNV,
                        _memory_requirements: *mut MemoryRequirements2KHR,
                    ) {
                        panic!("could not load vkGetAccelerationStructureMemoryRequirementsNV")
                    }
                    fallback
                }
            },
            get_acceleration_structure_opaque_capture_descriptor_data_ext: {
                let value =
                    loader(c"vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const AccelerationStructureCaptureDescriptorDataInfoEXT,
                        _data: *mut c_void,
                    ) -> Result {
                        panic!("could not load vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT")
                    }
                    fallback
                }
            },
            get_android_hardware_buffer_properties_android: {
                let value = loader(c"vkGetAndroidHardwareBufferPropertiesANDROID".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _buffer: *const AHardwareBuffer,
                        _properties: *mut AndroidHardwareBufferPropertiesANDROID,
                    ) -> Result {
                        panic!("could not load vkGetAndroidHardwareBufferPropertiesANDROID")
                    }
                    fallback
                }
            },
            get_buffer_collection_properties_fuchsia: {
                let value = loader(c"vkGetBufferCollectionPropertiesFUCHSIA".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _collection: BufferCollectionFUCHSIA,
                        _properties: *mut BufferCollectionPropertiesFUCHSIA,
                    ) -> Result {
                        panic!("could not load vkGetBufferCollectionPropertiesFUCHSIA")
                    }
                    fallback
                }
            },
            get_buffer_device_address: {
                let value = loader(c"vkGetBufferDeviceAddress".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const BufferDeviceAddressInfo,
                    ) -> DeviceAddress {
                        panic!("could not load vkGetBufferDeviceAddress")
                    }
                    fallback
                }
            },
            get_buffer_device_address_ext: {
                let value = loader(c"vkGetBufferDeviceAddressEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const BufferDeviceAddressInfo,
                    ) -> DeviceAddress {
                        panic!("could not load vkGetBufferDeviceAddressEXT")
                    }
                    fallback
                }
            },
            get_buffer_device_address_khr: {
                let value = loader(c"vkGetBufferDeviceAddressKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const BufferDeviceAddressInfo,
                    ) -> DeviceAddress {
                        panic!("could not load vkGetBufferDeviceAddressKHR")
                    }
                    fallback
                }
            },
            get_buffer_memory_requirements: {
                let value = loader(c"vkGetBufferMemoryRequirements".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _buffer: Buffer,
                        _memory_requirements: *mut MemoryRequirements,
                    ) {
                        panic!("could not load vkGetBufferMemoryRequirements")
                    }
                    fallback
                }
            },
            get_buffer_memory_requirements2: {
                let value = loader(c"vkGetBufferMemoryRequirements2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const BufferMemoryRequirementsInfo2,
                        _memory_requirements: *mut MemoryRequirements2,
                    ) {
                        panic!("could not load vkGetBufferMemoryRequirements2")
                    }
                    fallback
                }
            },
            get_buffer_memory_requirements2_khr: {
                let value = loader(c"vkGetBufferMemoryRequirements2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const BufferMemoryRequirementsInfo2,
                        _memory_requirements: *mut MemoryRequirements2,
                    ) {
                        panic!("could not load vkGetBufferMemoryRequirements2KHR")
                    }
                    fallback
                }
            },
            get_buffer_opaque_capture_address: {
                let value = loader(c"vkGetBufferOpaqueCaptureAddress".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const BufferDeviceAddressInfo,
                    ) -> u64 {
                        panic!("could not load vkGetBufferOpaqueCaptureAddress")
                    }
                    fallback
                }
            },
            get_buffer_opaque_capture_address_khr: {
                let value = loader(c"vkGetBufferOpaqueCaptureAddressKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const BufferDeviceAddressInfo,
                    ) -> u64 {
                        panic!("could not load vkGetBufferOpaqueCaptureAddressKHR")
                    }
                    fallback
                }
            },
            get_buffer_opaque_capture_descriptor_data_ext: {
                let value = loader(c"vkGetBufferOpaqueCaptureDescriptorDataEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const BufferCaptureDescriptorDataInfoEXT,
                        _data: *mut c_void,
                    ) -> Result {
                        panic!("could not load vkGetBufferOpaqueCaptureDescriptorDataEXT")
                    }
                    fallback
                }
            },
            get_calibrated_timestamps_ext: {
                let value = loader(c"vkGetCalibratedTimestampsEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _timestamp_count: u32,
                        _timestamp_infos: *const CalibratedTimestampInfoKHR,
                        _timestamps: *mut u64,
                        _max_deviation: *mut u64,
                    ) -> Result {
                        panic!("could not load vkGetCalibratedTimestampsEXT")
                    }
                    fallback
                }
            },
            get_calibrated_timestamps_khr: {
                let value = loader(c"vkGetCalibratedTimestampsKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _timestamp_count: u32,
                        _timestamp_infos: *const CalibratedTimestampInfoKHR,
                        _timestamps: *mut u64,
                        _max_deviation: *mut u64,
                    ) -> Result {
                        panic!("could not load vkGetCalibratedTimestampsKHR")
                    }
                    fallback
                }
            },
            get_cluster_acceleration_structure_build_sizes_nv: {
                let value = loader(c"vkGetClusterAccelerationStructureBuildSizesNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const ClusterAccelerationStructureInputInfoNV,
                        _size_info: *mut AccelerationStructureBuildSizesInfoKHR,
                    ) {
                        panic!("could not load vkGetClusterAccelerationStructureBuildSizesNV")
                    }
                    fallback
                }
            },
            get_cuda_module_cache_nv: {
                let value = loader(c"vkGetCudaModuleCacheNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _module: CudaModuleNV,
                        _cache_size: *mut usize,
                        _cache_data: *mut c_void,
                    ) -> Result {
                        panic!("could not load vkGetCudaModuleCacheNV")
                    }
                    fallback
                }
            },
            get_data_graph_pipeline_available_properties_arm: {
                let value = loader(c"vkGetDataGraphPipelineAvailablePropertiesARM".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _pipeline_info: *const DataGraphPipelineInfoARM,
                        _properties_count: *mut u32,
                        _properties: *mut DataGraphPipelinePropertyARM,
                    ) -> Result {
                        panic!("could not load vkGetDataGraphPipelineAvailablePropertiesARM")
                    }
                    fallback
                }
            },
            get_data_graph_pipeline_properties_arm: {
                let value = loader(c"vkGetDataGraphPipelinePropertiesARM".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _pipeline_info: *const DataGraphPipelineInfoARM,
                        _properties_count: u32,
                        _properties: *mut DataGraphPipelinePropertyQueryResultARM,
                    ) -> Result {
                        panic!("could not load vkGetDataGraphPipelinePropertiesARM")
                    }
                    fallback
                }
            },
            get_data_graph_pipeline_session_bind_point_requirements_arm: {
                let value =
                    loader(c"vkGetDataGraphPipelineSessionBindPointRequirementsARM".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const DataGraphPipelineSessionBindPointRequirementsInfoARM,
                        _bind_point_requirement_count: *mut u32,
                        _bind_point_requirements: *mut DataGraphPipelineSessionBindPointRequirementARM,
                    ) -> Result {
                        panic!(
                            "could not load vkGetDataGraphPipelineSessionBindPointRequirementsARM"
                        )
                    }
                    fallback
                }
            },
            get_data_graph_pipeline_session_memory_requirements_arm: {
                let value = loader(c"vkGetDataGraphPipelineSessionMemoryRequirementsARM".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const DataGraphPipelineSessionMemoryRequirementsInfoARM,
                        _memory_requirements: *mut MemoryRequirements2,
                    ) {
                        panic!("could not load vkGetDataGraphPipelineSessionMemoryRequirementsARM")
                    }
                    fallback
                }
            },
            get_deferred_operation_max_concurrency_khr: {
                let value = loader(c"vkGetDeferredOperationMaxConcurrencyKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _operation: DeferredOperationKHR,
                    ) -> u32 {
                        panic!("could not load vkGetDeferredOperationMaxConcurrencyKHR")
                    }
                    fallback
                }
            },
            get_deferred_operation_result_khr: {
                let value = loader(c"vkGetDeferredOperationResultKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _operation: DeferredOperationKHR,
                    ) -> Result {
                        panic!("could not load vkGetDeferredOperationResultKHR")
                    }
                    fallback
                }
            },
            get_descriptor_ext: {
                let value = loader(c"vkGetDescriptorEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _descriptor_info: *const DescriptorGetInfoEXT,
                        _data_size: usize,
                        _descriptor: *mut c_void,
                    ) {
                        panic!("could not load vkGetDescriptorEXT")
                    }
                    fallback
                }
            },
            get_descriptor_set_host_mapping_valve: {
                let value = loader(c"vkGetDescriptorSetHostMappingVALVE".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _descriptor_set: DescriptorSet,
                        _data: *mut *mut c_void,
                    ) {
                        panic!("could not load vkGetDescriptorSetHostMappingVALVE")
                    }
                    fallback
                }
            },
            get_descriptor_set_layout_binding_offset_ext: {
                let value = loader(c"vkGetDescriptorSetLayoutBindingOffsetEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _layout: DescriptorSetLayout,
                        _binding: u32,
                        _offset: *mut DeviceSize,
                    ) {
                        panic!("could not load vkGetDescriptorSetLayoutBindingOffsetEXT")
                    }
                    fallback
                }
            },
            get_descriptor_set_layout_host_mapping_info_valve: {
                let value = loader(c"vkGetDescriptorSetLayoutHostMappingInfoVALVE".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _binding_reference: *const DescriptorSetBindingReferenceVALVE,
                        _host_mapping: *mut DescriptorSetLayoutHostMappingInfoVALVE,
                    ) {
                        panic!("could not load vkGetDescriptorSetLayoutHostMappingInfoVALVE")
                    }
                    fallback
                }
            },
            get_descriptor_set_layout_size_ext: {
                let value = loader(c"vkGetDescriptorSetLayoutSizeEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _layout: DescriptorSetLayout,
                        _layout_size_in_bytes: *mut DeviceSize,
                    ) {
                        panic!("could not load vkGetDescriptorSetLayoutSizeEXT")
                    }
                    fallback
                }
            },
            get_descriptor_set_layout_support: {
                let value = loader(c"vkGetDescriptorSetLayoutSupport".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const DescriptorSetLayoutCreateInfo,
                        _support: *mut DescriptorSetLayoutSupport,
                    ) {
                        panic!("could not load vkGetDescriptorSetLayoutSupport")
                    }
                    fallback
                }
            },
            get_descriptor_set_layout_support_khr: {
                let value = loader(c"vkGetDescriptorSetLayoutSupportKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const DescriptorSetLayoutCreateInfo,
                        _support: *mut DescriptorSetLayoutSupport,
                    ) {
                        panic!("could not load vkGetDescriptorSetLayoutSupportKHR")
                    }
                    fallback
                }
            },
            get_device_acceleration_structure_compatibility_khr: {
                let value = loader(c"vkGetDeviceAccelerationStructureCompatibilityKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _version_info: *const AccelerationStructureVersionInfoKHR,
                        _compatibility: *mut AccelerationStructureCompatibilityKHR,
                    ) {
                        panic!("could not load vkGetDeviceAccelerationStructureCompatibilityKHR")
                    }
                    fallback
                }
            },
            get_device_buffer_memory_requirements: {
                let value = loader(c"vkGetDeviceBufferMemoryRequirements".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const DeviceBufferMemoryRequirements,
                        _memory_requirements: *mut MemoryRequirements2,
                    ) {
                        panic!("could not load vkGetDeviceBufferMemoryRequirements")
                    }
                    fallback
                }
            },
            get_device_buffer_memory_requirements_khr: {
                let value = loader(c"vkGetDeviceBufferMemoryRequirementsKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const DeviceBufferMemoryRequirements,
                        _memory_requirements: *mut MemoryRequirements2,
                    ) {
                        panic!("could not load vkGetDeviceBufferMemoryRequirementsKHR")
                    }
                    fallback
                }
            },
            get_device_fault_info_ext: {
                let value = loader(c"vkGetDeviceFaultInfoEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _fault_counts: *mut DeviceFaultCountsEXT,
                        _fault_info: *mut DeviceFaultInfoEXT,
                    ) -> Result {
                        panic!("could not load vkGetDeviceFaultInfoEXT")
                    }
                    fallback
                }
            },
            get_device_group_peer_memory_features: {
                let value = loader(c"vkGetDeviceGroupPeerMemoryFeatures".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _heap_index: u32,
                        _local_device_index: u32,
                        _remote_device_index: u32,
                        _peer_memory_features: *mut PeerMemoryFeatureFlags,
                    ) {
                        panic!("could not load vkGetDeviceGroupPeerMemoryFeatures")
                    }
                    fallback
                }
            },
            get_device_group_peer_memory_features_khr: {
                let value = loader(c"vkGetDeviceGroupPeerMemoryFeaturesKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _heap_index: u32,
                        _local_device_index: u32,
                        _remote_device_index: u32,
                        _peer_memory_features: *mut PeerMemoryFeatureFlags,
                    ) {
                        panic!("could not load vkGetDeviceGroupPeerMemoryFeaturesKHR")
                    }
                    fallback
                }
            },
            get_device_group_present_capabilities_khr: {
                let value = loader(c"vkGetDeviceGroupPresentCapabilitiesKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _device_group_present_capabilities: *mut DeviceGroupPresentCapabilitiesKHR,
                    ) -> Result {
                        panic!("could not load vkGetDeviceGroupPresentCapabilitiesKHR")
                    }
                    fallback
                }
            },
            get_device_group_surface_present_modes2_ext: {
                let value = loader(c"vkGetDeviceGroupSurfacePresentModes2EXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _surface_info: *const PhysicalDeviceSurfaceInfo2KHR,
                        _modes: *mut DeviceGroupPresentModeFlagsKHR,
                    ) -> Result {
                        panic!("could not load vkGetDeviceGroupSurfacePresentModes2EXT")
                    }
                    fallback
                }
            },
            get_device_group_surface_present_modes_khr: {
                let value = loader(c"vkGetDeviceGroupSurfacePresentModesKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _surface: SurfaceKHR,
                        _modes: *mut DeviceGroupPresentModeFlagsKHR,
                    ) -> Result {
                        panic!("could not load vkGetDeviceGroupSurfacePresentModesKHR")
                    }
                    fallback
                }
            },
            get_device_image_memory_requirements: {
                let value = loader(c"vkGetDeviceImageMemoryRequirements".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const DeviceImageMemoryRequirements,
                        _memory_requirements: *mut MemoryRequirements2,
                    ) {
                        panic!("could not load vkGetDeviceImageMemoryRequirements")
                    }
                    fallback
                }
            },
            get_device_image_memory_requirements_khr: {
                let value = loader(c"vkGetDeviceImageMemoryRequirementsKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const DeviceImageMemoryRequirements,
                        _memory_requirements: *mut MemoryRequirements2,
                    ) {
                        panic!("could not load vkGetDeviceImageMemoryRequirementsKHR")
                    }
                    fallback
                }
            },
            get_device_image_sparse_memory_requirements: {
                let value = loader(c"vkGetDeviceImageSparseMemoryRequirements".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const DeviceImageMemoryRequirements,
                        _sparse_memory_requirement_count: *mut u32,
                        _sparse_memory_requirements: *mut SparseImageMemoryRequirements2,
                    ) {
                        panic!("could not load vkGetDeviceImageSparseMemoryRequirements")
                    }
                    fallback
                }
            },
            get_device_image_sparse_memory_requirements_khr: {
                let value = loader(c"vkGetDeviceImageSparseMemoryRequirementsKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const DeviceImageMemoryRequirements,
                        _sparse_memory_requirement_count: *mut u32,
                        _sparse_memory_requirements: *mut SparseImageMemoryRequirements2,
                    ) {
                        panic!("could not load vkGetDeviceImageSparseMemoryRequirementsKHR")
                    }
                    fallback
                }
            },
            get_device_image_subresource_layout: {
                let value = loader(c"vkGetDeviceImageSubresourceLayout".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const DeviceImageSubresourceInfo,
                        _layout: *mut SubresourceLayout2,
                    ) {
                        panic!("could not load vkGetDeviceImageSubresourceLayout")
                    }
                    fallback
                }
            },
            get_device_image_subresource_layout_khr: {
                let value = loader(c"vkGetDeviceImageSubresourceLayoutKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const DeviceImageSubresourceInfo,
                        _layout: *mut SubresourceLayout2,
                    ) {
                        panic!("could not load vkGetDeviceImageSubresourceLayoutKHR")
                    }
                    fallback
                }
            },
            get_device_memory_commitment: {
                let value = loader(c"vkGetDeviceMemoryCommitment".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _memory: DeviceMemory,
                        _committed_memory_in_bytes: *mut DeviceSize,
                    ) {
                        panic!("could not load vkGetDeviceMemoryCommitment")
                    }
                    fallback
                }
            },
            get_device_memory_opaque_capture_address: {
                let value = loader(c"vkGetDeviceMemoryOpaqueCaptureAddress".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const DeviceMemoryOpaqueCaptureAddressInfo,
                    ) -> u64 {
                        panic!("could not load vkGetDeviceMemoryOpaqueCaptureAddress")
                    }
                    fallback
                }
            },
            get_device_memory_opaque_capture_address_khr: {
                let value = loader(c"vkGetDeviceMemoryOpaqueCaptureAddressKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const DeviceMemoryOpaqueCaptureAddressInfo,
                    ) -> u64 {
                        panic!("could not load vkGetDeviceMemoryOpaqueCaptureAddressKHR")
                    }
                    fallback
                }
            },
            get_device_micromap_compatibility_ext: {
                let value = loader(c"vkGetDeviceMicromapCompatibilityEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _version_info: *const MicromapVersionInfoEXT,
                        _compatibility: *mut AccelerationStructureCompatibilityKHR,
                    ) {
                        panic!("could not load vkGetDeviceMicromapCompatibilityEXT")
                    }
                    fallback
                }
            },
            get_device_queue: {
                let value = loader(c"vkGetDeviceQueue".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _queue_family_index: u32,
                        _queue_index: u32,
                        _queue: *mut Queue,
                    ) {
                        panic!("could not load vkGetDeviceQueue")
                    }
                    fallback
                }
            },
            get_device_queue2: {
                let value = loader(c"vkGetDeviceQueue2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _queue_info: *const DeviceQueueInfo2,
                        _queue: *mut Queue,
                    ) {
                        panic!("could not load vkGetDeviceQueue2")
                    }
                    fallback
                }
            },
            get_device_subpass_shading_max_workgroup_size_huawei: {
                let value = loader(c"vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _renderpass: RenderPass,
                        _max_workgroup_size: *mut Extent2D,
                    ) -> Result {
                        panic!("could not load vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI")
                    }
                    fallback
                }
            },
            get_device_tensor_memory_requirements_arm: {
                let value = loader(c"vkGetDeviceTensorMemoryRequirementsARM".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const DeviceTensorMemoryRequirementsARM,
                        _memory_requirements: *mut MemoryRequirements2,
                    ) {
                        panic!("could not load vkGetDeviceTensorMemoryRequirementsARM")
                    }
                    fallback
                }
            },
            get_dynamic_rendering_tile_properties_qcom: {
                let value = loader(c"vkGetDynamicRenderingTilePropertiesQCOM".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _rendering_info: *const RenderingInfo,
                        _properties: *mut TilePropertiesQCOM,
                    ) -> Result {
                        panic!("could not load vkGetDynamicRenderingTilePropertiesQCOM")
                    }
                    fallback
                }
            },
            get_encoded_video_session_parameters_khr: {
                let value = loader(c"vkGetEncodedVideoSessionParametersKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _video_session_parameters_info: *const VideoEncodeSessionParametersGetInfoKHR,
                        _feedback_info: *mut VideoEncodeSessionParametersFeedbackInfoKHR,
                        _data_size: *mut usize,
                        _data: *mut c_void,
                    ) -> Result {
                        panic!("could not load vkGetEncodedVideoSessionParametersKHR")
                    }
                    fallback
                }
            },
            get_event_status: {
                let value = loader(c"vkGetEventStatus".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(_device: Device, _event: Event) -> Result {
                        panic!("could not load vkGetEventStatus")
                    }
                    fallback
                }
            },
            get_execution_graph_pipeline_node_index_amdx: {
                let value = loader(c"vkGetExecutionGraphPipelineNodeIndexAMDX".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _execution_graph: Pipeline,
                        _node_info: *const PipelineShaderStageNodeCreateInfoAMDX,
                        _node_index: *mut u32,
                    ) -> Result {
                        panic!("could not load vkGetExecutionGraphPipelineNodeIndexAMDX")
                    }
                    fallback
                }
            },
            get_execution_graph_pipeline_scratch_size_amdx: {
                let value = loader(c"vkGetExecutionGraphPipelineScratchSizeAMDX".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _execution_graph: Pipeline,
                        _size_info: *mut ExecutionGraphPipelineScratchSizeAMDX,
                    ) -> Result {
                        panic!("could not load vkGetExecutionGraphPipelineScratchSizeAMDX")
                    }
                    fallback
                }
            },
            get_external_compute_queue_data_nv: {
                let value = loader(c"vkGetExternalComputeQueueDataNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _external_queue: ExternalComputeQueueNV,
                        _params: *mut ExternalComputeQueueDataParamsNV,
                        _data: *mut c_void,
                    ) {
                        panic!("could not load vkGetExternalComputeQueueDataNV")
                    }
                    fallback
                }
            },
            get_fence_fd_khr: {
                let value = loader(c"vkGetFenceFdKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _get_fd_info: *const FenceGetFdInfoKHR,
                        _fd: *mut c_int,
                    ) -> Result {
                        panic!("could not load vkGetFenceFdKHR")
                    }
                    fallback
                }
            },
            get_fence_sci_sync_fence_nv: {
                let value = loader(c"vkGetFenceSciSyncFenceNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _get_sci_sync_handle_info: *const FenceGetSciSyncInfoNV,
                        _handle: *mut c_void,
                    ) -> Result {
                        panic!("could not load vkGetFenceSciSyncFenceNV")
                    }
                    fallback
                }
            },
            get_fence_sci_sync_obj_nv: {
                let value = loader(c"vkGetFenceSciSyncObjNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _get_sci_sync_handle_info: *const FenceGetSciSyncInfoNV,
                        _handle: *mut c_void,
                    ) -> Result {
                        panic!("could not load vkGetFenceSciSyncObjNV")
                    }
                    fallback
                }
            },
            get_fence_status: {
                let value = loader(c"vkGetFenceStatus".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(_device: Device, _fence: Fence) -> Result {
                        panic!("could not load vkGetFenceStatus")
                    }
                    fallback
                }
            },
            get_fence_win32_handle_khr: {
                let value = loader(c"vkGetFenceWin32HandleKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _get_win32_handle_info: *const FenceGetWin32HandleInfoKHR,
                        _handle: *mut HANDLE,
                    ) -> Result {
                        panic!("could not load vkGetFenceWin32HandleKHR")
                    }
                    fallback
                }
            },
            get_framebuffer_tile_properties_qcom: {
                let value = loader(c"vkGetFramebufferTilePropertiesQCOM".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _framebuffer: Framebuffer,
                        _properties_count: *mut u32,
                        _properties: *mut TilePropertiesQCOM,
                    ) -> Result {
                        panic!("could not load vkGetFramebufferTilePropertiesQCOM")
                    }
                    fallback
                }
            },
            get_generated_commands_memory_requirements_ext: {
                let value = loader(c"vkGetGeneratedCommandsMemoryRequirementsEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const GeneratedCommandsMemoryRequirementsInfoEXT,
                        _memory_requirements: *mut MemoryRequirements2,
                    ) {
                        panic!("could not load vkGetGeneratedCommandsMemoryRequirementsEXT")
                    }
                    fallback
                }
            },
            get_generated_commands_memory_requirements_nv: {
                let value = loader(c"vkGetGeneratedCommandsMemoryRequirementsNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const GeneratedCommandsMemoryRequirementsInfoNV,
                        _memory_requirements: *mut MemoryRequirements2,
                    ) {
                        panic!("could not load vkGetGeneratedCommandsMemoryRequirementsNV")
                    }
                    fallback
                }
            },
            get_image_drm_format_modifier_properties_ext: {
                let value = loader(c"vkGetImageDrmFormatModifierPropertiesEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _image: Image,
                        _properties: *mut ImageDrmFormatModifierPropertiesEXT,
                    ) -> Result {
                        panic!("could not load vkGetImageDrmFormatModifierPropertiesEXT")
                    }
                    fallback
                }
            },
            get_image_memory_requirements: {
                let value = loader(c"vkGetImageMemoryRequirements".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _image: Image,
                        _memory_requirements: *mut MemoryRequirements,
                    ) {
                        panic!("could not load vkGetImageMemoryRequirements")
                    }
                    fallback
                }
            },
            get_image_memory_requirements2: {
                let value = loader(c"vkGetImageMemoryRequirements2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const ImageMemoryRequirementsInfo2,
                        _memory_requirements: *mut MemoryRequirements2,
                    ) {
                        panic!("could not load vkGetImageMemoryRequirements2")
                    }
                    fallback
                }
            },
            get_image_memory_requirements2_khr: {
                let value = loader(c"vkGetImageMemoryRequirements2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const ImageMemoryRequirementsInfo2,
                        _memory_requirements: *mut MemoryRequirements2,
                    ) {
                        panic!("could not load vkGetImageMemoryRequirements2KHR")
                    }
                    fallback
                }
            },
            get_image_opaque_capture_descriptor_data_ext: {
                let value = loader(c"vkGetImageOpaqueCaptureDescriptorDataEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const ImageCaptureDescriptorDataInfoEXT,
                        _data: *mut c_void,
                    ) -> Result {
                        panic!("could not load vkGetImageOpaqueCaptureDescriptorDataEXT")
                    }
                    fallback
                }
            },
            get_image_sparse_memory_requirements: {
                let value = loader(c"vkGetImageSparseMemoryRequirements".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _image: Image,
                        _sparse_memory_requirement_count: *mut u32,
                        _sparse_memory_requirements: *mut SparseImageMemoryRequirements,
                    ) {
                        panic!("could not load vkGetImageSparseMemoryRequirements")
                    }
                    fallback
                }
            },
            get_image_sparse_memory_requirements2: {
                let value = loader(c"vkGetImageSparseMemoryRequirements2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const ImageSparseMemoryRequirementsInfo2,
                        _sparse_memory_requirement_count: *mut u32,
                        _sparse_memory_requirements: *mut SparseImageMemoryRequirements2,
                    ) {
                        panic!("could not load vkGetImageSparseMemoryRequirements2")
                    }
                    fallback
                }
            },
            get_image_sparse_memory_requirements2_khr: {
                let value = loader(c"vkGetImageSparseMemoryRequirements2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const ImageSparseMemoryRequirementsInfo2,
                        _sparse_memory_requirement_count: *mut u32,
                        _sparse_memory_requirements: *mut SparseImageMemoryRequirements2,
                    ) {
                        panic!("could not load vkGetImageSparseMemoryRequirements2KHR")
                    }
                    fallback
                }
            },
            get_image_subresource_layout: {
                let value = loader(c"vkGetImageSubresourceLayout".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _image: Image,
                        _subresource: *const ImageSubresource,
                        _layout: *mut SubresourceLayout,
                    ) {
                        panic!("could not load vkGetImageSubresourceLayout")
                    }
                    fallback
                }
            },
            get_image_subresource_layout2: {
                let value = loader(c"vkGetImageSubresourceLayout2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _image: Image,
                        _subresource: *const ImageSubresource2,
                        _layout: *mut SubresourceLayout2,
                    ) {
                        panic!("could not load vkGetImageSubresourceLayout2")
                    }
                    fallback
                }
            },
            get_image_subresource_layout2_ext: {
                let value = loader(c"vkGetImageSubresourceLayout2EXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _image: Image,
                        _subresource: *const ImageSubresource2,
                        _layout: *mut SubresourceLayout2,
                    ) {
                        panic!("could not load vkGetImageSubresourceLayout2EXT")
                    }
                    fallback
                }
            },
            get_image_subresource_layout2_khr: {
                let value = loader(c"vkGetImageSubresourceLayout2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _image: Image,
                        _subresource: *const ImageSubresource2,
                        _layout: *mut SubresourceLayout2,
                    ) {
                        panic!("could not load vkGetImageSubresourceLayout2KHR")
                    }
                    fallback
                }
            },
            get_image_view_address_nvx: {
                let value = loader(c"vkGetImageViewAddressNVX".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _image_view: ImageView,
                        _properties: *mut ImageViewAddressPropertiesNVX,
                    ) -> Result {
                        panic!("could not load vkGetImageViewAddressNVX")
                    }
                    fallback
                }
            },
            get_image_view_handle64_nvx: {
                let value = loader(c"vkGetImageViewHandle64NVX".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const ImageViewHandleInfoNVX,
                    ) -> u64 {
                        panic!("could not load vkGetImageViewHandle64NVX")
                    }
                    fallback
                }
            },
            get_image_view_handle_nvx: {
                let value = loader(c"vkGetImageViewHandleNVX".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const ImageViewHandleInfoNVX,
                    ) -> u32 {
                        panic!("could not load vkGetImageViewHandleNVX")
                    }
                    fallback
                }
            },
            get_image_view_opaque_capture_descriptor_data_ext: {
                let value = loader(c"vkGetImageViewOpaqueCaptureDescriptorDataEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const ImageViewCaptureDescriptorDataInfoEXT,
                        _data: *mut c_void,
                    ) -> Result {
                        panic!("could not load vkGetImageViewOpaqueCaptureDescriptorDataEXT")
                    }
                    fallback
                }
            },
            get_latency_timings_nv: {
                let value = loader(c"vkGetLatencyTimingsNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _swapchain: SwapchainKHR,
                        _latency_marker_info: *mut GetLatencyMarkerInfoNV,
                    ) {
                        panic!("could not load vkGetLatencyTimingsNV")
                    }
                    fallback
                }
            },
            get_memory_android_hardware_buffer_android: {
                let value = loader(c"vkGetMemoryAndroidHardwareBufferANDROID".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const MemoryGetAndroidHardwareBufferInfoANDROID,
                        _buffer: *mut *mut AHardwareBuffer,
                    ) -> Result {
                        panic!("could not load vkGetMemoryAndroidHardwareBufferANDROID")
                    }
                    fallback
                }
            },
            get_memory_fd_khr: {
                let value = loader(c"vkGetMemoryFdKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _get_fd_info: *const MemoryGetFdInfoKHR,
                        _fd: *mut c_int,
                    ) -> Result {
                        panic!("could not load vkGetMemoryFdKHR")
                    }
                    fallback
                }
            },
            get_memory_fd_properties_khr: {
                let value = loader(c"vkGetMemoryFdPropertiesKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _handle_type: ExternalMemoryHandleTypeFlags,
                        _fd: c_int,
                        _memory_fd_properties: *mut MemoryFdPropertiesKHR,
                    ) -> Result {
                        panic!("could not load vkGetMemoryFdPropertiesKHR")
                    }
                    fallback
                }
            },
            get_memory_host_pointer_properties_ext: {
                let value = loader(c"vkGetMemoryHostPointerPropertiesEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _handle_type: ExternalMemoryHandleTypeFlags,
                        _host_pointer: *const c_void,
                        _memory_host_pointer_properties: *mut MemoryHostPointerPropertiesEXT,
                    ) -> Result {
                        panic!("could not load vkGetMemoryHostPointerPropertiesEXT")
                    }
                    fallback
                }
            },
            get_memory_metal_handle_ext: {
                let value = loader(c"vkGetMemoryMetalHandleEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _get_metal_handle_info: *const MemoryGetMetalHandleInfoEXT,
                        _handle: *mut *mut c_void,
                    ) -> Result {
                        panic!("could not load vkGetMemoryMetalHandleEXT")
                    }
                    fallback
                }
            },
            get_memory_metal_handle_properties_ext: {
                let value = loader(c"vkGetMemoryMetalHandlePropertiesEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _handle_type: ExternalMemoryHandleTypeFlags,
                        _handle: *const c_void,
                        _memory_metal_handle_properties: *mut MemoryMetalHandlePropertiesEXT,
                    ) -> Result {
                        panic!("could not load vkGetMemoryMetalHandlePropertiesEXT")
                    }
                    fallback
                }
            },
            get_memory_remote_address_nv: {
                let value = loader(c"vkGetMemoryRemoteAddressNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _memory_get_remote_address_info: *const MemoryGetRemoteAddressInfoNV,
                        _address: *mut RemoteAddressNV,
                    ) -> Result {
                        panic!("could not load vkGetMemoryRemoteAddressNV")
                    }
                    fallback
                }
            },
            get_memory_sci_buf_nv: {
                let value = loader(c"vkGetMemorySciBufNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _get_sci_buf_info: *const MemoryGetSciBufInfoNV,
                        _handle: *mut NvSciBufObj,
                    ) -> Result {
                        panic!("could not load vkGetMemorySciBufNV")
                    }
                    fallback
                }
            },
            get_memory_win32_handle_khr: {
                let value = loader(c"vkGetMemoryWin32HandleKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _get_win32_handle_info: *const MemoryGetWin32HandleInfoKHR,
                        _handle: *mut HANDLE,
                    ) -> Result {
                        panic!("could not load vkGetMemoryWin32HandleKHR")
                    }
                    fallback
                }
            },
            get_memory_win32_handle_nv: {
                let value = loader(c"vkGetMemoryWin32HandleNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _memory: DeviceMemory,
                        _handle_type: ExternalMemoryHandleTypeFlagsNV,
                        _handle: *mut HANDLE,
                    ) -> Result {
                        panic!("could not load vkGetMemoryWin32HandleNV")
                    }
                    fallback
                }
            },
            get_memory_win32_handle_properties_khr: {
                let value = loader(c"vkGetMemoryWin32HandlePropertiesKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _handle_type: ExternalMemoryHandleTypeFlags,
                        _handle: HANDLE,
                        _memory_win32_handle_properties: *mut MemoryWin32HandlePropertiesKHR,
                    ) -> Result {
                        panic!("could not load vkGetMemoryWin32HandlePropertiesKHR")
                    }
                    fallback
                }
            },
            get_memory_zircon_handle_fuchsia: {
                let value = loader(c"vkGetMemoryZirconHandleFUCHSIA".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _get_zircon_handle_info: *const MemoryGetZirconHandleInfoFUCHSIA,
                        _zircon_handle: *mut zx_handle_t,
                    ) -> Result {
                        panic!("could not load vkGetMemoryZirconHandleFUCHSIA")
                    }
                    fallback
                }
            },
            get_memory_zircon_handle_properties_fuchsia: {
                let value = loader(c"vkGetMemoryZirconHandlePropertiesFUCHSIA".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _handle_type: ExternalMemoryHandleTypeFlags,
                        _zircon_handle: zx_handle_t,
                        _memory_zircon_handle_properties: *mut MemoryZirconHandlePropertiesFUCHSIA,
                    ) -> Result {
                        panic!("could not load vkGetMemoryZirconHandlePropertiesFUCHSIA")
                    }
                    fallback
                }
            },
            get_micromap_build_sizes_ext: {
                let value = loader(c"vkGetMicromapBuildSizesEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _build_type: AccelerationStructureBuildTypeKHR,
                        _build_info: *const MicromapBuildInfoEXT,
                        _size_info: *mut MicromapBuildSizesInfoEXT,
                    ) {
                        panic!("could not load vkGetMicromapBuildSizesEXT")
                    }
                    fallback
                }
            },
            get_partitioned_acceleration_structures_build_sizes_nv: {
                let value = loader(c"vkGetPartitionedAccelerationStructuresBuildSizesNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const PartitionedAccelerationStructureInstancesInputNV,
                        _size_info: *mut AccelerationStructureBuildSizesInfoKHR,
                    ) {
                        panic!("could not load vkGetPartitionedAccelerationStructuresBuildSizesNV")
                    }
                    fallback
                }
            },
            get_past_presentation_timing_google: {
                let value = loader(c"vkGetPastPresentationTimingGOOGLE".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _swapchain: SwapchainKHR,
                        _presentation_timing_count: *mut u32,
                        _presentation_timings: *mut PastPresentationTimingGOOGLE,
                    ) -> Result {
                        panic!("could not load vkGetPastPresentationTimingGOOGLE")
                    }
                    fallback
                }
            },
            get_performance_parameter_intel: {
                let value = loader(c"vkGetPerformanceParameterINTEL".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _parameter: PerformanceParameterTypeINTEL,
                        _value: *mut PerformanceValueINTEL,
                    ) -> Result {
                        panic!("could not load vkGetPerformanceParameterINTEL")
                    }
                    fallback
                }
            },
            get_physical_device_calibrateable_time_domains_ext: {
                let value =
                    instance_loader(c"vkGetPhysicalDeviceCalibrateableTimeDomainsEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _time_domain_count: *mut u32,
                        _time_domains: *mut TimeDomainKHR,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDeviceCalibrateableTimeDomainsEXT")
                    }
                    fallback
                }
            },
            get_physical_device_calibrateable_time_domains_khr: {
                let value =
                    instance_loader(c"vkGetPhysicalDeviceCalibrateableTimeDomainsKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _time_domain_count: *mut u32,
                        _time_domains: *mut TimeDomainKHR,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDeviceCalibrateableTimeDomainsKHR")
                    }
                    fallback
                }
            },
            get_physical_device_cooperative_matrix_flexible_dimensions_properties_nv: {
                let value = instance_loader(
                    c"vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV".as_ptr(),
                );
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _property_count: *mut u32,
                        _properties: *mut CooperativeMatrixFlexibleDimensionsPropertiesNV,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV")
                    }
                    fallback
                }
            },
            get_physical_device_cooperative_matrix_properties_khr: {
                let value =
                    instance_loader(c"vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _property_count: *mut u32,
                        _properties: *mut CooperativeMatrixPropertiesKHR,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR")
                    }
                    fallback
                }
            },
            get_physical_device_cooperative_matrix_properties_nv: {
                let value =
                    instance_loader(c"vkGetPhysicalDeviceCooperativeMatrixPropertiesNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _property_count: *mut u32,
                        _properties: *mut CooperativeMatrixPropertiesNV,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDeviceCooperativeMatrixPropertiesNV")
                    }
                    fallback
                }
            },
            get_physical_device_cooperative_vector_properties_nv: {
                let value =
                    instance_loader(c"vkGetPhysicalDeviceCooperativeVectorPropertiesNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _property_count: *mut u32,
                        _properties: *mut CooperativeVectorPropertiesNV,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDeviceCooperativeVectorPropertiesNV")
                    }
                    fallback
                }
            },
            get_physical_device_external_memory_sci_buf_properties_nv: {
                let value = instance_loader(
                    c"vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV".as_ptr(),
                );
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _handle_type: ExternalMemoryHandleTypeFlags,
                        _handle: NvSciBufObj,
                        _memory_sci_buf_properties: *mut MemorySciBufPropertiesNV,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV")
                    }
                    fallback
                }
            },
            get_physical_device_external_tensor_properties_arm: {
                let value =
                    instance_loader(c"vkGetPhysicalDeviceExternalTensorPropertiesARM".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _external_tensor_info: *const PhysicalDeviceExternalTensorInfoARM,
                        _external_tensor_properties: *mut ExternalTensorPropertiesARM,
                    ) {
                        panic!("could not load vkGetPhysicalDeviceExternalTensorPropertiesARM")
                    }
                    fallback
                }
            },
            get_physical_device_fragment_shading_rates_khr: {
                let value = instance_loader(c"vkGetPhysicalDeviceFragmentShadingRatesKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _fragment_shading_rate_count: *mut u32,
                        _fragment_shading_rates: *mut PhysicalDeviceFragmentShadingRateKHR,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDeviceFragmentShadingRatesKHR")
                    }
                    fallback
                }
            },
            get_physical_device_multisample_properties_ext: {
                let value =
                    instance_loader(c"vkGetPhysicalDeviceMultisamplePropertiesEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _samples: SampleCountFlags,
                        _multisample_properties: *mut MultisamplePropertiesEXT,
                    ) {
                        panic!("could not load vkGetPhysicalDeviceMultisamplePropertiesEXT")
                    }
                    fallback
                }
            },
            get_physical_device_optical_flow_image_formats_nv: {
                let value =
                    instance_loader(c"vkGetPhysicalDeviceOpticalFlowImageFormatsNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _optical_flow_image_format_info: *const OpticalFlowImageFormatInfoNV,
                        _format_count: *mut u32,
                        _image_format_properties: *mut OpticalFlowImageFormatPropertiesNV,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDeviceOpticalFlowImageFormatsNV")
                    }
                    fallback
                }
            },
            get_physical_device_present_rectangles_khr: {
                let value = instance_loader(c"vkGetPhysicalDevicePresentRectanglesKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _surface: SurfaceKHR,
                        _rect_count: *mut u32,
                        _rects: *mut Rect2D,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDevicePresentRectanglesKHR")
                    }
                    fallback
                }
            },
            get_physical_device_queue_family_data_graph_processing_engine_properties_arm: {
                let value = instance_loader(
                    c"vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM"
                        .as_ptr(),
                );
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _queue_family_data_graph_processing_engine_info: *const PhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM,
                        _queue_family_data_graph_processing_engine_properties: *mut QueueFamilyDataGraphProcessingEnginePropertiesARM,
                    ) {
                        panic!("could not load vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM")
                    }
                    fallback
                }
            },
            get_physical_device_queue_family_data_graph_properties_arm: {
                let value = instance_loader(
                    c"vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM".as_ptr(),
                );
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _queue_family_index: u32,
                        _queue_family_data_graph_property_count: *mut u32,
                        _queue_family_data_graph_properties: *mut QueueFamilyDataGraphPropertiesARM,
                    ) -> Result {
                        panic!(
                            "could not load vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM"
                        )
                    }
                    fallback
                }
            },
            get_physical_device_queue_family_performance_query_passes_khr: {
                let value = instance_loader(
                    c"vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR".as_ptr(),
                );
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _performance_query_create_info: *const QueryPoolPerformanceCreateInfoKHR,
                        _num_passes: *mut u32,
                    ) {
                        panic!("could not load vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR")
                    }
                    fallback
                }
            },
            get_physical_device_refreshable_object_types_khr: {
                let value =
                    instance_loader(c"vkGetPhysicalDeviceRefreshableObjectTypesKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _refreshable_object_type_count: *mut u32,
                        _refreshable_object_types: *mut ObjectType,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDeviceRefreshableObjectTypesKHR")
                    }
                    fallback
                }
            },
            get_physical_device_sci_buf_attributes_nv: {
                let value = instance_loader(c"vkGetPhysicalDeviceSciBufAttributesNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _attributes: NvSciBufAttrList,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDeviceSciBufAttributesNV")
                    }
                    fallback
                }
            },
            get_physical_device_sci_sync_attributes_nv: {
                let value = instance_loader(c"vkGetPhysicalDeviceSciSyncAttributesNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _sci_sync_attributes_info: *const SciSyncAttributesInfoNV,
                        _attributes: NvSciSyncAttrList,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDeviceSciSyncAttributesNV")
                    }
                    fallback
                }
            },
            get_physical_device_supported_framebuffer_mixed_samples_combinations_nv: {
                let value = instance_loader(
                    c"vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV".as_ptr(),
                );
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _combination_count: *mut u32,
                        _combinations: *mut FramebufferMixedSamplesCombinationNV,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV")
                    }
                    fallback
                }
            },
            get_physical_device_surface_present_modes2_ext: {
                let value = instance_loader(c"vkGetPhysicalDeviceSurfacePresentModes2EXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _surface_info: *const PhysicalDeviceSurfaceInfo2KHR,
                        _present_mode_count: *mut u32,
                        _present_modes: *mut PresentModeKHR,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDeviceSurfacePresentModes2EXT")
                    }
                    fallback
                }
            },
            get_physical_device_tool_properties_ext: {
                let value = instance_loader(c"vkGetPhysicalDeviceToolPropertiesEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _tool_count: *mut u32,
                        _tool_properties: *mut PhysicalDeviceToolProperties,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDeviceToolPropertiesEXT")
                    }
                    fallback
                }
            },
            get_physical_device_video_capabilities_khr: {
                let value = instance_loader(c"vkGetPhysicalDeviceVideoCapabilitiesKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _video_profile: *const VideoProfileInfoKHR,
                        _capabilities: *mut VideoCapabilitiesKHR,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDeviceVideoCapabilitiesKHR")
                    }
                    fallback
                }
            },
            get_physical_device_video_encode_quality_level_properties_khr: {
                let value = instance_loader(
                    c"vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR".as_ptr(),
                );
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _quality_level_info: *const PhysicalDeviceVideoEncodeQualityLevelInfoKHR,
                        _quality_level_properties: *mut VideoEncodeQualityLevelPropertiesKHR,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR")
                    }
                    fallback
                }
            },
            get_physical_device_video_format_properties_khr: {
                let value =
                    instance_loader(c"vkGetPhysicalDeviceVideoFormatPropertiesKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _video_format_info: *const PhysicalDeviceVideoFormatInfoKHR,
                        _video_format_property_count: *mut u32,
                        _video_format_properties: *mut VideoFormatPropertiesKHR,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDeviceVideoFormatPropertiesKHR")
                    }
                    fallback
                }
            },
            get_pipeline_binary_data_khr: {
                let value = loader(c"vkGetPipelineBinaryDataKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const PipelineBinaryDataInfoKHR,
                        _pipeline_binary_key: *mut PipelineBinaryKeyKHR,
                        _pipeline_binary_data_size: *mut usize,
                        _pipeline_binary_data: *mut c_void,
                    ) -> Result {
                        panic!("could not load vkGetPipelineBinaryDataKHR")
                    }
                    fallback
                }
            },
            get_pipeline_cache_data: {
                let value = loader(c"vkGetPipelineCacheData".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _pipeline_cache: PipelineCache,
                        _data_size: *mut usize,
                        _data: *mut c_void,
                    ) -> Result {
                        panic!("could not load vkGetPipelineCacheData")
                    }
                    fallback
                }
            },
            get_pipeline_executable_internal_representations_khr: {
                let value = loader(c"vkGetPipelineExecutableInternalRepresentationsKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _executable_info: *const PipelineExecutableInfoKHR,
                        _internal_representation_count: *mut u32,
                        _internal_representations: *mut PipelineExecutableInternalRepresentationKHR,
                    ) -> Result {
                        panic!("could not load vkGetPipelineExecutableInternalRepresentationsKHR")
                    }
                    fallback
                }
            },
            get_pipeline_executable_properties_khr: {
                let value = loader(c"vkGetPipelineExecutablePropertiesKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _pipeline_info: *const PipelineInfoKHR,
                        _executable_count: *mut u32,
                        _properties: *mut PipelineExecutablePropertiesKHR,
                    ) -> Result {
                        panic!("could not load vkGetPipelineExecutablePropertiesKHR")
                    }
                    fallback
                }
            },
            get_pipeline_executable_statistics_khr: {
                let value = loader(c"vkGetPipelineExecutableStatisticsKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _executable_info: *const PipelineExecutableInfoKHR,
                        _statistic_count: *mut u32,
                        _statistics: *mut PipelineExecutableStatisticKHR,
                    ) -> Result {
                        panic!("could not load vkGetPipelineExecutableStatisticsKHR")
                    }
                    fallback
                }
            },
            get_pipeline_indirect_device_address_nv: {
                let value = loader(c"vkGetPipelineIndirectDeviceAddressNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const PipelineIndirectDeviceAddressInfoNV,
                    ) -> DeviceAddress {
                        panic!("could not load vkGetPipelineIndirectDeviceAddressNV")
                    }
                    fallback
                }
            },
            get_pipeline_indirect_memory_requirements_nv: {
                let value = loader(c"vkGetPipelineIndirectMemoryRequirementsNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const ComputePipelineCreateInfo,
                        _memory_requirements: *mut MemoryRequirements2,
                    ) {
                        panic!("could not load vkGetPipelineIndirectMemoryRequirementsNV")
                    }
                    fallback
                }
            },
            get_pipeline_key_khr: {
                let value = loader(c"vkGetPipelineKeyKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _pipeline_create_info: *const PipelineCreateInfoKHR,
                        _pipeline_key: *mut PipelineBinaryKeyKHR,
                    ) -> Result {
                        panic!("could not load vkGetPipelineKeyKHR")
                    }
                    fallback
                }
            },
            get_pipeline_properties_ext: {
                let value = loader(c"vkGetPipelinePropertiesEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _pipeline_info: *const PipelineInfoEXT,
                        _pipeline_properties: *mut BaseOutStructure,
                    ) -> Result {
                        panic!("could not load vkGetPipelinePropertiesEXT")
                    }
                    fallback
                }
            },
            get_private_data: {
                let value = loader(c"vkGetPrivateData".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _object_type: ObjectType,
                        _object_handle: u64,
                        _private_data_slot: PrivateDataSlot,
                        _data: *mut u64,
                    ) {
                        panic!("could not load vkGetPrivateData")
                    }
                    fallback
                }
            },
            get_private_data_ext: {
                let value = loader(c"vkGetPrivateDataEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _object_type: ObjectType,
                        _object_handle: u64,
                        _private_data_slot: PrivateDataSlot,
                        _data: *mut u64,
                    ) {
                        panic!("could not load vkGetPrivateDataEXT")
                    }
                    fallback
                }
            },
            get_query_pool_results: {
                let value = loader(c"vkGetQueryPoolResults".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _query_pool: QueryPool,
                        _first_query: u32,
                        _query_count: u32,
                        _data_size: usize,
                        _data: *mut c_void,
                        _stride: DeviceSize,
                        _flags: QueryResultFlags,
                    ) -> Result {
                        panic!("could not load vkGetQueryPoolResults")
                    }
                    fallback
                }
            },
            get_queue_checkpoint_data2_nv: {
                let value = loader(c"vkGetQueueCheckpointData2NV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _queue: Queue,
                        _checkpoint_data_count: *mut u32,
                        _checkpoint_data: *mut CheckpointData2NV,
                    ) {
                        panic!("could not load vkGetQueueCheckpointData2NV")
                    }
                    fallback
                }
            },
            get_queue_checkpoint_data_nv: {
                let value = loader(c"vkGetQueueCheckpointDataNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _queue: Queue,
                        _checkpoint_data_count: *mut u32,
                        _checkpoint_data: *mut CheckpointDataNV,
                    ) {
                        panic!("could not load vkGetQueueCheckpointDataNV")
                    }
                    fallback
                }
            },
            get_ray_tracing_capture_replay_shader_group_handles_khr: {
                let value = loader(c"vkGetRayTracingCaptureReplayShaderGroupHandlesKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _pipeline: Pipeline,
                        _first_group: u32,
                        _group_count: u32,
                        _data_size: usize,
                        _data: *mut c_void,
                    ) -> Result {
                        panic!("could not load vkGetRayTracingCaptureReplayShaderGroupHandlesKHR")
                    }
                    fallback
                }
            },
            get_ray_tracing_shader_group_handles_khr: {
                let value = loader(c"vkGetRayTracingShaderGroupHandlesKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _pipeline: Pipeline,
                        _first_group: u32,
                        _group_count: u32,
                        _data_size: usize,
                        _data: *mut c_void,
                    ) -> Result {
                        panic!("could not load vkGetRayTracingShaderGroupHandlesKHR")
                    }
                    fallback
                }
            },
            get_ray_tracing_shader_group_handles_nv: {
                let value = loader(c"vkGetRayTracingShaderGroupHandlesNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _pipeline: Pipeline,
                        _first_group: u32,
                        _group_count: u32,
                        _data_size: usize,
                        _data: *mut c_void,
                    ) -> Result {
                        panic!("could not load vkGetRayTracingShaderGroupHandlesNV")
                    }
                    fallback
                }
            },
            get_ray_tracing_shader_group_stack_size_khr: {
                let value = loader(c"vkGetRayTracingShaderGroupStackSizeKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _pipeline: Pipeline,
                        _group: u32,
                        _group_shader: ShaderGroupShaderKHR,
                    ) -> DeviceSize {
                        panic!("could not load vkGetRayTracingShaderGroupStackSizeKHR")
                    }
                    fallback
                }
            },
            get_refresh_cycle_duration_google: {
                let value = loader(c"vkGetRefreshCycleDurationGOOGLE".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _swapchain: SwapchainKHR,
                        _display_timing_properties: *mut RefreshCycleDurationGOOGLE,
                    ) -> Result {
                        panic!("could not load vkGetRefreshCycleDurationGOOGLE")
                    }
                    fallback
                }
            },
            get_render_area_granularity: {
                let value = loader(c"vkGetRenderAreaGranularity".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _render_pass: RenderPass,
                        _granularity: *mut Extent2D,
                    ) {
                        panic!("could not load vkGetRenderAreaGranularity")
                    }
                    fallback
                }
            },
            get_rendering_area_granularity: {
                let value = loader(c"vkGetRenderingAreaGranularity".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _rendering_area_info: *const RenderingAreaInfo,
                        _granularity: *mut Extent2D,
                    ) {
                        panic!("could not load vkGetRenderingAreaGranularity")
                    }
                    fallback
                }
            },
            get_rendering_area_granularity_khr: {
                let value = loader(c"vkGetRenderingAreaGranularityKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _rendering_area_info: *const RenderingAreaInfo,
                        _granularity: *mut Extent2D,
                    ) {
                        panic!("could not load vkGetRenderingAreaGranularityKHR")
                    }
                    fallback
                }
            },
            get_sampler_opaque_capture_descriptor_data_ext: {
                let value = loader(c"vkGetSamplerOpaqueCaptureDescriptorDataEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const SamplerCaptureDescriptorDataInfoEXT,
                        _data: *mut c_void,
                    ) -> Result {
                        panic!("could not load vkGetSamplerOpaqueCaptureDescriptorDataEXT")
                    }
                    fallback
                }
            },
            get_screen_buffer_properties_qnx: {
                let value = loader(c"vkGetScreenBufferPropertiesQNX".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _buffer: *const _screen_buffer,
                        _properties: *mut ScreenBufferPropertiesQNX,
                    ) -> Result {
                        panic!("could not load vkGetScreenBufferPropertiesQNX")
                    }
                    fallback
                }
            },
            get_semaphore_counter_value: {
                let value = loader(c"vkGetSemaphoreCounterValue".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _semaphore: Semaphore,
                        _value: *mut u64,
                    ) -> Result {
                        panic!("could not load vkGetSemaphoreCounterValue")
                    }
                    fallback
                }
            },
            get_semaphore_counter_value_khr: {
                let value = loader(c"vkGetSemaphoreCounterValueKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _semaphore: Semaphore,
                        _value: *mut u64,
                    ) -> Result {
                        panic!("could not load vkGetSemaphoreCounterValueKHR")
                    }
                    fallback
                }
            },
            get_semaphore_fd_khr: {
                let value = loader(c"vkGetSemaphoreFdKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _get_fd_info: *const SemaphoreGetFdInfoKHR,
                        _fd: *mut c_int,
                    ) -> Result {
                        panic!("could not load vkGetSemaphoreFdKHR")
                    }
                    fallback
                }
            },
            get_semaphore_sci_sync_obj_nv: {
                let value = loader(c"vkGetSemaphoreSciSyncObjNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _get_sci_sync_info: *const SemaphoreGetSciSyncInfoNV,
                        _handle: *mut c_void,
                    ) -> Result {
                        panic!("could not load vkGetSemaphoreSciSyncObjNV")
                    }
                    fallback
                }
            },
            get_semaphore_win32_handle_khr: {
                let value = loader(c"vkGetSemaphoreWin32HandleKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _get_win32_handle_info: *const SemaphoreGetWin32HandleInfoKHR,
                        _handle: *mut HANDLE,
                    ) -> Result {
                        panic!("could not load vkGetSemaphoreWin32HandleKHR")
                    }
                    fallback
                }
            },
            get_semaphore_zircon_handle_fuchsia: {
                let value = loader(c"vkGetSemaphoreZirconHandleFUCHSIA".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _get_zircon_handle_info: *const SemaphoreGetZirconHandleInfoFUCHSIA,
                        _zircon_handle: *mut zx_handle_t,
                    ) -> Result {
                        panic!("could not load vkGetSemaphoreZirconHandleFUCHSIA")
                    }
                    fallback
                }
            },
            get_shader_binary_data_ext: {
                let value = loader(c"vkGetShaderBinaryDataEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _shader: ShaderEXT,
                        _data_size: *mut usize,
                        _data: *mut c_void,
                    ) -> Result {
                        panic!("could not load vkGetShaderBinaryDataEXT")
                    }
                    fallback
                }
            },
            get_shader_info_amd: {
                let value = loader(c"vkGetShaderInfoAMD".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _pipeline: Pipeline,
                        _shader_stage: ShaderStageFlags,
                        _info_type: ShaderInfoTypeAMD,
                        _info_size: *mut usize,
                        _info: *mut c_void,
                    ) -> Result {
                        panic!("could not load vkGetShaderInfoAMD")
                    }
                    fallback
                }
            },
            get_shader_module_create_info_identifier_ext: {
                let value = loader(c"vkGetShaderModuleCreateInfoIdentifierEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _create_info: *const ShaderModuleCreateInfo,
                        _identifier: *mut ShaderModuleIdentifierEXT,
                    ) {
                        panic!("could not load vkGetShaderModuleCreateInfoIdentifierEXT")
                    }
                    fallback
                }
            },
            get_shader_module_identifier_ext: {
                let value = loader(c"vkGetShaderModuleIdentifierEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _shader_module: ShaderModule,
                        _identifier: *mut ShaderModuleIdentifierEXT,
                    ) {
                        panic!("could not load vkGetShaderModuleIdentifierEXT")
                    }
                    fallback
                }
            },
            get_swapchain_counter_ext: {
                let value = loader(c"vkGetSwapchainCounterEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _swapchain: SwapchainKHR,
                        _counter: SurfaceCounterFlagsEXT,
                        _counter_value: *mut u64,
                    ) -> Result {
                        panic!("could not load vkGetSwapchainCounterEXT")
                    }
                    fallback
                }
            },
            get_swapchain_images_khr: {
                let value = loader(c"vkGetSwapchainImagesKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _swapchain: SwapchainKHR,
                        _swapchain_image_count: *mut u32,
                        _swapchain_images: *mut Image,
                    ) -> Result {
                        panic!("could not load vkGetSwapchainImagesKHR")
                    }
                    fallback
                }
            },
            get_swapchain_status_khr: {
                let value = loader(c"vkGetSwapchainStatusKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _swapchain: SwapchainKHR,
                    ) -> Result {
                        panic!("could not load vkGetSwapchainStatusKHR")
                    }
                    fallback
                }
            },
            get_tensor_memory_requirements_arm: {
                let value = loader(c"vkGetTensorMemoryRequirementsARM".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const TensorMemoryRequirementsInfoARM,
                        _memory_requirements: *mut MemoryRequirements2,
                    ) {
                        panic!("could not load vkGetTensorMemoryRequirementsARM")
                    }
                    fallback
                }
            },
            get_tensor_opaque_capture_descriptor_data_arm: {
                let value = loader(c"vkGetTensorOpaqueCaptureDescriptorDataARM".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const TensorCaptureDescriptorDataInfoARM,
                        _data: *mut c_void,
                    ) -> Result {
                        panic!("could not load vkGetTensorOpaqueCaptureDescriptorDataARM")
                    }
                    fallback
                }
            },
            get_tensor_view_opaque_capture_descriptor_data_arm: {
                let value = loader(c"vkGetTensorViewOpaqueCaptureDescriptorDataARM".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const TensorViewCaptureDescriptorDataInfoARM,
                        _data: *mut c_void,
                    ) -> Result {
                        panic!("could not load vkGetTensorViewOpaqueCaptureDescriptorDataARM")
                    }
                    fallback
                }
            },
            get_validation_cache_data_ext: {
                let value = loader(c"vkGetValidationCacheDataEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _validation_cache: ValidationCacheEXT,
                        _data_size: *mut usize,
                        _data: *mut c_void,
                    ) -> Result {
                        panic!("could not load vkGetValidationCacheDataEXT")
                    }
                    fallback
                }
            },
            get_video_session_memory_requirements_khr: {
                let value = loader(c"vkGetVideoSessionMemoryRequirementsKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _video_session: VideoSessionKHR,
                        _memory_requirements_count: *mut u32,
                        _memory_requirements: *mut VideoSessionMemoryRequirementsKHR,
                    ) -> Result {
                        panic!("could not load vkGetVideoSessionMemoryRequirementsKHR")
                    }
                    fallback
                }
            },
            get_winrt_display_nv: {
                let value = instance_loader(c"vkGetWinrtDisplayNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _device_relative_id: u32,
                        _display: *mut DisplayKHR,
                    ) -> Result {
                        panic!("could not load vkGetWinrtDisplayNV")
                    }
                    fallback
                }
            },
            import_fence_fd_khr: {
                let value = loader(c"vkImportFenceFdKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _import_fence_fd_info: *const ImportFenceFdInfoKHR,
                    ) -> Result {
                        panic!("could not load vkImportFenceFdKHR")
                    }
                    fallback
                }
            },
            import_fence_sci_sync_fence_nv: {
                let value = loader(c"vkImportFenceSciSyncFenceNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _import_fence_sci_sync_info: *const ImportFenceSciSyncInfoNV,
                    ) -> Result {
                        panic!("could not load vkImportFenceSciSyncFenceNV")
                    }
                    fallback
                }
            },
            import_fence_sci_sync_obj_nv: {
                let value = loader(c"vkImportFenceSciSyncObjNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _import_fence_sci_sync_info: *const ImportFenceSciSyncInfoNV,
                    ) -> Result {
                        panic!("could not load vkImportFenceSciSyncObjNV")
                    }
                    fallback
                }
            },
            import_fence_win32_handle_khr: {
                let value = loader(c"vkImportFenceWin32HandleKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _import_fence_win32_handle_info: *const ImportFenceWin32HandleInfoKHR,
                    ) -> Result {
                        panic!("could not load vkImportFenceWin32HandleKHR")
                    }
                    fallback
                }
            },
            import_semaphore_fd_khr: {
                let value = loader(c"vkImportSemaphoreFdKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _import_semaphore_fd_info: *const ImportSemaphoreFdInfoKHR,
                    ) -> Result {
                        panic!("could not load vkImportSemaphoreFdKHR")
                    }
                    fallback
                }
            },
            import_semaphore_sci_sync_obj_nv: {
                let value = loader(c"vkImportSemaphoreSciSyncObjNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _import_semaphore_sci_sync_info: *const ImportSemaphoreSciSyncInfoNV,
                    ) -> Result {
                        panic!("could not load vkImportSemaphoreSciSyncObjNV")
                    }
                    fallback
                }
            },
            import_semaphore_win32_handle_khr: {
                let value = loader(c"vkImportSemaphoreWin32HandleKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _import_semaphore_win32_handle_info: *const ImportSemaphoreWin32HandleInfoKHR,
                    ) -> Result {
                        panic!("could not load vkImportSemaphoreWin32HandleKHR")
                    }
                    fallback
                }
            },
            import_semaphore_zircon_handle_fuchsia: {
                let value = loader(c"vkImportSemaphoreZirconHandleFUCHSIA".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _import_semaphore_zircon_handle_info: *const ImportSemaphoreZirconHandleInfoFUCHSIA,
                    ) -> Result {
                        panic!("could not load vkImportSemaphoreZirconHandleFUCHSIA")
                    }
                    fallback
                }
            },
            initialize_performance_api_intel: {
                let value = loader(c"vkInitializePerformanceApiINTEL".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _initialize_info: *const InitializePerformanceApiInfoINTEL,
                    ) -> Result {
                        panic!("could not load vkInitializePerformanceApiINTEL")
                    }
                    fallback
                }
            },
            invalidate_mapped_memory_ranges: {
                let value = loader(c"vkInvalidateMappedMemoryRanges".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _memory_range_count: u32,
                        _memory_ranges: *const MappedMemoryRange,
                    ) -> Result {
                        panic!("could not load vkInvalidateMappedMemoryRanges")
                    }
                    fallback
                }
            },
            latency_sleep_nv: {
                let value = loader(c"vkLatencySleepNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _swapchain: SwapchainKHR,
                        _sleep_info: *const LatencySleepInfoNV,
                    ) -> Result {
                        panic!("could not load vkLatencySleepNV")
                    }
                    fallback
                }
            },
            map_memory: {
                let value = loader(c"vkMapMemory".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _memory: DeviceMemory,
                        _offset: DeviceSize,
                        _size: DeviceSize,
                        _flags: MemoryMapFlags,
                        _data: *mut *mut c_void,
                    ) -> Result {
                        panic!("could not load vkMapMemory")
                    }
                    fallback
                }
            },
            map_memory2: {
                let value = loader(c"vkMapMemory2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _memory_map_info: *const MemoryMapInfo,
                        _data: *mut *mut c_void,
                    ) -> Result {
                        panic!("could not load vkMapMemory2")
                    }
                    fallback
                }
            },
            map_memory2_khr: {
                let value = loader(c"vkMapMemory2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _memory_map_info: *const MemoryMapInfo,
                        _data: *mut *mut c_void,
                    ) -> Result {
                        panic!("could not load vkMapMemory2KHR")
                    }
                    fallback
                }
            },
            merge_pipeline_caches: {
                let value = loader(c"vkMergePipelineCaches".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _dst_cache: PipelineCache,
                        _src_cache_count: u32,
                        _src_caches: *const PipelineCache,
                    ) -> Result {
                        panic!("could not load vkMergePipelineCaches")
                    }
                    fallback
                }
            },
            merge_validation_caches_ext: {
                let value = loader(c"vkMergeValidationCachesEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _dst_cache: ValidationCacheEXT,
                        _src_cache_count: u32,
                        _src_caches: *const ValidationCacheEXT,
                    ) -> Result {
                        panic!("could not load vkMergeValidationCachesEXT")
                    }
                    fallback
                }
            },
            queue_bind_sparse: {
                let value = loader(c"vkQueueBindSparse".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _queue: Queue,
                        _bind_info_count: u32,
                        _bind_info: *const BindSparseInfo,
                        _fence: Fence,
                    ) -> Result {
                        panic!("could not load vkQueueBindSparse")
                    }
                    fallback
                }
            },
            queue_notify_out_of_band_nv: {
                let value = loader(c"vkQueueNotifyOutOfBandNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _queue: Queue,
                        _queue_type_info: *const OutOfBandQueueTypeInfoNV,
                    ) {
                        panic!("could not load vkQueueNotifyOutOfBandNV")
                    }
                    fallback
                }
            },
            queue_present_khr: {
                let value = loader(c"vkQueuePresentKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _queue: Queue,
                        _present_info: *const PresentInfoKHR,
                    ) -> Result {
                        panic!("could not load vkQueuePresentKHR")
                    }
                    fallback
                }
            },
            queue_set_performance_configuration_intel: {
                let value = loader(c"vkQueueSetPerformanceConfigurationINTEL".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _queue: Queue,
                        _configuration: PerformanceConfigurationINTEL,
                    ) -> Result {
                        panic!("could not load vkQueueSetPerformanceConfigurationINTEL")
                    }
                    fallback
                }
            },
            queue_submit: {
                let value = loader(c"vkQueueSubmit".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _queue: Queue,
                        _submit_count: u32,
                        _submits: *const SubmitInfo,
                        _fence: Fence,
                    ) -> Result {
                        panic!("could not load vkQueueSubmit")
                    }
                    fallback
                }
            },
            queue_submit2: {
                let value = loader(c"vkQueueSubmit2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _queue: Queue,
                        _submit_count: u32,
                        _submits: *const SubmitInfo2,
                        _fence: Fence,
                    ) -> Result {
                        panic!("could not load vkQueueSubmit2")
                    }
                    fallback
                }
            },
            queue_submit2_khr: {
                let value = loader(c"vkQueueSubmit2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _queue: Queue,
                        _submit_count: u32,
                        _submits: *const SubmitInfo2,
                        _fence: Fence,
                    ) -> Result {
                        panic!("could not load vkQueueSubmit2KHR")
                    }
                    fallback
                }
            },
            queue_wait_idle: {
                let value = loader(c"vkQueueWaitIdle".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(_queue: Queue) -> Result {
                        panic!("could not load vkQueueWaitIdle")
                    }
                    fallback
                }
            },
            register_device_event_ext: {
                let value = loader(c"vkRegisterDeviceEventEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _device_event_info: *const DeviceEventInfoEXT,
                        _allocator: *const AllocationCallbacks,
                        _fence: *mut Fence,
                    ) -> Result {
                        panic!("could not load vkRegisterDeviceEventEXT")
                    }
                    fallback
                }
            },
            register_display_event_ext: {
                let value = loader(c"vkRegisterDisplayEventEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _display: DisplayKHR,
                        _display_event_info: *const DisplayEventInfoEXT,
                        _allocator: *const AllocationCallbacks,
                        _fence: *mut Fence,
                    ) -> Result {
                        panic!("could not load vkRegisterDisplayEventEXT")
                    }
                    fallback
                }
            },
            release_captured_pipeline_data_khr: {
                let value = loader(c"vkReleaseCapturedPipelineDataKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _info: *const ReleaseCapturedPipelineDataInfoKHR,
                        _allocator: *const AllocationCallbacks,
                    ) -> Result {
                        panic!("could not load vkReleaseCapturedPipelineDataKHR")
                    }
                    fallback
                }
            },
            release_full_screen_exclusive_mode_ext: {
                let value = loader(c"vkReleaseFullScreenExclusiveModeEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _swapchain: SwapchainKHR,
                    ) -> Result {
                        panic!("could not load vkReleaseFullScreenExclusiveModeEXT")
                    }
                    fallback
                }
            },
            release_performance_configuration_intel: {
                let value = loader(c"vkReleasePerformanceConfigurationINTEL".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _configuration: PerformanceConfigurationINTEL,
                    ) -> Result {
                        panic!("could not load vkReleasePerformanceConfigurationINTEL")
                    }
                    fallback
                }
            },
            release_profiling_lock_khr: {
                let value = loader(c"vkReleaseProfilingLockKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(_device: Device) {
                        panic!("could not load vkReleaseProfilingLockKHR")
                    }
                    fallback
                }
            },
            release_swapchain_images_ext: {
                let value = loader(c"vkReleaseSwapchainImagesEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _release_info: *const ReleaseSwapchainImagesInfoKHR,
                    ) -> Result {
                        panic!("could not load vkReleaseSwapchainImagesEXT")
                    }
                    fallback
                }
            },
            release_swapchain_images_khr: {
                let value = loader(c"vkReleaseSwapchainImagesKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _release_info: *const ReleaseSwapchainImagesInfoKHR,
                    ) -> Result {
                        panic!("could not load vkReleaseSwapchainImagesKHR")
                    }
                    fallback
                }
            },
            reset_command_buffer: {
                let value = loader(c"vkResetCommandBuffer".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _flags: CommandBufferResetFlags,
                    ) -> Result {
                        panic!("could not load vkResetCommandBuffer")
                    }
                    fallback
                }
            },
            reset_command_pool: {
                let value = loader(c"vkResetCommandPool".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _command_pool: CommandPool,
                        _flags: CommandPoolResetFlags,
                    ) -> Result {
                        panic!("could not load vkResetCommandPool")
                    }
                    fallback
                }
            },
            reset_descriptor_pool: {
                let value = loader(c"vkResetDescriptorPool".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _descriptor_pool: DescriptorPool,
                        _flags: DescriptorPoolResetFlags,
                    ) -> Result {
                        panic!("could not load vkResetDescriptorPool")
                    }
                    fallback
                }
            },
            reset_event: {
                let value = loader(c"vkResetEvent".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(_device: Device, _event: Event) -> Result {
                        panic!("could not load vkResetEvent")
                    }
                    fallback
                }
            },
            reset_fences: {
                let value = loader(c"vkResetFences".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _fence_count: u32,
                        _fences: *const Fence,
                    ) -> Result {
                        panic!("could not load vkResetFences")
                    }
                    fallback
                }
            },
            reset_query_pool: {
                let value = loader(c"vkResetQueryPool".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _query_pool: QueryPool,
                        _first_query: u32,
                        _query_count: u32,
                    ) {
                        panic!("could not load vkResetQueryPool")
                    }
                    fallback
                }
            },
            reset_query_pool_ext: {
                let value = loader(c"vkResetQueryPoolEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _query_pool: QueryPool,
                        _first_query: u32,
                        _query_count: u32,
                    ) {
                        panic!("could not load vkResetQueryPoolEXT")
                    }
                    fallback
                }
            },
            set_buffer_collection_buffer_constraints_fuchsia: {
                let value = loader(c"vkSetBufferCollectionBufferConstraintsFUCHSIA".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _collection: BufferCollectionFUCHSIA,
                        _buffer_constraints_info: *const BufferConstraintsInfoFUCHSIA,
                    ) -> Result {
                        panic!("could not load vkSetBufferCollectionBufferConstraintsFUCHSIA")
                    }
                    fallback
                }
            },
            set_buffer_collection_image_constraints_fuchsia: {
                let value = loader(c"vkSetBufferCollectionImageConstraintsFUCHSIA".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _collection: BufferCollectionFUCHSIA,
                        _image_constraints_info: *const ImageConstraintsInfoFUCHSIA,
                    ) -> Result {
                        panic!("could not load vkSetBufferCollectionImageConstraintsFUCHSIA")
                    }
                    fallback
                }
            },
            set_device_memory_priority_ext: {
                let value = loader(c"vkSetDeviceMemoryPriorityEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _memory: DeviceMemory,
                        _priority: f32,
                    ) {
                        panic!("could not load vkSetDeviceMemoryPriorityEXT")
                    }
                    fallback
                }
            },
            set_event: {
                let value = loader(c"vkSetEvent".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(_device: Device, _event: Event) -> Result {
                        panic!("could not load vkSetEvent")
                    }
                    fallback
                }
            },
            set_hdr_metadata_ext: {
                let value = loader(c"vkSetHdrMetadataEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _swapchain_count: u32,
                        _swapchains: *const SwapchainKHR,
                        _metadata: *const HdrMetadataEXT,
                    ) {
                        panic!("could not load vkSetHdrMetadataEXT")
                    }
                    fallback
                }
            },
            set_latency_marker_nv: {
                let value = loader(c"vkSetLatencyMarkerNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _swapchain: SwapchainKHR,
                        _latency_marker_info: *const SetLatencyMarkerInfoNV,
                    ) {
                        panic!("could not load vkSetLatencyMarkerNV")
                    }
                    fallback
                }
            },
            set_latency_sleep_mode_nv: {
                let value = loader(c"vkSetLatencySleepModeNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _swapchain: SwapchainKHR,
                        _sleep_mode_info: *const LatencySleepModeInfoNV,
                    ) -> Result {
                        panic!("could not load vkSetLatencySleepModeNV")
                    }
                    fallback
                }
            },
            set_local_dimming_amd: {
                let value = loader(c"vkSetLocalDimmingAMD".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _swap_chain: SwapchainKHR,
                        _local_dimming_enable: Bool32,
                    ) {
                        panic!("could not load vkSetLocalDimmingAMD")
                    }
                    fallback
                }
            },
            set_private_data: {
                let value = loader(c"vkSetPrivateData".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _object_type: ObjectType,
                        _object_handle: u64,
                        _private_data_slot: PrivateDataSlot,
                        _data: u64,
                    ) -> Result {
                        panic!("could not load vkSetPrivateData")
                    }
                    fallback
                }
            },
            set_private_data_ext: {
                let value = loader(c"vkSetPrivateDataEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _object_type: ObjectType,
                        _object_handle: u64,
                        _private_data_slot: PrivateDataSlot,
                        _data: u64,
                    ) -> Result {
                        panic!("could not load vkSetPrivateDataEXT")
                    }
                    fallback
                }
            },
            signal_semaphore: {
                let value = loader(c"vkSignalSemaphore".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _signal_info: *const SemaphoreSignalInfo,
                    ) -> Result {
                        panic!("could not load vkSignalSemaphore")
                    }
                    fallback
                }
            },
            signal_semaphore_khr: {
                let value = loader(c"vkSignalSemaphoreKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _signal_info: *const SemaphoreSignalInfo,
                    ) -> Result {
                        panic!("could not load vkSignalSemaphoreKHR")
                    }
                    fallback
                }
            },
            transition_image_layout: {
                let value = loader(c"vkTransitionImageLayout".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _transition_count: u32,
                        _transitions: *const HostImageLayoutTransitionInfo,
                    ) -> Result {
                        panic!("could not load vkTransitionImageLayout")
                    }
                    fallback
                }
            },
            transition_image_layout_ext: {
                let value = loader(c"vkTransitionImageLayoutEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _transition_count: u32,
                        _transitions: *const HostImageLayoutTransitionInfo,
                    ) -> Result {
                        panic!("could not load vkTransitionImageLayoutEXT")
                    }
                    fallback
                }
            },
            trim_command_pool: {
                let value = loader(c"vkTrimCommandPool".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _command_pool: CommandPool,
                        _flags: CommandPoolTrimFlags,
                    ) {
                        panic!("could not load vkTrimCommandPool")
                    }
                    fallback
                }
            },
            trim_command_pool_khr: {
                let value = loader(c"vkTrimCommandPoolKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _command_pool: CommandPool,
                        _flags: CommandPoolTrimFlags,
                    ) {
                        panic!("could not load vkTrimCommandPoolKHR")
                    }
                    fallback
                }
            },
            uninitialize_performance_api_intel: {
                let value = loader(c"vkUninitializePerformanceApiINTEL".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(_device: Device) {
                        panic!("could not load vkUninitializePerformanceApiINTEL")
                    }
                    fallback
                }
            },
            unmap_memory: {
                let value = loader(c"vkUnmapMemory".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(_device: Device, _memory: DeviceMemory) {
                        panic!("could not load vkUnmapMemory")
                    }
                    fallback
                }
            },
            unmap_memory2: {
                let value = loader(c"vkUnmapMemory2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _memory_unmap_info: *const MemoryUnmapInfo,
                    ) -> Result {
                        panic!("could not load vkUnmapMemory2")
                    }
                    fallback
                }
            },
            unmap_memory2_khr: {
                let value = loader(c"vkUnmapMemory2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _memory_unmap_info: *const MemoryUnmapInfo,
                    ) -> Result {
                        panic!("could not load vkUnmapMemory2KHR")
                    }
                    fallback
                }
            },
            update_descriptor_set_with_template: {
                let value = loader(c"vkUpdateDescriptorSetWithTemplate".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _descriptor_set: DescriptorSet,
                        _descriptor_update_template: DescriptorUpdateTemplate,
                        _data: *const c_void,
                    ) {
                        panic!("could not load vkUpdateDescriptorSetWithTemplate")
                    }
                    fallback
                }
            },
            update_descriptor_set_with_template_khr: {
                let value = loader(c"vkUpdateDescriptorSetWithTemplateKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _descriptor_set: DescriptorSet,
                        _descriptor_update_template: DescriptorUpdateTemplate,
                        _data: *const c_void,
                    ) {
                        panic!("could not load vkUpdateDescriptorSetWithTemplateKHR")
                    }
                    fallback
                }
            },
            update_descriptor_sets: {
                let value = loader(c"vkUpdateDescriptorSets".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _descriptor_write_count: u32,
                        _descriptor_writes: *const WriteDescriptorSet,
                        _descriptor_copy_count: u32,
                        _descriptor_copies: *const CopyDescriptorSet,
                    ) {
                        panic!("could not load vkUpdateDescriptorSets")
                    }
                    fallback
                }
            },
            update_indirect_execution_set_pipeline_ext: {
                let value = loader(c"vkUpdateIndirectExecutionSetPipelineEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _indirect_execution_set: IndirectExecutionSetEXT,
                        _execution_set_write_count: u32,
                        _execution_set_writes: *const WriteIndirectExecutionSetPipelineEXT,
                    ) {
                        panic!("could not load vkUpdateIndirectExecutionSetPipelineEXT")
                    }
                    fallback
                }
            },
            update_indirect_execution_set_shader_ext: {
                let value = loader(c"vkUpdateIndirectExecutionSetShaderEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _indirect_execution_set: IndirectExecutionSetEXT,
                        _execution_set_write_count: u32,
                        _execution_set_writes: *const WriteIndirectExecutionSetShaderEXT,
                    ) {
                        panic!("could not load vkUpdateIndirectExecutionSetShaderEXT")
                    }
                    fallback
                }
            },
            update_video_session_parameters_khr: {
                let value = loader(c"vkUpdateVideoSessionParametersKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _video_session_parameters: VideoSessionParametersKHR,
                        _update_info: *const VideoSessionParametersUpdateInfoKHR,
                    ) -> Result {
                        panic!("could not load vkUpdateVideoSessionParametersKHR")
                    }
                    fallback
                }
            },
            wait_for_fences: {
                let value = loader(c"vkWaitForFences".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _fence_count: u32,
                        _fences: *const Fence,
                        _wait_all: Bool32,
                        _timeout: u64,
                    ) -> Result {
                        panic!("could not load vkWaitForFences")
                    }
                    fallback
                }
            },
            wait_for_present2_khr: {
                let value = loader(c"vkWaitForPresent2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _swapchain: SwapchainKHR,
                        _present_wait2_info: *const PresentWait2InfoKHR,
                    ) -> Result {
                        panic!("could not load vkWaitForPresent2KHR")
                    }
                    fallback
                }
            },
            wait_for_present_khr: {
                let value = loader(c"vkWaitForPresentKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _swapchain: SwapchainKHR,
                        _present_id: u64,
                        _timeout: u64,
                    ) -> Result {
                        panic!("could not load vkWaitForPresentKHR")
                    }
                    fallback
                }
            },
            wait_semaphores: {
                let value = loader(c"vkWaitSemaphores".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _wait_info: *const SemaphoreWaitInfo,
                        _timeout: u64,
                    ) -> Result {
                        panic!("could not load vkWaitSemaphores")
                    }
                    fallback
                }
            },
            wait_semaphores_khr: {
                let value = loader(c"vkWaitSemaphoresKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _wait_info: *const SemaphoreWaitInfo,
                        _timeout: u64,
                    ) -> Result {
                        panic!("could not load vkWaitSemaphoresKHR")
                    }
                    fallback
                }
            },
            write_acceleration_structures_properties_khr: {
                let value = loader(c"vkWriteAccelerationStructuresPropertiesKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _acceleration_structure_count: u32,
                        _acceleration_structures: *const AccelerationStructureKHR,
                        _query_type: QueryType,
                        _data_size: usize,
                        _data: *mut c_void,
                        _stride: usize,
                    ) -> Result {
                        panic!("could not load vkWriteAccelerationStructuresPropertiesKHR")
                    }
                    fallback
                }
            },
            write_micromaps_properties_ext: {
                let value = loader(c"vkWriteMicromapsPropertiesEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _micromap_count: u32,
                        _micromaps: *const MicromapEXT,
                        _query_type: QueryType,
                        _data_size: usize,
                        _data: *mut c_void,
                        _stride: usize,
                    ) -> Result {
                        panic!("could not load vkWriteMicromapsPropertiesEXT")
                    }
                    fallback
                }
            },
        }
    }
}

/// Loaded Vulkan entry commands.
#[derive(Copy, Clone)]
pub struct EntryCommands {
    pub create_instance: PFN_vkCreateInstance,
    pub enumerate_instance_extension_properties: PFN_vkEnumerateInstanceExtensionProperties,
    pub enumerate_instance_layer_properties: PFN_vkEnumerateInstanceLayerProperties,
    pub enumerate_instance_version: PFN_vkEnumerateInstanceVersion,
}

impl EntryCommands {
    #[inline]
    pub unsafe fn load(
        mut loader: impl FnMut(*const c_char) -> Option<unsafe extern "system" fn()>,
    ) -> Self {
        Self {
            create_instance: {
                let value = loader(c"vkCreateInstance".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _create_info: *const InstanceCreateInfo,
                        _allocator: *const AllocationCallbacks,
                        _instance: *mut Instance,
                    ) -> Result {
                        panic!("could not load vkCreateInstance")
                    }
                    fallback
                }
            },
            enumerate_instance_extension_properties: {
                let value = loader(c"vkEnumerateInstanceExtensionProperties".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _layer_name: *const c_char,
                        _property_count: *mut u32,
                        _properties: *mut ExtensionProperties,
                    ) -> Result {
                        panic!("could not load vkEnumerateInstanceExtensionProperties")
                    }
                    fallback
                }
            },
            enumerate_instance_layer_properties: {
                let value = loader(c"vkEnumerateInstanceLayerProperties".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _property_count: *mut u32,
                        _properties: *mut LayerProperties,
                    ) -> Result {
                        panic!("could not load vkEnumerateInstanceLayerProperties")
                    }
                    fallback
                }
            },
            enumerate_instance_version: {
                let value = loader(c"vkEnumerateInstanceVersion".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(_api_version: *mut u32) -> Result {
                        panic!("could not load vkEnumerateInstanceVersion")
                    }
                    fallback
                }
            },
        }
    }
}

/// Loaded Vulkan instance commands.
#[derive(Copy, Clone)]
pub struct InstanceCommands {
    pub acquire_drm_display_ext: PFN_vkAcquireDrmDisplayEXT,
    pub acquire_xlib_display_ext: PFN_vkAcquireXlibDisplayEXT,
    pub cmd_begin_debug_utils_label_ext: PFN_vkCmdBeginDebugUtilsLabelEXT,
    pub cmd_end_debug_utils_label_ext: PFN_vkCmdEndDebugUtilsLabelEXT,
    pub cmd_insert_debug_utils_label_ext: PFN_vkCmdInsertDebugUtilsLabelEXT,
    pub create_android_surface_khr: PFN_vkCreateAndroidSurfaceKHR,
    pub create_debug_report_callback_ext: PFN_vkCreateDebugReportCallbackEXT,
    pub create_debug_utils_messenger_ext: PFN_vkCreateDebugUtilsMessengerEXT,
    pub create_device: PFN_vkCreateDevice,
    pub create_direct_fb_surface_ext: PFN_vkCreateDirectFBSurfaceEXT,
    pub create_display_mode_khr: PFN_vkCreateDisplayModeKHR,
    pub create_display_plane_surface_khr: PFN_vkCreateDisplayPlaneSurfaceKHR,
    pub create_headless_surface_ext: PFN_vkCreateHeadlessSurfaceEXT,
    pub create_ios_surface_mvk: PFN_vkCreateIOSSurfaceMVK,
    pub create_image_pipe_surface_fuchsia: PFN_vkCreateImagePipeSurfaceFUCHSIA,
    pub create_mac_os_surface_mvk: PFN_vkCreateMacOSSurfaceMVK,
    pub create_metal_surface_ext: PFN_vkCreateMetalSurfaceEXT,
    pub create_screen_surface_qnx: PFN_vkCreateScreenSurfaceQNX,
    pub create_stream_descriptor_surface_ggp: PFN_vkCreateStreamDescriptorSurfaceGGP,
    pub create_surface_ohos: PFN_vkCreateSurfaceOHOS,
    pub create_vi_surface_nn: PFN_vkCreateViSurfaceNN,
    pub create_wayland_surface_khr: PFN_vkCreateWaylandSurfaceKHR,
    pub create_win32_surface_khr: PFN_vkCreateWin32SurfaceKHR,
    pub create_xcb_surface_khr: PFN_vkCreateXcbSurfaceKHR,
    pub create_xlib_surface_khr: PFN_vkCreateXlibSurfaceKHR,
    pub debug_report_message_ext: PFN_vkDebugReportMessageEXT,
    pub destroy_debug_report_callback_ext: PFN_vkDestroyDebugReportCallbackEXT,
    pub destroy_debug_utils_messenger_ext: PFN_vkDestroyDebugUtilsMessengerEXT,
    pub destroy_instance: PFN_vkDestroyInstance,
    pub destroy_surface_khr: PFN_vkDestroySurfaceKHR,
    pub enumerate_device_extension_properties: PFN_vkEnumerateDeviceExtensionProperties,
    pub enumerate_device_layer_properties: PFN_vkEnumerateDeviceLayerProperties,
    pub enumerate_physical_device_groups: PFN_vkEnumeratePhysicalDeviceGroups,
    pub enumerate_physical_device_groups_khr: PFN_vkEnumeratePhysicalDeviceGroupsKHR,
    pub enumerate_physical_devices: PFN_vkEnumeratePhysicalDevices,
    pub get_display_mode_properties2_khr: PFN_vkGetDisplayModeProperties2KHR,
    pub get_display_mode_properties_khr: PFN_vkGetDisplayModePropertiesKHR,
    pub get_display_plane_capabilities2_khr: PFN_vkGetDisplayPlaneCapabilities2KHR,
    pub get_display_plane_capabilities_khr: PFN_vkGetDisplayPlaneCapabilitiesKHR,
    pub get_display_plane_supported_displays_khr: PFN_vkGetDisplayPlaneSupportedDisplaysKHR,
    pub get_drm_display_ext: PFN_vkGetDrmDisplayEXT,
    pub get_physical_device_direct_fb_presentation_support_ext:
        PFN_vkGetPhysicalDeviceDirectFBPresentationSupportEXT,
    pub get_physical_device_display_plane_properties2_khr:
        PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR,
    pub get_physical_device_display_plane_properties_khr:
        PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR,
    pub get_physical_device_display_properties2_khr: PFN_vkGetPhysicalDeviceDisplayProperties2KHR,
    pub get_physical_device_display_properties_khr: PFN_vkGetPhysicalDeviceDisplayPropertiesKHR,
    pub get_physical_device_external_buffer_properties:
        PFN_vkGetPhysicalDeviceExternalBufferProperties,
    pub get_physical_device_external_buffer_properties_khr:
        PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR,
    pub get_physical_device_external_fence_properties:
        PFN_vkGetPhysicalDeviceExternalFenceProperties,
    pub get_physical_device_external_fence_properties_khr:
        PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR,
    pub get_physical_device_external_image_format_properties_nv:
        PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV,
    pub get_physical_device_external_semaphore_properties:
        PFN_vkGetPhysicalDeviceExternalSemaphoreProperties,
    pub get_physical_device_external_semaphore_properties_khr:
        PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR,
    pub get_physical_device_features: PFN_vkGetPhysicalDeviceFeatures,
    pub get_physical_device_features2: PFN_vkGetPhysicalDeviceFeatures2,
    pub get_physical_device_features2_khr: PFN_vkGetPhysicalDeviceFeatures2KHR,
    pub get_physical_device_format_properties: PFN_vkGetPhysicalDeviceFormatProperties,
    pub get_physical_device_format_properties2: PFN_vkGetPhysicalDeviceFormatProperties2,
    pub get_physical_device_format_properties2_khr: PFN_vkGetPhysicalDeviceFormatProperties2KHR,
    pub get_physical_device_image_format_properties: PFN_vkGetPhysicalDeviceImageFormatProperties,
    pub get_physical_device_image_format_properties2: PFN_vkGetPhysicalDeviceImageFormatProperties2,
    pub get_physical_device_image_format_properties2_khr:
        PFN_vkGetPhysicalDeviceImageFormatProperties2KHR,
    pub get_physical_device_memory_properties: PFN_vkGetPhysicalDeviceMemoryProperties,
    pub get_physical_device_memory_properties2: PFN_vkGetPhysicalDeviceMemoryProperties2,
    pub get_physical_device_memory_properties2_khr: PFN_vkGetPhysicalDeviceMemoryProperties2KHR,
    pub get_physical_device_properties: PFN_vkGetPhysicalDeviceProperties,
    pub get_physical_device_properties2: PFN_vkGetPhysicalDeviceProperties2,
    pub get_physical_device_properties2_khr: PFN_vkGetPhysicalDeviceProperties2KHR,
    pub get_physical_device_queue_family_properties: PFN_vkGetPhysicalDeviceQueueFamilyProperties,
    pub get_physical_device_queue_family_properties2: PFN_vkGetPhysicalDeviceQueueFamilyProperties2,
    pub get_physical_device_queue_family_properties2_khr:
        PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR,
    pub get_physical_device_screen_presentation_support_qnx:
        PFN_vkGetPhysicalDeviceScreenPresentationSupportQNX,
    pub get_physical_device_sparse_image_format_properties:
        PFN_vkGetPhysicalDeviceSparseImageFormatProperties,
    pub get_physical_device_sparse_image_format_properties2:
        PFN_vkGetPhysicalDeviceSparseImageFormatProperties2,
    pub get_physical_device_sparse_image_format_properties2_khr:
        PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR,
    pub get_physical_device_surface_capabilities2_ext:
        PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT,
    pub get_physical_device_surface_capabilities2_khr:
        PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR,
    pub get_physical_device_surface_capabilities_khr: PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR,
    pub get_physical_device_surface_formats2_khr: PFN_vkGetPhysicalDeviceSurfaceFormats2KHR,
    pub get_physical_device_surface_formats_khr: PFN_vkGetPhysicalDeviceSurfaceFormatsKHR,
    pub get_physical_device_surface_present_modes_khr:
        PFN_vkGetPhysicalDeviceSurfacePresentModesKHR,
    pub get_physical_device_surface_support_khr: PFN_vkGetPhysicalDeviceSurfaceSupportKHR,
    pub get_physical_device_tool_properties: PFN_vkGetPhysicalDeviceToolProperties,
    pub get_physical_device_wayland_presentation_support_khr:
        PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR,
    pub get_physical_device_win32_presentation_support_khr:
        PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR,
    pub get_physical_device_xcb_presentation_support_khr:
        PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR,
    pub get_physical_device_xlib_presentation_support_khr:
        PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR,
    pub get_rand_r_output_display_ext: PFN_vkGetRandROutputDisplayEXT,
    pub queue_begin_debug_utils_label_ext: PFN_vkQueueBeginDebugUtilsLabelEXT,
    pub queue_end_debug_utils_label_ext: PFN_vkQueueEndDebugUtilsLabelEXT,
    pub queue_insert_debug_utils_label_ext: PFN_vkQueueInsertDebugUtilsLabelEXT,
    pub release_display_ext: PFN_vkReleaseDisplayEXT,
    pub set_debug_utils_object_name_ext: PFN_vkSetDebugUtilsObjectNameEXT,
    pub set_debug_utils_object_tag_ext: PFN_vkSetDebugUtilsObjectTagEXT,
    pub submit_debug_utils_message_ext: PFN_vkSubmitDebugUtilsMessageEXT,
}

impl InstanceCommands {
    #[inline]
    pub unsafe fn load(
        mut loader: impl FnMut(*const c_char) -> Option<unsafe extern "system" fn()>,
    ) -> Self {
        Self {
            acquire_drm_display_ext: {
                let value = loader(c"vkAcquireDrmDisplayEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _drm_fd: i32,
                        _display: DisplayKHR,
                    ) -> Result {
                        panic!("could not load vkAcquireDrmDisplayEXT")
                    }
                    fallback
                }
            },
            acquire_xlib_display_ext: {
                let value = loader(c"vkAcquireXlibDisplayEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _dpy: *mut Display,
                        _display: DisplayKHR,
                    ) -> Result {
                        panic!("could not load vkAcquireXlibDisplayEXT")
                    }
                    fallback
                }
            },
            cmd_begin_debug_utils_label_ext: {
                let value = loader(c"vkCmdBeginDebugUtilsLabelEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _label_info: *const DebugUtilsLabelEXT,
                    ) {
                        panic!("could not load vkCmdBeginDebugUtilsLabelEXT")
                    }
                    fallback
                }
            },
            cmd_end_debug_utils_label_ext: {
                let value = loader(c"vkCmdEndDebugUtilsLabelEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(_command_buffer: CommandBuffer) {
                        panic!("could not load vkCmdEndDebugUtilsLabelEXT")
                    }
                    fallback
                }
            },
            cmd_insert_debug_utils_label_ext: {
                let value = loader(c"vkCmdInsertDebugUtilsLabelEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _command_buffer: CommandBuffer,
                        _label_info: *const DebugUtilsLabelEXT,
                    ) {
                        panic!("could not load vkCmdInsertDebugUtilsLabelEXT")
                    }
                    fallback
                }
            },
            create_android_surface_khr: {
                let value = loader(c"vkCreateAndroidSurfaceKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _instance: Instance,
                        _create_info: *const AndroidSurfaceCreateInfoKHR,
                        _allocator: *const AllocationCallbacks,
                        _surface: *mut SurfaceKHR,
                    ) -> Result {
                        panic!("could not load vkCreateAndroidSurfaceKHR")
                    }
                    fallback
                }
            },
            create_debug_report_callback_ext: {
                let value = loader(c"vkCreateDebugReportCallbackEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _instance: Instance,
                        _create_info: *const DebugReportCallbackCreateInfoEXT,
                        _allocator: *const AllocationCallbacks,
                        _callback: *mut DebugReportCallbackEXT,
                    ) -> Result {
                        panic!("could not load vkCreateDebugReportCallbackEXT")
                    }
                    fallback
                }
            },
            create_debug_utils_messenger_ext: {
                let value = loader(c"vkCreateDebugUtilsMessengerEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _instance: Instance,
                        _create_info: *const DebugUtilsMessengerCreateInfoEXT,
                        _allocator: *const AllocationCallbacks,
                        _messenger: *mut DebugUtilsMessengerEXT,
                    ) -> Result {
                        panic!("could not load vkCreateDebugUtilsMessengerEXT")
                    }
                    fallback
                }
            },
            create_device: {
                let value = loader(c"vkCreateDevice".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _create_info: *const DeviceCreateInfo,
                        _allocator: *const AllocationCallbacks,
                        _device: *mut Device,
                    ) -> Result {
                        panic!("could not load vkCreateDevice")
                    }
                    fallback
                }
            },
            create_direct_fb_surface_ext: {
                let value = loader(c"vkCreateDirectFBSurfaceEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _instance: Instance,
                        _create_info: *const DirectFBSurfaceCreateInfoEXT,
                        _allocator: *const AllocationCallbacks,
                        _surface: *mut SurfaceKHR,
                    ) -> Result {
                        panic!("could not load vkCreateDirectFBSurfaceEXT")
                    }
                    fallback
                }
            },
            create_display_mode_khr: {
                let value = loader(c"vkCreateDisplayModeKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _display: DisplayKHR,
                        _create_info: *const DisplayModeCreateInfoKHR,
                        _allocator: *const AllocationCallbacks,
                        _mode: *mut DisplayModeKHR,
                    ) -> Result {
                        panic!("could not load vkCreateDisplayModeKHR")
                    }
                    fallback
                }
            },
            create_display_plane_surface_khr: {
                let value = loader(c"vkCreateDisplayPlaneSurfaceKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _instance: Instance,
                        _create_info: *const DisplaySurfaceCreateInfoKHR,
                        _allocator: *const AllocationCallbacks,
                        _surface: *mut SurfaceKHR,
                    ) -> Result {
                        panic!("could not load vkCreateDisplayPlaneSurfaceKHR")
                    }
                    fallback
                }
            },
            create_headless_surface_ext: {
                let value = loader(c"vkCreateHeadlessSurfaceEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _instance: Instance,
                        _create_info: *const HeadlessSurfaceCreateInfoEXT,
                        _allocator: *const AllocationCallbacks,
                        _surface: *mut SurfaceKHR,
                    ) -> Result {
                        panic!("could not load vkCreateHeadlessSurfaceEXT")
                    }
                    fallback
                }
            },
            create_ios_surface_mvk: {
                let value = loader(c"vkCreateIOSSurfaceMVK".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _instance: Instance,
                        _create_info: *const IOSSurfaceCreateInfoMVK,
                        _allocator: *const AllocationCallbacks,
                        _surface: *mut SurfaceKHR,
                    ) -> Result {
                        panic!("could not load vkCreateIOSSurfaceMVK")
                    }
                    fallback
                }
            },
            create_image_pipe_surface_fuchsia: {
                let value = loader(c"vkCreateImagePipeSurfaceFUCHSIA".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _instance: Instance,
                        _create_info: *const ImagePipeSurfaceCreateInfoFUCHSIA,
                        _allocator: *const AllocationCallbacks,
                        _surface: *mut SurfaceKHR,
                    ) -> Result {
                        panic!("could not load vkCreateImagePipeSurfaceFUCHSIA")
                    }
                    fallback
                }
            },
            create_mac_os_surface_mvk: {
                let value = loader(c"vkCreateMacOSSurfaceMVK".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _instance: Instance,
                        _create_info: *const MacOSSurfaceCreateInfoMVK,
                        _allocator: *const AllocationCallbacks,
                        _surface: *mut SurfaceKHR,
                    ) -> Result {
                        panic!("could not load vkCreateMacOSSurfaceMVK")
                    }
                    fallback
                }
            },
            create_metal_surface_ext: {
                let value = loader(c"vkCreateMetalSurfaceEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _instance: Instance,
                        _create_info: *const MetalSurfaceCreateInfoEXT,
                        _allocator: *const AllocationCallbacks,
                        _surface: *mut SurfaceKHR,
                    ) -> Result {
                        panic!("could not load vkCreateMetalSurfaceEXT")
                    }
                    fallback
                }
            },
            create_screen_surface_qnx: {
                let value = loader(c"vkCreateScreenSurfaceQNX".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _instance: Instance,
                        _create_info: *const ScreenSurfaceCreateInfoQNX,
                        _allocator: *const AllocationCallbacks,
                        _surface: *mut SurfaceKHR,
                    ) -> Result {
                        panic!("could not load vkCreateScreenSurfaceQNX")
                    }
                    fallback
                }
            },
            create_stream_descriptor_surface_ggp: {
                let value = loader(c"vkCreateStreamDescriptorSurfaceGGP".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _instance: Instance,
                        _create_info: *const StreamDescriptorSurfaceCreateInfoGGP,
                        _allocator: *const AllocationCallbacks,
                        _surface: *mut SurfaceKHR,
                    ) -> Result {
                        panic!("could not load vkCreateStreamDescriptorSurfaceGGP")
                    }
                    fallback
                }
            },
            create_surface_ohos: {
                let value = loader(c"vkCreateSurfaceOHOS".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _instance: Instance,
                        _create_info: *const SurfaceCreateInfoOHOS,
                        _allocator: *const AllocationCallbacks,
                        _surface: *mut SurfaceKHR,
                    ) -> Result {
                        panic!("could not load vkCreateSurfaceOHOS")
                    }
                    fallback
                }
            },
            create_vi_surface_nn: {
                let value = loader(c"vkCreateViSurfaceNN".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _instance: Instance,
                        _create_info: *const ViSurfaceCreateInfoNN,
                        _allocator: *const AllocationCallbacks,
                        _surface: *mut SurfaceKHR,
                    ) -> Result {
                        panic!("could not load vkCreateViSurfaceNN")
                    }
                    fallback
                }
            },
            create_wayland_surface_khr: {
                let value = loader(c"vkCreateWaylandSurfaceKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _instance: Instance,
                        _create_info: *const WaylandSurfaceCreateInfoKHR,
                        _allocator: *const AllocationCallbacks,
                        _surface: *mut SurfaceKHR,
                    ) -> Result {
                        panic!("could not load vkCreateWaylandSurfaceKHR")
                    }
                    fallback
                }
            },
            create_win32_surface_khr: {
                let value = loader(c"vkCreateWin32SurfaceKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _instance: Instance,
                        _create_info: *const Win32SurfaceCreateInfoKHR,
                        _allocator: *const AllocationCallbacks,
                        _surface: *mut SurfaceKHR,
                    ) -> Result {
                        panic!("could not load vkCreateWin32SurfaceKHR")
                    }
                    fallback
                }
            },
            create_xcb_surface_khr: {
                let value = loader(c"vkCreateXcbSurfaceKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _instance: Instance,
                        _create_info: *const XcbSurfaceCreateInfoKHR,
                        _allocator: *const AllocationCallbacks,
                        _surface: *mut SurfaceKHR,
                    ) -> Result {
                        panic!("could not load vkCreateXcbSurfaceKHR")
                    }
                    fallback
                }
            },
            create_xlib_surface_khr: {
                let value = loader(c"vkCreateXlibSurfaceKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _instance: Instance,
                        _create_info: *const XlibSurfaceCreateInfoKHR,
                        _allocator: *const AllocationCallbacks,
                        _surface: *mut SurfaceKHR,
                    ) -> Result {
                        panic!("could not load vkCreateXlibSurfaceKHR")
                    }
                    fallback
                }
            },
            debug_report_message_ext: {
                let value = loader(c"vkDebugReportMessageEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _instance: Instance,
                        _flags: DebugReportFlagsEXT,
                        _object_type: DebugReportObjectTypeEXT,
                        _object: u64,
                        _location: usize,
                        _message_code: i32,
                        _layer_prefix: *const c_char,
                        _message: *const c_char,
                    ) {
                        panic!("could not load vkDebugReportMessageEXT")
                    }
                    fallback
                }
            },
            destroy_debug_report_callback_ext: {
                let value = loader(c"vkDestroyDebugReportCallbackEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _instance: Instance,
                        _callback: DebugReportCallbackEXT,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyDebugReportCallbackEXT")
                    }
                    fallback
                }
            },
            destroy_debug_utils_messenger_ext: {
                let value = loader(c"vkDestroyDebugUtilsMessengerEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _instance: Instance,
                        _messenger: DebugUtilsMessengerEXT,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyDebugUtilsMessengerEXT")
                    }
                    fallback
                }
            },
            destroy_instance: {
                let value = loader(c"vkDestroyInstance".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _instance: Instance,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroyInstance")
                    }
                    fallback
                }
            },
            destroy_surface_khr: {
                let value = loader(c"vkDestroySurfaceKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _instance: Instance,
                        _surface: SurfaceKHR,
                        _allocator: *const AllocationCallbacks,
                    ) {
                        panic!("could not load vkDestroySurfaceKHR")
                    }
                    fallback
                }
            },
            enumerate_device_extension_properties: {
                let value = loader(c"vkEnumerateDeviceExtensionProperties".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _layer_name: *const c_char,
                        _property_count: *mut u32,
                        _properties: *mut ExtensionProperties,
                    ) -> Result {
                        panic!("could not load vkEnumerateDeviceExtensionProperties")
                    }
                    fallback
                }
            },
            enumerate_device_layer_properties: {
                let value = loader(c"vkEnumerateDeviceLayerProperties".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _property_count: *mut u32,
                        _properties: *mut LayerProperties,
                    ) -> Result {
                        panic!("could not load vkEnumerateDeviceLayerProperties")
                    }
                    fallback
                }
            },
            enumerate_physical_device_groups: {
                let value = loader(c"vkEnumeratePhysicalDeviceGroups".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _instance: Instance,
                        _physical_device_group_count: *mut u32,
                        _physical_device_group_properties: *mut PhysicalDeviceGroupProperties,
                    ) -> Result {
                        panic!("could not load vkEnumeratePhysicalDeviceGroups")
                    }
                    fallback
                }
            },
            enumerate_physical_device_groups_khr: {
                let value = loader(c"vkEnumeratePhysicalDeviceGroupsKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _instance: Instance,
                        _physical_device_group_count: *mut u32,
                        _physical_device_group_properties: *mut PhysicalDeviceGroupProperties,
                    ) -> Result {
                        panic!("could not load vkEnumeratePhysicalDeviceGroupsKHR")
                    }
                    fallback
                }
            },
            enumerate_physical_devices: {
                let value = loader(c"vkEnumeratePhysicalDevices".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _instance: Instance,
                        _physical_device_count: *mut u32,
                        _physical_devices: *mut PhysicalDevice,
                    ) -> Result {
                        panic!("could not load vkEnumeratePhysicalDevices")
                    }
                    fallback
                }
            },
            get_display_mode_properties2_khr: {
                let value = loader(c"vkGetDisplayModeProperties2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _display: DisplayKHR,
                        _property_count: *mut u32,
                        _properties: *mut DisplayModeProperties2KHR,
                    ) -> Result {
                        panic!("could not load vkGetDisplayModeProperties2KHR")
                    }
                    fallback
                }
            },
            get_display_mode_properties_khr: {
                let value = loader(c"vkGetDisplayModePropertiesKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _display: DisplayKHR,
                        _property_count: *mut u32,
                        _properties: *mut DisplayModePropertiesKHR,
                    ) -> Result {
                        panic!("could not load vkGetDisplayModePropertiesKHR")
                    }
                    fallback
                }
            },
            get_display_plane_capabilities2_khr: {
                let value = loader(c"vkGetDisplayPlaneCapabilities2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _display_plane_info: *const DisplayPlaneInfo2KHR,
                        _capabilities: *mut DisplayPlaneCapabilities2KHR,
                    ) -> Result {
                        panic!("could not load vkGetDisplayPlaneCapabilities2KHR")
                    }
                    fallback
                }
            },
            get_display_plane_capabilities_khr: {
                let value = loader(c"vkGetDisplayPlaneCapabilitiesKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _mode: DisplayModeKHR,
                        _plane_index: u32,
                        _capabilities: *mut DisplayPlaneCapabilitiesKHR,
                    ) -> Result {
                        panic!("could not load vkGetDisplayPlaneCapabilitiesKHR")
                    }
                    fallback
                }
            },
            get_display_plane_supported_displays_khr: {
                let value = loader(c"vkGetDisplayPlaneSupportedDisplaysKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _plane_index: u32,
                        _display_count: *mut u32,
                        _displays: *mut DisplayKHR,
                    ) -> Result {
                        panic!("could not load vkGetDisplayPlaneSupportedDisplaysKHR")
                    }
                    fallback
                }
            },
            get_drm_display_ext: {
                let value = loader(c"vkGetDrmDisplayEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _drm_fd: i32,
                        _connector_id: u32,
                        _display: *mut DisplayKHR,
                    ) -> Result {
                        panic!("could not load vkGetDrmDisplayEXT")
                    }
                    fallback
                }
            },
            get_physical_device_direct_fb_presentation_support_ext: {
                let value = loader(c"vkGetPhysicalDeviceDirectFBPresentationSupportEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _queue_family_index: u32,
                        _dfb: *mut IDirectFB,
                    ) -> Bool32 {
                        panic!("could not load vkGetPhysicalDeviceDirectFBPresentationSupportEXT")
                    }
                    fallback
                }
            },
            get_physical_device_display_plane_properties2_khr: {
                let value = loader(c"vkGetPhysicalDeviceDisplayPlaneProperties2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _property_count: *mut u32,
                        _properties: *mut DisplayPlaneProperties2KHR,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDeviceDisplayPlaneProperties2KHR")
                    }
                    fallback
                }
            },
            get_physical_device_display_plane_properties_khr: {
                let value = loader(c"vkGetPhysicalDeviceDisplayPlanePropertiesKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _property_count: *mut u32,
                        _properties: *mut DisplayPlanePropertiesKHR,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDeviceDisplayPlanePropertiesKHR")
                    }
                    fallback
                }
            },
            get_physical_device_display_properties2_khr: {
                let value = loader(c"vkGetPhysicalDeviceDisplayProperties2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _property_count: *mut u32,
                        _properties: *mut DisplayProperties2KHR,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDeviceDisplayProperties2KHR")
                    }
                    fallback
                }
            },
            get_physical_device_display_properties_khr: {
                let value = loader(c"vkGetPhysicalDeviceDisplayPropertiesKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _property_count: *mut u32,
                        _properties: *mut DisplayPropertiesKHR,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDeviceDisplayPropertiesKHR")
                    }
                    fallback
                }
            },
            get_physical_device_external_buffer_properties: {
                let value = loader(c"vkGetPhysicalDeviceExternalBufferProperties".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _external_buffer_info: *const PhysicalDeviceExternalBufferInfo,
                        _external_buffer_properties: *mut ExternalBufferProperties,
                    ) {
                        panic!("could not load vkGetPhysicalDeviceExternalBufferProperties")
                    }
                    fallback
                }
            },
            get_physical_device_external_buffer_properties_khr: {
                let value = loader(c"vkGetPhysicalDeviceExternalBufferPropertiesKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _external_buffer_info: *const PhysicalDeviceExternalBufferInfo,
                        _external_buffer_properties: *mut ExternalBufferProperties,
                    ) {
                        panic!("could not load vkGetPhysicalDeviceExternalBufferPropertiesKHR")
                    }
                    fallback
                }
            },
            get_physical_device_external_fence_properties: {
                let value = loader(c"vkGetPhysicalDeviceExternalFenceProperties".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _external_fence_info: *const PhysicalDeviceExternalFenceInfo,
                        _external_fence_properties: *mut ExternalFenceProperties,
                    ) {
                        panic!("could not load vkGetPhysicalDeviceExternalFenceProperties")
                    }
                    fallback
                }
            },
            get_physical_device_external_fence_properties_khr: {
                let value = loader(c"vkGetPhysicalDeviceExternalFencePropertiesKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _external_fence_info: *const PhysicalDeviceExternalFenceInfo,
                        _external_fence_properties: *mut ExternalFenceProperties,
                    ) {
                        panic!("could not load vkGetPhysicalDeviceExternalFencePropertiesKHR")
                    }
                    fallback
                }
            },
            get_physical_device_external_image_format_properties_nv: {
                let value = loader(c"vkGetPhysicalDeviceExternalImageFormatPropertiesNV".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _format: Format,
                        _type_: ImageType,
                        _tiling: ImageTiling,
                        _usage: ImageUsageFlags,
                        _flags: ImageCreateFlags,
                        _external_handle_type: ExternalMemoryHandleTypeFlagsNV,
                        _external_image_format_properties: *mut ExternalImageFormatPropertiesNV,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDeviceExternalImageFormatPropertiesNV")
                    }
                    fallback
                }
            },
            get_physical_device_external_semaphore_properties: {
                let value = loader(c"vkGetPhysicalDeviceExternalSemaphoreProperties".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _external_semaphore_info: *const PhysicalDeviceExternalSemaphoreInfo,
                        _external_semaphore_properties: *mut ExternalSemaphoreProperties,
                    ) {
                        panic!("could not load vkGetPhysicalDeviceExternalSemaphoreProperties")
                    }
                    fallback
                }
            },
            get_physical_device_external_semaphore_properties_khr: {
                let value = loader(c"vkGetPhysicalDeviceExternalSemaphorePropertiesKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _external_semaphore_info: *const PhysicalDeviceExternalSemaphoreInfo,
                        _external_semaphore_properties: *mut ExternalSemaphoreProperties,
                    ) {
                        panic!("could not load vkGetPhysicalDeviceExternalSemaphorePropertiesKHR")
                    }
                    fallback
                }
            },
            get_physical_device_features: {
                let value = loader(c"vkGetPhysicalDeviceFeatures".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _features: *mut PhysicalDeviceFeatures,
                    ) {
                        panic!("could not load vkGetPhysicalDeviceFeatures")
                    }
                    fallback
                }
            },
            get_physical_device_features2: {
                let value = loader(c"vkGetPhysicalDeviceFeatures2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _features: *mut PhysicalDeviceFeatures2,
                    ) {
                        panic!("could not load vkGetPhysicalDeviceFeatures2")
                    }
                    fallback
                }
            },
            get_physical_device_features2_khr: {
                let value = loader(c"vkGetPhysicalDeviceFeatures2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _features: *mut PhysicalDeviceFeatures2,
                    ) {
                        panic!("could not load vkGetPhysicalDeviceFeatures2KHR")
                    }
                    fallback
                }
            },
            get_physical_device_format_properties: {
                let value = loader(c"vkGetPhysicalDeviceFormatProperties".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _format: Format,
                        _format_properties: *mut FormatProperties,
                    ) {
                        panic!("could not load vkGetPhysicalDeviceFormatProperties")
                    }
                    fallback
                }
            },
            get_physical_device_format_properties2: {
                let value = loader(c"vkGetPhysicalDeviceFormatProperties2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _format: Format,
                        _format_properties: *mut FormatProperties2,
                    ) {
                        panic!("could not load vkGetPhysicalDeviceFormatProperties2")
                    }
                    fallback
                }
            },
            get_physical_device_format_properties2_khr: {
                let value = loader(c"vkGetPhysicalDeviceFormatProperties2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _format: Format,
                        _format_properties: *mut FormatProperties2,
                    ) {
                        panic!("could not load vkGetPhysicalDeviceFormatProperties2KHR")
                    }
                    fallback
                }
            },
            get_physical_device_image_format_properties: {
                let value = loader(c"vkGetPhysicalDeviceImageFormatProperties".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _format: Format,
                        _type_: ImageType,
                        _tiling: ImageTiling,
                        _usage: ImageUsageFlags,
                        _flags: ImageCreateFlags,
                        _image_format_properties: *mut ImageFormatProperties,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDeviceImageFormatProperties")
                    }
                    fallback
                }
            },
            get_physical_device_image_format_properties2: {
                let value = loader(c"vkGetPhysicalDeviceImageFormatProperties2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _image_format_info: *const PhysicalDeviceImageFormatInfo2,
                        _image_format_properties: *mut ImageFormatProperties2,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDeviceImageFormatProperties2")
                    }
                    fallback
                }
            },
            get_physical_device_image_format_properties2_khr: {
                let value = loader(c"vkGetPhysicalDeviceImageFormatProperties2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _image_format_info: *const PhysicalDeviceImageFormatInfo2,
                        _image_format_properties: *mut ImageFormatProperties2,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDeviceImageFormatProperties2KHR")
                    }
                    fallback
                }
            },
            get_physical_device_memory_properties: {
                let value = loader(c"vkGetPhysicalDeviceMemoryProperties".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _memory_properties: *mut PhysicalDeviceMemoryProperties,
                    ) {
                        panic!("could not load vkGetPhysicalDeviceMemoryProperties")
                    }
                    fallback
                }
            },
            get_physical_device_memory_properties2: {
                let value = loader(c"vkGetPhysicalDeviceMemoryProperties2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _memory_properties: *mut PhysicalDeviceMemoryProperties2,
                    ) {
                        panic!("could not load vkGetPhysicalDeviceMemoryProperties2")
                    }
                    fallback
                }
            },
            get_physical_device_memory_properties2_khr: {
                let value = loader(c"vkGetPhysicalDeviceMemoryProperties2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _memory_properties: *mut PhysicalDeviceMemoryProperties2,
                    ) {
                        panic!("could not load vkGetPhysicalDeviceMemoryProperties2KHR")
                    }
                    fallback
                }
            },
            get_physical_device_properties: {
                let value = loader(c"vkGetPhysicalDeviceProperties".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _properties: *mut PhysicalDeviceProperties,
                    ) {
                        panic!("could not load vkGetPhysicalDeviceProperties")
                    }
                    fallback
                }
            },
            get_physical_device_properties2: {
                let value = loader(c"vkGetPhysicalDeviceProperties2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _properties: *mut PhysicalDeviceProperties2,
                    ) {
                        panic!("could not load vkGetPhysicalDeviceProperties2")
                    }
                    fallback
                }
            },
            get_physical_device_properties2_khr: {
                let value = loader(c"vkGetPhysicalDeviceProperties2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _properties: *mut PhysicalDeviceProperties2,
                    ) {
                        panic!("could not load vkGetPhysicalDeviceProperties2KHR")
                    }
                    fallback
                }
            },
            get_physical_device_queue_family_properties: {
                let value = loader(c"vkGetPhysicalDeviceQueueFamilyProperties".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _queue_family_property_count: *mut u32,
                        _queue_family_properties: *mut QueueFamilyProperties,
                    ) {
                        panic!("could not load vkGetPhysicalDeviceQueueFamilyProperties")
                    }
                    fallback
                }
            },
            get_physical_device_queue_family_properties2: {
                let value = loader(c"vkGetPhysicalDeviceQueueFamilyProperties2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _queue_family_property_count: *mut u32,
                        _queue_family_properties: *mut QueueFamilyProperties2,
                    ) {
                        panic!("could not load vkGetPhysicalDeviceQueueFamilyProperties2")
                    }
                    fallback
                }
            },
            get_physical_device_queue_family_properties2_khr: {
                let value = loader(c"vkGetPhysicalDeviceQueueFamilyProperties2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _queue_family_property_count: *mut u32,
                        _queue_family_properties: *mut QueueFamilyProperties2,
                    ) {
                        panic!("could not load vkGetPhysicalDeviceQueueFamilyProperties2KHR")
                    }
                    fallback
                }
            },
            get_physical_device_screen_presentation_support_qnx: {
                let value = loader(c"vkGetPhysicalDeviceScreenPresentationSupportQNX".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _queue_family_index: u32,
                        _window: *mut _screen_window,
                    ) -> Bool32 {
                        panic!("could not load vkGetPhysicalDeviceScreenPresentationSupportQNX")
                    }
                    fallback
                }
            },
            get_physical_device_sparse_image_format_properties: {
                let value = loader(c"vkGetPhysicalDeviceSparseImageFormatProperties".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _format: Format,
                        _type_: ImageType,
                        _samples: SampleCountFlags,
                        _usage: ImageUsageFlags,
                        _tiling: ImageTiling,
                        _property_count: *mut u32,
                        _properties: *mut SparseImageFormatProperties,
                    ) {
                        panic!("could not load vkGetPhysicalDeviceSparseImageFormatProperties")
                    }
                    fallback
                }
            },
            get_physical_device_sparse_image_format_properties2: {
                let value = loader(c"vkGetPhysicalDeviceSparseImageFormatProperties2".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _format_info: *const PhysicalDeviceSparseImageFormatInfo2,
                        _property_count: *mut u32,
                        _properties: *mut SparseImageFormatProperties2,
                    ) {
                        panic!("could not load vkGetPhysicalDeviceSparseImageFormatProperties2")
                    }
                    fallback
                }
            },
            get_physical_device_sparse_image_format_properties2_khr: {
                let value = loader(c"vkGetPhysicalDeviceSparseImageFormatProperties2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _format_info: *const PhysicalDeviceSparseImageFormatInfo2,
                        _property_count: *mut u32,
                        _properties: *mut SparseImageFormatProperties2,
                    ) {
                        panic!("could not load vkGetPhysicalDeviceSparseImageFormatProperties2KHR")
                    }
                    fallback
                }
            },
            get_physical_device_surface_capabilities2_ext: {
                let value = loader(c"vkGetPhysicalDeviceSurfaceCapabilities2EXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _surface: SurfaceKHR,
                        _surface_capabilities: *mut SurfaceCapabilities2EXT,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDeviceSurfaceCapabilities2EXT")
                    }
                    fallback
                }
            },
            get_physical_device_surface_capabilities2_khr: {
                let value = loader(c"vkGetPhysicalDeviceSurfaceCapabilities2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _surface_info: *const PhysicalDeviceSurfaceInfo2KHR,
                        _surface_capabilities: *mut SurfaceCapabilities2KHR,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDeviceSurfaceCapabilities2KHR")
                    }
                    fallback
                }
            },
            get_physical_device_surface_capabilities_khr: {
                let value = loader(c"vkGetPhysicalDeviceSurfaceCapabilitiesKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _surface: SurfaceKHR,
                        _surface_capabilities: *mut SurfaceCapabilitiesKHR,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDeviceSurfaceCapabilitiesKHR")
                    }
                    fallback
                }
            },
            get_physical_device_surface_formats2_khr: {
                let value = loader(c"vkGetPhysicalDeviceSurfaceFormats2KHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _surface_info: *const PhysicalDeviceSurfaceInfo2KHR,
                        _surface_format_count: *mut u32,
                        _surface_formats: *mut SurfaceFormat2KHR,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDeviceSurfaceFormats2KHR")
                    }
                    fallback
                }
            },
            get_physical_device_surface_formats_khr: {
                let value = loader(c"vkGetPhysicalDeviceSurfaceFormatsKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _surface: SurfaceKHR,
                        _surface_format_count: *mut u32,
                        _surface_formats: *mut SurfaceFormatKHR,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDeviceSurfaceFormatsKHR")
                    }
                    fallback
                }
            },
            get_physical_device_surface_present_modes_khr: {
                let value = loader(c"vkGetPhysicalDeviceSurfacePresentModesKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _surface: SurfaceKHR,
                        _present_mode_count: *mut u32,
                        _present_modes: *mut PresentModeKHR,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDeviceSurfacePresentModesKHR")
                    }
                    fallback
                }
            },
            get_physical_device_surface_support_khr: {
                let value = loader(c"vkGetPhysicalDeviceSurfaceSupportKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _queue_family_index: u32,
                        _surface: SurfaceKHR,
                        _supported: *mut Bool32,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDeviceSurfaceSupportKHR")
                    }
                    fallback
                }
            },
            get_physical_device_tool_properties: {
                let value = loader(c"vkGetPhysicalDeviceToolProperties".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _tool_count: *mut u32,
                        _tool_properties: *mut PhysicalDeviceToolProperties,
                    ) -> Result {
                        panic!("could not load vkGetPhysicalDeviceToolProperties")
                    }
                    fallback
                }
            },
            get_physical_device_wayland_presentation_support_khr: {
                let value = loader(c"vkGetPhysicalDeviceWaylandPresentationSupportKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _queue_family_index: u32,
                        _display: *mut wl_display,
                    ) -> Bool32 {
                        panic!("could not load vkGetPhysicalDeviceWaylandPresentationSupportKHR")
                    }
                    fallback
                }
            },
            get_physical_device_win32_presentation_support_khr: {
                let value = loader(c"vkGetPhysicalDeviceWin32PresentationSupportKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _queue_family_index: u32,
                    ) -> Bool32 {
                        panic!("could not load vkGetPhysicalDeviceWin32PresentationSupportKHR")
                    }
                    fallback
                }
            },
            get_physical_device_xcb_presentation_support_khr: {
                let value = loader(c"vkGetPhysicalDeviceXcbPresentationSupportKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _queue_family_index: u32,
                        _connection: *mut xcb_connection_t,
                        _visual_id: xcb_visualid_t,
                    ) -> Bool32 {
                        panic!("could not load vkGetPhysicalDeviceXcbPresentationSupportKHR")
                    }
                    fallback
                }
            },
            get_physical_device_xlib_presentation_support_khr: {
                let value = loader(c"vkGetPhysicalDeviceXlibPresentationSupportKHR".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _queue_family_index: u32,
                        _dpy: *mut Display,
                        _visual_id: VisualID,
                    ) -> Bool32 {
                        panic!("could not load vkGetPhysicalDeviceXlibPresentationSupportKHR")
                    }
                    fallback
                }
            },
            get_rand_r_output_display_ext: {
                let value = loader(c"vkGetRandROutputDisplayEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _dpy: *mut Display,
                        _rr_output: RROutput,
                        _display: *mut DisplayKHR,
                    ) -> Result {
                        panic!("could not load vkGetRandROutputDisplayEXT")
                    }
                    fallback
                }
            },
            queue_begin_debug_utils_label_ext: {
                let value = loader(c"vkQueueBeginDebugUtilsLabelEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _queue: Queue,
                        _label_info: *const DebugUtilsLabelEXT,
                    ) {
                        panic!("could not load vkQueueBeginDebugUtilsLabelEXT")
                    }
                    fallback
                }
            },
            queue_end_debug_utils_label_ext: {
                let value = loader(c"vkQueueEndDebugUtilsLabelEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(_queue: Queue) {
                        panic!("could not load vkQueueEndDebugUtilsLabelEXT")
                    }
                    fallback
                }
            },
            queue_insert_debug_utils_label_ext: {
                let value = loader(c"vkQueueInsertDebugUtilsLabelEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _queue: Queue,
                        _label_info: *const DebugUtilsLabelEXT,
                    ) {
                        panic!("could not load vkQueueInsertDebugUtilsLabelEXT")
                    }
                    fallback
                }
            },
            release_display_ext: {
                let value = loader(c"vkReleaseDisplayEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _physical_device: PhysicalDevice,
                        _display: DisplayKHR,
                    ) -> Result {
                        panic!("could not load vkReleaseDisplayEXT")
                    }
                    fallback
                }
            },
            set_debug_utils_object_name_ext: {
                let value = loader(c"vkSetDebugUtilsObjectNameEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _name_info: *const DebugUtilsObjectNameInfoEXT,
                    ) -> Result {
                        panic!("could not load vkSetDebugUtilsObjectNameEXT")
                    }
                    fallback
                }
            },
            set_debug_utils_object_tag_ext: {
                let value = loader(c"vkSetDebugUtilsObjectTagEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _tag_info: *const DebugUtilsObjectTagInfoEXT,
                    ) -> Result {
                        panic!("could not load vkSetDebugUtilsObjectTagEXT")
                    }
                    fallback
                }
            },
            submit_debug_utils_message_ext: {
                let value = loader(c"vkSubmitDebugUtilsMessageEXT".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _instance: Instance,
                        _message_severity: DebugUtilsMessageSeverityFlagsEXT,
                        _message_types: DebugUtilsMessageTypeFlagsEXT,
                        _callback_data: *const DebugUtilsMessengerCallbackDataEXT,
                    ) {
                        panic!("could not load vkSubmitDebugUtilsMessageEXT")
                    }
                    fallback
                }
            },
        }
    }
}

/// Loaded Vulkan static commands.
#[derive(Copy, Clone)]
pub struct StaticCommands {
    pub get_device_proc_addr: PFN_vkGetDeviceProcAddr,
    pub get_instance_proc_addr: PFN_vkGetInstanceProcAddr,
}

impl StaticCommands {
    #[inline]
    pub unsafe fn load(
        mut loader: impl FnMut(*const c_char) -> Option<unsafe extern "system" fn()>,
    ) -> Self {
        Self {
            get_device_proc_addr: {
                let value = loader(c"vkGetDeviceProcAddr".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _device: Device,
                        _name: *const c_char,
                    ) -> PFN_vkVoidFunction {
                        panic!("could not load vkGetDeviceProcAddr")
                    }
                    fallback
                }
            },
            get_instance_proc_addr: {
                let value = loader(c"vkGetInstanceProcAddr".as_ptr());
                if let Some(value) = value {
                    mem::transmute(value)
                } else {
                    unsafe extern "system" fn fallback(
                        _instance: Instance,
                        _name: *const c_char,
                    ) -> PFN_vkVoidFunction {
                        panic!("could not load vkGetInstanceProcAddr")
                    }
                    fallback
                }
            },
        }
    }
}
