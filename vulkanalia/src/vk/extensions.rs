// SPDX-License-Identifier: Apache-2.0

// DO NOT EDIT.
//
// This file has been generated by the Kotlin project in the `generator`
// directory from a Vulkan API registry.

#![allow(
    non_camel_case_types,
    non_snake_case,
    clippy::bad_bit_mask,
    clippy::let_unit_value,
    clippy::missing_safety_doc,
    clippy::missing_transmute_annotations,
    clippy::too_many_arguments,
    clippy::type_complexity,
    clippy::unnecessary_cast,
    clippy::upper_case_acronyms,
    clippy::useless_transmute
)]

use alloc::vec::Vec;
use core::ffi::{c_int, c_void};
use core::mem::MaybeUninit;
use core::ptr;

use super::*;

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_AMDX_shader_enqueue.html>
///
/// ## WARNING
///
/// This is a
/// [provisional extension](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/provisional-headers.html).
/// Provisional extensions are not guaranteed to be backwards compatible and are
/// not intended to be used in production applications.
#[cfg(feature = "provisional")]
pub trait AmdxShaderEnqueueExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = AMDX_SHADER_ENQUEUE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDispatchGraphAMDX.html>
    #[inline]
    unsafe fn cmd_dispatch_graph_amdx(
        &self,
        command_buffer: CommandBuffer,
        scratch: DeviceAddress,
        count_info: &DispatchGraphCountInfoAMDX,
    ) {
        let __result =
            (self.commands().cmd_dispatch_graph_amdx)(command_buffer, scratch, count_info);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDispatchGraphIndirectAMDX.html>
    #[inline]
    unsafe fn cmd_dispatch_graph_indirect_amdx(
        &self,
        command_buffer: CommandBuffer,
        scratch: DeviceAddress,
        count_info: &DispatchGraphCountInfoAMDX,
    ) {
        let __result =
            (self.commands().cmd_dispatch_graph_indirect_amdx)(command_buffer, scratch, count_info);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDispatchGraphIndirectCountAMDX.html>
    #[inline]
    unsafe fn cmd_dispatch_graph_indirect_count_amdx(
        &self,
        command_buffer: CommandBuffer,
        scratch: DeviceAddress,
        count_info: DeviceAddress,
    ) {
        let __result = (self.commands().cmd_dispatch_graph_indirect_count_amdx)(
            command_buffer,
            scratch,
            count_info,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdInitializeGraphScratchMemoryAMDX.html>
    #[inline]
    unsafe fn cmd_initialize_graph_scratch_memory_amdx(
        &self,
        command_buffer: CommandBuffer,
        scratch: DeviceAddress,
    ) {
        let __result =
            (self.commands().cmd_initialize_graph_scratch_memory_amdx)(command_buffer, scratch);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateExecutionGraphPipelinesAMDX.html>
    #[inline]
    unsafe fn create_execution_graph_pipelines_amdx(
        &self,
        pipeline_cache: PipelineCache,
        create_infos: &[impl Cast<Target = ExecutionGraphPipelineCreateInfoAMDX>],
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkSuccessResult<Vec<Pipeline>> {
        let mut pipelines = Vec::with_capacity(create_infos.len() as usize);

        let __result = (self.commands().create_execution_graph_pipelines_amdx)(
            self.handle(),
            pipeline_cache,
            create_infos.len() as u32,
            create_infos.as_ptr().cast(),
            allocator.map_or(ptr::null(), |v| v),
            pipelines.as_mut_ptr(),
        );

        pipelines.set_len(create_infos.len() as usize);

        if __result >= Result::SUCCESS {
            Ok((pipelines, __result.into()))
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetExecutionGraphPipelineNodeIndexAMDX.html>
    #[inline]
    unsafe fn get_execution_graph_pipeline_node_index_amdx(
        &self,
        execution_graph: Pipeline,
        node_info: &PipelineShaderStageNodeCreateInfoAMDX,
    ) -> crate::VkResult<u32> {
        let mut node_index = MaybeUninit::<u32>::uninit();

        let __result = (self.commands().get_execution_graph_pipeline_node_index_amdx)(
            self.handle(),
            execution_graph,
            node_info,
            node_index.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(node_index.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetExecutionGraphPipelineScratchSizeAMDX.html>
    #[inline]
    unsafe fn get_execution_graph_pipeline_scratch_size_amdx(
        &self,
        execution_graph: Pipeline,
        size_info: &mut ExecutionGraphPipelineScratchSizeAMDX,
    ) -> crate::VkResult<()> {
        let __result = (self
            .commands()
            .get_execution_graph_pipeline_scratch_size_amdx)(
            self.handle(),
            execution_graph,
            size_info,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

#[cfg(feature = "provisional")]
impl AmdxShaderEnqueueExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_AMD_anti_lag.html>
pub trait AmdAntiLagExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = AMD_ANTI_LAG_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAntiLagUpdateAMD.html>
    #[inline]
    unsafe fn anti_lag_update_amd(&self, data: &AntiLagDataAMD) {
        let __result = (self.commands().anti_lag_update_amd)(self.handle(), data);
    }
}

impl AmdAntiLagExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_AMD_buffer_marker.html>
pub trait AmdBufferMarkerExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = AMD_BUFFER_MARKER_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWriteBufferMarkerAMD.html>
    #[inline]
    unsafe fn cmd_write_buffer_marker_amd(
        &self,
        command_buffer: CommandBuffer,
        pipeline_stage: PipelineStageFlags,
        dst_buffer: Buffer,
        dst_offset: DeviceSize,
        marker: u32,
    ) {
        let __result = (self.commands().cmd_write_buffer_marker_amd)(
            command_buffer,
            pipeline_stage,
            dst_buffer,
            dst_offset,
            marker,
        );
    }
}

impl AmdBufferMarkerExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_AMD_device_coherent_memory.html>
pub trait AmdDeviceCoherentMemoryExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = AMD_DEVICE_COHERENT_MEMORY_EXTENSION;
}

impl AmdDeviceCoherentMemoryExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_AMD_display_native_hdr.html>
pub trait AmdDisplayNativeHdrExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = AMD_DISPLAY_NATIVE_HDR_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetLocalDimmingAMD.html>
    #[inline]
    unsafe fn set_local_dimming_amd(&self, swap_chain: SwapchainKHR, local_dimming_enable: bool) {
        let __result = (self.commands().set_local_dimming_amd)(
            self.handle(),
            swap_chain,
            local_dimming_enable as Bool32,
        );
    }
}

impl AmdDisplayNativeHdrExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_AMD_draw_indirect_count.html>
pub trait AmdDrawIndirectCountExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = AMD_DRAW_INDIRECT_COUNT_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndexedIndirectCountAMD.html>
    #[inline]
    unsafe fn cmd_draw_indexed_indirect_count_amd(
        &self,
        command_buffer: CommandBuffer,
        buffer: Buffer,
        offset: DeviceSize,
        count_buffer: Buffer,
        count_buffer_offset: DeviceSize,
        max_draw_count: u32,
        stride: u32,
    ) {
        let __result = (self.commands().cmd_draw_indexed_indirect_count_amd)(
            command_buffer,
            buffer,
            offset,
            count_buffer,
            count_buffer_offset,
            max_draw_count,
            stride,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndirectCountAMD.html>
    #[inline]
    unsafe fn cmd_draw_indirect_count_amd(
        &self,
        command_buffer: CommandBuffer,
        buffer: Buffer,
        offset: DeviceSize,
        count_buffer: Buffer,
        count_buffer_offset: DeviceSize,
        max_draw_count: u32,
        stride: u32,
    ) {
        let __result = (self.commands().cmd_draw_indirect_count_amd)(
            command_buffer,
            buffer,
            offset,
            count_buffer,
            count_buffer_offset,
            max_draw_count,
            stride,
        );
    }
}

impl AmdDrawIndirectCountExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_AMD_gcn_shader.html>
pub trait AmdGcnShaderExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = AMD_GCN_SHADER_EXTENSION;
}

impl AmdGcnShaderExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_AMD_gpu_shader_half_float.html>
#[deprecated(note = "deprecated in favor of `VK_KHR_shader_float16_int8`")]
pub trait AmdGpuShaderHalfFloatExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = AMD_GPU_SHADER_HALF_FLOAT_EXTENSION;
}

#[allow(deprecated)]
impl AmdGpuShaderHalfFloatExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_AMD_gpu_shader_int16.html>
#[deprecated(note = "deprecated in favor of `VK_KHR_shader_float16_int8`")]
pub trait AmdGpuShaderInt16Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = AMD_GPU_SHADER_INT16_EXTENSION;
}

#[allow(deprecated)]
impl AmdGpuShaderInt16Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_AMD_memory_overallocation_behavior.html>
pub trait AmdMemoryOverallocationBehaviorExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION;
}

impl AmdMemoryOverallocationBehaviorExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_AMD_mixed_attachment_samples.html>
pub trait AmdMixedAttachmentSamplesExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION;
}

impl AmdMixedAttachmentSamplesExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_AMD_negative_viewport_height.html>
pub trait AmdNegativeViewportHeightExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION;
}

impl AmdNegativeViewportHeightExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_AMD_pipeline_compiler_control.html>
pub trait AmdPipelineCompilerControlExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = AMD_PIPELINE_COMPILER_CONTROL_EXTENSION;
}

impl AmdPipelineCompilerControlExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_AMD_rasterization_order.html>
pub trait AmdRasterizationOrderExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = AMD_RASTERIZATION_ORDER_EXTENSION;
}

impl AmdRasterizationOrderExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_AMD_shader_ballot.html>
pub trait AmdShaderBallotExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = AMD_SHADER_BALLOT_EXTENSION;
}

impl AmdShaderBallotExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_AMD_shader_core_properties.html>
pub trait AmdShaderCorePropertiesExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = AMD_SHADER_CORE_PROPERTIES_EXTENSION;
}

impl AmdShaderCorePropertiesExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_AMD_shader_core_properties2.html>
pub trait AmdShaderCoreProperties2Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = AMD_SHADER_CORE_PROPERTIES2_EXTENSION;
}

impl AmdShaderCoreProperties2Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_AMD_shader_early_and_late_fragment_tests.html>
pub trait AmdShaderEarlyAndLateFragmentTestsExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_EXTENSION;
}

impl AmdShaderEarlyAndLateFragmentTestsExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_AMD_shader_explicit_vertex_parameter.html>
pub trait AmdShaderExplicitVertexParameterExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION;
}

impl AmdShaderExplicitVertexParameterExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_AMD_shader_fragment_mask.html>
pub trait AmdShaderFragmentMaskExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = AMD_SHADER_FRAGMENT_MASK_EXTENSION;
}

impl AmdShaderFragmentMaskExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_AMD_shader_image_load_store_lod.html>
pub trait AmdShaderImageLoadStoreLodExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION;
}

impl AmdShaderImageLoadStoreLodExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_AMD_shader_info.html>
pub trait AmdShaderInfoExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = AMD_SHADER_INFO_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetShaderInfoAMD.html>
    #[inline]
    unsafe fn get_shader_info_amd(
        &self,
        pipeline: Pipeline,
        shader_stage: ShaderStageFlags,
        info_type: ShaderInfoTypeAMD,
    ) -> crate::VkResult<Vec<u8>> {
        let mut info_size = 0;

        (self.commands().get_shader_info_amd)(
            self.handle(),
            pipeline,
            shader_stage,
            info_type,
            &mut info_size,
            ptr::null_mut(),
        );

        let mut info = Vec::with_capacity(info_size as usize);

        let __result = (self.commands().get_shader_info_amd)(
            self.handle(),
            pipeline,
            shader_stage,
            info_type,
            &mut info_size,
            info.as_mut_ptr() as *mut c_void,
        );

        debug_assert!(info.capacity() == info_size as usize);
        info.set_len(info_size as usize);

        if __result == Result::SUCCESS {
            Ok(info)
        } else {
            Err(__result.into())
        }
    }
}

impl AmdShaderInfoExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_AMD_shader_trinary_minmax.html>
pub trait AmdShaderTrinaryMinmaxExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = AMD_SHADER_TRINARY_MINMAX_EXTENSION;
}

impl AmdShaderTrinaryMinmaxExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_AMD_texture_gather_bias_lod.html>
pub trait AmdTextureGatherBiasLodExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION;
}

impl AmdTextureGatherBiasLodExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_ANDROID_external_format_resolve.html>
pub trait AndroidExternalFormatResolveExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = ANDROID_EXTERNAL_FORMAT_RESOLVE_EXTENSION;
}

impl AndroidExternalFormatResolveExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_ANDROID_external_memory_android_hardware_buffer.html>
pub trait AndroidExternalMemoryAndroidHardwareBufferExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetAndroidHardwareBufferPropertiesANDROID.html>
    #[inline]
    unsafe fn get_android_hardware_buffer_properties_android(
        &self,
        buffer: *const AHardwareBuffer,
        properties: &mut AndroidHardwareBufferPropertiesANDROID,
    ) -> crate::VkResult<()> {
        let __result = (self
            .commands()
            .get_android_hardware_buffer_properties_android)(
            self.handle(), buffer, properties
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetMemoryAndroidHardwareBufferANDROID.html>
    #[inline]
    unsafe fn get_memory_android_hardware_buffer_android(
        &self,
        info: &MemoryGetAndroidHardwareBufferInfoANDROID,
    ) -> crate::VkResult<*mut AHardwareBuffer> {
        let mut buffer = MaybeUninit::<*mut AHardwareBuffer>::uninit();

        let __result = (self.commands().get_memory_android_hardware_buffer_android)(
            self.handle(),
            info,
            buffer.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(buffer.assume_init())
        } else {
            Err(__result.into())
        }
    }
}

impl AndroidExternalMemoryAndroidHardwareBufferExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_ARM_rasterization_order_attachment_access.html>
pub trait ArmRasterizationOrderAttachmentAccessExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = ARM_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION;
}

impl ArmRasterizationOrderAttachmentAccessExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_ARM_render_pass_striped.html>
pub trait ArmRenderPassStripedExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = ARM_RENDER_PASS_STRIPED_EXTENSION;
}

impl ArmRenderPassStripedExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_ARM_scheduling_controls.html>
pub trait ArmSchedulingControlsExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = ARM_SCHEDULING_CONTROLS_EXTENSION;
}

impl ArmSchedulingControlsExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_ARM_shader_core_builtins.html>
pub trait ArmShaderCoreBuiltinsExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = ARM_SHADER_CORE_BUILTINS_EXTENSION;
}

impl ArmShaderCoreBuiltinsExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_ARM_shader_core_properties.html>
pub trait ArmShaderCorePropertiesExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = ARM_SHADER_CORE_PROPERTIES_EXTENSION;
}

impl ArmShaderCorePropertiesExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_4444_formats.html>
pub trait Ext4444FormatsExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_4444_FORMATS_EXTENSION;
}

impl Ext4444FormatsExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_acquire_drm_display.html>
pub trait ExtAcquireDrmDisplayExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_ACQUIRE_DRM_DISPLAY_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAcquireDrmDisplayEXT.html>
    #[inline]
    unsafe fn acquire_drm_display_ext(
        &self,
        physical_device: PhysicalDevice,
        drm_fd: i32,
        display: DisplayKHR,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().acquire_drm_display_ext)(physical_device, drm_fd, display);

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDrmDisplayEXT.html>
    #[inline]
    unsafe fn get_drm_display_ext(
        &self,
        physical_device: PhysicalDevice,
        drm_fd: i32,
        connector_id: u32,
    ) -> crate::VkResult<DisplayKHR> {
        let mut display = MaybeUninit::<DisplayKHR>::uninit();

        let __result = (self.commands().get_drm_display_ext)(
            physical_device,
            drm_fd,
            connector_id,
            display.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(display.assume_init())
        } else {
            Err(__result.into())
        }
    }
}

impl ExtAcquireDrmDisplayExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_acquire_xlib_display.html>
pub trait ExtAcquireXlibDisplayExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_ACQUIRE_XLIB_DISPLAY_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAcquireXlibDisplayEXT.html>
    #[inline]
    unsafe fn acquire_xlib_display_ext(
        &self,
        physical_device: PhysicalDevice,
        display: DisplayKHR,
    ) -> crate::VkResult<Display> {
        let mut dpy = MaybeUninit::<Display>::uninit();

        let __result =
            (self.commands().acquire_xlib_display_ext)(physical_device, dpy.as_mut_ptr(), display);

        if __result == Result::SUCCESS {
            Ok(dpy.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetRandROutputDisplayEXT.html>
    #[inline]
    unsafe fn get_rand_r_output_display_ext(
        &self,
        physical_device: PhysicalDevice,
        rr_output: RROutput,
    ) -> crate::VkResult<(Display, DisplayKHR)> {
        let mut dpy = MaybeUninit::<Display>::uninit();
        let mut display = MaybeUninit::<DisplayKHR>::uninit();

        let __result = (self.commands().get_rand_r_output_display_ext)(
            physical_device,
            dpy.as_mut_ptr(),
            rr_output,
            display.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok((dpy.assume_init(), display.assume_init()))
        } else {
            Err(__result.into())
        }
    }
}

impl ExtAcquireXlibDisplayExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_application_parameters.html>
pub trait ExtApplicationParametersExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_APPLICATION_PARAMETERS_EXTENSION;
}

impl ExtApplicationParametersExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_astc_decode_mode.html>
pub trait ExtAstcDecodeModeExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_ASTC_DECODE_MODE_EXTENSION;
}

impl ExtAstcDecodeModeExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_attachment_feedback_loop_dynamic_state.html>
pub trait ExtAttachmentFeedbackLoopDynamicStateExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetAttachmentFeedbackLoopEnableEXT.html>
    #[inline]
    unsafe fn cmd_set_attachment_feedback_loop_enable_ext(
        &self,
        command_buffer: CommandBuffer,
        aspect_mask: ImageAspectFlags,
    ) {
        let __result = (self.commands().cmd_set_attachment_feedback_loop_enable_ext)(
            command_buffer,
            aspect_mask,
        );
    }
}

impl ExtAttachmentFeedbackLoopDynamicStateExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_attachment_feedback_loop_layout.html>
pub trait ExtAttachmentFeedbackLoopLayoutExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_EXTENSION;
}

impl ExtAttachmentFeedbackLoopLayoutExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_blend_operation_advanced.html>
pub trait ExtBlendOperationAdvancedExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_BLEND_OPERATION_ADVANCED_EXTENSION;
}

impl ExtBlendOperationAdvancedExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_border_color_swizzle.html>
pub trait ExtBorderColorSwizzleExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_BORDER_COLOR_SWIZZLE_EXTENSION;
}

impl ExtBorderColorSwizzleExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_buffer_device_address.html>
#[deprecated(note = "deprecated in favor of `VK_KHR_buffer_device_address`")]
pub trait ExtBufferDeviceAddressExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_BUFFER_DEVICE_ADDRESS_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetBufferDeviceAddressEXT.html>
    #[inline]
    unsafe fn get_buffer_device_address_ext(
        &self,
        info: &BufferDeviceAddressInfo,
    ) -> DeviceAddress {
        let __result = (self.commands().get_buffer_device_address_ext)(self.handle(), info);

        __result
    }
}

#[allow(deprecated)]
impl ExtBufferDeviceAddressExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_calibrated_timestamps.html>
pub trait ExtCalibratedTimestampsExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_CALIBRATED_TIMESTAMPS_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetCalibratedTimestampsEXT.html>
    #[inline]
    unsafe fn get_calibrated_timestamps_ext(
        &self,
        timestamp_infos: &[impl Cast<Target = CalibratedTimestampInfoKHR>],
    ) -> crate::VkResult<(Vec<u64>, u64)> {
        let mut timestamps = Vec::with_capacity(timestamp_infos.len() as usize);
        let mut max_deviation = MaybeUninit::<u64>::uninit();

        let __result = (self.commands().get_calibrated_timestamps_ext)(
            self.handle(),
            timestamp_infos.len() as u32,
            timestamp_infos.as_ptr().cast(),
            timestamps.as_mut_ptr(),
            max_deviation.as_mut_ptr(),
        );

        debug_assert!(timestamps.capacity() == timestamp_infos.len() as usize);
        timestamps.set_len(timestamp_infos.len() as usize);

        if __result == Result::SUCCESS {
            Ok((timestamps, max_deviation.assume_init()))
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceCalibrateableTimeDomainsEXT.html>
    #[inline]
    unsafe fn get_physical_device_calibrateable_time_domains_ext(
        &self,
        physical_device: PhysicalDevice,
    ) -> crate::VkResult<Vec<TimeDomainKHR>> {
        let mut time_domain_count = 0;

        (self
            .commands()
            .get_physical_device_calibrateable_time_domains_ext)(
            physical_device,
            &mut time_domain_count,
            ptr::null_mut(),
        );

        let mut time_domains = Vec::with_capacity(time_domain_count as usize);

        let __result = (self
            .commands()
            .get_physical_device_calibrateable_time_domains_ext)(
            physical_device,
            &mut time_domain_count,
            time_domains.as_mut_ptr(),
        );

        debug_assert!(time_domains.capacity() == time_domain_count as usize);
        time_domains.set_len(time_domain_count as usize);

        if __result == Result::SUCCESS {
            Ok(time_domains)
        } else {
            Err(__result.into())
        }
    }
}

impl ExtCalibratedTimestampsExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_color_write_enable.html>
pub trait ExtColorWriteEnableExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_COLOR_WRITE_ENABLE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetColorWriteEnableEXT.html>
    #[inline]
    unsafe fn cmd_set_color_write_enable_ext(
        &self,
        command_buffer: CommandBuffer,
        color_write_enables: &[Bool32],
    ) {
        let __result = (self.commands().cmd_set_color_write_enable_ext)(
            command_buffer,
            color_write_enables.len() as u32,
            color_write_enables.as_ptr(),
        );
    }
}

impl ExtColorWriteEnableExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_conditional_rendering.html>
pub trait ExtConditionalRenderingExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_CONDITIONAL_RENDERING_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginConditionalRenderingEXT.html>
    #[inline]
    unsafe fn cmd_begin_conditional_rendering_ext(
        &self,
        command_buffer: CommandBuffer,
        conditional_rendering_begin: &ConditionalRenderingBeginInfoEXT,
    ) {
        let __result = (self.commands().cmd_begin_conditional_rendering_ext)(
            command_buffer,
            conditional_rendering_begin,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndConditionalRenderingEXT.html>
    #[inline]
    unsafe fn cmd_end_conditional_rendering_ext(&self, command_buffer: CommandBuffer) {
        let __result = (self.commands().cmd_end_conditional_rendering_ext)(command_buffer);
    }
}

impl ExtConditionalRenderingExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_conservative_rasterization.html>
pub trait ExtConservativeRasterizationExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_CONSERVATIVE_RASTERIZATION_EXTENSION;
}

impl ExtConservativeRasterizationExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_custom_border_color.html>
pub trait ExtCustomBorderColorExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_CUSTOM_BORDER_COLOR_EXTENSION;
}

impl ExtCustomBorderColorExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_debug_marker.html>
pub trait ExtDebugMarkerExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_DEBUG_MARKER_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDebugMarkerBeginEXT.html>
    #[inline]
    unsafe fn cmd_debug_marker_begin_ext(
        &self,
        command_buffer: CommandBuffer,
        marker_info: &DebugMarkerMarkerInfoEXT,
    ) {
        let __result = (self.commands().cmd_debug_marker_begin_ext)(command_buffer, marker_info);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDebugMarkerEndEXT.html>
    #[inline]
    unsafe fn cmd_debug_marker_end_ext(&self, command_buffer: CommandBuffer) {
        let __result = (self.commands().cmd_debug_marker_end_ext)(command_buffer);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDebugMarkerInsertEXT.html>
    #[inline]
    unsafe fn cmd_debug_marker_insert_ext(
        &self,
        command_buffer: CommandBuffer,
        marker_info: &DebugMarkerMarkerInfoEXT,
    ) {
        let __result = (self.commands().cmd_debug_marker_insert_ext)(command_buffer, marker_info);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDebugMarkerSetObjectNameEXT.html>
    #[inline]
    unsafe fn debug_marker_set_object_name_ext(
        &self,
        name_info: &DebugMarkerObjectNameInfoEXT,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().debug_marker_set_object_name_ext)(self.handle(), name_info);

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDebugMarkerSetObjectTagEXT.html>
    #[inline]
    unsafe fn debug_marker_set_object_tag_ext(
        &self,
        tag_info: &DebugMarkerObjectTagInfoEXT,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().debug_marker_set_object_tag_ext)(self.handle(), tag_info);

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

impl ExtDebugMarkerExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_debug_report.html>
#[deprecated(note = "deprecated in favor of `VK_EXT_debug_utils`")]
pub trait ExtDebugReportExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_DEBUG_REPORT_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDebugReportCallbackEXT.html>
    #[inline]
    unsafe fn create_debug_report_callback_ext(
        &self,
        create_info: &DebugReportCallbackCreateInfoEXT,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<DebugReportCallbackEXT> {
        let mut callback = MaybeUninit::<DebugReportCallbackEXT>::uninit();

        let __result = (self.commands().create_debug_report_callback_ext)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            callback.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(callback.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDebugReportMessageEXT.html>
    #[inline]
    unsafe fn debug_report_message_ext(
        &self,
        flags: DebugReportFlagsEXT,
        object_type: DebugReportObjectTypeEXT,
        object: u64,
        location: usize,
        message_code: i32,
        layer_prefix: &[u8],
        message: &[u8],
    ) {
        let __result = (self.commands().debug_report_message_ext)(
            self.handle(),
            flags,
            object_type,
            object,
            location,
            message_code,
            layer_prefix.as_ptr().cast(),
            message.as_ptr().cast(),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDebugReportCallbackEXT.html>
    #[inline]
    unsafe fn destroy_debug_report_callback_ext(
        &self,
        callback: DebugReportCallbackEXT,
        allocator: Option<&AllocationCallbacks>,
    ) {
        let __result = (self.commands().destroy_debug_report_callback_ext)(
            self.handle(),
            callback,
            allocator.map_or(ptr::null(), |v| v),
        );
    }
}

#[allow(deprecated)]
impl ExtDebugReportExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_debug_utils.html>
pub trait ExtDebugUtilsExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_DEBUG_UTILS_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginDebugUtilsLabelEXT.html>
    #[inline]
    unsafe fn cmd_begin_debug_utils_label_ext(
        &self,
        command_buffer: CommandBuffer,
        label_info: &DebugUtilsLabelEXT,
    ) {
        let __result =
            (self.commands().cmd_begin_debug_utils_label_ext)(command_buffer, label_info);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndDebugUtilsLabelEXT.html>
    #[inline]
    unsafe fn cmd_end_debug_utils_label_ext(&self, command_buffer: CommandBuffer) {
        let __result = (self.commands().cmd_end_debug_utils_label_ext)(command_buffer);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdInsertDebugUtilsLabelEXT.html>
    #[inline]
    unsafe fn cmd_insert_debug_utils_label_ext(
        &self,
        command_buffer: CommandBuffer,
        label_info: &DebugUtilsLabelEXT,
    ) {
        let __result =
            (self.commands().cmd_insert_debug_utils_label_ext)(command_buffer, label_info);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDebugUtilsMessengerEXT.html>
    #[inline]
    unsafe fn create_debug_utils_messenger_ext(
        &self,
        create_info: &DebugUtilsMessengerCreateInfoEXT,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<DebugUtilsMessengerEXT> {
        let mut messenger = MaybeUninit::<DebugUtilsMessengerEXT>::uninit();

        let __result = (self.commands().create_debug_utils_messenger_ext)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            messenger.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(messenger.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDebugUtilsMessengerEXT.html>
    #[inline]
    unsafe fn destroy_debug_utils_messenger_ext(
        &self,
        messenger: DebugUtilsMessengerEXT,
        allocator: Option<&AllocationCallbacks>,
    ) {
        let __result = (self.commands().destroy_debug_utils_messenger_ext)(
            self.handle(),
            messenger,
            allocator.map_or(ptr::null(), |v| v),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueBeginDebugUtilsLabelEXT.html>
    #[inline]
    unsafe fn queue_begin_debug_utils_label_ext(
        &self,
        queue: Queue,
        label_info: &DebugUtilsLabelEXT,
    ) {
        let __result = (self.commands().queue_begin_debug_utils_label_ext)(queue, label_info);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueEndDebugUtilsLabelEXT.html>
    #[inline]
    unsafe fn queue_end_debug_utils_label_ext(&self, queue: Queue) {
        let __result = (self.commands().queue_end_debug_utils_label_ext)(queue);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueInsertDebugUtilsLabelEXT.html>
    #[inline]
    unsafe fn queue_insert_debug_utils_label_ext(
        &self,
        queue: Queue,
        label_info: &DebugUtilsLabelEXT,
    ) {
        let __result = (self.commands().queue_insert_debug_utils_label_ext)(queue, label_info);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetDebugUtilsObjectNameEXT.html>
    #[inline]
    unsafe fn set_debug_utils_object_name_ext(
        &self,
        device: Device,
        name_info: &DebugUtilsObjectNameInfoEXT,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().set_debug_utils_object_name_ext)(device, name_info);

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetDebugUtilsObjectTagEXT.html>
    #[inline]
    unsafe fn set_debug_utils_object_tag_ext(
        &self,
        device: Device,
        tag_info: &DebugUtilsObjectTagInfoEXT,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().set_debug_utils_object_tag_ext)(device, tag_info);

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSubmitDebugUtilsMessageEXT.html>
    #[inline]
    unsafe fn submit_debug_utils_message_ext(
        &self,
        message_severity: DebugUtilsMessageSeverityFlagsEXT,
        message_types: DebugUtilsMessageTypeFlagsEXT,
        callback_data: &DebugUtilsMessengerCallbackDataEXT,
    ) {
        let __result = (self.commands().submit_debug_utils_message_ext)(
            self.handle(),
            message_severity,
            message_types,
            callback_data,
        );
    }
}

impl ExtDebugUtilsExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_depth_bias_control.html>
pub trait ExtDepthBiasControlExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_DEPTH_BIAS_CONTROL_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBias2EXT.html>
    #[inline]
    unsafe fn cmd_set_depth_bias2_ext(
        &self,
        command_buffer: CommandBuffer,
        depth_bias_info: &DepthBiasInfoEXT,
    ) {
        let __result = (self.commands().cmd_set_depth_bias2_ext)(command_buffer, depth_bias_info);
    }
}

impl ExtDepthBiasControlExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_depth_clamp_zero_one.html>
pub trait ExtDepthClampZeroOneExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_DEPTH_CLAMP_ZERO_ONE_EXTENSION;
}

impl ExtDepthClampZeroOneExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_depth_clip_control.html>
pub trait ExtDepthClipControlExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_DEPTH_CLIP_CONTROL_EXTENSION;
}

impl ExtDepthClipControlExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_depth_clip_enable.html>
pub trait ExtDepthClipEnableExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_DEPTH_CLIP_ENABLE_EXTENSION;
}

impl ExtDepthClipEnableExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_depth_range_unrestricted.html>
pub trait ExtDepthRangeUnrestrictedExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION;
}

impl ExtDepthRangeUnrestrictedExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_descriptor_buffer.html>
pub trait ExtDescriptorBufferExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_DESCRIPTOR_BUFFER_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindDescriptorBufferEmbeddedSamplersEXT.html>
    #[inline]
    unsafe fn cmd_bind_descriptor_buffer_embedded_samplers_ext(
        &self,
        command_buffer: CommandBuffer,
        pipeline_bind_point: PipelineBindPoint,
        layout: PipelineLayout,
        set: u32,
    ) {
        let __result = (self
            .commands()
            .cmd_bind_descriptor_buffer_embedded_samplers_ext)(
            command_buffer,
            pipeline_bind_point,
            layout,
            set,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindDescriptorBuffersEXT.html>
    #[inline]
    unsafe fn cmd_bind_descriptor_buffers_ext(
        &self,
        command_buffer: CommandBuffer,
        binding_infos: &[impl Cast<Target = DescriptorBufferBindingInfoEXT>],
    ) {
        let __result = (self.commands().cmd_bind_descriptor_buffers_ext)(
            command_buffer,
            binding_infos.len() as u32,
            binding_infos.as_ptr().cast(),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDescriptorBufferOffsetsEXT.html>
    #[inline]
    unsafe fn cmd_set_descriptor_buffer_offsets_ext(
        &self,
        command_buffer: CommandBuffer,
        pipeline_bind_point: PipelineBindPoint,
        layout: PipelineLayout,
        first_set: u32,
        buffer_indices: &[u32],
        offsets: &[DeviceSize],
    ) {
        let __result = (self.commands().cmd_set_descriptor_buffer_offsets_ext)(
            command_buffer,
            pipeline_bind_point,
            layout,
            first_set,
            buffer_indices.len() as u32,
            buffer_indices.as_ptr(),
            offsets.as_ptr(),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT.html>
    #[inline]
    unsafe fn get_acceleration_structure_opaque_capture_descriptor_data_ext(
        &self,
        info: &AccelerationStructureCaptureDescriptorDataInfoEXT,
    ) -> crate::VkResult<c_void> {
        let mut data = MaybeUninit::<c_void>::uninit();

        let __result = (self
            .commands()
            .get_acceleration_structure_opaque_capture_descriptor_data_ext)(
            self.handle(),
            info,
            data.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(data.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetBufferOpaqueCaptureDescriptorDataEXT.html>
    #[inline]
    unsafe fn get_buffer_opaque_capture_descriptor_data_ext(
        &self,
        info: &BufferCaptureDescriptorDataInfoEXT,
    ) -> crate::VkResult<c_void> {
        let mut data = MaybeUninit::<c_void>::uninit();

        let __result = (self
            .commands()
            .get_buffer_opaque_capture_descriptor_data_ext)(
            self.handle(), info, data.as_mut_ptr()
        );

        if __result == Result::SUCCESS {
            Ok(data.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDescriptorEXT.html>
    #[inline]
    unsafe fn get_descriptor_ext(
        &self,
        descriptor_info: &DescriptorGetInfoEXT,
        descriptor: &mut [u8],
    ) {
        let __result = (self.commands().get_descriptor_ext)(
            self.handle(),
            descriptor_info,
            descriptor.len() as usize,
            descriptor.as_ptr() as *mut c_void,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDescriptorSetLayoutBindingOffsetEXT.html>
    #[inline]
    unsafe fn get_descriptor_set_layout_binding_offset_ext(
        &self,
        layout: DescriptorSetLayout,
        binding: u32,
    ) -> DeviceSize {
        let mut offset = MaybeUninit::<DeviceSize>::uninit();

        let __result = (self.commands().get_descriptor_set_layout_binding_offset_ext)(
            self.handle(),
            layout,
            binding,
            offset.as_mut_ptr(),
        );

        offset.assume_init()
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDescriptorSetLayoutSizeEXT.html>
    #[inline]
    unsafe fn get_descriptor_set_layout_size_ext(&self, layout: DescriptorSetLayout) -> DeviceSize {
        let mut layout_size_in_bytes = MaybeUninit::<DeviceSize>::uninit();

        let __result = (self.commands().get_descriptor_set_layout_size_ext)(
            self.handle(),
            layout,
            layout_size_in_bytes.as_mut_ptr(),
        );

        layout_size_in_bytes.assume_init()
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageOpaqueCaptureDescriptorDataEXT.html>
    #[inline]
    unsafe fn get_image_opaque_capture_descriptor_data_ext(
        &self,
        info: &ImageCaptureDescriptorDataInfoEXT,
    ) -> crate::VkResult<c_void> {
        let mut data = MaybeUninit::<c_void>::uninit();

        let __result = (self.commands().get_image_opaque_capture_descriptor_data_ext)(
            self.handle(),
            info,
            data.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(data.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageViewOpaqueCaptureDescriptorDataEXT.html>
    #[inline]
    unsafe fn get_image_view_opaque_capture_descriptor_data_ext(
        &self,
        info: &ImageViewCaptureDescriptorDataInfoEXT,
    ) -> crate::VkResult<c_void> {
        let mut data = MaybeUninit::<c_void>::uninit();

        let __result = (self
            .commands()
            .get_image_view_opaque_capture_descriptor_data_ext)(
            self.handle(),
            info,
            data.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(data.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetSamplerOpaqueCaptureDescriptorDataEXT.html>
    #[inline]
    unsafe fn get_sampler_opaque_capture_descriptor_data_ext(
        &self,
        info: &SamplerCaptureDescriptorDataInfoEXT,
    ) -> crate::VkResult<c_void> {
        let mut data = MaybeUninit::<c_void>::uninit();

        let __result = (self
            .commands()
            .get_sampler_opaque_capture_descriptor_data_ext)(
            self.handle(),
            info,
            data.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(data.assume_init())
        } else {
            Err(__result.into())
        }
    }
}

impl ExtDescriptorBufferExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_descriptor_indexing.html>
pub trait ExtDescriptorIndexingExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_DESCRIPTOR_INDEXING_EXTENSION;
}

impl ExtDescriptorIndexingExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_device_address_binding_report.html>
pub trait ExtDeviceAddressBindingReportExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_DEVICE_ADDRESS_BINDING_REPORT_EXTENSION;
}

impl ExtDeviceAddressBindingReportExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_device_fault.html>
pub trait ExtDeviceFaultExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_DEVICE_FAULT_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceFaultInfoEXT.html>
    #[inline]
    unsafe fn get_device_fault_info_ext(
        &self,
        fault_counts: &mut DeviceFaultCountsEXT,
        fault_info: Option<&mut DeviceFaultInfoEXT>,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().get_device_fault_info_ext)(
            self.handle(),
            fault_counts,
            fault_info.map_or(ptr::null_mut(), |v| v),
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

impl ExtDeviceFaultExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_device_memory_report.html>
pub trait ExtDeviceMemoryReportExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_DEVICE_MEMORY_REPORT_EXTENSION;
}

impl ExtDeviceMemoryReportExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_direct_mode_display.html>
pub trait ExtDirectModeDisplayExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_DIRECT_MODE_DISPLAY_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkReleaseDisplayEXT.html>
    #[inline]
    unsafe fn release_display_ext(
        &self,
        physical_device: PhysicalDevice,
        display: DisplayKHR,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().release_display_ext)(physical_device, display);

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

impl ExtDirectModeDisplayExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_directfb_surface.html>
pub trait ExtDirectfbSurfaceExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_DIRECTFB_SURFACE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDirectFBSurfaceEXT.html>
    #[inline]
    unsafe fn create_direct_fb_surface_ext(
        &self,
        create_info: &DirectFBSurfaceCreateInfoEXT,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<SurfaceKHR> {
        let mut surface = MaybeUninit::<SurfaceKHR>::uninit();

        let __result = (self.commands().create_direct_fb_surface_ext)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            surface.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(surface.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceDirectFBPresentationSupportEXT.html>
    #[inline]
    unsafe fn get_physical_device_direct_fb_presentation_support_ext(
        &self,
        physical_device: PhysicalDevice,
        queue_family_index: u32,
        dfb: *mut IDirectFB,
    ) -> Bool32 {
        let __result = (self
            .commands()
            .get_physical_device_direct_fb_presentation_support_ext)(
            physical_device,
            queue_family_index,
            dfb,
        );

        __result
    }
}

impl ExtDirectfbSurfaceExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_discard_rectangles.html>
pub trait ExtDiscardRectanglesExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_DISCARD_RECTANGLES_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDiscardRectangleEXT.html>
    #[inline]
    unsafe fn cmd_set_discard_rectangle_ext(
        &self,
        command_buffer: CommandBuffer,
        first_discard_rectangle: u32,
        discard_rectangles: &[impl Cast<Target = Rect2D>],
    ) {
        let __result = (self.commands().cmd_set_discard_rectangle_ext)(
            command_buffer,
            first_discard_rectangle,
            discard_rectangles.len() as u32,
            discard_rectangles.as_ptr().cast(),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDiscardRectangleEnableEXT.html>
    #[inline]
    unsafe fn cmd_set_discard_rectangle_enable_ext(
        &self,
        command_buffer: CommandBuffer,
        discard_rectangle_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_discard_rectangle_enable_ext)(
            command_buffer,
            discard_rectangle_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDiscardRectangleModeEXT.html>
    #[inline]
    unsafe fn cmd_set_discard_rectangle_mode_ext(
        &self,
        command_buffer: CommandBuffer,
        discard_rectangle_mode: DiscardRectangleModeEXT,
    ) {
        let __result = (self.commands().cmd_set_discard_rectangle_mode_ext)(
            command_buffer,
            discard_rectangle_mode,
        );
    }
}

impl ExtDiscardRectanglesExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_display_control.html>
pub trait ExtDisplayControlExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_DISPLAY_CONTROL_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDisplayPowerControlEXT.html>
    #[inline]
    unsafe fn display_power_control_ext(
        &self,
        display: DisplayKHR,
        display_power_info: &DisplayPowerInfoEXT,
    ) -> crate::VkResult<()> {
        let __result =
            (self.commands().display_power_control_ext)(self.handle(), display, display_power_info);

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetSwapchainCounterEXT.html>
    #[inline]
    unsafe fn get_swapchain_counter_ext(
        &self,
        swapchain: SwapchainKHR,
        counter: SurfaceCounterFlagsEXT,
    ) -> crate::VkResult<u64> {
        let mut counter_value = MaybeUninit::<u64>::uninit();

        let __result = (self.commands().get_swapchain_counter_ext)(
            self.handle(),
            swapchain,
            counter,
            counter_value.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(counter_value.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkRegisterDeviceEventEXT.html>
    #[inline]
    unsafe fn register_device_event_ext(
        &self,
        device_event_info: &DeviceEventInfoEXT,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<Fence> {
        let mut fence = MaybeUninit::<Fence>::uninit();

        let __result = (self.commands().register_device_event_ext)(
            self.handle(),
            device_event_info,
            allocator.map_or(ptr::null(), |v| v),
            fence.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(fence.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkRegisterDisplayEventEXT.html>
    #[inline]
    unsafe fn register_display_event_ext(
        &self,
        display: DisplayKHR,
        display_event_info: &DisplayEventInfoEXT,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<Fence> {
        let mut fence = MaybeUninit::<Fence>::uninit();

        let __result = (self.commands().register_display_event_ext)(
            self.handle(),
            display,
            display_event_info,
            allocator.map_or(ptr::null(), |v| v),
            fence.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(fence.assume_init())
        } else {
            Err(__result.into())
        }
    }
}

impl ExtDisplayControlExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_display_surface_counter.html>
pub trait ExtDisplaySurfaceCounterExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_DISPLAY_SURFACE_COUNTER_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceCapabilities2EXT.html>
    #[inline]
    unsafe fn get_physical_device_surface_capabilities2_ext(
        &self,
        physical_device: PhysicalDevice,
        surface: SurfaceKHR,
        surface_capabilities: &mut SurfaceCapabilities2EXT,
    ) -> crate::VkResult<()> {
        let __result = (self
            .commands()
            .get_physical_device_surface_capabilities2_ext)(
            physical_device,
            surface,
            surface_capabilities,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

impl ExtDisplaySurfaceCounterExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_dynamic_rendering_unused_attachments.html>
pub trait ExtDynamicRenderingUnusedAttachmentsExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_EXTENSION;
}

impl ExtDynamicRenderingUnusedAttachmentsExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_extended_dynamic_state.html>
pub trait ExtExtendedDynamicStateExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_EXTENDED_DYNAMIC_STATE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindVertexBuffers2EXT.html>
    #[inline]
    unsafe fn cmd_bind_vertex_buffers2_ext(
        &self,
        command_buffer: CommandBuffer,
        first_binding: u32,
        buffers: &[Buffer],
        offsets: &[DeviceSize],
        sizes: &[DeviceSize],
        strides: &[DeviceSize],
    ) {
        let __result = (self.commands().cmd_bind_vertex_buffers2_ext)(
            command_buffer,
            first_binding,
            buffers.len() as u32,
            buffers.as_ptr(),
            offsets.as_ptr(),
            sizes.as_ptr(),
            strides.as_ptr(),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCullModeEXT.html>
    #[inline]
    unsafe fn cmd_set_cull_mode_ext(
        &self,
        command_buffer: CommandBuffer,
        cull_mode: CullModeFlags,
    ) {
        let __result = (self.commands().cmd_set_cull_mode_ext)(command_buffer, cull_mode);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBoundsTestEnableEXT.html>
    #[inline]
    unsafe fn cmd_set_depth_bounds_test_enable_ext(
        &self,
        command_buffer: CommandBuffer,
        depth_bounds_test_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_depth_bounds_test_enable_ext)(
            command_buffer,
            depth_bounds_test_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthCompareOpEXT.html>
    #[inline]
    unsafe fn cmd_set_depth_compare_op_ext(
        &self,
        command_buffer: CommandBuffer,
        depth_compare_op: CompareOp,
    ) {
        let __result =
            (self.commands().cmd_set_depth_compare_op_ext)(command_buffer, depth_compare_op);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthTestEnableEXT.html>
    #[inline]
    unsafe fn cmd_set_depth_test_enable_ext(
        &self,
        command_buffer: CommandBuffer,
        depth_test_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_depth_test_enable_ext)(
            command_buffer,
            depth_test_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthWriteEnableEXT.html>
    #[inline]
    unsafe fn cmd_set_depth_write_enable_ext(
        &self,
        command_buffer: CommandBuffer,
        depth_write_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_depth_write_enable_ext)(
            command_buffer,
            depth_write_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetFrontFaceEXT.html>
    #[inline]
    unsafe fn cmd_set_front_face_ext(&self, command_buffer: CommandBuffer, front_face: FrontFace) {
        let __result = (self.commands().cmd_set_front_face_ext)(command_buffer, front_face);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPrimitiveTopologyEXT.html>
    #[inline]
    unsafe fn cmd_set_primitive_topology_ext(
        &self,
        command_buffer: CommandBuffer,
        primitive_topology: PrimitiveTopology,
    ) {
        let __result =
            (self.commands().cmd_set_primitive_topology_ext)(command_buffer, primitive_topology);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetScissorWithCountEXT.html>
    #[inline]
    unsafe fn cmd_set_scissor_with_count_ext(
        &self,
        command_buffer: CommandBuffer,
        scissors: &[impl Cast<Target = Rect2D>],
    ) {
        let __result = (self.commands().cmd_set_scissor_with_count_ext)(
            command_buffer,
            scissors.len() as u32,
            scissors.as_ptr().cast(),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilOpEXT.html>
    #[inline]
    unsafe fn cmd_set_stencil_op_ext(
        &self,
        command_buffer: CommandBuffer,
        face_mask: StencilFaceFlags,
        fail_op: StencilOp,
        pass_op: StencilOp,
        depth_fail_op: StencilOp,
        compare_op: CompareOp,
    ) {
        let __result = (self.commands().cmd_set_stencil_op_ext)(
            command_buffer,
            face_mask,
            fail_op,
            pass_op,
            depth_fail_op,
            compare_op,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilTestEnableEXT.html>
    #[inline]
    unsafe fn cmd_set_stencil_test_enable_ext(
        &self,
        command_buffer: CommandBuffer,
        stencil_test_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_stencil_test_enable_ext)(
            command_buffer,
            stencil_test_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewportWithCountEXT.html>
    #[inline]
    unsafe fn cmd_set_viewport_with_count_ext(
        &self,
        command_buffer: CommandBuffer,
        viewports: &[impl Cast<Target = Viewport>],
    ) {
        let __result = (self.commands().cmd_set_viewport_with_count_ext)(
            command_buffer,
            viewports.len() as u32,
            viewports.as_ptr().cast(),
        );
    }
}

impl ExtExtendedDynamicStateExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_extended_dynamic_state2.html>
pub trait ExtExtendedDynamicState2Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_EXTENDED_DYNAMIC_STATE2_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBiasEnableEXT.html>
    #[inline]
    unsafe fn cmd_set_depth_bias_enable_ext(
        &self,
        command_buffer: CommandBuffer,
        depth_bias_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_depth_bias_enable_ext)(
            command_buffer,
            depth_bias_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetLogicOpEXT.html>
    #[inline]
    unsafe fn cmd_set_logic_op_ext(&self, command_buffer: CommandBuffer, logic_op: LogicOp) {
        let __result = (self.commands().cmd_set_logic_op_ext)(command_buffer, logic_op);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPatchControlPointsEXT.html>
    #[inline]
    unsafe fn cmd_set_patch_control_points_ext(
        &self,
        command_buffer: CommandBuffer,
        patch_control_points: u32,
    ) {
        let __result = (self.commands().cmd_set_patch_control_points_ext)(
            command_buffer,
            patch_control_points,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPrimitiveRestartEnableEXT.html>
    #[inline]
    unsafe fn cmd_set_primitive_restart_enable_ext(
        &self,
        command_buffer: CommandBuffer,
        primitive_restart_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_primitive_restart_enable_ext)(
            command_buffer,
            primitive_restart_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetRasterizerDiscardEnableEXT.html>
    #[inline]
    unsafe fn cmd_set_rasterizer_discard_enable_ext(
        &self,
        command_buffer: CommandBuffer,
        rasterizer_discard_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_rasterizer_discard_enable_ext)(
            command_buffer,
            rasterizer_discard_enable as Bool32,
        );
    }
}

impl ExtExtendedDynamicState2Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_extended_dynamic_state3.html>
pub trait ExtExtendedDynamicState3Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_EXTENDED_DYNAMIC_STATE3_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetAlphaToCoverageEnableEXT.html>
    #[inline]
    unsafe fn cmd_set_alpha_to_coverage_enable_ext(
        &self,
        command_buffer: CommandBuffer,
        alpha_to_coverage_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_alpha_to_coverage_enable_ext)(
            command_buffer,
            alpha_to_coverage_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetAlphaToOneEnableEXT.html>
    #[inline]
    unsafe fn cmd_set_alpha_to_one_enable_ext(
        &self,
        command_buffer: CommandBuffer,
        alpha_to_one_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_alpha_to_one_enable_ext)(
            command_buffer,
            alpha_to_one_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetColorBlendAdvancedEXT.html>
    #[inline]
    unsafe fn cmd_set_color_blend_advanced_ext(
        &self,
        command_buffer: CommandBuffer,
        first_attachment: u32,
        color_blend_advanced: &[impl Cast<Target = ColorBlendAdvancedEXT>],
    ) {
        let __result = (self.commands().cmd_set_color_blend_advanced_ext)(
            command_buffer,
            first_attachment,
            color_blend_advanced.len() as u32,
            color_blend_advanced.as_ptr().cast(),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetColorBlendEnableEXT.html>
    #[inline]
    unsafe fn cmd_set_color_blend_enable_ext(
        &self,
        command_buffer: CommandBuffer,
        first_attachment: u32,
        color_blend_enables: &[Bool32],
    ) {
        let __result = (self.commands().cmd_set_color_blend_enable_ext)(
            command_buffer,
            first_attachment,
            color_blend_enables.len() as u32,
            color_blend_enables.as_ptr(),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetColorBlendEquationEXT.html>
    #[inline]
    unsafe fn cmd_set_color_blend_equation_ext(
        &self,
        command_buffer: CommandBuffer,
        first_attachment: u32,
        color_blend_equations: &[impl Cast<Target = ColorBlendEquationEXT>],
    ) {
        let __result = (self.commands().cmd_set_color_blend_equation_ext)(
            command_buffer,
            first_attachment,
            color_blend_equations.len() as u32,
            color_blend_equations.as_ptr().cast(),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetColorWriteMaskEXT.html>
    #[inline]
    unsafe fn cmd_set_color_write_mask_ext(
        &self,
        command_buffer: CommandBuffer,
        first_attachment: u32,
        color_write_masks: &[ColorComponentFlags],
    ) {
        let __result = (self.commands().cmd_set_color_write_mask_ext)(
            command_buffer,
            first_attachment,
            color_write_masks.len() as u32,
            color_write_masks.as_ptr(),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetConservativeRasterizationModeEXT.html>
    #[inline]
    unsafe fn cmd_set_conservative_rasterization_mode_ext(
        &self,
        command_buffer: CommandBuffer,
        conservative_rasterization_mode: ConservativeRasterizationModeEXT,
    ) {
        let __result = (self.commands().cmd_set_conservative_rasterization_mode_ext)(
            command_buffer,
            conservative_rasterization_mode,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoverageModulationModeNV.html>
    #[inline]
    unsafe fn cmd_set_coverage_modulation_mode_nv(
        &self,
        command_buffer: CommandBuffer,
        coverage_modulation_mode: CoverageModulationModeNV,
    ) {
        let __result = (self.commands().cmd_set_coverage_modulation_mode_nv)(
            command_buffer,
            coverage_modulation_mode,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoverageModulationTableEnableNV.html>
    #[inline]
    unsafe fn cmd_set_coverage_modulation_table_enable_nv(
        &self,
        command_buffer: CommandBuffer,
        coverage_modulation_table_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_coverage_modulation_table_enable_nv)(
            command_buffer,
            coverage_modulation_table_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoverageModulationTableNV.html>
    #[inline]
    unsafe fn cmd_set_coverage_modulation_table_nv(
        &self,
        command_buffer: CommandBuffer,
        coverage_modulation_table: &[f32],
    ) {
        let __result = (self.commands().cmd_set_coverage_modulation_table_nv)(
            command_buffer,
            coverage_modulation_table.len() as u32,
            coverage_modulation_table.as_ptr(),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoverageReductionModeNV.html>
    #[inline]
    unsafe fn cmd_set_coverage_reduction_mode_nv(
        &self,
        command_buffer: CommandBuffer,
        coverage_reduction_mode: CoverageReductionModeNV,
    ) {
        let __result = (self.commands().cmd_set_coverage_reduction_mode_nv)(
            command_buffer,
            coverage_reduction_mode,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoverageToColorEnableNV.html>
    #[inline]
    unsafe fn cmd_set_coverage_to_color_enable_nv(
        &self,
        command_buffer: CommandBuffer,
        coverage_to_color_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_coverage_to_color_enable_nv)(
            command_buffer,
            coverage_to_color_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoverageToColorLocationNV.html>
    #[inline]
    unsafe fn cmd_set_coverage_to_color_location_nv(
        &self,
        command_buffer: CommandBuffer,
        coverage_to_color_location: u32,
    ) {
        let __result = (self.commands().cmd_set_coverage_to_color_location_nv)(
            command_buffer,
            coverage_to_color_location,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthClampEnableEXT.html>
    #[inline]
    unsafe fn cmd_set_depth_clamp_enable_ext(
        &self,
        command_buffer: CommandBuffer,
        depth_clamp_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_depth_clamp_enable_ext)(
            command_buffer,
            depth_clamp_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthClipEnableEXT.html>
    #[inline]
    unsafe fn cmd_set_depth_clip_enable_ext(
        &self,
        command_buffer: CommandBuffer,
        depth_clip_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_depth_clip_enable_ext)(
            command_buffer,
            depth_clip_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthClipNegativeOneToOneEXT.html>
    #[inline]
    unsafe fn cmd_set_depth_clip_negative_one_to_one_ext(
        &self,
        command_buffer: CommandBuffer,
        negative_one_to_one: bool,
    ) {
        let __result = (self.commands().cmd_set_depth_clip_negative_one_to_one_ext)(
            command_buffer,
            negative_one_to_one as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetExtraPrimitiveOverestimationSizeEXT.html>
    #[inline]
    unsafe fn cmd_set_extra_primitive_overestimation_size_ext(
        &self,
        command_buffer: CommandBuffer,
        extra_primitive_overestimation_size: f32,
    ) {
        let __result = (self
            .commands()
            .cmd_set_extra_primitive_overestimation_size_ext)(
            command_buffer,
            extra_primitive_overestimation_size,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetLineRasterizationModeEXT.html>
    #[inline]
    unsafe fn cmd_set_line_rasterization_mode_ext(
        &self,
        command_buffer: CommandBuffer,
        line_rasterization_mode: LineRasterizationModeEXT,
    ) {
        let __result = (self.commands().cmd_set_line_rasterization_mode_ext)(
            command_buffer,
            line_rasterization_mode,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetLineStippleEnableEXT.html>
    #[inline]
    unsafe fn cmd_set_line_stipple_enable_ext(
        &self,
        command_buffer: CommandBuffer,
        stippled_line_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_line_stipple_enable_ext)(
            command_buffer,
            stippled_line_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetLogicOpEnableEXT.html>
    #[inline]
    unsafe fn cmd_set_logic_op_enable_ext(
        &self,
        command_buffer: CommandBuffer,
        logic_op_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_logic_op_enable_ext)(
            command_buffer,
            logic_op_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPolygonModeEXT.html>
    #[inline]
    unsafe fn cmd_set_polygon_mode_ext(
        &self,
        command_buffer: CommandBuffer,
        polygon_mode: PolygonMode,
    ) {
        let __result = (self.commands().cmd_set_polygon_mode_ext)(command_buffer, polygon_mode);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetProvokingVertexModeEXT.html>
    #[inline]
    unsafe fn cmd_set_provoking_vertex_mode_ext(
        &self,
        command_buffer: CommandBuffer,
        provoking_vertex_mode: ProvokingVertexModeEXT,
    ) {
        let __result = (self.commands().cmd_set_provoking_vertex_mode_ext)(
            command_buffer,
            provoking_vertex_mode,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetRasterizationSamplesEXT.html>
    #[inline]
    unsafe fn cmd_set_rasterization_samples_ext(
        &self,
        command_buffer: CommandBuffer,
        rasterization_samples: SampleCountFlags,
    ) {
        let __result = (self.commands().cmd_set_rasterization_samples_ext)(
            command_buffer,
            rasterization_samples,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetRasterizationStreamEXT.html>
    #[inline]
    unsafe fn cmd_set_rasterization_stream_ext(
        &self,
        command_buffer: CommandBuffer,
        rasterization_stream: u32,
    ) {
        let __result = (self.commands().cmd_set_rasterization_stream_ext)(
            command_buffer,
            rasterization_stream,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetRepresentativeFragmentTestEnableNV.html>
    #[inline]
    unsafe fn cmd_set_representative_fragment_test_enable_nv(
        &self,
        command_buffer: CommandBuffer,
        representative_fragment_test_enable: bool,
    ) {
        let __result = (self
            .commands()
            .cmd_set_representative_fragment_test_enable_nv)(
            command_buffer,
            representative_fragment_test_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetSampleLocationsEnableEXT.html>
    #[inline]
    unsafe fn cmd_set_sample_locations_enable_ext(
        &self,
        command_buffer: CommandBuffer,
        sample_locations_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_sample_locations_enable_ext)(
            command_buffer,
            sample_locations_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetSampleMaskEXT.html>
    #[inline]
    unsafe fn cmd_set_sample_mask_ext(
        &self,
        command_buffer: CommandBuffer,
        samples: SampleCountFlags,
        sample_mask: &SampleMask,
    ) {
        let __result =
            (self.commands().cmd_set_sample_mask_ext)(command_buffer, samples, sample_mask);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetShadingRateImageEnableNV.html>
    #[inline]
    unsafe fn cmd_set_shading_rate_image_enable_nv(
        &self,
        command_buffer: CommandBuffer,
        shading_rate_image_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_shading_rate_image_enable_nv)(
            command_buffer,
            shading_rate_image_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetTessellationDomainOriginEXT.html>
    #[inline]
    unsafe fn cmd_set_tessellation_domain_origin_ext(
        &self,
        command_buffer: CommandBuffer,
        domain_origin: TessellationDomainOrigin,
    ) {
        let __result =
            (self.commands().cmd_set_tessellation_domain_origin_ext)(command_buffer, domain_origin);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewportSwizzleNV.html>
    #[inline]
    unsafe fn cmd_set_viewport_swizzle_nv(
        &self,
        command_buffer: CommandBuffer,
        first_viewport: u32,
        viewport_swizzles: &[impl Cast<Target = ViewportSwizzleNV>],
    ) {
        let __result = (self.commands().cmd_set_viewport_swizzle_nv)(
            command_buffer,
            first_viewport,
            viewport_swizzles.len() as u32,
            viewport_swizzles.as_ptr().cast(),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewportWScalingEnableNV.html>
    #[inline]
    unsafe fn cmd_set_viewport_w_scaling_enable_nv(
        &self,
        command_buffer: CommandBuffer,
        viewport_w_scaling_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_viewport_w_scaling_enable_nv)(
            command_buffer,
            viewport_w_scaling_enable as Bool32,
        );
    }
}

impl ExtExtendedDynamicState3Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_external_memory_acquire_unmodified.html>
pub trait ExtExternalMemoryAcquireUnmodifiedExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXTENSION;
}

impl ExtExternalMemoryAcquireUnmodifiedExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_external_memory_dma_buf.html>
pub trait ExtExternalMemoryDmaBufExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION;
}

impl ExtExternalMemoryDmaBufExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_external_memory_host.html>
pub trait ExtExternalMemoryHostExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_EXTERNAL_MEMORY_HOST_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetMemoryHostPointerPropertiesEXT.html>
    #[inline]
    unsafe fn get_memory_host_pointer_properties_ext(
        &self,
        handle_type: ExternalMemoryHandleTypeFlags,
        host_pointer: &c_void,
        memory_host_pointer_properties: &mut MemoryHostPointerPropertiesEXT,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().get_memory_host_pointer_properties_ext)(
            self.handle(),
            handle_type,
            host_pointer,
            memory_host_pointer_properties,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

impl ExtExternalMemoryHostExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_filter_cubic.html>
pub trait ExtFilterCubicExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_FILTER_CUBIC_EXTENSION;
}

impl ExtFilterCubicExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_fragment_density_map.html>
pub trait ExtFragmentDensityMapExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_FRAGMENT_DENSITY_MAP_EXTENSION;
}

impl ExtFragmentDensityMapExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_fragment_density_map2.html>
pub trait ExtFragmentDensityMap2Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_FRAGMENT_DENSITY_MAP2_EXTENSION;
}

impl ExtFragmentDensityMap2Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_fragment_shader_interlock.html>
pub trait ExtFragmentShaderInterlockExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION;
}

impl ExtFragmentShaderInterlockExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_frame_boundary.html>
pub trait ExtFrameBoundaryExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_FRAME_BOUNDARY_EXTENSION;
}

impl ExtFrameBoundaryExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_full_screen_exclusive.html>
pub trait ExtFullScreenExclusiveExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_FULL_SCREEN_EXCLUSIVE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAcquireFullScreenExclusiveModeEXT.html>
    #[inline]
    unsafe fn acquire_full_screen_exclusive_mode_ext(
        &self,
        swapchain: SwapchainKHR,
    ) -> crate::VkResult<()> {
        let __result =
            (self.commands().acquire_full_screen_exclusive_mode_ext)(self.handle(), swapchain);

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceGroupSurfacePresentModes2EXT.html>
    #[inline]
    unsafe fn get_device_group_surface_present_modes2_ext(
        &self,
        surface_info: &PhysicalDeviceSurfaceInfo2KHR,
    ) -> crate::VkResult<DeviceGroupPresentModeFlagsKHR> {
        let mut modes = MaybeUninit::<DeviceGroupPresentModeFlagsKHR>::uninit();

        let __result = (self.commands().get_device_group_surface_present_modes2_ext)(
            self.handle(),
            surface_info,
            modes.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(modes.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfacePresentModes2EXT.html>
    #[inline]
    unsafe fn get_physical_device_surface_present_modes2_ext(
        &self,
        physical_device: PhysicalDevice,
        surface_info: &PhysicalDeviceSurfaceInfo2KHR,
    ) -> crate::VkResult<Vec<PresentModeKHR>> {
        let mut present_mode_count = 0;

        (self
            .commands()
            .get_physical_device_surface_present_modes2_ext)(
            physical_device,
            surface_info,
            &mut present_mode_count,
            ptr::null_mut(),
        );

        let mut present_modes = Vec::with_capacity(present_mode_count as usize);

        let __result = (self
            .commands()
            .get_physical_device_surface_present_modes2_ext)(
            physical_device,
            surface_info,
            &mut present_mode_count,
            present_modes.as_mut_ptr(),
        );

        debug_assert!(present_modes.capacity() == present_mode_count as usize);
        present_modes.set_len(present_mode_count as usize);

        if __result == Result::SUCCESS {
            Ok(present_modes)
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkReleaseFullScreenExclusiveModeEXT.html>
    #[inline]
    unsafe fn release_full_screen_exclusive_mode_ext(
        &self,
        swapchain: SwapchainKHR,
    ) -> crate::VkResult<()> {
        let __result =
            (self.commands().release_full_screen_exclusive_mode_ext)(self.handle(), swapchain);

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

impl ExtFullScreenExclusiveExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_global_priority.html>
pub trait ExtGlobalPriorityExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_GLOBAL_PRIORITY_EXTENSION;
}

impl ExtGlobalPriorityExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_global_priority_query.html>
pub trait ExtGlobalPriorityQueryExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_GLOBAL_PRIORITY_QUERY_EXTENSION;
}

impl ExtGlobalPriorityQueryExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_graphics_pipeline_library.html>
pub trait ExtGraphicsPipelineLibraryExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_GRAPHICS_PIPELINE_LIBRARY_EXTENSION;
}

impl ExtGraphicsPipelineLibraryExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_hdr_metadata.html>
pub trait ExtHdrMetadataExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_HDR_METADATA_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetHdrMetadataEXT.html>
    #[inline]
    unsafe fn set_hdr_metadata_ext(
        &self,
        swapchains: &[SwapchainKHR],
        metadata: &[impl Cast<Target = HdrMetadataEXT>],
    ) {
        let __result = (self.commands().set_hdr_metadata_ext)(
            self.handle(),
            swapchains.len() as u32,
            swapchains.as_ptr(),
            metadata.as_ptr().cast(),
        );
    }
}

impl ExtHdrMetadataExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_headless_surface.html>
pub trait ExtHeadlessSurfaceExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_HEADLESS_SURFACE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateHeadlessSurfaceEXT.html>
    #[inline]
    unsafe fn create_headless_surface_ext(
        &self,
        create_info: &HeadlessSurfaceCreateInfoEXT,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<SurfaceKHR> {
        let mut surface = MaybeUninit::<SurfaceKHR>::uninit();

        let __result = (self.commands().create_headless_surface_ext)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            surface.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(surface.assume_init())
        } else {
            Err(__result.into())
        }
    }
}

impl ExtHeadlessSurfaceExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_host_image_copy.html>
pub trait ExtHostImageCopyExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_HOST_IMAGE_COPY_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCopyImageToImageEXT.html>
    #[inline]
    unsafe fn copy_image_to_image_ext(
        &self,
        copy_image_to_image_info: &CopyImageToImageInfoEXT,
    ) -> crate::VkResult<()> {
        let __result =
            (self.commands().copy_image_to_image_ext)(self.handle(), copy_image_to_image_info);

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCopyImageToMemoryEXT.html>
    #[inline]
    unsafe fn copy_image_to_memory_ext(
        &self,
        copy_image_to_memory_info: &CopyImageToMemoryInfoEXT,
    ) -> crate::VkResult<()> {
        let __result =
            (self.commands().copy_image_to_memory_ext)(self.handle(), copy_image_to_memory_info);

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCopyMemoryToImageEXT.html>
    #[inline]
    unsafe fn copy_memory_to_image_ext(
        &self,
        copy_memory_to_image_info: &CopyMemoryToImageInfoEXT,
    ) -> crate::VkResult<()> {
        let __result =
            (self.commands().copy_memory_to_image_ext)(self.handle(), copy_memory_to_image_info);

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageSubresourceLayout2EXT.html>
    #[inline]
    unsafe fn get_image_subresource_layout2_ext(
        &self,
        image: Image,
        subresource: &ImageSubresource2KHR,
        layout: &mut SubresourceLayout2KHR,
    ) {
        let __result = (self.commands().get_image_subresource_layout2_ext)(
            self.handle(),
            image,
            subresource,
            layout,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkTransitionImageLayoutEXT.html>
    #[inline]
    unsafe fn transition_image_layout_ext(
        &self,
        transitions: &[impl Cast<Target = HostImageLayoutTransitionInfoEXT>],
    ) -> crate::VkResult<()> {
        let __result = (self.commands().transition_image_layout_ext)(
            self.handle(),
            transitions.len() as u32,
            transitions.as_ptr().cast(),
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

impl ExtHostImageCopyExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_host_query_reset.html>
pub trait ExtHostQueryResetExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_HOST_QUERY_RESET_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetQueryPoolEXT.html>
    #[inline]
    unsafe fn reset_query_pool_ext(
        &self,
        query_pool: QueryPool,
        first_query: u32,
        query_count: u32,
    ) {
        let __result = (self.commands().reset_query_pool_ext)(
            self.handle(),
            query_pool,
            first_query,
            query_count,
        );
    }
}

impl ExtHostQueryResetExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_image_2d_view_of_3d.html>
pub trait ExtImage2dViewOf3dExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_IMAGE_2D_VIEW_OF_3D_EXTENSION;
}

impl ExtImage2dViewOf3dExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_image_compression_control.html>
pub trait ExtImageCompressionControlExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_IMAGE_COMPRESSION_CONTROL_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageSubresourceLayout2EXT.html>
    #[inline]
    unsafe fn get_image_subresource_layout2_ext(
        &self,
        image: Image,
        subresource: &ImageSubresource2KHR,
        layout: &mut SubresourceLayout2KHR,
    ) {
        let __result = (self.commands().get_image_subresource_layout2_ext)(
            self.handle(),
            image,
            subresource,
            layout,
        );
    }
}

impl ExtImageCompressionControlExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_image_compression_control_swapchain.html>
pub trait ExtImageCompressionControlSwapchainExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_EXTENSION;
}

impl ExtImageCompressionControlSwapchainExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_image_drm_format_modifier.html>
pub trait ExtImageDrmFormatModifierExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageDrmFormatModifierPropertiesEXT.html>
    #[inline]
    unsafe fn get_image_drm_format_modifier_properties_ext(
        &self,
        image: Image,
        properties: &mut ImageDrmFormatModifierPropertiesEXT,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().get_image_drm_format_modifier_properties_ext)(
            self.handle(),
            image,
            properties,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

impl ExtImageDrmFormatModifierExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_image_robustness.html>
pub trait ExtImageRobustnessExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_IMAGE_ROBUSTNESS_EXTENSION;
}

impl ExtImageRobustnessExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_image_sliced_view_of_3d.html>
pub trait ExtImageSlicedViewOf3dExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_IMAGE_SLICED_VIEW_OF_3D_EXTENSION;
}

impl ExtImageSlicedViewOf3dExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_image_view_min_lod.html>
pub trait ExtImageViewMinLodExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_IMAGE_VIEW_MIN_LOD_EXTENSION;
}

impl ExtImageViewMinLodExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_index_type_uint8.html>
pub trait ExtIndexTypeUint8Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_INDEX_TYPE_UINT8_EXTENSION;
}

impl ExtIndexTypeUint8Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_inline_uniform_block.html>
pub trait ExtInlineUniformBlockExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_INLINE_UNIFORM_BLOCK_EXTENSION;
}

impl ExtInlineUniformBlockExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_layer_settings.html>
pub trait ExtLayerSettingsExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_LAYER_SETTINGS_EXTENSION;
}

impl ExtLayerSettingsExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_legacy_dithering.html>
pub trait ExtLegacyDitheringExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_LEGACY_DITHERING_EXTENSION;
}

impl ExtLegacyDitheringExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_legacy_vertex_attributes.html>
pub trait ExtLegacyVertexAttributesExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_LEGACY_VERTEX_ATTRIBUTES_EXTENSION;
}

impl ExtLegacyVertexAttributesExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_line_rasterization.html>
pub trait ExtLineRasterizationExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_LINE_RASTERIZATION_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetLineStippleEXT.html>
    #[inline]
    unsafe fn cmd_set_line_stipple_ext(
        &self,
        command_buffer: CommandBuffer,
        line_stipple_factor: u32,
        line_stipple_pattern: u16,
    ) {
        let __result = (self.commands().cmd_set_line_stipple_ext)(
            command_buffer,
            line_stipple_factor,
            line_stipple_pattern,
        );
    }
}

impl ExtLineRasterizationExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_load_store_op_none.html>
pub trait ExtLoadStoreOpNoneExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_LOAD_STORE_OP_NONE_EXTENSION;
}

impl ExtLoadStoreOpNoneExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_map_memory_placed.html>
pub trait ExtMapMemoryPlacedExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_MAP_MEMORY_PLACED_EXTENSION;
}

impl ExtMapMemoryPlacedExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_memory_budget.html>
pub trait ExtMemoryBudgetExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_MEMORY_BUDGET_EXTENSION;
}

impl ExtMemoryBudgetExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_memory_priority.html>
pub trait ExtMemoryPriorityExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_MEMORY_PRIORITY_EXTENSION;
}

impl ExtMemoryPriorityExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_mesh_shader.html>
pub trait ExtMeshShaderExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_MESH_SHADER_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMeshTasksEXT.html>
    #[inline]
    unsafe fn cmd_draw_mesh_tasks_ext(
        &self,
        command_buffer: CommandBuffer,
        group_count_x: u32,
        group_count_y: u32,
        group_count_z: u32,
    ) {
        let __result = (self.commands().cmd_draw_mesh_tasks_ext)(
            command_buffer,
            group_count_x,
            group_count_y,
            group_count_z,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMeshTasksIndirectCountEXT.html>
    #[inline]
    unsafe fn cmd_draw_mesh_tasks_indirect_count_ext(
        &self,
        command_buffer: CommandBuffer,
        buffer: Buffer,
        offset: DeviceSize,
        count_buffer: Buffer,
        count_buffer_offset: DeviceSize,
        max_draw_count: u32,
        stride: u32,
    ) {
        let __result = (self.commands().cmd_draw_mesh_tasks_indirect_count_ext)(
            command_buffer,
            buffer,
            offset,
            count_buffer,
            count_buffer_offset,
            max_draw_count,
            stride,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMeshTasksIndirectEXT.html>
    #[inline]
    unsafe fn cmd_draw_mesh_tasks_indirect_ext(
        &self,
        command_buffer: CommandBuffer,
        buffer: Buffer,
        offset: DeviceSize,
        draw_count: u32,
        stride: u32,
    ) {
        let __result = (self.commands().cmd_draw_mesh_tasks_indirect_ext)(
            command_buffer,
            buffer,
            offset,
            draw_count,
            stride,
        );
    }
}

impl ExtMeshShaderExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_metal_objects.html>
pub trait ExtMetalObjectsExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_METAL_OBJECTS_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkExportMetalObjectsEXT.html>
    #[inline]
    unsafe fn export_metal_objects_ext(&self, metal_objects_info: &mut ExportMetalObjectsInfoEXT) {
        let __result =
            (self.commands().export_metal_objects_ext)(self.handle(), metal_objects_info);
    }
}

impl ExtMetalObjectsExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_metal_surface.html>
pub trait ExtMetalSurfaceExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_METAL_SURFACE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateMetalSurfaceEXT.html>
    #[inline]
    unsafe fn create_metal_surface_ext(
        &self,
        create_info: &MetalSurfaceCreateInfoEXT,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<SurfaceKHR> {
        let mut surface = MaybeUninit::<SurfaceKHR>::uninit();

        let __result = (self.commands().create_metal_surface_ext)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            surface.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(surface.assume_init())
        } else {
            Err(__result.into())
        }
    }
}

impl ExtMetalSurfaceExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_multi_draw.html>
pub trait ExtMultiDrawExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_MULTI_DRAW_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMultiEXT.html>
    #[inline]
    unsafe fn cmd_draw_multi_ext(
        &self,
        command_buffer: CommandBuffer,
        vertex_info: &[impl Cast<Target = MultiDrawInfoEXT>],
        instance_count: u32,
        first_instance: u32,
        stride: u32,
    ) {
        let __result = (self.commands().cmd_draw_multi_ext)(
            command_buffer,
            vertex_info.len() as u32,
            vertex_info.as_ptr().cast(),
            instance_count,
            first_instance,
            stride,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMultiIndexedEXT.html>
    #[inline]
    unsafe fn cmd_draw_multi_indexed_ext(
        &self,
        command_buffer: CommandBuffer,
        index_info: &[impl Cast<Target = MultiDrawIndexedInfoEXT>],
        instance_count: u32,
        first_instance: u32,
        stride: u32,
        vertex_offset: Option<&i32>,
    ) {
        let __result = (self.commands().cmd_draw_multi_indexed_ext)(
            command_buffer,
            index_info.len() as u32,
            index_info.as_ptr().cast(),
            instance_count,
            first_instance,
            stride,
            vertex_offset.map_or(ptr::null(), |v| v),
        );
    }
}

impl ExtMultiDrawExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_multisampled_render_to_single_sampled.html>
pub trait ExtMultisampledRenderToSingleSampledExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_EXTENSION;
}

impl ExtMultisampledRenderToSingleSampledExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_mutable_descriptor_type.html>
pub trait ExtMutableDescriptorTypeExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_MUTABLE_DESCRIPTOR_TYPE_EXTENSION;
}

impl ExtMutableDescriptorTypeExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_nested_command_buffer.html>
pub trait ExtNestedCommandBufferExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_NESTED_COMMAND_BUFFER_EXTENSION;
}

impl ExtNestedCommandBufferExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_non_seamless_cube_map.html>
pub trait ExtNonSeamlessCubeMapExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_NON_SEAMLESS_CUBE_MAP_EXTENSION;
}

impl ExtNonSeamlessCubeMapExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_opacity_micromap.html>
pub trait ExtOpacityMicromapExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_OPACITY_MICROMAP_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBuildMicromapsEXT.html>
    #[inline]
    unsafe fn build_micromaps_ext(
        &self,
        deferred_operation: DeferredOperationKHR,
        infos: &[impl Cast<Target = MicromapBuildInfoEXT>],
    ) -> crate::VkResult<SuccessCode> {
        let __result = (self.commands().build_micromaps_ext)(
            self.handle(),
            deferred_operation,
            infos.len() as u32,
            infos.as_ptr().cast(),
        );

        if __result >= Result::SUCCESS {
            Ok(__result.into())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBuildMicromapsEXT.html>
    #[inline]
    unsafe fn cmd_build_micromaps_ext(
        &self,
        command_buffer: CommandBuffer,
        infos: &[impl Cast<Target = MicromapBuildInfoEXT>],
    ) {
        let __result = (self.commands().cmd_build_micromaps_ext)(
            command_buffer,
            infos.len() as u32,
            infos.as_ptr().cast(),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyMemoryToMicromapEXT.html>
    #[inline]
    unsafe fn cmd_copy_memory_to_micromap_ext(
        &self,
        command_buffer: CommandBuffer,
        info: &CopyMemoryToMicromapInfoEXT,
    ) {
        let __result = (self.commands().cmd_copy_memory_to_micromap_ext)(command_buffer, info);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyMicromapEXT.html>
    #[inline]
    unsafe fn cmd_copy_micromap_ext(
        &self,
        command_buffer: CommandBuffer,
        info: &CopyMicromapInfoEXT,
    ) {
        let __result = (self.commands().cmd_copy_micromap_ext)(command_buffer, info);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyMicromapToMemoryEXT.html>
    #[inline]
    unsafe fn cmd_copy_micromap_to_memory_ext(
        &self,
        command_buffer: CommandBuffer,
        info: &CopyMicromapToMemoryInfoEXT,
    ) {
        let __result = (self.commands().cmd_copy_micromap_to_memory_ext)(command_buffer, info);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWriteMicromapsPropertiesEXT.html>
    #[inline]
    unsafe fn cmd_write_micromaps_properties_ext(
        &self,
        command_buffer: CommandBuffer,
        micromaps: &[MicromapEXT],
        query_type: QueryType,
        query_pool: QueryPool,
        first_query: u32,
    ) {
        let __result = (self.commands().cmd_write_micromaps_properties_ext)(
            command_buffer,
            micromaps.len() as u32,
            micromaps.as_ptr(),
            query_type,
            query_pool,
            first_query,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCopyMemoryToMicromapEXT.html>
    #[inline]
    unsafe fn copy_memory_to_micromap_ext(
        &self,
        deferred_operation: DeferredOperationKHR,
        info: &CopyMemoryToMicromapInfoEXT,
    ) -> crate::VkResult<SuccessCode> {
        let __result =
            (self.commands().copy_memory_to_micromap_ext)(self.handle(), deferred_operation, info);

        if __result >= Result::SUCCESS {
            Ok(__result.into())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCopyMicromapEXT.html>
    #[inline]
    unsafe fn copy_micromap_ext(
        &self,
        deferred_operation: DeferredOperationKHR,
        info: &CopyMicromapInfoEXT,
    ) -> crate::VkResult<SuccessCode> {
        let __result = (self.commands().copy_micromap_ext)(self.handle(), deferred_operation, info);

        if __result >= Result::SUCCESS {
            Ok(__result.into())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCopyMicromapToMemoryEXT.html>
    #[inline]
    unsafe fn copy_micromap_to_memory_ext(
        &self,
        deferred_operation: DeferredOperationKHR,
        info: &CopyMicromapToMemoryInfoEXT,
    ) -> crate::VkResult<SuccessCode> {
        let __result =
            (self.commands().copy_micromap_to_memory_ext)(self.handle(), deferred_operation, info);

        if __result >= Result::SUCCESS {
            Ok(__result.into())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateMicromapEXT.html>
    #[inline]
    unsafe fn create_micromap_ext(
        &self,
        create_info: &MicromapCreateInfoEXT,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<MicromapEXT> {
        let mut micromap = MaybeUninit::<MicromapEXT>::uninit();

        let __result = (self.commands().create_micromap_ext)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            micromap.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(micromap.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyMicromapEXT.html>
    #[inline]
    unsafe fn destroy_micromap_ext(
        &self,
        micromap: MicromapEXT,
        allocator: Option<&AllocationCallbacks>,
    ) {
        let __result = (self.commands().destroy_micromap_ext)(
            self.handle(),
            micromap,
            allocator.map_or(ptr::null(), |v| v),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceMicromapCompatibilityEXT.html>
    #[inline]
    unsafe fn get_device_micromap_compatibility_ext(
        &self,
        version_info: &MicromapVersionInfoEXT,
    ) -> AccelerationStructureCompatibilityKHR {
        let mut compatibility = MaybeUninit::<AccelerationStructureCompatibilityKHR>::uninit();

        let __result = (self.commands().get_device_micromap_compatibility_ext)(
            self.handle(),
            version_info,
            compatibility.as_mut_ptr(),
        );

        compatibility.assume_init()
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetMicromapBuildSizesEXT.html>
    #[inline]
    unsafe fn get_micromap_build_sizes_ext(
        &self,
        build_type: AccelerationStructureBuildTypeKHR,
        build_info: &MicromapBuildInfoEXT,
        size_info: &mut MicromapBuildSizesInfoEXT,
    ) {
        let __result = (self.commands().get_micromap_build_sizes_ext)(
            self.handle(),
            build_type,
            build_info,
            size_info,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkWriteMicromapsPropertiesEXT.html>
    #[inline]
    unsafe fn write_micromaps_properties_ext(
        &self,
        micromaps: &[MicromapEXT],
        query_type: QueryType,
        data: &mut [u8],
        stride: usize,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().write_micromaps_properties_ext)(
            self.handle(),
            micromaps.len() as u32,
            micromaps.as_ptr(),
            query_type,
            data.len() as usize,
            data.as_ptr() as *mut c_void,
            stride,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

impl ExtOpacityMicromapExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_pageable_device_local_memory.html>
pub trait ExtPageableDeviceLocalMemoryExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetDeviceMemoryPriorityEXT.html>
    #[inline]
    unsafe fn set_device_memory_priority_ext(&self, memory: DeviceMemory, priority: f32) {
        let __result =
            (self.commands().set_device_memory_priority_ext)(self.handle(), memory, priority);
    }
}

impl ExtPageableDeviceLocalMemoryExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_pci_bus_info.html>
pub trait ExtPciBusInfoExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_PCI_BUS_INFO_EXTENSION;
}

impl ExtPciBusInfoExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_physical_device_drm.html>
pub trait ExtPhysicalDeviceDrmExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_PHYSICAL_DEVICE_DRM_EXTENSION;
}

impl ExtPhysicalDeviceDrmExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_pipeline_creation_cache_control.html>
pub trait ExtPipelineCreationCacheControlExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_PIPELINE_CREATION_CACHE_CONTROL_EXTENSION;
}

impl ExtPipelineCreationCacheControlExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_pipeline_creation_feedback.html>
pub trait ExtPipelineCreationFeedbackExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION;
}

impl ExtPipelineCreationFeedbackExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_pipeline_library_group_handles.html>
pub trait ExtPipelineLibraryGroupHandlesExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_PIPELINE_LIBRARY_GROUP_HANDLES_EXTENSION;
}

impl ExtPipelineLibraryGroupHandlesExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_pipeline_properties.html>
pub trait ExtPipelinePropertiesExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_PIPELINE_PROPERTIES_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPipelinePropertiesEXT.html>
    #[inline]
    unsafe fn get_pipeline_properties_ext(
        &self,
        pipeline_info: &PipelineInfoEXT,
    ) -> crate::VkResult<BaseOutStructure> {
        let mut pipeline_properties = MaybeUninit::<BaseOutStructure>::uninit();

        let __result = (self.commands().get_pipeline_properties_ext)(
            self.handle(),
            pipeline_info,
            pipeline_properties.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(pipeline_properties.assume_init())
        } else {
            Err(__result.into())
        }
    }
}

impl ExtPipelinePropertiesExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_pipeline_protected_access.html>
pub trait ExtPipelineProtectedAccessExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_PIPELINE_PROTECTED_ACCESS_EXTENSION;
}

impl ExtPipelineProtectedAccessExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_pipeline_robustness.html>
pub trait ExtPipelineRobustnessExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_PIPELINE_ROBUSTNESS_EXTENSION;
}

impl ExtPipelineRobustnessExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_post_depth_coverage.html>
pub trait ExtPostDepthCoverageExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_POST_DEPTH_COVERAGE_EXTENSION;
}

impl ExtPostDepthCoverageExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_primitive_topology_list_restart.html>
pub trait ExtPrimitiveTopologyListRestartExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_EXTENSION;
}

impl ExtPrimitiveTopologyListRestartExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_primitives_generated_query.html>
pub trait ExtPrimitivesGeneratedQueryExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_PRIMITIVES_GENERATED_QUERY_EXTENSION;
}

impl ExtPrimitivesGeneratedQueryExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_private_data.html>
pub trait ExtPrivateDataExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_PRIVATE_DATA_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreatePrivateDataSlotEXT.html>
    #[inline]
    unsafe fn create_private_data_slot_ext(
        &self,
        create_info: &PrivateDataSlotCreateInfo,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<PrivateDataSlot> {
        let mut private_data_slot = MaybeUninit::<PrivateDataSlot>::uninit();

        let __result = (self.commands().create_private_data_slot_ext)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            private_data_slot.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(private_data_slot.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyPrivateDataSlotEXT.html>
    #[inline]
    unsafe fn destroy_private_data_slot_ext(
        &self,
        private_data_slot: PrivateDataSlot,
        allocator: Option<&AllocationCallbacks>,
    ) {
        let __result = (self.commands().destroy_private_data_slot_ext)(
            self.handle(),
            private_data_slot,
            allocator.map_or(ptr::null(), |v| v),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPrivateDataEXT.html>
    #[inline]
    unsafe fn get_private_data_ext(
        &self,
        object_type: ObjectType,
        object_handle: u64,
        private_data_slot: PrivateDataSlot,
    ) -> u64 {
        let mut data = MaybeUninit::<u64>::uninit();

        let __result = (self.commands().get_private_data_ext)(
            self.handle(),
            object_type,
            object_handle,
            private_data_slot,
            data.as_mut_ptr(),
        );

        data.assume_init()
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetPrivateDataEXT.html>
    #[inline]
    unsafe fn set_private_data_ext(
        &self,
        object_type: ObjectType,
        object_handle: u64,
        private_data_slot: PrivateDataSlot,
        data: u64,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().set_private_data_ext)(
            self.handle(),
            object_type,
            object_handle,
            private_data_slot,
            data,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

impl ExtPrivateDataExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_provoking_vertex.html>
pub trait ExtProvokingVertexExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_PROVOKING_VERTEX_EXTENSION;
}

impl ExtProvokingVertexExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_queue_family_foreign.html>
pub trait ExtQueueFamilyForeignExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_QUEUE_FAMILY_FOREIGN_EXTENSION;
}

impl ExtQueueFamilyForeignExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_rasterization_order_attachment_access.html>
pub trait ExtRasterizationOrderAttachmentAccessExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION;
}

impl ExtRasterizationOrderAttachmentAccessExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_rgba10x6_formats.html>
pub trait ExtRgba10x6FormatsExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_RGBA10X6_FORMATS_EXTENSION;
}

impl ExtRgba10x6FormatsExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_robustness2.html>
pub trait ExtRobustness2Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_ROBUSTNESS2_EXTENSION;
}

impl ExtRobustness2Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_sample_locations.html>
pub trait ExtSampleLocationsExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_SAMPLE_LOCATIONS_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetSampleLocationsEXT.html>
    #[inline]
    unsafe fn cmd_set_sample_locations_ext(
        &self,
        command_buffer: CommandBuffer,
        sample_locations_info: &SampleLocationsInfoEXT,
    ) {
        let __result =
            (self.commands().cmd_set_sample_locations_ext)(command_buffer, sample_locations_info);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceMultisamplePropertiesEXT.html>
    #[inline]
    unsafe fn get_physical_device_multisample_properties_ext(
        &self,
        physical_device: PhysicalDevice,
        samples: SampleCountFlags,
        multisample_properties: &mut MultisamplePropertiesEXT,
    ) {
        let __result = (self
            .commands()
            .get_physical_device_multisample_properties_ext)(
            physical_device,
            samples,
            multisample_properties,
        );
    }
}

impl ExtSampleLocationsExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_sampler_filter_minmax.html>
pub trait ExtSamplerFilterMinmaxExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_SAMPLER_FILTER_MINMAX_EXTENSION;
}

impl ExtSamplerFilterMinmaxExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_scalar_block_layout.html>
pub trait ExtScalarBlockLayoutExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_SCALAR_BLOCK_LAYOUT_EXTENSION;
}

impl ExtScalarBlockLayoutExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_separate_stencil_usage.html>
pub trait ExtSeparateStencilUsageExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_SEPARATE_STENCIL_USAGE_EXTENSION;
}

impl ExtSeparateStencilUsageExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_shader_atomic_float.html>
pub trait ExtShaderAtomicFloatExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_SHADER_ATOMIC_FLOAT_EXTENSION;
}

impl ExtShaderAtomicFloatExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_shader_atomic_float2.html>
pub trait ExtShaderAtomicFloat2Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_SHADER_ATOMIC_FLOAT2_EXTENSION;
}

impl ExtShaderAtomicFloat2Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_shader_demote_to_helper_invocation.html>
pub trait ExtShaderDemoteToHelperInvocationExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION;
}

impl ExtShaderDemoteToHelperInvocationExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_shader_image_atomic_int64.html>
pub trait ExtShaderImageAtomicInt64Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION;
}

impl ExtShaderImageAtomicInt64Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_shader_module_identifier.html>
pub trait ExtShaderModuleIdentifierExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_SHADER_MODULE_IDENTIFIER_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetShaderModuleCreateInfoIdentifierEXT.html>
    #[inline]
    unsafe fn get_shader_module_create_info_identifier_ext(
        &self,
        create_info: &ShaderModuleCreateInfo,
        identifier: &mut ShaderModuleIdentifierEXT,
    ) {
        let __result = (self.commands().get_shader_module_create_info_identifier_ext)(
            self.handle(),
            create_info,
            identifier,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetShaderModuleIdentifierEXT.html>
    #[inline]
    unsafe fn get_shader_module_identifier_ext(
        &self,
        shader_module: ShaderModule,
        identifier: &mut ShaderModuleIdentifierEXT,
    ) {
        let __result = (self.commands().get_shader_module_identifier_ext)(
            self.handle(),
            shader_module,
            identifier,
        );
    }
}

impl ExtShaderModuleIdentifierExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_shader_object.html>
pub trait ExtShaderObjectExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_SHADER_OBJECT_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindShadersEXT.html>
    #[inline]
    unsafe fn cmd_bind_shaders_ext(
        &self,
        command_buffer: CommandBuffer,
        stages: &[ShaderStageFlags],
        shaders: &[ShaderEXT],
    ) {
        let __result = (self.commands().cmd_bind_shaders_ext)(
            command_buffer,
            stages.len() as u32,
            stages.as_ptr(),
            shaders.as_ptr(),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindVertexBuffers2EXT.html>
    #[inline]
    unsafe fn cmd_bind_vertex_buffers2_ext(
        &self,
        command_buffer: CommandBuffer,
        first_binding: u32,
        buffers: &[Buffer],
        offsets: &[DeviceSize],
        sizes: &[DeviceSize],
        strides: &[DeviceSize],
    ) {
        let __result = (self.commands().cmd_bind_vertex_buffers2_ext)(
            command_buffer,
            first_binding,
            buffers.len() as u32,
            buffers.as_ptr(),
            offsets.as_ptr(),
            sizes.as_ptr(),
            strides.as_ptr(),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetAlphaToCoverageEnableEXT.html>
    #[inline]
    unsafe fn cmd_set_alpha_to_coverage_enable_ext(
        &self,
        command_buffer: CommandBuffer,
        alpha_to_coverage_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_alpha_to_coverage_enable_ext)(
            command_buffer,
            alpha_to_coverage_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetAlphaToOneEnableEXT.html>
    #[inline]
    unsafe fn cmd_set_alpha_to_one_enable_ext(
        &self,
        command_buffer: CommandBuffer,
        alpha_to_one_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_alpha_to_one_enable_ext)(
            command_buffer,
            alpha_to_one_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetColorBlendAdvancedEXT.html>
    #[inline]
    unsafe fn cmd_set_color_blend_advanced_ext(
        &self,
        command_buffer: CommandBuffer,
        first_attachment: u32,
        color_blend_advanced: &[impl Cast<Target = ColorBlendAdvancedEXT>],
    ) {
        let __result = (self.commands().cmd_set_color_blend_advanced_ext)(
            command_buffer,
            first_attachment,
            color_blend_advanced.len() as u32,
            color_blend_advanced.as_ptr().cast(),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetColorBlendEnableEXT.html>
    #[inline]
    unsafe fn cmd_set_color_blend_enable_ext(
        &self,
        command_buffer: CommandBuffer,
        first_attachment: u32,
        color_blend_enables: &[Bool32],
    ) {
        let __result = (self.commands().cmd_set_color_blend_enable_ext)(
            command_buffer,
            first_attachment,
            color_blend_enables.len() as u32,
            color_blend_enables.as_ptr(),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetColorBlendEquationEXT.html>
    #[inline]
    unsafe fn cmd_set_color_blend_equation_ext(
        &self,
        command_buffer: CommandBuffer,
        first_attachment: u32,
        color_blend_equations: &[impl Cast<Target = ColorBlendEquationEXT>],
    ) {
        let __result = (self.commands().cmd_set_color_blend_equation_ext)(
            command_buffer,
            first_attachment,
            color_blend_equations.len() as u32,
            color_blend_equations.as_ptr().cast(),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetColorWriteMaskEXT.html>
    #[inline]
    unsafe fn cmd_set_color_write_mask_ext(
        &self,
        command_buffer: CommandBuffer,
        first_attachment: u32,
        color_write_masks: &[ColorComponentFlags],
    ) {
        let __result = (self.commands().cmd_set_color_write_mask_ext)(
            command_buffer,
            first_attachment,
            color_write_masks.len() as u32,
            color_write_masks.as_ptr(),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetConservativeRasterizationModeEXT.html>
    #[inline]
    unsafe fn cmd_set_conservative_rasterization_mode_ext(
        &self,
        command_buffer: CommandBuffer,
        conservative_rasterization_mode: ConservativeRasterizationModeEXT,
    ) {
        let __result = (self.commands().cmd_set_conservative_rasterization_mode_ext)(
            command_buffer,
            conservative_rasterization_mode,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoverageModulationModeNV.html>
    #[inline]
    unsafe fn cmd_set_coverage_modulation_mode_nv(
        &self,
        command_buffer: CommandBuffer,
        coverage_modulation_mode: CoverageModulationModeNV,
    ) {
        let __result = (self.commands().cmd_set_coverage_modulation_mode_nv)(
            command_buffer,
            coverage_modulation_mode,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoverageModulationTableEnableNV.html>
    #[inline]
    unsafe fn cmd_set_coverage_modulation_table_enable_nv(
        &self,
        command_buffer: CommandBuffer,
        coverage_modulation_table_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_coverage_modulation_table_enable_nv)(
            command_buffer,
            coverage_modulation_table_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoverageModulationTableNV.html>
    #[inline]
    unsafe fn cmd_set_coverage_modulation_table_nv(
        &self,
        command_buffer: CommandBuffer,
        coverage_modulation_table: &[f32],
    ) {
        let __result = (self.commands().cmd_set_coverage_modulation_table_nv)(
            command_buffer,
            coverage_modulation_table.len() as u32,
            coverage_modulation_table.as_ptr(),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoverageReductionModeNV.html>
    #[inline]
    unsafe fn cmd_set_coverage_reduction_mode_nv(
        &self,
        command_buffer: CommandBuffer,
        coverage_reduction_mode: CoverageReductionModeNV,
    ) {
        let __result = (self.commands().cmd_set_coverage_reduction_mode_nv)(
            command_buffer,
            coverage_reduction_mode,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoverageToColorEnableNV.html>
    #[inline]
    unsafe fn cmd_set_coverage_to_color_enable_nv(
        &self,
        command_buffer: CommandBuffer,
        coverage_to_color_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_coverage_to_color_enable_nv)(
            command_buffer,
            coverage_to_color_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoverageToColorLocationNV.html>
    #[inline]
    unsafe fn cmd_set_coverage_to_color_location_nv(
        &self,
        command_buffer: CommandBuffer,
        coverage_to_color_location: u32,
    ) {
        let __result = (self.commands().cmd_set_coverage_to_color_location_nv)(
            command_buffer,
            coverage_to_color_location,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCullModeEXT.html>
    #[inline]
    unsafe fn cmd_set_cull_mode_ext(
        &self,
        command_buffer: CommandBuffer,
        cull_mode: CullModeFlags,
    ) {
        let __result = (self.commands().cmd_set_cull_mode_ext)(command_buffer, cull_mode);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBiasEnableEXT.html>
    #[inline]
    unsafe fn cmd_set_depth_bias_enable_ext(
        &self,
        command_buffer: CommandBuffer,
        depth_bias_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_depth_bias_enable_ext)(
            command_buffer,
            depth_bias_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBoundsTestEnableEXT.html>
    #[inline]
    unsafe fn cmd_set_depth_bounds_test_enable_ext(
        &self,
        command_buffer: CommandBuffer,
        depth_bounds_test_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_depth_bounds_test_enable_ext)(
            command_buffer,
            depth_bounds_test_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthClampEnableEXT.html>
    #[inline]
    unsafe fn cmd_set_depth_clamp_enable_ext(
        &self,
        command_buffer: CommandBuffer,
        depth_clamp_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_depth_clamp_enable_ext)(
            command_buffer,
            depth_clamp_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthClipEnableEXT.html>
    #[inline]
    unsafe fn cmd_set_depth_clip_enable_ext(
        &self,
        command_buffer: CommandBuffer,
        depth_clip_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_depth_clip_enable_ext)(
            command_buffer,
            depth_clip_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthClipNegativeOneToOneEXT.html>
    #[inline]
    unsafe fn cmd_set_depth_clip_negative_one_to_one_ext(
        &self,
        command_buffer: CommandBuffer,
        negative_one_to_one: bool,
    ) {
        let __result = (self.commands().cmd_set_depth_clip_negative_one_to_one_ext)(
            command_buffer,
            negative_one_to_one as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthCompareOpEXT.html>
    #[inline]
    unsafe fn cmd_set_depth_compare_op_ext(
        &self,
        command_buffer: CommandBuffer,
        depth_compare_op: CompareOp,
    ) {
        let __result =
            (self.commands().cmd_set_depth_compare_op_ext)(command_buffer, depth_compare_op);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthTestEnableEXT.html>
    #[inline]
    unsafe fn cmd_set_depth_test_enable_ext(
        &self,
        command_buffer: CommandBuffer,
        depth_test_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_depth_test_enable_ext)(
            command_buffer,
            depth_test_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthWriteEnableEXT.html>
    #[inline]
    unsafe fn cmd_set_depth_write_enable_ext(
        &self,
        command_buffer: CommandBuffer,
        depth_write_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_depth_write_enable_ext)(
            command_buffer,
            depth_write_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetExtraPrimitiveOverestimationSizeEXT.html>
    #[inline]
    unsafe fn cmd_set_extra_primitive_overestimation_size_ext(
        &self,
        command_buffer: CommandBuffer,
        extra_primitive_overestimation_size: f32,
    ) {
        let __result = (self
            .commands()
            .cmd_set_extra_primitive_overestimation_size_ext)(
            command_buffer,
            extra_primitive_overestimation_size,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetFrontFaceEXT.html>
    #[inline]
    unsafe fn cmd_set_front_face_ext(&self, command_buffer: CommandBuffer, front_face: FrontFace) {
        let __result = (self.commands().cmd_set_front_face_ext)(command_buffer, front_face);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetLineRasterizationModeEXT.html>
    #[inline]
    unsafe fn cmd_set_line_rasterization_mode_ext(
        &self,
        command_buffer: CommandBuffer,
        line_rasterization_mode: LineRasterizationModeEXT,
    ) {
        let __result = (self.commands().cmd_set_line_rasterization_mode_ext)(
            command_buffer,
            line_rasterization_mode,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetLineStippleEnableEXT.html>
    #[inline]
    unsafe fn cmd_set_line_stipple_enable_ext(
        &self,
        command_buffer: CommandBuffer,
        stippled_line_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_line_stipple_enable_ext)(
            command_buffer,
            stippled_line_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetLogicOpEXT.html>
    #[inline]
    unsafe fn cmd_set_logic_op_ext(&self, command_buffer: CommandBuffer, logic_op: LogicOp) {
        let __result = (self.commands().cmd_set_logic_op_ext)(command_buffer, logic_op);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetLogicOpEnableEXT.html>
    #[inline]
    unsafe fn cmd_set_logic_op_enable_ext(
        &self,
        command_buffer: CommandBuffer,
        logic_op_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_logic_op_enable_ext)(
            command_buffer,
            logic_op_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPatchControlPointsEXT.html>
    #[inline]
    unsafe fn cmd_set_patch_control_points_ext(
        &self,
        command_buffer: CommandBuffer,
        patch_control_points: u32,
    ) {
        let __result = (self.commands().cmd_set_patch_control_points_ext)(
            command_buffer,
            patch_control_points,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPolygonModeEXT.html>
    #[inline]
    unsafe fn cmd_set_polygon_mode_ext(
        &self,
        command_buffer: CommandBuffer,
        polygon_mode: PolygonMode,
    ) {
        let __result = (self.commands().cmd_set_polygon_mode_ext)(command_buffer, polygon_mode);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPrimitiveRestartEnableEXT.html>
    #[inline]
    unsafe fn cmd_set_primitive_restart_enable_ext(
        &self,
        command_buffer: CommandBuffer,
        primitive_restart_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_primitive_restart_enable_ext)(
            command_buffer,
            primitive_restart_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPrimitiveTopologyEXT.html>
    #[inline]
    unsafe fn cmd_set_primitive_topology_ext(
        &self,
        command_buffer: CommandBuffer,
        primitive_topology: PrimitiveTopology,
    ) {
        let __result =
            (self.commands().cmd_set_primitive_topology_ext)(command_buffer, primitive_topology);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetProvokingVertexModeEXT.html>
    #[inline]
    unsafe fn cmd_set_provoking_vertex_mode_ext(
        &self,
        command_buffer: CommandBuffer,
        provoking_vertex_mode: ProvokingVertexModeEXT,
    ) {
        let __result = (self.commands().cmd_set_provoking_vertex_mode_ext)(
            command_buffer,
            provoking_vertex_mode,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetRasterizationSamplesEXT.html>
    #[inline]
    unsafe fn cmd_set_rasterization_samples_ext(
        &self,
        command_buffer: CommandBuffer,
        rasterization_samples: SampleCountFlags,
    ) {
        let __result = (self.commands().cmd_set_rasterization_samples_ext)(
            command_buffer,
            rasterization_samples,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetRasterizationStreamEXT.html>
    #[inline]
    unsafe fn cmd_set_rasterization_stream_ext(
        &self,
        command_buffer: CommandBuffer,
        rasterization_stream: u32,
    ) {
        let __result = (self.commands().cmd_set_rasterization_stream_ext)(
            command_buffer,
            rasterization_stream,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetRasterizerDiscardEnableEXT.html>
    #[inline]
    unsafe fn cmd_set_rasterizer_discard_enable_ext(
        &self,
        command_buffer: CommandBuffer,
        rasterizer_discard_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_rasterizer_discard_enable_ext)(
            command_buffer,
            rasterizer_discard_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetRepresentativeFragmentTestEnableNV.html>
    #[inline]
    unsafe fn cmd_set_representative_fragment_test_enable_nv(
        &self,
        command_buffer: CommandBuffer,
        representative_fragment_test_enable: bool,
    ) {
        let __result = (self
            .commands()
            .cmd_set_representative_fragment_test_enable_nv)(
            command_buffer,
            representative_fragment_test_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetSampleLocationsEnableEXT.html>
    #[inline]
    unsafe fn cmd_set_sample_locations_enable_ext(
        &self,
        command_buffer: CommandBuffer,
        sample_locations_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_sample_locations_enable_ext)(
            command_buffer,
            sample_locations_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetSampleMaskEXT.html>
    #[inline]
    unsafe fn cmd_set_sample_mask_ext(
        &self,
        command_buffer: CommandBuffer,
        samples: SampleCountFlags,
        sample_mask: &SampleMask,
    ) {
        let __result =
            (self.commands().cmd_set_sample_mask_ext)(command_buffer, samples, sample_mask);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetScissorWithCountEXT.html>
    #[inline]
    unsafe fn cmd_set_scissor_with_count_ext(
        &self,
        command_buffer: CommandBuffer,
        scissors: &[impl Cast<Target = Rect2D>],
    ) {
        let __result = (self.commands().cmd_set_scissor_with_count_ext)(
            command_buffer,
            scissors.len() as u32,
            scissors.as_ptr().cast(),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetShadingRateImageEnableNV.html>
    #[inline]
    unsafe fn cmd_set_shading_rate_image_enable_nv(
        &self,
        command_buffer: CommandBuffer,
        shading_rate_image_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_shading_rate_image_enable_nv)(
            command_buffer,
            shading_rate_image_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilOpEXT.html>
    #[inline]
    unsafe fn cmd_set_stencil_op_ext(
        &self,
        command_buffer: CommandBuffer,
        face_mask: StencilFaceFlags,
        fail_op: StencilOp,
        pass_op: StencilOp,
        depth_fail_op: StencilOp,
        compare_op: CompareOp,
    ) {
        let __result = (self.commands().cmd_set_stencil_op_ext)(
            command_buffer,
            face_mask,
            fail_op,
            pass_op,
            depth_fail_op,
            compare_op,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilTestEnableEXT.html>
    #[inline]
    unsafe fn cmd_set_stencil_test_enable_ext(
        &self,
        command_buffer: CommandBuffer,
        stencil_test_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_stencil_test_enable_ext)(
            command_buffer,
            stencil_test_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetTessellationDomainOriginEXT.html>
    #[inline]
    unsafe fn cmd_set_tessellation_domain_origin_ext(
        &self,
        command_buffer: CommandBuffer,
        domain_origin: TessellationDomainOrigin,
    ) {
        let __result =
            (self.commands().cmd_set_tessellation_domain_origin_ext)(command_buffer, domain_origin);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetVertexInputEXT.html>
    #[inline]
    unsafe fn cmd_set_vertex_input_ext(
        &self,
        command_buffer: CommandBuffer,
        vertex_binding_descriptions: &[impl Cast<Target = VertexInputBindingDescription2EXT>],
        vertex_attribute_descriptions: &[impl Cast<Target = VertexInputAttributeDescription2EXT>],
    ) {
        let __result = (self.commands().cmd_set_vertex_input_ext)(
            command_buffer,
            vertex_binding_descriptions.len() as u32,
            vertex_binding_descriptions.as_ptr().cast(),
            vertex_attribute_descriptions.len() as u32,
            vertex_attribute_descriptions.as_ptr().cast(),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewportSwizzleNV.html>
    #[inline]
    unsafe fn cmd_set_viewport_swizzle_nv(
        &self,
        command_buffer: CommandBuffer,
        first_viewport: u32,
        viewport_swizzles: &[impl Cast<Target = ViewportSwizzleNV>],
    ) {
        let __result = (self.commands().cmd_set_viewport_swizzle_nv)(
            command_buffer,
            first_viewport,
            viewport_swizzles.len() as u32,
            viewport_swizzles.as_ptr().cast(),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewportWScalingEnableNV.html>
    #[inline]
    unsafe fn cmd_set_viewport_w_scaling_enable_nv(
        &self,
        command_buffer: CommandBuffer,
        viewport_w_scaling_enable: bool,
    ) {
        let __result = (self.commands().cmd_set_viewport_w_scaling_enable_nv)(
            command_buffer,
            viewport_w_scaling_enable as Bool32,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewportWithCountEXT.html>
    #[inline]
    unsafe fn cmd_set_viewport_with_count_ext(
        &self,
        command_buffer: CommandBuffer,
        viewports: &[impl Cast<Target = Viewport>],
    ) {
        let __result = (self.commands().cmd_set_viewport_with_count_ext)(
            command_buffer,
            viewports.len() as u32,
            viewports.as_ptr().cast(),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateShadersEXT.html>
    #[inline]
    unsafe fn create_shaders_ext(
        &self,
        create_infos: &[impl Cast<Target = ShaderCreateInfoEXT>],
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkSuccessResult<Vec<ShaderEXT>> {
        let mut shaders = Vec::with_capacity(create_infos.len() as usize);

        let __result = (self.commands().create_shaders_ext)(
            self.handle(),
            create_infos.len() as u32,
            create_infos.as_ptr().cast(),
            allocator.map_or(ptr::null(), |v| v),
            shaders.as_mut_ptr(),
        );

        shaders.set_len(create_infos.len() as usize);

        if __result >= Result::SUCCESS {
            Ok((shaders, __result.into()))
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyShaderEXT.html>
    #[inline]
    unsafe fn destroy_shader_ext(
        &self,
        shader: ShaderEXT,
        allocator: Option<&AllocationCallbacks>,
    ) {
        let __result = (self.commands().destroy_shader_ext)(
            self.handle(),
            shader,
            allocator.map_or(ptr::null(), |v| v),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetShaderBinaryDataEXT.html>
    #[inline]
    unsafe fn get_shader_binary_data_ext(&self, shader: ShaderEXT) -> crate::VkResult<Vec<u8>> {
        let mut data_size = 0;

        (self.commands().get_shader_binary_data_ext)(
            self.handle(),
            shader,
            &mut data_size,
            ptr::null_mut(),
        );

        let mut data = Vec::with_capacity(data_size as usize);

        let __result = (self.commands().get_shader_binary_data_ext)(
            self.handle(),
            shader,
            &mut data_size,
            data.as_mut_ptr() as *mut c_void,
        );

        debug_assert!(data.capacity() == data_size as usize);
        data.set_len(data_size as usize);

        if __result == Result::SUCCESS {
            Ok(data)
        } else {
            Err(__result.into())
        }
    }
}

impl ExtShaderObjectExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_shader_replicated_composites.html>
pub trait ExtShaderReplicatedCompositesExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_SHADER_REPLICATED_COMPOSITES_EXTENSION;
}

impl ExtShaderReplicatedCompositesExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_shader_stencil_export.html>
pub trait ExtShaderStencilExportExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_SHADER_STENCIL_EXPORT_EXTENSION;
}

impl ExtShaderStencilExportExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_shader_subgroup_ballot.html>
#[deprecated(note = "deprecated in favor of `VK_VERSION_1_2`")]
pub trait ExtShaderSubgroupBallotExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_SHADER_SUBGROUP_BALLOT_EXTENSION;
}

#[allow(deprecated)]
impl ExtShaderSubgroupBallotExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_shader_subgroup_vote.html>
#[deprecated(note = "deprecated in favor of `VK_VERSION_1_1`")]
pub trait ExtShaderSubgroupVoteExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_SHADER_SUBGROUP_VOTE_EXTENSION;
}

#[allow(deprecated)]
impl ExtShaderSubgroupVoteExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_shader_tile_image.html>
pub trait ExtShaderTileImageExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_SHADER_TILE_IMAGE_EXTENSION;
}

impl ExtShaderTileImageExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_shader_viewport_index_layer.html>
pub trait ExtShaderViewportIndexLayerExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION;
}

impl ExtShaderViewportIndexLayerExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_subgroup_size_control.html>
pub trait ExtSubgroupSizeControlExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_SUBGROUP_SIZE_CONTROL_EXTENSION;
}

impl ExtSubgroupSizeControlExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_subpass_merge_feedback.html>
pub trait ExtSubpassMergeFeedbackExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_SUBPASS_MERGE_FEEDBACK_EXTENSION;
}

impl ExtSubpassMergeFeedbackExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_surface_maintenance1.html>
pub trait ExtSurfaceMaintenance1Extension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_SURFACE_MAINTENANCE1_EXTENSION;
}

impl ExtSurfaceMaintenance1Extension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_swapchain_colorspace.html>
pub trait ExtSwapchainColorspaceExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_SWAPCHAIN_COLORSPACE_EXTENSION;
}

impl ExtSwapchainColorspaceExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_swapchain_maintenance1.html>
pub trait ExtSwapchainMaintenance1Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_SWAPCHAIN_MAINTENANCE1_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkReleaseSwapchainImagesEXT.html>
    #[inline]
    unsafe fn release_swapchain_images_ext(
        &self,
        release_info: &ReleaseSwapchainImagesInfoEXT,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().release_swapchain_images_ext)(self.handle(), release_info);

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

impl ExtSwapchainMaintenance1Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_texel_buffer_alignment.html>
pub trait ExtTexelBufferAlignmentExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION;
}

impl ExtTexelBufferAlignmentExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_texture_compression_astc_hdr.html>
pub trait ExtTextureCompressionAstcHdrExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION;
}

impl ExtTextureCompressionAstcHdrExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_tooling_info.html>
pub trait ExtToolingInfoExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_TOOLING_INFO_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceToolPropertiesEXT.html>
    #[inline]
    unsafe fn get_physical_device_tool_properties_ext(
        &self,
        physical_device: PhysicalDevice,
    ) -> crate::VkResult<Vec<PhysicalDeviceToolProperties>> {
        let mut tool_count = 0;

        (self.commands().get_physical_device_tool_properties_ext)(
            physical_device,
            &mut tool_count,
            ptr::null_mut(),
        );

        let mut tool_properties = Vec::with_capacity(tool_count as usize);

        let __result = (self.commands().get_physical_device_tool_properties_ext)(
            physical_device,
            &mut tool_count,
            tool_properties.as_mut_ptr(),
        );

        debug_assert!(tool_properties.capacity() == tool_count as usize);
        tool_properties.set_len(tool_count as usize);

        if __result == Result::SUCCESS {
            Ok(tool_properties)
        } else {
            Err(__result.into())
        }
    }
}

impl ExtToolingInfoExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_transform_feedback.html>
pub trait ExtTransformFeedbackExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_TRANSFORM_FEEDBACK_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginQueryIndexedEXT.html>
    #[inline]
    unsafe fn cmd_begin_query_indexed_ext(
        &self,
        command_buffer: CommandBuffer,
        query_pool: QueryPool,
        query: u32,
        flags: QueryControlFlags,
        index: u32,
    ) {
        let __result = (self.commands().cmd_begin_query_indexed_ext)(
            command_buffer,
            query_pool,
            query,
            flags,
            index,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginTransformFeedbackEXT.html>
    #[inline]
    unsafe fn cmd_begin_transform_feedback_ext(
        &self,
        command_buffer: CommandBuffer,
        first_counter_buffer: u32,
        counter_buffers: &[Buffer],
        counter_buffer_offsets: &[DeviceSize],
    ) {
        let __result = (self.commands().cmd_begin_transform_feedback_ext)(
            command_buffer,
            first_counter_buffer,
            counter_buffers.len() as u32,
            counter_buffers.as_ptr(),
            counter_buffer_offsets.as_ptr(),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindTransformFeedbackBuffersEXT.html>
    #[inline]
    unsafe fn cmd_bind_transform_feedback_buffers_ext(
        &self,
        command_buffer: CommandBuffer,
        first_binding: u32,
        buffers: &[Buffer],
        offsets: &[DeviceSize],
        sizes: &[DeviceSize],
    ) {
        let __result = (self.commands().cmd_bind_transform_feedback_buffers_ext)(
            command_buffer,
            first_binding,
            buffers.len() as u32,
            buffers.as_ptr(),
            offsets.as_ptr(),
            sizes.as_ptr(),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndirectByteCountEXT.html>
    #[inline]
    unsafe fn cmd_draw_indirect_byte_count_ext(
        &self,
        command_buffer: CommandBuffer,
        instance_count: u32,
        first_instance: u32,
        counter_buffer: Buffer,
        counter_buffer_offset: DeviceSize,
        counter_offset: u32,
        vertex_stride: u32,
    ) {
        let __result = (self.commands().cmd_draw_indirect_byte_count_ext)(
            command_buffer,
            instance_count,
            first_instance,
            counter_buffer,
            counter_buffer_offset,
            counter_offset,
            vertex_stride,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndQueryIndexedEXT.html>
    #[inline]
    unsafe fn cmd_end_query_indexed_ext(
        &self,
        command_buffer: CommandBuffer,
        query_pool: QueryPool,
        query: u32,
        index: u32,
    ) {
        let __result =
            (self.commands().cmd_end_query_indexed_ext)(command_buffer, query_pool, query, index);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndTransformFeedbackEXT.html>
    #[inline]
    unsafe fn cmd_end_transform_feedback_ext(
        &self,
        command_buffer: CommandBuffer,
        first_counter_buffer: u32,
        counter_buffers: &[Buffer],
        counter_buffer_offsets: &[DeviceSize],
    ) {
        let __result = (self.commands().cmd_end_transform_feedback_ext)(
            command_buffer,
            first_counter_buffer,
            counter_buffers.len() as u32,
            counter_buffers.as_ptr(),
            counter_buffer_offsets.as_ptr(),
        );
    }
}

impl ExtTransformFeedbackExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_validation_cache.html>
pub trait ExtValidationCacheExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_VALIDATION_CACHE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateValidationCacheEXT.html>
    #[inline]
    unsafe fn create_validation_cache_ext(
        &self,
        create_info: &ValidationCacheCreateInfoEXT,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<ValidationCacheEXT> {
        let mut validation_cache = MaybeUninit::<ValidationCacheEXT>::uninit();

        let __result = (self.commands().create_validation_cache_ext)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            validation_cache.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(validation_cache.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyValidationCacheEXT.html>
    #[inline]
    unsafe fn destroy_validation_cache_ext(
        &self,
        validation_cache: ValidationCacheEXT,
        allocator: Option<&AllocationCallbacks>,
    ) {
        let __result = (self.commands().destroy_validation_cache_ext)(
            self.handle(),
            validation_cache,
            allocator.map_or(ptr::null(), |v| v),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetValidationCacheDataEXT.html>
    #[inline]
    unsafe fn get_validation_cache_data_ext(
        &self,
        validation_cache: ValidationCacheEXT,
    ) -> crate::VkResult<Vec<u8>> {
        let mut data_size = 0;

        (self.commands().get_validation_cache_data_ext)(
            self.handle(),
            validation_cache,
            &mut data_size,
            ptr::null_mut(),
        );

        let mut data = Vec::with_capacity(data_size as usize);

        let __result = (self.commands().get_validation_cache_data_ext)(
            self.handle(),
            validation_cache,
            &mut data_size,
            data.as_mut_ptr() as *mut c_void,
        );

        debug_assert!(data.capacity() == data_size as usize);
        data.set_len(data_size as usize);

        if __result == Result::SUCCESS {
            Ok(data)
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkMergeValidationCachesEXT.html>
    #[inline]
    unsafe fn merge_validation_caches_ext(
        &self,
        dst_cache: ValidationCacheEXT,
        src_caches: &[ValidationCacheEXT],
    ) -> crate::VkResult<()> {
        let __result = (self.commands().merge_validation_caches_ext)(
            self.handle(),
            dst_cache,
            src_caches.len() as u32,
            src_caches.as_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

impl ExtValidationCacheExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_validation_features.html>
#[deprecated(note = "deprecated in favor of `VK_EXT_layer_settings`")]
pub trait ExtValidationFeaturesExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_VALIDATION_FEATURES_EXTENSION;
}

#[allow(deprecated)]
impl ExtValidationFeaturesExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_validation_flags.html>
#[deprecated(note = "deprecated in favor of `VK_EXT_layer_settings`")]
pub trait ExtValidationFlagsExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_VALIDATION_FLAGS_EXTENSION;
}

#[allow(deprecated)]
impl ExtValidationFlagsExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_vertex_attribute_divisor.html>
pub trait ExtVertexAttributeDivisorExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION;
}

impl ExtVertexAttributeDivisorExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_vertex_input_dynamic_state.html>
pub trait ExtVertexInputDynamicStateExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_VERTEX_INPUT_DYNAMIC_STATE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetVertexInputEXT.html>
    #[inline]
    unsafe fn cmd_set_vertex_input_ext(
        &self,
        command_buffer: CommandBuffer,
        vertex_binding_descriptions: &[impl Cast<Target = VertexInputBindingDescription2EXT>],
        vertex_attribute_descriptions: &[impl Cast<Target = VertexInputAttributeDescription2EXT>],
    ) {
        let __result = (self.commands().cmd_set_vertex_input_ext)(
            command_buffer,
            vertex_binding_descriptions.len() as u32,
            vertex_binding_descriptions.as_ptr().cast(),
            vertex_attribute_descriptions.len() as u32,
            vertex_attribute_descriptions.as_ptr().cast(),
        );
    }
}

impl ExtVertexInputDynamicStateExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_ycbcr_2plane_444_formats.html>
pub trait ExtYcbcr2plane444FormatsExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_YCBCR_2PLANE_444_FORMATS_EXTENSION;
}

impl ExtYcbcr2plane444FormatsExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_EXT_ycbcr_image_arrays.html>
pub trait ExtYcbcrImageArraysExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = EXT_YCBCR_IMAGE_ARRAYS_EXTENSION;
}

impl ExtYcbcrImageArraysExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_FUCHSIA_buffer_collection.html>
pub trait FuchsiaBufferCollectionExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = FUCHSIA_BUFFER_COLLECTION_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateBufferCollectionFUCHSIA.html>
    #[inline]
    unsafe fn create_buffer_collection_fuchsia(
        &self,
        create_info: &BufferCollectionCreateInfoFUCHSIA,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<BufferCollectionFUCHSIA> {
        let mut collection = MaybeUninit::<BufferCollectionFUCHSIA>::uninit();

        let __result = (self.commands().create_buffer_collection_fuchsia)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            collection.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(collection.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyBufferCollectionFUCHSIA.html>
    #[inline]
    unsafe fn destroy_buffer_collection_fuchsia(
        &self,
        collection: BufferCollectionFUCHSIA,
        allocator: Option<&AllocationCallbacks>,
    ) {
        let __result = (self.commands().destroy_buffer_collection_fuchsia)(
            self.handle(),
            collection,
            allocator.map_or(ptr::null(), |v| v),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetBufferCollectionPropertiesFUCHSIA.html>
    #[inline]
    unsafe fn get_buffer_collection_properties_fuchsia(
        &self,
        collection: BufferCollectionFUCHSIA,
        properties: &mut BufferCollectionPropertiesFUCHSIA,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().get_buffer_collection_properties_fuchsia)(
            self.handle(),
            collection,
            properties,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetBufferCollectionBufferConstraintsFUCHSIA.html>
    #[inline]
    unsafe fn set_buffer_collection_buffer_constraints_fuchsia(
        &self,
        collection: BufferCollectionFUCHSIA,
        buffer_constraints_info: &BufferConstraintsInfoFUCHSIA,
    ) -> crate::VkResult<()> {
        let __result = (self
            .commands()
            .set_buffer_collection_buffer_constraints_fuchsia)(
            self.handle(),
            collection,
            buffer_constraints_info,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetBufferCollectionImageConstraintsFUCHSIA.html>
    #[inline]
    unsafe fn set_buffer_collection_image_constraints_fuchsia(
        &self,
        collection: BufferCollectionFUCHSIA,
        image_constraints_info: &ImageConstraintsInfoFUCHSIA,
    ) -> crate::VkResult<()> {
        let __result = (self
            .commands()
            .set_buffer_collection_image_constraints_fuchsia)(
            self.handle(),
            collection,
            image_constraints_info,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

impl FuchsiaBufferCollectionExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_FUCHSIA_external_memory.html>
pub trait FuchsiaExternalMemoryExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = FUCHSIA_EXTERNAL_MEMORY_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetMemoryZirconHandleFUCHSIA.html>
    #[inline]
    unsafe fn get_memory_zircon_handle_fuchsia(
        &self,
        get_zircon_handle_info: &MemoryGetZirconHandleInfoFUCHSIA,
    ) -> crate::VkResult<zx_handle_t> {
        let mut zircon_handle = MaybeUninit::<zx_handle_t>::uninit();

        let __result = (self.commands().get_memory_zircon_handle_fuchsia)(
            self.handle(),
            get_zircon_handle_info,
            zircon_handle.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(zircon_handle.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetMemoryZirconHandlePropertiesFUCHSIA.html>
    #[inline]
    unsafe fn get_memory_zircon_handle_properties_fuchsia(
        &self,
        handle_type: ExternalMemoryHandleTypeFlags,
        zircon_handle: zx_handle_t,
        memory_zircon_handle_properties: &mut MemoryZirconHandlePropertiesFUCHSIA,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().get_memory_zircon_handle_properties_fuchsia)(
            self.handle(),
            handle_type,
            zircon_handle,
            memory_zircon_handle_properties,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

impl FuchsiaExternalMemoryExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_FUCHSIA_external_semaphore.html>
pub trait FuchsiaExternalSemaphoreExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = FUCHSIA_EXTERNAL_SEMAPHORE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetSemaphoreZirconHandleFUCHSIA.html>
    #[inline]
    unsafe fn get_semaphore_zircon_handle_fuchsia(
        &self,
        get_zircon_handle_info: &SemaphoreGetZirconHandleInfoFUCHSIA,
    ) -> crate::VkResult<zx_handle_t> {
        let mut zircon_handle = MaybeUninit::<zx_handle_t>::uninit();

        let __result = (self.commands().get_semaphore_zircon_handle_fuchsia)(
            self.handle(),
            get_zircon_handle_info,
            zircon_handle.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(zircon_handle.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkImportSemaphoreZirconHandleFUCHSIA.html>
    #[inline]
    unsafe fn import_semaphore_zircon_handle_fuchsia(
        &self,
        import_semaphore_zircon_handle_info: &ImportSemaphoreZirconHandleInfoFUCHSIA,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().import_semaphore_zircon_handle_fuchsia)(
            self.handle(),
            import_semaphore_zircon_handle_info,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

impl FuchsiaExternalSemaphoreExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_FUCHSIA_imagepipe_surface.html>
pub trait FuchsiaImagepipeSurfaceExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = FUCHSIA_IMAGEPIPE_SURFACE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateImagePipeSurfaceFUCHSIA.html>
    #[inline]
    unsafe fn create_image_pipe_surface_fuchsia(
        &self,
        create_info: &ImagePipeSurfaceCreateInfoFUCHSIA,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<SurfaceKHR> {
        let mut surface = MaybeUninit::<SurfaceKHR>::uninit();

        let __result = (self.commands().create_image_pipe_surface_fuchsia)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            surface.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(surface.assume_init())
        } else {
            Err(__result.into())
        }
    }
}

impl FuchsiaImagepipeSurfaceExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_GGP_frame_token.html>
pub trait GgpFrameTokenExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = GGP_FRAME_TOKEN_EXTENSION;
}

impl GgpFrameTokenExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_GGP_stream_descriptor_surface.html>
pub trait GgpStreamDescriptorSurfaceExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = GGP_STREAM_DESCRIPTOR_SURFACE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateStreamDescriptorSurfaceGGP.html>
    #[inline]
    unsafe fn create_stream_descriptor_surface_ggp(
        &self,
        create_info: &StreamDescriptorSurfaceCreateInfoGGP,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<SurfaceKHR> {
        let mut surface = MaybeUninit::<SurfaceKHR>::uninit();

        let __result = (self.commands().create_stream_descriptor_surface_ggp)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            surface.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(surface.assume_init())
        } else {
            Err(__result.into())
        }
    }
}

impl GgpStreamDescriptorSurfaceExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_GOOGLE_decorate_string.html>
pub trait GoogleDecorateStringExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = GOOGLE_DECORATE_STRING_EXTENSION;
}

impl GoogleDecorateStringExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_GOOGLE_display_timing.html>
pub trait GoogleDisplayTimingExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = GOOGLE_DISPLAY_TIMING_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPastPresentationTimingGOOGLE.html>
    #[inline]
    unsafe fn get_past_presentation_timing_google(
        &self,
        swapchain: SwapchainKHR,
    ) -> crate::VkResult<Vec<PastPresentationTimingGOOGLE>> {
        let mut presentation_timing_count = 0;

        (self.commands().get_past_presentation_timing_google)(
            self.handle(),
            swapchain,
            &mut presentation_timing_count,
            ptr::null_mut(),
        );

        let mut presentation_timings = Vec::with_capacity(presentation_timing_count as usize);

        let __result = (self.commands().get_past_presentation_timing_google)(
            self.handle(),
            swapchain,
            &mut presentation_timing_count,
            presentation_timings.as_mut_ptr(),
        );

        debug_assert!(presentation_timings.capacity() == presentation_timing_count as usize);
        presentation_timings.set_len(presentation_timing_count as usize);

        if __result == Result::SUCCESS {
            Ok(presentation_timings)
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetRefreshCycleDurationGOOGLE.html>
    #[inline]
    unsafe fn get_refresh_cycle_duration_google(
        &self,
        swapchain: SwapchainKHR,
    ) -> crate::VkResult<RefreshCycleDurationGOOGLE> {
        let mut display_timing_properties = MaybeUninit::<RefreshCycleDurationGOOGLE>::uninit();

        let __result = (self.commands().get_refresh_cycle_duration_google)(
            self.handle(),
            swapchain,
            display_timing_properties.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(display_timing_properties.assume_init())
        } else {
            Err(__result.into())
        }
    }
}

impl GoogleDisplayTimingExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_GOOGLE_hlsl_functionality1.html>
pub trait GoogleHlslFunctionality1Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = GOOGLE_HLSL_FUNCTIONALITY1_EXTENSION;
}

impl GoogleHlslFunctionality1Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_GOOGLE_surfaceless_query.html>
pub trait GoogleSurfacelessQueryExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = GOOGLE_SURFACELESS_QUERY_EXTENSION;
}

impl GoogleSurfacelessQueryExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_GOOGLE_user_type.html>
pub trait GoogleUserTypeExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = GOOGLE_USER_TYPE_EXTENSION;
}

impl GoogleUserTypeExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_HUAWEI_cluster_culling_shader.html>
pub trait HuaweiClusterCullingShaderExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = HUAWEI_CLUSTER_CULLING_SHADER_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawClusterHUAWEI.html>
    #[inline]
    unsafe fn cmd_draw_cluster_huawei(
        &self,
        command_buffer: CommandBuffer,
        group_count_x: u32,
        group_count_y: u32,
        group_count_z: u32,
    ) {
        let __result = (self.commands().cmd_draw_cluster_huawei)(
            command_buffer,
            group_count_x,
            group_count_y,
            group_count_z,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawClusterIndirectHUAWEI.html>
    #[inline]
    unsafe fn cmd_draw_cluster_indirect_huawei(
        &self,
        command_buffer: CommandBuffer,
        buffer: Buffer,
        offset: DeviceSize,
    ) {
        let __result =
            (self.commands().cmd_draw_cluster_indirect_huawei)(command_buffer, buffer, offset);
    }
}

impl HuaweiClusterCullingShaderExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_HUAWEI_invocation_mask.html>
pub trait HuaweiInvocationMaskExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = HUAWEI_INVOCATION_MASK_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindInvocationMaskHUAWEI.html>
    #[inline]
    unsafe fn cmd_bind_invocation_mask_huawei(
        &self,
        command_buffer: CommandBuffer,
        image_view: ImageView,
        image_layout: ImageLayout,
    ) {
        let __result = (self.commands().cmd_bind_invocation_mask_huawei)(
            command_buffer,
            image_view,
            image_layout,
        );
    }
}

impl HuaweiInvocationMaskExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_HUAWEI_subpass_shading.html>
pub trait HuaweiSubpassShadingExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = HUAWEI_SUBPASS_SHADING_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSubpassShadingHUAWEI.html>
    #[inline]
    unsafe fn cmd_subpass_shading_huawei(&self, command_buffer: CommandBuffer) {
        let __result = (self.commands().cmd_subpass_shading_huawei)(command_buffer);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI.html>
    #[inline]
    unsafe fn get_device_subpass_shading_max_workgroup_size_huawei(
        &self,
        renderpass: RenderPass,
    ) -> crate::VkResult<Extent2D> {
        let mut max_workgroup_size = MaybeUninit::<Extent2D>::uninit();

        let __result = (self
            .commands()
            .get_device_subpass_shading_max_workgroup_size_huawei)(
            self.handle(),
            renderpass,
            max_workgroup_size.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(max_workgroup_size.assume_init())
        } else {
            Err(__result.into())
        }
    }
}

impl HuaweiSubpassShadingExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_IMG_filter_cubic.html>
pub trait ImgFilterCubicExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = IMG_FILTER_CUBIC_EXTENSION;
}

impl ImgFilterCubicExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_IMG_format_pvrtc.html>
#[deprecated]
pub trait ImgFormatPvrtcExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = IMG_FORMAT_PVRTC_EXTENSION;
}

#[allow(deprecated)]
impl ImgFormatPvrtcExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_IMG_relaxed_line_rasterization.html>
pub trait ImgRelaxedLineRasterizationExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = IMG_RELAXED_LINE_RASTERIZATION_EXTENSION;
}

impl ImgRelaxedLineRasterizationExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_INTEL_performance_query.html>
pub trait IntelPerformanceQueryExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = INTEL_PERFORMANCE_QUERY_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAcquirePerformanceConfigurationINTEL.html>
    #[inline]
    unsafe fn acquire_performance_configuration_intel(
        &self,
        acquire_info: &PerformanceConfigurationAcquireInfoINTEL,
    ) -> crate::VkResult<PerformanceConfigurationINTEL> {
        let mut configuration = MaybeUninit::<PerformanceConfigurationINTEL>::uninit();

        let __result = (self.commands().acquire_performance_configuration_intel)(
            self.handle(),
            acquire_info,
            configuration.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(configuration.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPerformanceMarkerINTEL.html>
    #[inline]
    unsafe fn cmd_set_performance_marker_intel(
        &self,
        command_buffer: CommandBuffer,
        marker_info: &PerformanceMarkerInfoINTEL,
    ) -> crate::VkResult<()> {
        let __result =
            (self.commands().cmd_set_performance_marker_intel)(command_buffer, marker_info);

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPerformanceOverrideINTEL.html>
    #[inline]
    unsafe fn cmd_set_performance_override_intel(
        &self,
        command_buffer: CommandBuffer,
        override_info: &PerformanceOverrideInfoINTEL,
    ) -> crate::VkResult<()> {
        let __result =
            (self.commands().cmd_set_performance_override_intel)(command_buffer, override_info);

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPerformanceStreamMarkerINTEL.html>
    #[inline]
    unsafe fn cmd_set_performance_stream_marker_intel(
        &self,
        command_buffer: CommandBuffer,
        marker_info: &PerformanceStreamMarkerInfoINTEL,
    ) -> crate::VkResult<()> {
        let __result =
            (self.commands().cmd_set_performance_stream_marker_intel)(command_buffer, marker_info);

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPerformanceParameterINTEL.html>
    #[inline]
    unsafe fn get_performance_parameter_intel(
        &self,
        parameter: PerformanceParameterTypeINTEL,
    ) -> crate::VkResult<PerformanceValueINTEL> {
        let mut value = MaybeUninit::<PerformanceValueINTEL>::uninit();

        let __result = (self.commands().get_performance_parameter_intel)(
            self.handle(),
            parameter,
            value.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(value.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkInitializePerformanceApiINTEL.html>
    #[inline]
    unsafe fn initialize_performance_api_intel(
        &self,
        initialize_info: &InitializePerformanceApiInfoINTEL,
    ) -> crate::VkResult<()> {
        let __result =
            (self.commands().initialize_performance_api_intel)(self.handle(), initialize_info);

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueSetPerformanceConfigurationINTEL.html>
    #[inline]
    unsafe fn queue_set_performance_configuration_intel(
        &self,
        queue: Queue,
        configuration: PerformanceConfigurationINTEL,
    ) -> crate::VkResult<()> {
        let __result =
            (self.commands().queue_set_performance_configuration_intel)(queue, configuration);

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkReleasePerformanceConfigurationINTEL.html>
    #[inline]
    unsafe fn release_performance_configuration_intel(
        &self,
        configuration: PerformanceConfigurationINTEL,
    ) -> crate::VkResult<()> {
        let __result =
            (self.commands().release_performance_configuration_intel)(self.handle(), configuration);

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkUninitializePerformanceApiINTEL.html>
    #[inline]
    unsafe fn uninitialize_performance_api_intel(&self) {
        let __result = (self.commands().uninitialize_performance_api_intel)(self.handle());
    }
}

impl IntelPerformanceQueryExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_INTEL_shader_integer_functions2.html>
pub trait IntelShaderIntegerFunctions2Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = INTEL_SHADER_INTEGER_FUNCTIONS2_EXTENSION;
}

impl IntelShaderIntegerFunctions2Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_16bit_storage.html>
pub trait Khr16bitStorageExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_16BIT_STORAGE_EXTENSION;
}

impl Khr16bitStorageExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_8bit_storage.html>
pub trait Khr8bitStorageExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_8BIT_STORAGE_EXTENSION;
}

impl Khr8bitStorageExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_acceleration_structure.html>
pub trait KhrAccelerationStructureExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_ACCELERATION_STRUCTURE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBuildAccelerationStructuresKHR.html>
    #[inline]
    unsafe fn build_acceleration_structures_khr(
        &self,
        deferred_operation: DeferredOperationKHR,
        infos: &[impl Cast<Target = AccelerationStructureBuildGeometryInfoKHR>],
        build_range_infos: &[&AccelerationStructureBuildRangeInfoKHR],
    ) -> crate::VkResult<SuccessCode> {
        let __result = (self.commands().build_acceleration_structures_khr)(
            self.handle(),
            deferred_operation,
            infos.len() as u32,
            infos.as_ptr().cast(),
            build_range_infos.as_ptr().cast(),
        );

        if __result >= Result::SUCCESS {
            Ok(__result.into())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBuildAccelerationStructuresIndirectKHR.html>
    #[inline]
    unsafe fn cmd_build_acceleration_structures_indirect_khr(
        &self,
        command_buffer: CommandBuffer,
        infos: &[impl Cast<Target = AccelerationStructureBuildGeometryInfoKHR>],
        indirect_device_addresses: &[DeviceAddress],
        indirect_strides: &[u32],
        max_primitive_counts: &[&u32],
    ) {
        let __result = (self
            .commands()
            .cmd_build_acceleration_structures_indirect_khr)(
            command_buffer,
            infos.len() as u32,
            infos.as_ptr().cast(),
            indirect_device_addresses.as_ptr(),
            indirect_strides.as_ptr(),
            max_primitive_counts.as_ptr().cast(),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBuildAccelerationStructuresKHR.html>
    #[inline]
    unsafe fn cmd_build_acceleration_structures_khr(
        &self,
        command_buffer: CommandBuffer,
        infos: &[impl Cast<Target = AccelerationStructureBuildGeometryInfoKHR>],
        build_range_infos: &[&AccelerationStructureBuildRangeInfoKHR],
    ) {
        let __result = (self.commands().cmd_build_acceleration_structures_khr)(
            command_buffer,
            infos.len() as u32,
            infos.as_ptr().cast(),
            build_range_infos.as_ptr().cast(),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyAccelerationStructureKHR.html>
    #[inline]
    unsafe fn cmd_copy_acceleration_structure_khr(
        &self,
        command_buffer: CommandBuffer,
        info: &CopyAccelerationStructureInfoKHR,
    ) {
        let __result = (self.commands().cmd_copy_acceleration_structure_khr)(command_buffer, info);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyAccelerationStructureToMemoryKHR.html>
    #[inline]
    unsafe fn cmd_copy_acceleration_structure_to_memory_khr(
        &self,
        command_buffer: CommandBuffer,
        info: &CopyAccelerationStructureToMemoryInfoKHR,
    ) {
        let __result =
            (self
                .commands()
                .cmd_copy_acceleration_structure_to_memory_khr)(command_buffer, info);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyMemoryToAccelerationStructureKHR.html>
    #[inline]
    unsafe fn cmd_copy_memory_to_acceleration_structure_khr(
        &self,
        command_buffer: CommandBuffer,
        info: &CopyMemoryToAccelerationStructureInfoKHR,
    ) {
        let __result =
            (self
                .commands()
                .cmd_copy_memory_to_acceleration_structure_khr)(command_buffer, info);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWriteAccelerationStructuresPropertiesKHR.html>
    #[inline]
    unsafe fn cmd_write_acceleration_structures_properties_khr(
        &self,
        command_buffer: CommandBuffer,
        acceleration_structures: &[AccelerationStructureKHR],
        query_type: QueryType,
        query_pool: QueryPool,
        first_query: u32,
    ) {
        let __result = (self
            .commands()
            .cmd_write_acceleration_structures_properties_khr)(
            command_buffer,
            acceleration_structures.len() as u32,
            acceleration_structures.as_ptr(),
            query_type,
            query_pool,
            first_query,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCopyAccelerationStructureKHR.html>
    #[inline]
    unsafe fn copy_acceleration_structure_khr(
        &self,
        deferred_operation: DeferredOperationKHR,
        info: &CopyAccelerationStructureInfoKHR,
    ) -> crate::VkResult<SuccessCode> {
        let __result = (self.commands().copy_acceleration_structure_khr)(
            self.handle(),
            deferred_operation,
            info,
        );

        if __result >= Result::SUCCESS {
            Ok(__result.into())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCopyAccelerationStructureToMemoryKHR.html>
    #[inline]
    unsafe fn copy_acceleration_structure_to_memory_khr(
        &self,
        deferred_operation: DeferredOperationKHR,
        info: &CopyAccelerationStructureToMemoryInfoKHR,
    ) -> crate::VkResult<SuccessCode> {
        let __result = (self.commands().copy_acceleration_structure_to_memory_khr)(
            self.handle(),
            deferred_operation,
            info,
        );

        if __result >= Result::SUCCESS {
            Ok(__result.into())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCopyMemoryToAccelerationStructureKHR.html>
    #[inline]
    unsafe fn copy_memory_to_acceleration_structure_khr(
        &self,
        deferred_operation: DeferredOperationKHR,
        info: &CopyMemoryToAccelerationStructureInfoKHR,
    ) -> crate::VkResult<SuccessCode> {
        let __result = (self.commands().copy_memory_to_acceleration_structure_khr)(
            self.handle(),
            deferred_operation,
            info,
        );

        if __result >= Result::SUCCESS {
            Ok(__result.into())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateAccelerationStructureKHR.html>
    #[inline]
    unsafe fn create_acceleration_structure_khr(
        &self,
        create_info: &AccelerationStructureCreateInfoKHR,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<AccelerationStructureKHR> {
        let mut acceleration_structure = MaybeUninit::<AccelerationStructureKHR>::uninit();

        let __result = (self.commands().create_acceleration_structure_khr)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            acceleration_structure.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(acceleration_structure.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyAccelerationStructureKHR.html>
    #[inline]
    unsafe fn destroy_acceleration_structure_khr(
        &self,
        acceleration_structure: AccelerationStructureKHR,
        allocator: Option<&AllocationCallbacks>,
    ) {
        let __result = (self.commands().destroy_acceleration_structure_khr)(
            self.handle(),
            acceleration_structure,
            allocator.map_or(ptr::null(), |v| v),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetAccelerationStructureBuildSizesKHR.html>
    #[inline]
    unsafe fn get_acceleration_structure_build_sizes_khr(
        &self,
        build_type: AccelerationStructureBuildTypeKHR,
        build_info: &AccelerationStructureBuildGeometryInfoKHR,
        max_primitive_counts: &[u32],
        size_info: &mut AccelerationStructureBuildSizesInfoKHR,
    ) {
        let __result = (self.commands().get_acceleration_structure_build_sizes_khr)(
            self.handle(),
            build_type,
            build_info,
            max_primitive_counts.as_ptr(),
            size_info,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetAccelerationStructureDeviceAddressKHR.html>
    #[inline]
    unsafe fn get_acceleration_structure_device_address_khr(
        &self,
        info: &AccelerationStructureDeviceAddressInfoKHR,
    ) -> DeviceAddress {
        let __result =
            (self
                .commands()
                .get_acceleration_structure_device_address_khr)(self.handle(), info);

        __result
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceAccelerationStructureCompatibilityKHR.html>
    #[inline]
    unsafe fn get_device_acceleration_structure_compatibility_khr(
        &self,
        version_info: &AccelerationStructureVersionInfoKHR,
    ) -> AccelerationStructureCompatibilityKHR {
        let mut compatibility = MaybeUninit::<AccelerationStructureCompatibilityKHR>::uninit();

        let __result = (self
            .commands()
            .get_device_acceleration_structure_compatibility_khr)(
            self.handle(),
            version_info,
            compatibility.as_mut_ptr(),
        );

        compatibility.assume_init()
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkWriteAccelerationStructuresPropertiesKHR.html>
    #[inline]
    unsafe fn write_acceleration_structures_properties_khr(
        &self,
        acceleration_structures: &[AccelerationStructureKHR],
        query_type: QueryType,
        data: &mut [u8],
        stride: usize,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().write_acceleration_structures_properties_khr)(
            self.handle(),
            acceleration_structures.len() as u32,
            acceleration_structures.as_ptr(),
            query_type,
            data.len() as usize,
            data.as_ptr() as *mut c_void,
            stride,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

impl KhrAccelerationStructureExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_android_surface.html>
pub trait KhrAndroidSurfaceExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_ANDROID_SURFACE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateAndroidSurfaceKHR.html>
    #[inline]
    unsafe fn create_android_surface_khr(
        &self,
        create_info: &AndroidSurfaceCreateInfoKHR,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<SurfaceKHR> {
        let mut surface = MaybeUninit::<SurfaceKHR>::uninit();

        let __result = (self.commands().create_android_surface_khr)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            surface.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(surface.assume_init())
        } else {
            Err(__result.into())
        }
    }
}

impl KhrAndroidSurfaceExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_bind_memory2.html>
pub trait KhrBindMemory2Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_BIND_MEMORY2_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindBufferMemory2KHR.html>
    #[inline]
    unsafe fn bind_buffer_memory2_khr(
        &self,
        bind_infos: &[impl Cast<Target = BindBufferMemoryInfo>],
    ) -> crate::VkResult<()> {
        let __result = (self.commands().bind_buffer_memory2_khr)(
            self.handle(),
            bind_infos.len() as u32,
            bind_infos.as_ptr().cast(),
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindImageMemory2KHR.html>
    #[inline]
    unsafe fn bind_image_memory2_khr(
        &self,
        bind_infos: &[impl Cast<Target = BindImageMemoryInfo>],
    ) -> crate::VkResult<()> {
        let __result = (self.commands().bind_image_memory2_khr)(
            self.handle(),
            bind_infos.len() as u32,
            bind_infos.as_ptr().cast(),
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

impl KhrBindMemory2Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_buffer_device_address.html>
pub trait KhrBufferDeviceAddressExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_BUFFER_DEVICE_ADDRESS_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetBufferDeviceAddressKHR.html>
    #[inline]
    unsafe fn get_buffer_device_address_khr(
        &self,
        info: &BufferDeviceAddressInfo,
    ) -> DeviceAddress {
        let __result = (self.commands().get_buffer_device_address_khr)(self.handle(), info);

        __result
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetBufferOpaqueCaptureAddressKHR.html>
    #[inline]
    unsafe fn get_buffer_opaque_capture_address_khr(&self, info: &BufferDeviceAddressInfo) -> u64 {
        let __result = (self.commands().get_buffer_opaque_capture_address_khr)(self.handle(), info);

        __result
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceMemoryOpaqueCaptureAddressKHR.html>
    #[inline]
    unsafe fn get_device_memory_opaque_capture_address_khr(
        &self,
        info: &DeviceMemoryOpaqueCaptureAddressInfo,
    ) -> u64 {
        let __result =
            (self.commands().get_device_memory_opaque_capture_address_khr)(self.handle(), info);

        __result
    }
}

impl KhrBufferDeviceAddressExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_calibrated_timestamps.html>
pub trait KhrCalibratedTimestampsExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_CALIBRATED_TIMESTAMPS_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetCalibratedTimestampsKHR.html>
    #[inline]
    unsafe fn get_calibrated_timestamps_khr(
        &self,
        timestamp_infos: &[impl Cast<Target = CalibratedTimestampInfoKHR>],
    ) -> crate::VkResult<(Vec<u64>, u64)> {
        let mut timestamps = Vec::with_capacity(timestamp_infos.len() as usize);
        let mut max_deviation = MaybeUninit::<u64>::uninit();

        let __result = (self.commands().get_calibrated_timestamps_khr)(
            self.handle(),
            timestamp_infos.len() as u32,
            timestamp_infos.as_ptr().cast(),
            timestamps.as_mut_ptr(),
            max_deviation.as_mut_ptr(),
        );

        debug_assert!(timestamps.capacity() == timestamp_infos.len() as usize);
        timestamps.set_len(timestamp_infos.len() as usize);

        if __result == Result::SUCCESS {
            Ok((timestamps, max_deviation.assume_init()))
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceCalibrateableTimeDomainsKHR.html>
    #[inline]
    unsafe fn get_physical_device_calibrateable_time_domains_khr(
        &self,
        physical_device: PhysicalDevice,
    ) -> crate::VkResult<Vec<TimeDomainKHR>> {
        let mut time_domain_count = 0;

        (self
            .commands()
            .get_physical_device_calibrateable_time_domains_khr)(
            physical_device,
            &mut time_domain_count,
            ptr::null_mut(),
        );

        let mut time_domains = Vec::with_capacity(time_domain_count as usize);

        let __result = (self
            .commands()
            .get_physical_device_calibrateable_time_domains_khr)(
            physical_device,
            &mut time_domain_count,
            time_domains.as_mut_ptr(),
        );

        debug_assert!(time_domains.capacity() == time_domain_count as usize);
        time_domains.set_len(time_domain_count as usize);

        if __result == Result::SUCCESS {
            Ok(time_domains)
        } else {
            Err(__result.into())
        }
    }
}

impl KhrCalibratedTimestampsExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_compute_shader_derivatives.html>
pub trait KhrComputeShaderDerivativesExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_COMPUTE_SHADER_DERIVATIVES_EXTENSION;
}

impl KhrComputeShaderDerivativesExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_cooperative_matrix.html>
pub trait KhrCooperativeMatrixExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_COOPERATIVE_MATRIX_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR.html>
    #[inline]
    unsafe fn get_physical_device_cooperative_matrix_properties_khr(
        &self,
        physical_device: PhysicalDevice,
    ) -> crate::VkResult<Vec<CooperativeMatrixPropertiesKHR>> {
        let mut property_count = 0;

        (self
            .commands()
            .get_physical_device_cooperative_matrix_properties_khr)(
            physical_device,
            &mut property_count,
            ptr::null_mut(),
        );

        let mut properties = Vec::with_capacity(property_count as usize);

        let __result = (self
            .commands()
            .get_physical_device_cooperative_matrix_properties_khr)(
            physical_device,
            &mut property_count,
            properties.as_mut_ptr(),
        );

        debug_assert!(properties.capacity() == property_count as usize);
        properties.set_len(property_count as usize);

        if __result == Result::SUCCESS {
            Ok(properties)
        } else {
            Err(__result.into())
        }
    }
}

impl KhrCooperativeMatrixExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_copy_commands2.html>
pub trait KhrCopyCommands2Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_COPY_COMMANDS2_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBlitImage2KHR.html>
    #[inline]
    unsafe fn cmd_blit_image2_khr(
        &self,
        command_buffer: CommandBuffer,
        blit_image_info: &BlitImageInfo2,
    ) {
        let __result = (self.commands().cmd_blit_image2_khr)(command_buffer, blit_image_info);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBuffer2KHR.html>
    #[inline]
    unsafe fn cmd_copy_buffer2_khr(
        &self,
        command_buffer: CommandBuffer,
        copy_buffer_info: &CopyBufferInfo2,
    ) {
        let __result = (self.commands().cmd_copy_buffer2_khr)(command_buffer, copy_buffer_info);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBufferToImage2KHR.html>
    #[inline]
    unsafe fn cmd_copy_buffer_to_image2_khr(
        &self,
        command_buffer: CommandBuffer,
        copy_buffer_to_image_info: &CopyBufferToImageInfo2,
    ) {
        let __result = (self.commands().cmd_copy_buffer_to_image2_khr)(
            command_buffer,
            copy_buffer_to_image_info,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyImage2KHR.html>
    #[inline]
    unsafe fn cmd_copy_image2_khr(
        &self,
        command_buffer: CommandBuffer,
        copy_image_info: &CopyImageInfo2,
    ) {
        let __result = (self.commands().cmd_copy_image2_khr)(command_buffer, copy_image_info);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyImageToBuffer2KHR.html>
    #[inline]
    unsafe fn cmd_copy_image_to_buffer2_khr(
        &self,
        command_buffer: CommandBuffer,
        copy_image_to_buffer_info: &CopyImageToBufferInfo2,
    ) {
        let __result = (self.commands().cmd_copy_image_to_buffer2_khr)(
            command_buffer,
            copy_image_to_buffer_info,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResolveImage2KHR.html>
    #[inline]
    unsafe fn cmd_resolve_image2_khr(
        &self,
        command_buffer: CommandBuffer,
        resolve_image_info: &ResolveImageInfo2,
    ) {
        let __result = (self.commands().cmd_resolve_image2_khr)(command_buffer, resolve_image_info);
    }
}

impl KhrCopyCommands2Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_create_renderpass2.html>
pub trait KhrCreateRenderpass2Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_CREATE_RENDERPASS2_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRenderPass2KHR.html>
    #[inline]
    unsafe fn cmd_begin_render_pass2_khr(
        &self,
        command_buffer: CommandBuffer,
        render_pass_begin: &RenderPassBeginInfo,
        subpass_begin_info: &SubpassBeginInfo,
    ) {
        let __result = (self.commands().cmd_begin_render_pass2_khr)(
            command_buffer,
            render_pass_begin,
            subpass_begin_info,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndRenderPass2KHR.html>
    #[inline]
    unsafe fn cmd_end_render_pass2_khr(
        &self,
        command_buffer: CommandBuffer,
        subpass_end_info: &SubpassEndInfo,
    ) {
        let __result = (self.commands().cmd_end_render_pass2_khr)(command_buffer, subpass_end_info);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdNextSubpass2KHR.html>
    #[inline]
    unsafe fn cmd_next_subpass2_khr(
        &self,
        command_buffer: CommandBuffer,
        subpass_begin_info: &SubpassBeginInfo,
        subpass_end_info: &SubpassEndInfo,
    ) {
        let __result = (self.commands().cmd_next_subpass2_khr)(
            command_buffer,
            subpass_begin_info,
            subpass_end_info,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateRenderPass2KHR.html>
    #[inline]
    unsafe fn create_render_pass2_khr(
        &self,
        create_info: &RenderPassCreateInfo2,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<RenderPass> {
        let mut render_pass = MaybeUninit::<RenderPass>::uninit();

        let __result = (self.commands().create_render_pass2_khr)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            render_pass.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(render_pass.assume_init())
        } else {
            Err(__result.into())
        }
    }
}

impl KhrCreateRenderpass2Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_dedicated_allocation.html>
pub trait KhrDedicatedAllocationExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_DEDICATED_ALLOCATION_EXTENSION;
}

impl KhrDedicatedAllocationExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_deferred_host_operations.html>
pub trait KhrDeferredHostOperationsExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_DEFERRED_HOST_OPERATIONS_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDeferredOperationKHR.html>
    #[inline]
    unsafe fn create_deferred_operation_khr(
        &self,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<DeferredOperationKHR> {
        let mut deferred_operation = MaybeUninit::<DeferredOperationKHR>::uninit();

        let __result = (self.commands().create_deferred_operation_khr)(
            self.handle(),
            allocator.map_or(ptr::null(), |v| v),
            deferred_operation.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(deferred_operation.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDeferredOperationJoinKHR.html>
    #[inline]
    unsafe fn deferred_operation_join_khr(
        &self,
        operation: DeferredOperationKHR,
    ) -> crate::VkResult<SuccessCode> {
        let __result = (self.commands().deferred_operation_join_khr)(self.handle(), operation);

        if __result >= Result::SUCCESS {
            Ok(__result.into())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDeferredOperationKHR.html>
    #[inline]
    unsafe fn destroy_deferred_operation_khr(
        &self,
        operation: DeferredOperationKHR,
        allocator: Option<&AllocationCallbacks>,
    ) {
        let __result = (self.commands().destroy_deferred_operation_khr)(
            self.handle(),
            operation,
            allocator.map_or(ptr::null(), |v| v),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeferredOperationMaxConcurrencyKHR.html>
    #[inline]
    unsafe fn get_deferred_operation_max_concurrency_khr(
        &self,
        operation: DeferredOperationKHR,
    ) -> u32 {
        let __result =
            (self.commands().get_deferred_operation_max_concurrency_khr)(self.handle(), operation);

        __result
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeferredOperationResultKHR.html>
    #[inline]
    unsafe fn get_deferred_operation_result_khr(
        &self,
        operation: DeferredOperationKHR,
    ) -> crate::VkResult<SuccessCode> {
        let __result =
            (self.commands().get_deferred_operation_result_khr)(self.handle(), operation);

        if __result >= Result::SUCCESS {
            Ok(__result.into())
        } else {
            Err(__result.into())
        }
    }
}

impl KhrDeferredHostOperationsExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_depth_stencil_resolve.html>
pub trait KhrDepthStencilResolveExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_DEPTH_STENCIL_RESOLVE_EXTENSION;
}

impl KhrDepthStencilResolveExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_descriptor_update_template.html>
pub trait KhrDescriptorUpdateTemplateExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPushDescriptorSetWithTemplateKHR.html>
    #[inline]
    unsafe fn cmd_push_descriptor_set_with_template_khr(
        &self,
        command_buffer: CommandBuffer,
        descriptor_update_template: DescriptorUpdateTemplate,
        layout: PipelineLayout,
        set: u32,
        data: &c_void,
    ) {
        let __result = (self.commands().cmd_push_descriptor_set_with_template_khr)(
            command_buffer,
            descriptor_update_template,
            layout,
            set,
            data,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDescriptorUpdateTemplateKHR.html>
    #[inline]
    unsafe fn create_descriptor_update_template_khr(
        &self,
        create_info: &DescriptorUpdateTemplateCreateInfo,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<DescriptorUpdateTemplate> {
        let mut descriptor_update_template = MaybeUninit::<DescriptorUpdateTemplate>::uninit();

        let __result = (self.commands().create_descriptor_update_template_khr)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            descriptor_update_template.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(descriptor_update_template.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDescriptorUpdateTemplateKHR.html>
    #[inline]
    unsafe fn destroy_descriptor_update_template_khr(
        &self,
        descriptor_update_template: DescriptorUpdateTemplate,
        allocator: Option<&AllocationCallbacks>,
    ) {
        let __result = (self.commands().destroy_descriptor_update_template_khr)(
            self.handle(),
            descriptor_update_template,
            allocator.map_or(ptr::null(), |v| v),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkUpdateDescriptorSetWithTemplateKHR.html>
    #[inline]
    unsafe fn update_descriptor_set_with_template_khr(
        &self,
        descriptor_set: DescriptorSet,
        descriptor_update_template: DescriptorUpdateTemplate,
        data: &c_void,
    ) {
        let __result = (self.commands().update_descriptor_set_with_template_khr)(
            self.handle(),
            descriptor_set,
            descriptor_update_template,
            data,
        );
    }
}

impl KhrDescriptorUpdateTemplateExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_device_group.html>
pub trait KhrDeviceGroupExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_DEVICE_GROUP_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAcquireNextImage2KHR.html>
    #[inline]
    unsafe fn acquire_next_image2_khr(
        &self,
        acquire_info: &AcquireNextImageInfoKHR,
    ) -> crate::VkSuccessResult<u32> {
        let mut image_index = MaybeUninit::<u32>::uninit();

        let __result = (self.commands().acquire_next_image2_khr)(
            self.handle(),
            acquire_info,
            image_index.as_mut_ptr(),
        );

        if __result >= Result::SUCCESS {
            Ok((image_index.assume_init(), __result.into()))
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDispatchBaseKHR.html>
    #[inline]
    unsafe fn cmd_dispatch_base_khr(
        &self,
        command_buffer: CommandBuffer,
        base_group_x: u32,
        base_group_y: u32,
        base_group_z: u32,
        group_count_x: u32,
        group_count_y: u32,
        group_count_z: u32,
    ) {
        let __result = (self.commands().cmd_dispatch_base_khr)(
            command_buffer,
            base_group_x,
            base_group_y,
            base_group_z,
            group_count_x,
            group_count_y,
            group_count_z,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDeviceMaskKHR.html>
    #[inline]
    unsafe fn cmd_set_device_mask_khr(&self, command_buffer: CommandBuffer, device_mask: u32) {
        let __result = (self.commands().cmd_set_device_mask_khr)(command_buffer, device_mask);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceGroupPeerMemoryFeaturesKHR.html>
    #[inline]
    unsafe fn get_device_group_peer_memory_features_khr(
        &self,
        heap_index: u32,
        local_device_index: u32,
        remote_device_index: u32,
    ) -> PeerMemoryFeatureFlags {
        let mut peer_memory_features = MaybeUninit::<PeerMemoryFeatureFlags>::uninit();

        let __result = (self.commands().get_device_group_peer_memory_features_khr)(
            self.handle(),
            heap_index,
            local_device_index,
            remote_device_index,
            peer_memory_features.as_mut_ptr(),
        );

        peer_memory_features.assume_init()
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceGroupPresentCapabilitiesKHR.html>
    #[inline]
    unsafe fn get_device_group_present_capabilities_khr(
        &self,
        device_group_present_capabilities: &mut DeviceGroupPresentCapabilitiesKHR,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().get_device_group_present_capabilities_khr)(
            self.handle(),
            device_group_present_capabilities,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceGroupSurfacePresentModesKHR.html>
    #[inline]
    unsafe fn get_device_group_surface_present_modes_khr(
        &self,
        surface: SurfaceKHR,
    ) -> crate::VkResult<DeviceGroupPresentModeFlagsKHR> {
        let mut modes = MaybeUninit::<DeviceGroupPresentModeFlagsKHR>::uninit();

        let __result = (self.commands().get_device_group_surface_present_modes_khr)(
            self.handle(),
            surface,
            modes.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(modes.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDevicePresentRectanglesKHR.html>
    #[inline]
    unsafe fn get_physical_device_present_rectangles_khr(
        &self,
        physical_device: PhysicalDevice,
        surface: SurfaceKHR,
    ) -> crate::VkResult<Vec<Rect2D>> {
        let mut rect_count = 0;

        (self.commands().get_physical_device_present_rectangles_khr)(
            physical_device,
            surface,
            &mut rect_count,
            ptr::null_mut(),
        );

        let mut rects = Vec::with_capacity(rect_count as usize);

        let __result = (self.commands().get_physical_device_present_rectangles_khr)(
            physical_device,
            surface,
            &mut rect_count,
            rects.as_mut_ptr(),
        );

        debug_assert!(rects.capacity() == rect_count as usize);
        rects.set_len(rect_count as usize);

        if __result == Result::SUCCESS {
            Ok(rects)
        } else {
            Err(__result.into())
        }
    }
}

impl KhrDeviceGroupExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_device_group_creation.html>
pub trait KhrDeviceGroupCreationExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_DEVICE_GROUP_CREATION_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumeratePhysicalDeviceGroupsKHR.html>
    #[inline]
    unsafe fn enumerate_physical_device_groups_khr(
        &self,
    ) -> crate::VkResult<Vec<PhysicalDeviceGroupProperties>> {
        let mut physical_device_group_count = 0;

        (self.commands().enumerate_physical_device_groups_khr)(
            self.handle(),
            &mut physical_device_group_count,
            ptr::null_mut(),
        );

        let mut physical_device_group_properties =
            Vec::with_capacity(physical_device_group_count as usize);

        let __result = (self.commands().enumerate_physical_device_groups_khr)(
            self.handle(),
            &mut physical_device_group_count,
            physical_device_group_properties.as_mut_ptr(),
        );

        debug_assert!(
            physical_device_group_properties.capacity() == physical_device_group_count as usize
        );
        physical_device_group_properties.set_len(physical_device_group_count as usize);

        if __result == Result::SUCCESS {
            Ok(physical_device_group_properties)
        } else {
            Err(__result.into())
        }
    }
}

impl KhrDeviceGroupCreationExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_display.html>
pub trait KhrDisplayExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_DISPLAY_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDisplayModeKHR.html>
    #[inline]
    unsafe fn create_display_mode_khr(
        &self,
        physical_device: PhysicalDevice,
        display: DisplayKHR,
        create_info: &DisplayModeCreateInfoKHR,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<DisplayModeKHR> {
        let mut mode = MaybeUninit::<DisplayModeKHR>::uninit();

        let __result = (self.commands().create_display_mode_khr)(
            physical_device,
            display,
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            mode.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(mode.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDisplayPlaneSurfaceKHR.html>
    #[inline]
    unsafe fn create_display_plane_surface_khr(
        &self,
        create_info: &DisplaySurfaceCreateInfoKHR,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<SurfaceKHR> {
        let mut surface = MaybeUninit::<SurfaceKHR>::uninit();

        let __result = (self.commands().create_display_plane_surface_khr)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            surface.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(surface.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDisplayModePropertiesKHR.html>
    #[inline]
    unsafe fn get_display_mode_properties_khr(
        &self,
        physical_device: PhysicalDevice,
        display: DisplayKHR,
    ) -> crate::VkResult<Vec<DisplayModePropertiesKHR>> {
        let mut property_count = 0;

        (self.commands().get_display_mode_properties_khr)(
            physical_device,
            display,
            &mut property_count,
            ptr::null_mut(),
        );

        let mut properties = Vec::with_capacity(property_count as usize);

        let __result = (self.commands().get_display_mode_properties_khr)(
            physical_device,
            display,
            &mut property_count,
            properties.as_mut_ptr(),
        );

        debug_assert!(properties.capacity() == property_count as usize);
        properties.set_len(property_count as usize);

        if __result == Result::SUCCESS {
            Ok(properties)
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDisplayPlaneCapabilitiesKHR.html>
    #[inline]
    unsafe fn get_display_plane_capabilities_khr(
        &self,
        physical_device: PhysicalDevice,
        mode: DisplayModeKHR,
        plane_index: u32,
    ) -> crate::VkResult<DisplayPlaneCapabilitiesKHR> {
        let mut capabilities = MaybeUninit::<DisplayPlaneCapabilitiesKHR>::uninit();

        let __result = (self.commands().get_display_plane_capabilities_khr)(
            physical_device,
            mode,
            plane_index,
            capabilities.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(capabilities.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDisplayPlaneSupportedDisplaysKHR.html>
    #[inline]
    unsafe fn get_display_plane_supported_displays_khr(
        &self,
        physical_device: PhysicalDevice,
        plane_index: u32,
    ) -> crate::VkResult<Vec<DisplayKHR>> {
        let mut display_count = 0;

        (self.commands().get_display_plane_supported_displays_khr)(
            physical_device,
            plane_index,
            &mut display_count,
            ptr::null_mut(),
        );

        let mut displays = Vec::with_capacity(display_count as usize);

        let __result = (self.commands().get_display_plane_supported_displays_khr)(
            physical_device,
            plane_index,
            &mut display_count,
            displays.as_mut_ptr(),
        );

        debug_assert!(displays.capacity() == display_count as usize);
        displays.set_len(display_count as usize);

        if __result == Result::SUCCESS {
            Ok(displays)
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceDisplayPlanePropertiesKHR.html>
    #[inline]
    unsafe fn get_physical_device_display_plane_properties_khr(
        &self,
        physical_device: PhysicalDevice,
    ) -> crate::VkResult<Vec<DisplayPlanePropertiesKHR>> {
        let mut property_count = 0;

        (self
            .commands()
            .get_physical_device_display_plane_properties_khr)(
            physical_device,
            &mut property_count,
            ptr::null_mut(),
        );

        let mut properties = Vec::with_capacity(property_count as usize);

        let __result = (self
            .commands()
            .get_physical_device_display_plane_properties_khr)(
            physical_device,
            &mut property_count,
            properties.as_mut_ptr(),
        );

        debug_assert!(properties.capacity() == property_count as usize);
        properties.set_len(property_count as usize);

        if __result == Result::SUCCESS {
            Ok(properties)
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceDisplayPropertiesKHR.html>
    #[inline]
    unsafe fn get_physical_device_display_properties_khr(
        &self,
        physical_device: PhysicalDevice,
    ) -> crate::VkResult<Vec<DisplayPropertiesKHR>> {
        let mut property_count = 0;

        (self.commands().get_physical_device_display_properties_khr)(
            physical_device,
            &mut property_count,
            ptr::null_mut(),
        );

        let mut properties = Vec::with_capacity(property_count as usize);

        let __result = (self.commands().get_physical_device_display_properties_khr)(
            physical_device,
            &mut property_count,
            properties.as_mut_ptr(),
        );

        debug_assert!(properties.capacity() == property_count as usize);
        properties.set_len(property_count as usize);

        if __result == Result::SUCCESS {
            Ok(properties)
        } else {
            Err(__result.into())
        }
    }
}

impl KhrDisplayExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_display_swapchain.html>
pub trait KhrDisplaySwapchainExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_DISPLAY_SWAPCHAIN_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateSharedSwapchainsKHR.html>
    #[inline]
    unsafe fn create_shared_swapchains_khr(
        &self,
        create_infos: &[impl Cast<Target = SwapchainCreateInfoKHR>],
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<Vec<SwapchainKHR>> {
        let mut swapchains = Vec::with_capacity(create_infos.len() as usize);

        let __result = (self.commands().create_shared_swapchains_khr)(
            self.handle(),
            create_infos.len() as u32,
            create_infos.as_ptr().cast(),
            allocator.map_or(ptr::null(), |v| v),
            swapchains.as_mut_ptr(),
        );

        swapchains.set_len(create_infos.len() as usize);

        if __result == Result::SUCCESS {
            Ok(swapchains)
        } else {
            Err(__result.into())
        }
    }
}

impl KhrDisplaySwapchainExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_draw_indirect_count.html>
pub trait KhrDrawIndirectCountExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_DRAW_INDIRECT_COUNT_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndexedIndirectCountKHR.html>
    #[inline]
    unsafe fn cmd_draw_indexed_indirect_count_khr(
        &self,
        command_buffer: CommandBuffer,
        buffer: Buffer,
        offset: DeviceSize,
        count_buffer: Buffer,
        count_buffer_offset: DeviceSize,
        max_draw_count: u32,
        stride: u32,
    ) {
        let __result = (self.commands().cmd_draw_indexed_indirect_count_khr)(
            command_buffer,
            buffer,
            offset,
            count_buffer,
            count_buffer_offset,
            max_draw_count,
            stride,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndirectCountKHR.html>
    #[inline]
    unsafe fn cmd_draw_indirect_count_khr(
        &self,
        command_buffer: CommandBuffer,
        buffer: Buffer,
        offset: DeviceSize,
        count_buffer: Buffer,
        count_buffer_offset: DeviceSize,
        max_draw_count: u32,
        stride: u32,
    ) {
        let __result = (self.commands().cmd_draw_indirect_count_khr)(
            command_buffer,
            buffer,
            offset,
            count_buffer,
            count_buffer_offset,
            max_draw_count,
            stride,
        );
    }
}

impl KhrDrawIndirectCountExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_driver_properties.html>
pub trait KhrDriverPropertiesExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_DRIVER_PROPERTIES_EXTENSION;
}

impl KhrDriverPropertiesExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_dynamic_rendering.html>
pub trait KhrDynamicRenderingExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_DYNAMIC_RENDERING_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRenderingKHR.html>
    #[inline]
    unsafe fn cmd_begin_rendering_khr(
        &self,
        command_buffer: CommandBuffer,
        rendering_info: &RenderingInfo,
    ) {
        let __result = (self.commands().cmd_begin_rendering_khr)(command_buffer, rendering_info);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndRenderingKHR.html>
    #[inline]
    unsafe fn cmd_end_rendering_khr(&self, command_buffer: CommandBuffer) {
        let __result = (self.commands().cmd_end_rendering_khr)(command_buffer);
    }
}

impl KhrDynamicRenderingExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_dynamic_rendering_local_read.html>
pub trait KhrDynamicRenderingLocalReadExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_DYNAMIC_RENDERING_LOCAL_READ_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetRenderingAttachmentLocationsKHR.html>
    #[inline]
    unsafe fn cmd_set_rendering_attachment_locations_khr(
        &self,
        command_buffer: CommandBuffer,
        location_info: &RenderingAttachmentLocationInfoKHR,
    ) {
        let __result = (self.commands().cmd_set_rendering_attachment_locations_khr)(
            command_buffer,
            location_info,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetRenderingInputAttachmentIndicesKHR.html>
    #[inline]
    unsafe fn cmd_set_rendering_input_attachment_indices_khr(
        &self,
        command_buffer: CommandBuffer,
        input_attachment_index_info: &RenderingInputAttachmentIndexInfoKHR,
    ) {
        let __result = (self
            .commands()
            .cmd_set_rendering_input_attachment_indices_khr)(
            command_buffer,
            input_attachment_index_info,
        );
    }
}

impl KhrDynamicRenderingLocalReadExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_fence.html>
pub trait KhrExternalFenceExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_EXTERNAL_FENCE_EXTENSION;
}

impl KhrExternalFenceExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_fence_capabilities.html>
pub trait KhrExternalFenceCapabilitiesExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceExternalFencePropertiesKHR.html>
    #[inline]
    unsafe fn get_physical_device_external_fence_properties_khr(
        &self,
        physical_device: PhysicalDevice,
        external_fence_info: &PhysicalDeviceExternalFenceInfo,
        external_fence_properties: &mut ExternalFenceProperties,
    ) {
        let __result = (self
            .commands()
            .get_physical_device_external_fence_properties_khr)(
            physical_device,
            external_fence_info,
            external_fence_properties,
        );
    }
}

impl KhrExternalFenceCapabilitiesExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_fence_fd.html>
pub trait KhrExternalFenceFdExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_EXTERNAL_FENCE_FD_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetFenceFdKHR.html>
    #[inline]
    unsafe fn get_fence_fd_khr(&self, get_fd_info: &FenceGetFdInfoKHR) -> crate::VkResult<c_int> {
        let mut fd = MaybeUninit::<c_int>::uninit();

        let __result =
            (self.commands().get_fence_fd_khr)(self.handle(), get_fd_info, fd.as_mut_ptr());

        if __result == Result::SUCCESS {
            Ok(fd.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkImportFenceFdKHR.html>
    #[inline]
    unsafe fn import_fence_fd_khr(
        &self,
        import_fence_fd_info: &ImportFenceFdInfoKHR,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().import_fence_fd_khr)(self.handle(), import_fence_fd_info);

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

impl KhrExternalFenceFdExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_fence_win32.html>
pub trait KhrExternalFenceWin32Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_EXTERNAL_FENCE_WIN32_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetFenceWin32HandleKHR.html>
    #[inline]
    unsafe fn get_fence_win32_handle_khr(
        &self,
        get_win32_handle_info: &FenceGetWin32HandleInfoKHR,
    ) -> crate::VkResult<HANDLE> {
        let mut handle = MaybeUninit::<HANDLE>::uninit();

        let __result = (self.commands().get_fence_win32_handle_khr)(
            self.handle(),
            get_win32_handle_info,
            handle.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(handle.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkImportFenceWin32HandleKHR.html>
    #[inline]
    unsafe fn import_fence_win32_handle_khr(
        &self,
        import_fence_win32_handle_info: &ImportFenceWin32HandleInfoKHR,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().import_fence_win32_handle_khr)(
            self.handle(),
            import_fence_win32_handle_info,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

impl KhrExternalFenceWin32Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_memory.html>
pub trait KhrExternalMemoryExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_EXTERNAL_MEMORY_EXTENSION;
}

impl KhrExternalMemoryExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_memory_capabilities.html>
pub trait KhrExternalMemoryCapabilitiesExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceExternalBufferPropertiesKHR.html>
    #[inline]
    unsafe fn get_physical_device_external_buffer_properties_khr(
        &self,
        physical_device: PhysicalDevice,
        external_buffer_info: &PhysicalDeviceExternalBufferInfo,
        external_buffer_properties: &mut ExternalBufferProperties,
    ) {
        let __result = (self
            .commands()
            .get_physical_device_external_buffer_properties_khr)(
            physical_device,
            external_buffer_info,
            external_buffer_properties,
        );
    }
}

impl KhrExternalMemoryCapabilitiesExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_memory_fd.html>
pub trait KhrExternalMemoryFdExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_EXTERNAL_MEMORY_FD_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetMemoryFdKHR.html>
    #[inline]
    unsafe fn get_memory_fd_khr(&self, get_fd_info: &MemoryGetFdInfoKHR) -> crate::VkResult<c_int> {
        let mut fd = MaybeUninit::<c_int>::uninit();

        let __result =
            (self.commands().get_memory_fd_khr)(self.handle(), get_fd_info, fd.as_mut_ptr());

        if __result == Result::SUCCESS {
            Ok(fd.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetMemoryFdPropertiesKHR.html>
    #[inline]
    unsafe fn get_memory_fd_properties_khr(
        &self,
        handle_type: ExternalMemoryHandleTypeFlags,
        fd: c_int,
        memory_fd_properties: &mut MemoryFdPropertiesKHR,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().get_memory_fd_properties_khr)(
            self.handle(),
            handle_type,
            fd,
            memory_fd_properties,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

impl KhrExternalMemoryFdExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_memory_win32.html>
pub trait KhrExternalMemoryWin32Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_EXTERNAL_MEMORY_WIN32_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetMemoryWin32HandleKHR.html>
    #[inline]
    unsafe fn get_memory_win32_handle_khr(
        &self,
        get_win32_handle_info: &MemoryGetWin32HandleInfoKHR,
    ) -> crate::VkResult<HANDLE> {
        let mut handle = MaybeUninit::<HANDLE>::uninit();

        let __result = (self.commands().get_memory_win32_handle_khr)(
            self.handle(),
            get_win32_handle_info,
            handle.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(handle.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetMemoryWin32HandlePropertiesKHR.html>
    #[inline]
    unsafe fn get_memory_win32_handle_properties_khr(
        &self,
        handle_type: ExternalMemoryHandleTypeFlags,
        handle: HANDLE,
        memory_win32_handle_properties: &mut MemoryWin32HandlePropertiesKHR,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().get_memory_win32_handle_properties_khr)(
            self.handle(),
            handle_type,
            handle,
            memory_win32_handle_properties,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

impl KhrExternalMemoryWin32Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_semaphore.html>
pub trait KhrExternalSemaphoreExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_EXTERNAL_SEMAPHORE_EXTENSION;
}

impl KhrExternalSemaphoreExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_semaphore_capabilities.html>
pub trait KhrExternalSemaphoreCapabilitiesExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceExternalSemaphorePropertiesKHR.html>
    #[inline]
    unsafe fn get_physical_device_external_semaphore_properties_khr(
        &self,
        physical_device: PhysicalDevice,
        external_semaphore_info: &PhysicalDeviceExternalSemaphoreInfo,
        external_semaphore_properties: &mut ExternalSemaphoreProperties,
    ) {
        let __result = (self
            .commands()
            .get_physical_device_external_semaphore_properties_khr)(
            physical_device,
            external_semaphore_info,
            external_semaphore_properties,
        );
    }
}

impl KhrExternalSemaphoreCapabilitiesExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_semaphore_fd.html>
pub trait KhrExternalSemaphoreFdExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetSemaphoreFdKHR.html>
    #[inline]
    unsafe fn get_semaphore_fd_khr(
        &self,
        get_fd_info: &SemaphoreGetFdInfoKHR,
    ) -> crate::VkResult<c_int> {
        let mut fd = MaybeUninit::<c_int>::uninit();

        let __result =
            (self.commands().get_semaphore_fd_khr)(self.handle(), get_fd_info, fd.as_mut_ptr());

        if __result == Result::SUCCESS {
            Ok(fd.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkImportSemaphoreFdKHR.html>
    #[inline]
    unsafe fn import_semaphore_fd_khr(
        &self,
        import_semaphore_fd_info: &ImportSemaphoreFdInfoKHR,
    ) -> crate::VkResult<()> {
        let __result =
            (self.commands().import_semaphore_fd_khr)(self.handle(), import_semaphore_fd_info);

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

impl KhrExternalSemaphoreFdExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_semaphore_win32.html>
pub trait KhrExternalSemaphoreWin32Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetSemaphoreWin32HandleKHR.html>
    #[inline]
    unsafe fn get_semaphore_win32_handle_khr(
        &self,
        get_win32_handle_info: &SemaphoreGetWin32HandleInfoKHR,
    ) -> crate::VkResult<HANDLE> {
        let mut handle = MaybeUninit::<HANDLE>::uninit();

        let __result = (self.commands().get_semaphore_win32_handle_khr)(
            self.handle(),
            get_win32_handle_info,
            handle.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(handle.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkImportSemaphoreWin32HandleKHR.html>
    #[inline]
    unsafe fn import_semaphore_win32_handle_khr(
        &self,
        import_semaphore_win32_handle_info: &ImportSemaphoreWin32HandleInfoKHR,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().import_semaphore_win32_handle_khr)(
            self.handle(),
            import_semaphore_win32_handle_info,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

impl KhrExternalSemaphoreWin32Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_format_feature_flags2.html>
pub trait KhrFormatFeatureFlags2Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_FORMAT_FEATURE_FLAGS2_EXTENSION;
}

impl KhrFormatFeatureFlags2Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_fragment_shader_barycentric.html>
pub trait KhrFragmentShaderBarycentricExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION;
}

impl KhrFragmentShaderBarycentricExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_fragment_shading_rate.html>
pub trait KhrFragmentShadingRateExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_FRAGMENT_SHADING_RATE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetFragmentShadingRateKHR.html>
    #[inline]
    unsafe fn cmd_set_fragment_shading_rate_khr(
        &self,
        command_buffer: CommandBuffer,
        fragment_size: &Extent2D,
        combiner_ops: [FragmentShadingRateCombinerOpKHR; 2],
    ) {
        let __result = (self.commands().cmd_set_fragment_shading_rate_khr)(
            command_buffer,
            fragment_size,
            combiner_ops.as_ptr(),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFragmentShadingRatesKHR.html>
    #[inline]
    unsafe fn get_physical_device_fragment_shading_rates_khr(
        &self,
        physical_device: PhysicalDevice,
    ) -> crate::VkResult<Vec<PhysicalDeviceFragmentShadingRateKHR>> {
        let mut fragment_shading_rate_count = 0;

        (self
            .commands()
            .get_physical_device_fragment_shading_rates_khr)(
            physical_device,
            &mut fragment_shading_rate_count,
            ptr::null_mut(),
        );

        let mut fragment_shading_rates = Vec::with_capacity(fragment_shading_rate_count as usize);

        let __result = (self
            .commands()
            .get_physical_device_fragment_shading_rates_khr)(
            physical_device,
            &mut fragment_shading_rate_count,
            fragment_shading_rates.as_mut_ptr(),
        );

        debug_assert!(fragment_shading_rates.capacity() == fragment_shading_rate_count as usize);
        fragment_shading_rates.set_len(fragment_shading_rate_count as usize);

        if __result == Result::SUCCESS {
            Ok(fragment_shading_rates)
        } else {
            Err(__result.into())
        }
    }
}

impl KhrFragmentShadingRateExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_get_display_properties2.html>
pub trait KhrGetDisplayProperties2Extension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_GET_DISPLAY_PROPERTIES2_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDisplayModeProperties2KHR.html>
    #[inline]
    unsafe fn get_display_mode_properties2_khr(
        &self,
        physical_device: PhysicalDevice,
        display: DisplayKHR,
    ) -> crate::VkResult<Vec<DisplayModeProperties2KHR>> {
        let mut property_count = 0;

        (self.commands().get_display_mode_properties2_khr)(
            physical_device,
            display,
            &mut property_count,
            ptr::null_mut(),
        );

        let mut properties = Vec::with_capacity(property_count as usize);

        let __result = (self.commands().get_display_mode_properties2_khr)(
            physical_device,
            display,
            &mut property_count,
            properties.as_mut_ptr(),
        );

        debug_assert!(properties.capacity() == property_count as usize);
        properties.set_len(property_count as usize);

        if __result == Result::SUCCESS {
            Ok(properties)
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDisplayPlaneCapabilities2KHR.html>
    #[inline]
    unsafe fn get_display_plane_capabilities2_khr(
        &self,
        physical_device: PhysicalDevice,
        display_plane_info: &DisplayPlaneInfo2KHR,
        capabilities: &mut DisplayPlaneCapabilities2KHR,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().get_display_plane_capabilities2_khr)(
            physical_device,
            display_plane_info,
            capabilities,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceDisplayPlaneProperties2KHR.html>
    #[inline]
    unsafe fn get_physical_device_display_plane_properties2_khr(
        &self,
        physical_device: PhysicalDevice,
    ) -> crate::VkResult<Vec<DisplayPlaneProperties2KHR>> {
        let mut property_count = 0;

        (self
            .commands()
            .get_physical_device_display_plane_properties2_khr)(
            physical_device,
            &mut property_count,
            ptr::null_mut(),
        );

        let mut properties = Vec::with_capacity(property_count as usize);

        let __result = (self
            .commands()
            .get_physical_device_display_plane_properties2_khr)(
            physical_device,
            &mut property_count,
            properties.as_mut_ptr(),
        );

        debug_assert!(properties.capacity() == property_count as usize);
        properties.set_len(property_count as usize);

        if __result == Result::SUCCESS {
            Ok(properties)
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceDisplayProperties2KHR.html>
    #[inline]
    unsafe fn get_physical_device_display_properties2_khr(
        &self,
        physical_device: PhysicalDevice,
    ) -> crate::VkResult<Vec<DisplayProperties2KHR>> {
        let mut property_count = 0;

        (self.commands().get_physical_device_display_properties2_khr)(
            physical_device,
            &mut property_count,
            ptr::null_mut(),
        );

        let mut properties = Vec::with_capacity(property_count as usize);

        let __result = (self.commands().get_physical_device_display_properties2_khr)(
            physical_device,
            &mut property_count,
            properties.as_mut_ptr(),
        );

        debug_assert!(properties.capacity() == property_count as usize);
        properties.set_len(property_count as usize);

        if __result == Result::SUCCESS {
            Ok(properties)
        } else {
            Err(__result.into())
        }
    }
}

impl KhrGetDisplayProperties2Extension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_get_memory_requirements2.html>
pub trait KhrGetMemoryRequirements2Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_GET_MEMORY_REQUIREMENTS2_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetBufferMemoryRequirements2KHR.html>
    #[inline]
    unsafe fn get_buffer_memory_requirements2_khr(
        &self,
        info: &BufferMemoryRequirementsInfo2,
        memory_requirements: &mut MemoryRequirements2,
    ) {
        let __result = (self.commands().get_buffer_memory_requirements2_khr)(
            self.handle(),
            info,
            memory_requirements,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageMemoryRequirements2KHR.html>
    #[inline]
    unsafe fn get_image_memory_requirements2_khr(
        &self,
        info: &ImageMemoryRequirementsInfo2,
        memory_requirements: &mut MemoryRequirements2,
    ) {
        let __result = (self.commands().get_image_memory_requirements2_khr)(
            self.handle(),
            info,
            memory_requirements,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageSparseMemoryRequirements2KHR.html>
    #[inline]
    unsafe fn get_image_sparse_memory_requirements2_khr(
        &self,
        info: &ImageSparseMemoryRequirementsInfo2,
    ) -> Vec<SparseImageMemoryRequirements2> {
        let mut sparse_memory_requirement_count = 0;

        (self.commands().get_image_sparse_memory_requirements2_khr)(
            self.handle(),
            info,
            &mut sparse_memory_requirement_count,
            ptr::null_mut(),
        );

        let mut sparse_memory_requirements =
            Vec::with_capacity(sparse_memory_requirement_count as usize);

        let __result = (self.commands().get_image_sparse_memory_requirements2_khr)(
            self.handle(),
            info,
            &mut sparse_memory_requirement_count,
            sparse_memory_requirements.as_mut_ptr(),
        );

        debug_assert!(
            sparse_memory_requirements.capacity() == sparse_memory_requirement_count as usize
        );
        sparse_memory_requirements.set_len(sparse_memory_requirement_count as usize);

        sparse_memory_requirements
    }
}

impl KhrGetMemoryRequirements2Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_get_physical_device_properties2.html>
pub trait KhrGetPhysicalDeviceProperties2Extension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_GET_PHYSICAL_DEVICE_PROPERTIES2_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFeatures2KHR.html>
    #[inline]
    unsafe fn get_physical_device_features2_khr(
        &self,
        physical_device: PhysicalDevice,
        features: &mut PhysicalDeviceFeatures2,
    ) {
        let __result =
            (self.commands().get_physical_device_features2_khr)(physical_device, features);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFormatProperties2KHR.html>
    #[inline]
    unsafe fn get_physical_device_format_properties2_khr(
        &self,
        physical_device: PhysicalDevice,
        format: Format,
        format_properties: &mut FormatProperties2,
    ) {
        let __result = (self.commands().get_physical_device_format_properties2_khr)(
            physical_device,
            format,
            format_properties,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceImageFormatProperties2KHR.html>
    #[inline]
    unsafe fn get_physical_device_image_format_properties2_khr(
        &self,
        physical_device: PhysicalDevice,
        image_format_info: &PhysicalDeviceImageFormatInfo2,
        image_format_properties: &mut ImageFormatProperties2,
    ) -> crate::VkResult<()> {
        let __result = (self
            .commands()
            .get_physical_device_image_format_properties2_khr)(
            physical_device,
            image_format_info,
            image_format_properties,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceMemoryProperties2KHR.html>
    #[inline]
    unsafe fn get_physical_device_memory_properties2_khr(
        &self,
        physical_device: PhysicalDevice,
        memory_properties: &mut PhysicalDeviceMemoryProperties2,
    ) {
        let __result = (self.commands().get_physical_device_memory_properties2_khr)(
            physical_device,
            memory_properties,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceProperties2KHR.html>
    #[inline]
    unsafe fn get_physical_device_properties2_khr(
        &self,
        physical_device: PhysicalDevice,
        properties: &mut PhysicalDeviceProperties2,
    ) {
        let __result =
            (self.commands().get_physical_device_properties2_khr)(physical_device, properties);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceQueueFamilyProperties2KHR.html>
    #[inline]
    unsafe fn get_physical_device_queue_family_properties2_khr(
        &self,
        physical_device: PhysicalDevice,
    ) -> Vec<QueueFamilyProperties2> {
        let mut queue_family_property_count = 0;

        (self
            .commands()
            .get_physical_device_queue_family_properties2_khr)(
            physical_device,
            &mut queue_family_property_count,
            ptr::null_mut(),
        );

        let mut queue_family_properties = Vec::with_capacity(queue_family_property_count as usize);

        let __result = (self
            .commands()
            .get_physical_device_queue_family_properties2_khr)(
            physical_device,
            &mut queue_family_property_count,
            queue_family_properties.as_mut_ptr(),
        );

        debug_assert!(queue_family_properties.capacity() == queue_family_property_count as usize);
        queue_family_properties.set_len(queue_family_property_count as usize);

        queue_family_properties
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSparseImageFormatProperties2KHR.html>
    #[inline]
    unsafe fn get_physical_device_sparse_image_format_properties2_khr(
        &self,
        physical_device: PhysicalDevice,
        format_info: &PhysicalDeviceSparseImageFormatInfo2,
    ) -> Vec<SparseImageFormatProperties2> {
        let mut property_count = 0;

        (self
            .commands()
            .get_physical_device_sparse_image_format_properties2_khr)(
            physical_device,
            format_info,
            &mut property_count,
            ptr::null_mut(),
        );

        let mut properties = Vec::with_capacity(property_count as usize);

        let __result = (self
            .commands()
            .get_physical_device_sparse_image_format_properties2_khr)(
            physical_device,
            format_info,
            &mut property_count,
            properties.as_mut_ptr(),
        );

        debug_assert!(properties.capacity() == property_count as usize);
        properties.set_len(property_count as usize);

        properties
    }
}

impl KhrGetPhysicalDeviceProperties2Extension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_get_surface_capabilities2.html>
pub trait KhrGetSurfaceCapabilities2Extension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_GET_SURFACE_CAPABILITIES2_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceCapabilities2KHR.html>
    #[inline]
    unsafe fn get_physical_device_surface_capabilities2_khr(
        &self,
        physical_device: PhysicalDevice,
        surface_info: &PhysicalDeviceSurfaceInfo2KHR,
        surface_capabilities: &mut SurfaceCapabilities2KHR,
    ) -> crate::VkResult<()> {
        let __result = (self
            .commands()
            .get_physical_device_surface_capabilities2_khr)(
            physical_device,
            surface_info,
            surface_capabilities,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceFormats2KHR.html>
    #[inline]
    unsafe fn get_physical_device_surface_formats2_khr(
        &self,
        physical_device: PhysicalDevice,
        surface_info: &PhysicalDeviceSurfaceInfo2KHR,
    ) -> crate::VkResult<Vec<SurfaceFormat2KHR>> {
        let mut surface_format_count = 0;

        (self.commands().get_physical_device_surface_formats2_khr)(
            physical_device,
            surface_info,
            &mut surface_format_count,
            ptr::null_mut(),
        );

        let mut surface_formats = Vec::with_capacity(surface_format_count as usize);

        let __result = (self.commands().get_physical_device_surface_formats2_khr)(
            physical_device,
            surface_info,
            &mut surface_format_count,
            surface_formats.as_mut_ptr(),
        );

        debug_assert!(surface_formats.capacity() == surface_format_count as usize);
        surface_formats.set_len(surface_format_count as usize);

        if __result == Result::SUCCESS {
            Ok(surface_formats)
        } else {
            Err(__result.into())
        }
    }
}

impl KhrGetSurfaceCapabilities2Extension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_global_priority.html>
pub trait KhrGlobalPriorityExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_GLOBAL_PRIORITY_EXTENSION;
}

impl KhrGlobalPriorityExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_image_format_list.html>
pub trait KhrImageFormatListExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_IMAGE_FORMAT_LIST_EXTENSION;
}

impl KhrImageFormatListExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_imageless_framebuffer.html>
pub trait KhrImagelessFramebufferExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_IMAGELESS_FRAMEBUFFER_EXTENSION;
}

impl KhrImagelessFramebufferExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_incremental_present.html>
pub trait KhrIncrementalPresentExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_INCREMENTAL_PRESENT_EXTENSION;
}

impl KhrIncrementalPresentExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_index_type_uint8.html>
pub trait KhrIndexTypeUint8Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_INDEX_TYPE_UINT8_EXTENSION;
}

impl KhrIndexTypeUint8Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_line_rasterization.html>
pub trait KhrLineRasterizationExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_LINE_RASTERIZATION_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetLineStippleKHR.html>
    #[inline]
    unsafe fn cmd_set_line_stipple_khr(
        &self,
        command_buffer: CommandBuffer,
        line_stipple_factor: u32,
        line_stipple_pattern: u16,
    ) {
        let __result = (self.commands().cmd_set_line_stipple_khr)(
            command_buffer,
            line_stipple_factor,
            line_stipple_pattern,
        );
    }
}

impl KhrLineRasterizationExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_load_store_op_none.html>
pub trait KhrLoadStoreOpNoneExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_LOAD_STORE_OP_NONE_EXTENSION;
}

impl KhrLoadStoreOpNoneExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_maintenance1.html>
pub trait KhrMaintenance1Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_MAINTENANCE1_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkTrimCommandPoolKHR.html>
    #[inline]
    unsafe fn trim_command_pool_khr(&self, command_pool: CommandPool, flags: CommandPoolTrimFlags) {
        let __result = (self.commands().trim_command_pool_khr)(self.handle(), command_pool, flags);
    }
}

impl KhrMaintenance1Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_maintenance2.html>
pub trait KhrMaintenance2Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_MAINTENANCE2_EXTENSION;
}

impl KhrMaintenance2Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_maintenance3.html>
pub trait KhrMaintenance3Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_MAINTENANCE3_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDescriptorSetLayoutSupportKHR.html>
    #[inline]
    unsafe fn get_descriptor_set_layout_support_khr(
        &self,
        create_info: &DescriptorSetLayoutCreateInfo,
        support: &mut DescriptorSetLayoutSupport,
    ) {
        let __result = (self.commands().get_descriptor_set_layout_support_khr)(
            self.handle(),
            create_info,
            support,
        );
    }
}

impl KhrMaintenance3Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_maintenance4.html>
pub trait KhrMaintenance4Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_MAINTENANCE4_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceBufferMemoryRequirementsKHR.html>
    #[inline]
    unsafe fn get_device_buffer_memory_requirements_khr(
        &self,
        info: &DeviceBufferMemoryRequirements,
        memory_requirements: &mut MemoryRequirements2,
    ) {
        let __result = (self.commands().get_device_buffer_memory_requirements_khr)(
            self.handle(),
            info,
            memory_requirements,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceImageMemoryRequirementsKHR.html>
    #[inline]
    unsafe fn get_device_image_memory_requirements_khr(
        &self,
        info: &DeviceImageMemoryRequirements,
        memory_requirements: &mut MemoryRequirements2,
    ) {
        let __result = (self.commands().get_device_image_memory_requirements_khr)(
            self.handle(),
            info,
            memory_requirements,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceImageSparseMemoryRequirementsKHR.html>
    #[inline]
    unsafe fn get_device_image_sparse_memory_requirements_khr(
        &self,
        info: &DeviceImageMemoryRequirements,
    ) -> Vec<SparseImageMemoryRequirements2> {
        let mut sparse_memory_requirement_count = 0;

        (self
            .commands()
            .get_device_image_sparse_memory_requirements_khr)(
            self.handle(),
            info,
            &mut sparse_memory_requirement_count,
            ptr::null_mut(),
        );

        let mut sparse_memory_requirements =
            Vec::with_capacity(sparse_memory_requirement_count as usize);

        let __result = (self
            .commands()
            .get_device_image_sparse_memory_requirements_khr)(
            self.handle(),
            info,
            &mut sparse_memory_requirement_count,
            sparse_memory_requirements.as_mut_ptr(),
        );

        debug_assert!(
            sparse_memory_requirements.capacity() == sparse_memory_requirement_count as usize
        );
        sparse_memory_requirements.set_len(sparse_memory_requirement_count as usize);

        sparse_memory_requirements
    }
}

impl KhrMaintenance4Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_maintenance5.html>
pub trait KhrMaintenance5Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_MAINTENANCE5_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindIndexBuffer2KHR.html>
    #[inline]
    unsafe fn cmd_bind_index_buffer2_khr(
        &self,
        command_buffer: CommandBuffer,
        buffer: Buffer,
        offset: DeviceSize,
        size: DeviceSize,
        index_type: IndexType,
    ) {
        let __result = (self.commands().cmd_bind_index_buffer2_khr)(
            command_buffer,
            buffer,
            offset,
            size,
            index_type,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceImageSubresourceLayoutKHR.html>
    #[inline]
    unsafe fn get_device_image_subresource_layout_khr(
        &self,
        info: &DeviceImageSubresourceInfoKHR,
        layout: &mut SubresourceLayout2KHR,
    ) {
        let __result =
            (self.commands().get_device_image_subresource_layout_khr)(self.handle(), info, layout);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageSubresourceLayout2KHR.html>
    #[inline]
    unsafe fn get_image_subresource_layout2_khr(
        &self,
        image: Image,
        subresource: &ImageSubresource2KHR,
        layout: &mut SubresourceLayout2KHR,
    ) {
        let __result = (self.commands().get_image_subresource_layout2_khr)(
            self.handle(),
            image,
            subresource,
            layout,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetRenderingAreaGranularityKHR.html>
    #[inline]
    unsafe fn get_rendering_area_granularity_khr(
        &self,
        rendering_area_info: &RenderingAreaInfoKHR,
    ) -> Extent2D {
        let mut granularity = MaybeUninit::<Extent2D>::uninit();

        let __result = (self.commands().get_rendering_area_granularity_khr)(
            self.handle(),
            rendering_area_info,
            granularity.as_mut_ptr(),
        );

        granularity.assume_init()
    }
}

impl KhrMaintenance5Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_maintenance6.html>
pub trait KhrMaintenance6Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_MAINTENANCE6_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindDescriptorBufferEmbeddedSamplers2EXT.html>
    #[inline]
    unsafe fn cmd_bind_descriptor_buffer_embedded_samplers2_ext(
        &self,
        command_buffer: CommandBuffer,
        bind_descriptor_buffer_embedded_samplers_info: &BindDescriptorBufferEmbeddedSamplersInfoEXT,
    ) {
        let __result = (self
            .commands()
            .cmd_bind_descriptor_buffer_embedded_samplers2_ext)(
            command_buffer,
            bind_descriptor_buffer_embedded_samplers_info,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindDescriptorSets2KHR.html>
    #[inline]
    unsafe fn cmd_bind_descriptor_sets2_khr(
        &self,
        command_buffer: CommandBuffer,
        bind_descriptor_sets_info: &BindDescriptorSetsInfoKHR,
    ) {
        let __result = (self.commands().cmd_bind_descriptor_sets2_khr)(
            command_buffer,
            bind_descriptor_sets_info,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPushConstants2KHR.html>
    #[inline]
    unsafe fn cmd_push_constants2_khr(
        &self,
        command_buffer: CommandBuffer,
        push_constants_info: &PushConstantsInfoKHR,
    ) {
        let __result =
            (self.commands().cmd_push_constants2_khr)(command_buffer, push_constants_info);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPushDescriptorSet2KHR.html>
    #[inline]
    unsafe fn cmd_push_descriptor_set2_khr(
        &self,
        command_buffer: CommandBuffer,
        push_descriptor_set_info: &PushDescriptorSetInfoKHR,
    ) {
        let __result = (self.commands().cmd_push_descriptor_set2_khr)(
            command_buffer,
            push_descriptor_set_info,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPushDescriptorSetWithTemplate2KHR.html>
    #[inline]
    unsafe fn cmd_push_descriptor_set_with_template2_khr(
        &self,
        command_buffer: CommandBuffer,
        push_descriptor_set_with_template_info: &PushDescriptorSetWithTemplateInfoKHR,
    ) {
        let __result = (self.commands().cmd_push_descriptor_set_with_template2_khr)(
            command_buffer,
            push_descriptor_set_with_template_info,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDescriptorBufferOffsets2EXT.html>
    #[inline]
    unsafe fn cmd_set_descriptor_buffer_offsets2_ext(
        &self,
        command_buffer: CommandBuffer,
        set_descriptor_buffer_offsets_info: &SetDescriptorBufferOffsetsInfoEXT,
    ) {
        let __result = (self.commands().cmd_set_descriptor_buffer_offsets2_ext)(
            command_buffer,
            set_descriptor_buffer_offsets_info,
        );
    }
}

impl KhrMaintenance6Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_maintenance7.html>
pub trait KhrMaintenance7Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_MAINTENANCE7_EXTENSION;
}

impl KhrMaintenance7Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_map_memory2.html>
pub trait KhrMapMemory2Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_MAP_MEMORY2_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkMapMemory2KHR.html>
    #[inline]
    unsafe fn map_memory2_khr(
        &self,
        memory_map_info: &MemoryMapInfoKHR,
    ) -> crate::VkResult<*mut c_void> {
        let mut data = MaybeUninit::<*mut c_void>::uninit();

        let __result =
            (self.commands().map_memory2_khr)(self.handle(), memory_map_info, data.as_mut_ptr());

        if __result == Result::SUCCESS {
            Ok(data.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkUnmapMemory2KHR.html>
    #[inline]
    unsafe fn unmap_memory2_khr(
        &self,
        memory_unmap_info: &MemoryUnmapInfoKHR,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().unmap_memory2_khr)(self.handle(), memory_unmap_info);

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

impl KhrMapMemory2Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_multiview.html>
pub trait KhrMultiviewExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_MULTIVIEW_EXTENSION;
}

impl KhrMultiviewExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_object_refresh.html>
pub trait KhrObjectRefreshExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_OBJECT_REFRESH_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdRefreshObjectsKHR.html>
    #[inline]
    unsafe fn cmd_refresh_objects_khr(
        &self,
        command_buffer: CommandBuffer,
        refresh_objects: &RefreshObjectListKHR,
    ) {
        let __result = (self.commands().cmd_refresh_objects_khr)(command_buffer, refresh_objects);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceRefreshableObjectTypesKHR.html>
    #[inline]
    unsafe fn get_physical_device_refreshable_object_types_khr(
        &self,
        physical_device: PhysicalDevice,
    ) -> crate::VkResult<Vec<ObjectType>> {
        let mut refreshable_object_type_count = 0;

        (self
            .commands()
            .get_physical_device_refreshable_object_types_khr)(
            physical_device,
            &mut refreshable_object_type_count,
            ptr::null_mut(),
        );

        let mut refreshable_object_types =
            Vec::with_capacity(refreshable_object_type_count as usize);

        let __result = (self
            .commands()
            .get_physical_device_refreshable_object_types_khr)(
            physical_device,
            &mut refreshable_object_type_count,
            refreshable_object_types.as_mut_ptr(),
        );

        debug_assert!(
            refreshable_object_types.capacity() == refreshable_object_type_count as usize
        );
        refreshable_object_types.set_len(refreshable_object_type_count as usize);

        if __result == Result::SUCCESS {
            Ok(refreshable_object_types)
        } else {
            Err(__result.into())
        }
    }
}

impl KhrObjectRefreshExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_performance_query.html>
pub trait KhrPerformanceQueryExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_PERFORMANCE_QUERY_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAcquireProfilingLockKHR.html>
    #[inline]
    unsafe fn acquire_profiling_lock_khr(
        &self,
        info: &AcquireProfilingLockInfoKHR,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().acquire_profiling_lock_khr)(self.handle(), info);

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR.html>
    #[inline]
    unsafe fn enumerate_physical_device_queue_family_performance_query_counters_khr(
        &self,
        physical_device: PhysicalDevice,
        queue_family_index: u32,
    ) -> crate::VkResult<(
        Vec<PerformanceCounterKHR>,
        Vec<PerformanceCounterDescriptionKHR>,
    )> {
        let mut counter_count = 0;

        (self
            .commands()
            .enumerate_physical_device_queue_family_performance_query_counters_khr)(
            physical_device,
            queue_family_index,
            &mut counter_count,
            ptr::null_mut(),
            ptr::null_mut(),
        );

        let mut counters = Vec::with_capacity(counter_count as usize);
        let mut counter_descriptions = Vec::with_capacity(counter_count as usize);

        let __result = (self
            .commands()
            .enumerate_physical_device_queue_family_performance_query_counters_khr)(
            physical_device,
            queue_family_index,
            &mut counter_count,
            counters.as_mut_ptr(),
            counter_descriptions.as_mut_ptr(),
        );

        debug_assert!(counters.capacity() == counter_count as usize);
        counters.set_len(counter_count as usize);
        debug_assert!(counter_descriptions.capacity() == counter_count as usize);
        counter_descriptions.set_len(counter_count as usize);

        if __result == Result::SUCCESS {
            Ok((counters, counter_descriptions))
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR.html>
    #[inline]
    unsafe fn get_physical_device_queue_family_performance_query_passes_khr(
        &self,
        physical_device: PhysicalDevice,
        performance_query_create_info: &QueryPoolPerformanceCreateInfoKHR,
    ) -> u32 {
        let mut num_passes = MaybeUninit::<u32>::uninit();

        let __result = (self
            .commands()
            .get_physical_device_queue_family_performance_query_passes_khr)(
            physical_device,
            performance_query_create_info,
            num_passes.as_mut_ptr(),
        );

        num_passes.assume_init()
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkReleaseProfilingLockKHR.html>
    #[inline]
    unsafe fn release_profiling_lock_khr(&self) {
        let __result = (self.commands().release_profiling_lock_khr)(self.handle());
    }
}

impl KhrPerformanceQueryExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_pipeline_binary.html>
pub trait KhrPipelineBinaryExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_PIPELINE_BINARY_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreatePipelineBinariesKHR.html>
    #[inline]
    unsafe fn create_pipeline_binaries_khr(
        &self,
        create_info: &PipelineBinaryCreateInfoKHR,
        allocator: Option<&AllocationCallbacks>,
        binaries: &mut PipelineBinaryHandlesInfoKHR,
    ) -> crate::VkResult<SuccessCode> {
        let __result = (self.commands().create_pipeline_binaries_khr)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            binaries,
        );

        if __result >= Result::SUCCESS {
            Ok(__result.into())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyPipelineBinaryKHR.html>
    #[inline]
    unsafe fn destroy_pipeline_binary_khr(
        &self,
        pipeline_binary: PipelineBinaryKHR,
        allocator: Option<&AllocationCallbacks>,
    ) {
        let __result = (self.commands().destroy_pipeline_binary_khr)(
            self.handle(),
            pipeline_binary,
            allocator.map_or(ptr::null(), |v| v),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPipelineBinaryDataKHR.html>
    #[inline]
    unsafe fn get_pipeline_binary_data_khr(
        &self,
        info: &PipelineBinaryDataInfoKHR,
        pipeline_binary_key: &mut PipelineBinaryKeyKHR,
    ) -> crate::VkResult<Vec<u8>> {
        let mut pipeline_binary_data_size = 0;

        (self.commands().get_pipeline_binary_data_khr)(
            self.handle(),
            info,
            ptr::null_mut(),
            &mut pipeline_binary_data_size,
            ptr::null_mut(),
        );

        let mut pipeline_binary_data = Vec::with_capacity(pipeline_binary_data_size as usize);

        let __result = (self.commands().get_pipeline_binary_data_khr)(
            self.handle(),
            info,
            pipeline_binary_key,
            &mut pipeline_binary_data_size,
            pipeline_binary_data.as_mut_ptr() as *mut c_void,
        );

        debug_assert!(pipeline_binary_data.capacity() == pipeline_binary_data_size as usize);
        pipeline_binary_data.set_len(pipeline_binary_data_size as usize);

        if __result == Result::SUCCESS {
            Ok(pipeline_binary_data)
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPipelineKeyKHR.html>
    #[inline]
    unsafe fn get_pipeline_key_khr(
        &self,
        pipeline_create_info: Option<&PipelineCreateInfoKHR>,
        pipeline_key: &mut PipelineBinaryKeyKHR,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().get_pipeline_key_khr)(
            self.handle(),
            pipeline_create_info.map_or(ptr::null(), |v| v),
            pipeline_key,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkReleaseCapturedPipelineDataKHR.html>
    #[inline]
    unsafe fn release_captured_pipeline_data_khr(
        &self,
        info: &ReleaseCapturedPipelineDataInfoKHR,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().release_captured_pipeline_data_khr)(
            self.handle(),
            info,
            allocator.map_or(ptr::null(), |v| v),
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

impl KhrPipelineBinaryExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_pipeline_executable_properties.html>
pub trait KhrPipelineExecutablePropertiesExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPipelineExecutableInternalRepresentationsKHR.html>
    #[inline]
    unsafe fn get_pipeline_executable_internal_representations_khr(
        &self,
        executable_info: &PipelineExecutableInfoKHR,
    ) -> crate::VkResult<Vec<PipelineExecutableInternalRepresentationKHR>> {
        let mut internal_representation_count = 0;

        (self
            .commands()
            .get_pipeline_executable_internal_representations_khr)(
            self.handle(),
            executable_info,
            &mut internal_representation_count,
            ptr::null_mut(),
        );

        let mut internal_representations =
            Vec::with_capacity(internal_representation_count as usize);

        let __result = (self
            .commands()
            .get_pipeline_executable_internal_representations_khr)(
            self.handle(),
            executable_info,
            &mut internal_representation_count,
            internal_representations.as_mut_ptr(),
        );

        debug_assert!(
            internal_representations.capacity() == internal_representation_count as usize
        );
        internal_representations.set_len(internal_representation_count as usize);

        if __result == Result::SUCCESS {
            Ok(internal_representations)
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPipelineExecutablePropertiesKHR.html>
    #[inline]
    unsafe fn get_pipeline_executable_properties_khr(
        &self,
        pipeline_info: &PipelineInfoKHR,
    ) -> crate::VkResult<Vec<PipelineExecutablePropertiesKHR>> {
        let mut executable_count = 0;

        (self.commands().get_pipeline_executable_properties_khr)(
            self.handle(),
            pipeline_info,
            &mut executable_count,
            ptr::null_mut(),
        );

        let mut properties = Vec::with_capacity(executable_count as usize);

        let __result = (self.commands().get_pipeline_executable_properties_khr)(
            self.handle(),
            pipeline_info,
            &mut executable_count,
            properties.as_mut_ptr(),
        );

        debug_assert!(properties.capacity() == executable_count as usize);
        properties.set_len(executable_count as usize);

        if __result == Result::SUCCESS {
            Ok(properties)
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPipelineExecutableStatisticsKHR.html>
    #[inline]
    unsafe fn get_pipeline_executable_statistics_khr(
        &self,
        executable_info: &PipelineExecutableInfoKHR,
    ) -> crate::VkResult<Vec<PipelineExecutableStatisticKHR>> {
        let mut statistic_count = 0;

        (self.commands().get_pipeline_executable_statistics_khr)(
            self.handle(),
            executable_info,
            &mut statistic_count,
            ptr::null_mut(),
        );

        let mut statistics = Vec::with_capacity(statistic_count as usize);

        let __result = (self.commands().get_pipeline_executable_statistics_khr)(
            self.handle(),
            executable_info,
            &mut statistic_count,
            statistics.as_mut_ptr(),
        );

        debug_assert!(statistics.capacity() == statistic_count as usize);
        statistics.set_len(statistic_count as usize);

        if __result == Result::SUCCESS {
            Ok(statistics)
        } else {
            Err(__result.into())
        }
    }
}

impl KhrPipelineExecutablePropertiesExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_pipeline_library.html>
pub trait KhrPipelineLibraryExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_PIPELINE_LIBRARY_EXTENSION;
}

impl KhrPipelineLibraryExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_portability_enumeration.html>
pub trait KhrPortabilityEnumerationExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_PORTABILITY_ENUMERATION_EXTENSION;
}

impl KhrPortabilityEnumerationExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_portability_subset.html>
///
/// ## WARNING
///
/// This is a
/// [provisional extension](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/provisional-headers.html).
/// Provisional extensions are not guaranteed to be backwards compatible and are
/// not intended to be used in production applications.
#[cfg(feature = "provisional")]
pub trait KhrPortabilitySubsetExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_PORTABILITY_SUBSET_EXTENSION;
}

#[cfg(feature = "provisional")]
impl KhrPortabilitySubsetExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_present_id.html>
pub trait KhrPresentIdExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_PRESENT_ID_EXTENSION;
}

impl KhrPresentIdExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_present_wait.html>
pub trait KhrPresentWaitExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_PRESENT_WAIT_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkWaitForPresentKHR.html>
    #[inline]
    unsafe fn wait_for_present_khr(
        &self,
        swapchain: SwapchainKHR,
        present_id: u64,
        timeout: u64,
    ) -> crate::VkResult<SuccessCode> {
        let __result =
            (self.commands().wait_for_present_khr)(self.handle(), swapchain, present_id, timeout);

        if __result >= Result::SUCCESS {
            Ok(__result.into())
        } else {
            Err(__result.into())
        }
    }
}

impl KhrPresentWaitExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_push_descriptor.html>
pub trait KhrPushDescriptorExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_PUSH_DESCRIPTOR_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPushDescriptorSetKHR.html>
    #[inline]
    unsafe fn cmd_push_descriptor_set_khr(
        &self,
        command_buffer: CommandBuffer,
        pipeline_bind_point: PipelineBindPoint,
        layout: PipelineLayout,
        set: u32,
        descriptor_writes: &[impl Cast<Target = WriteDescriptorSet>],
    ) {
        let __result = (self.commands().cmd_push_descriptor_set_khr)(
            command_buffer,
            pipeline_bind_point,
            layout,
            set,
            descriptor_writes.len() as u32,
            descriptor_writes.as_ptr().cast(),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPushDescriptorSetWithTemplateKHR.html>
    #[inline]
    unsafe fn cmd_push_descriptor_set_with_template_khr(
        &self,
        command_buffer: CommandBuffer,
        descriptor_update_template: DescriptorUpdateTemplate,
        layout: PipelineLayout,
        set: u32,
        data: &c_void,
    ) {
        let __result = (self.commands().cmd_push_descriptor_set_with_template_khr)(
            command_buffer,
            descriptor_update_template,
            layout,
            set,
            data,
        );
    }
}

impl KhrPushDescriptorExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_ray_query.html>
pub trait KhrRayQueryExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_RAY_QUERY_EXTENSION;
}

impl KhrRayQueryExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_ray_tracing_maintenance1.html>
pub trait KhrRayTracingMaintenance1Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_RAY_TRACING_MAINTENANCE1_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdTraceRaysIndirect2KHR.html>
    #[inline]
    unsafe fn cmd_trace_rays_indirect2_khr(
        &self,
        command_buffer: CommandBuffer,
        indirect_device_address: DeviceAddress,
    ) {
        let __result =
            (self.commands().cmd_trace_rays_indirect2_khr)(command_buffer, indirect_device_address);
    }
}

impl KhrRayTracingMaintenance1Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_ray_tracing_pipeline.html>
pub trait KhrRayTracingPipelineExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_RAY_TRACING_PIPELINE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetRayTracingPipelineStackSizeKHR.html>
    #[inline]
    unsafe fn cmd_set_ray_tracing_pipeline_stack_size_khr(
        &self,
        command_buffer: CommandBuffer,
        pipeline_stack_size: u32,
    ) {
        let __result = (self.commands().cmd_set_ray_tracing_pipeline_stack_size_khr)(
            command_buffer,
            pipeline_stack_size,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdTraceRaysIndirectKHR.html>
    #[inline]
    unsafe fn cmd_trace_rays_indirect_khr(
        &self,
        command_buffer: CommandBuffer,
        raygen_shader_binding_table: &StridedDeviceAddressRegionKHR,
        miss_shader_binding_table: &StridedDeviceAddressRegionKHR,
        hit_shader_binding_table: &StridedDeviceAddressRegionKHR,
        callable_shader_binding_table: &StridedDeviceAddressRegionKHR,
        indirect_device_address: DeviceAddress,
    ) {
        let __result = (self.commands().cmd_trace_rays_indirect_khr)(
            command_buffer,
            raygen_shader_binding_table,
            miss_shader_binding_table,
            hit_shader_binding_table,
            callable_shader_binding_table,
            indirect_device_address,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdTraceRaysKHR.html>
    #[inline]
    unsafe fn cmd_trace_rays_khr(
        &self,
        command_buffer: CommandBuffer,
        raygen_shader_binding_table: &StridedDeviceAddressRegionKHR,
        miss_shader_binding_table: &StridedDeviceAddressRegionKHR,
        hit_shader_binding_table: &StridedDeviceAddressRegionKHR,
        callable_shader_binding_table: &StridedDeviceAddressRegionKHR,
        width: u32,
        height: u32,
        depth: u32,
    ) {
        let __result = (self.commands().cmd_trace_rays_khr)(
            command_buffer,
            raygen_shader_binding_table,
            miss_shader_binding_table,
            hit_shader_binding_table,
            callable_shader_binding_table,
            width,
            height,
            depth,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateRayTracingPipelinesKHR.html>
    #[inline]
    unsafe fn create_ray_tracing_pipelines_khr(
        &self,
        deferred_operation: DeferredOperationKHR,
        pipeline_cache: PipelineCache,
        create_infos: &[impl Cast<Target = RayTracingPipelineCreateInfoKHR>],
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkSuccessResult<Vec<Pipeline>> {
        let mut pipelines = Vec::with_capacity(create_infos.len() as usize);

        let __result = (self.commands().create_ray_tracing_pipelines_khr)(
            self.handle(),
            deferred_operation,
            pipeline_cache,
            create_infos.len() as u32,
            create_infos.as_ptr().cast(),
            allocator.map_or(ptr::null(), |v| v),
            pipelines.as_mut_ptr(),
        );

        pipelines.set_len(create_infos.len() as usize);

        if __result >= Result::SUCCESS {
            Ok((pipelines, __result.into()))
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetRayTracingCaptureReplayShaderGroupHandlesKHR.html>
    #[inline]
    unsafe fn get_ray_tracing_capture_replay_shader_group_handles_khr(
        &self,
        pipeline: Pipeline,
        first_group: u32,
        group_count: u32,
        data: &mut [u8],
    ) -> crate::VkResult<()> {
        let __result = (self
            .commands()
            .get_ray_tracing_capture_replay_shader_group_handles_khr)(
            self.handle(),
            pipeline,
            first_group,
            group_count,
            data.len() as usize,
            data.as_ptr() as *mut c_void,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetRayTracingShaderGroupHandlesKHR.html>
    #[inline]
    unsafe fn get_ray_tracing_shader_group_handles_khr(
        &self,
        pipeline: Pipeline,
        first_group: u32,
        group_count: u32,
        data: &mut [u8],
    ) -> crate::VkResult<()> {
        let __result = (self.commands().get_ray_tracing_shader_group_handles_khr)(
            self.handle(),
            pipeline,
            first_group,
            group_count,
            data.len() as usize,
            data.as_ptr() as *mut c_void,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetRayTracingShaderGroupStackSizeKHR.html>
    #[inline]
    unsafe fn get_ray_tracing_shader_group_stack_size_khr(
        &self,
        pipeline: Pipeline,
        group: u32,
        group_shader: ShaderGroupShaderKHR,
    ) -> DeviceSize {
        let __result = (self.commands().get_ray_tracing_shader_group_stack_size_khr)(
            self.handle(),
            pipeline,
            group,
            group_shader,
        );

        __result
    }
}

impl KhrRayTracingPipelineExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_ray_tracing_position_fetch.html>
pub trait KhrRayTracingPositionFetchExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_RAY_TRACING_POSITION_FETCH_EXTENSION;
}

impl KhrRayTracingPositionFetchExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_relaxed_block_layout.html>
pub trait KhrRelaxedBlockLayoutExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_RELAXED_BLOCK_LAYOUT_EXTENSION;
}

impl KhrRelaxedBlockLayoutExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_sampler_mirror_clamp_to_edge.html>
pub trait KhrSamplerMirrorClampToEdgeExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION;
}

impl KhrSamplerMirrorClampToEdgeExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_sampler_ycbcr_conversion.html>
pub trait KhrSamplerYcbcrConversionExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateSamplerYcbcrConversionKHR.html>
    #[inline]
    unsafe fn create_sampler_ycbcr_conversion_khr(
        &self,
        create_info: &SamplerYcbcrConversionCreateInfo,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<SamplerYcbcrConversion> {
        let mut ycbcr_conversion = MaybeUninit::<SamplerYcbcrConversion>::uninit();

        let __result = (self.commands().create_sampler_ycbcr_conversion_khr)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            ycbcr_conversion.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(ycbcr_conversion.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySamplerYcbcrConversionKHR.html>
    #[inline]
    unsafe fn destroy_sampler_ycbcr_conversion_khr(
        &self,
        ycbcr_conversion: SamplerYcbcrConversion,
        allocator: Option<&AllocationCallbacks>,
    ) {
        let __result = (self.commands().destroy_sampler_ycbcr_conversion_khr)(
            self.handle(),
            ycbcr_conversion,
            allocator.map_or(ptr::null(), |v| v),
        );
    }
}

impl KhrSamplerYcbcrConversionExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_separate_depth_stencil_layouts.html>
pub trait KhrSeparateDepthStencilLayoutsExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION;
}

impl KhrSeparateDepthStencilLayoutsExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_shader_atomic_int64.html>
pub trait KhrShaderAtomicInt64Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_SHADER_ATOMIC_INT64_EXTENSION;
}

impl KhrShaderAtomicInt64Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_shader_clock.html>
pub trait KhrShaderClockExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_SHADER_CLOCK_EXTENSION;
}

impl KhrShaderClockExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_shader_draw_parameters.html>
pub trait KhrShaderDrawParametersExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_SHADER_DRAW_PARAMETERS_EXTENSION;
}

impl KhrShaderDrawParametersExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_shader_expect_assume.html>
pub trait KhrShaderExpectAssumeExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_SHADER_EXPECT_ASSUME_EXTENSION;
}

impl KhrShaderExpectAssumeExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_shader_float16_int8.html>
pub trait KhrShaderFloat16Int8Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_SHADER_FLOAT16_INT8_EXTENSION;
}

impl KhrShaderFloat16Int8Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_shader_float_controls.html>
pub trait KhrShaderFloatControlsExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_SHADER_FLOAT_CONTROLS_EXTENSION;
}

impl KhrShaderFloatControlsExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_shader_float_controls2.html>
pub trait KhrShaderFloatControls2Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_SHADER_FLOAT_CONTROLS2_EXTENSION;
}

impl KhrShaderFloatControls2Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_shader_integer_dot_product.html>
pub trait KhrShaderIntegerDotProductExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION;
}

impl KhrShaderIntegerDotProductExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_shader_maximal_reconvergence.html>
pub trait KhrShaderMaximalReconvergenceExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_SHADER_MAXIMAL_RECONVERGENCE_EXTENSION;
}

impl KhrShaderMaximalReconvergenceExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_shader_non_semantic_info.html>
pub trait KhrShaderNonSemanticInfoExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION;
}

impl KhrShaderNonSemanticInfoExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_shader_quad_control.html>
pub trait KhrShaderQuadControlExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_SHADER_QUAD_CONTROL_EXTENSION;
}

impl KhrShaderQuadControlExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_shader_relaxed_extended_instruction.html>
pub trait KhrShaderRelaxedExtendedInstructionExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_SHADER_RELAXED_EXTENDED_INSTRUCTION_EXTENSION;
}

impl KhrShaderRelaxedExtendedInstructionExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_shader_subgroup_extended_types.html>
pub trait KhrShaderSubgroupExtendedTypesExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION;
}

impl KhrShaderSubgroupExtendedTypesExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_shader_subgroup_rotate.html>
pub trait KhrShaderSubgroupRotateExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_SHADER_SUBGROUP_ROTATE_EXTENSION;
}

impl KhrShaderSubgroupRotateExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_shader_subgroup_uniform_control_flow.html>
pub trait KhrShaderSubgroupUniformControlFlowExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_EXTENSION;
}

impl KhrShaderSubgroupUniformControlFlowExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_shader_terminate_invocation.html>
pub trait KhrShaderTerminateInvocationExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_SHADER_TERMINATE_INVOCATION_EXTENSION;
}

impl KhrShaderTerminateInvocationExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_shared_presentable_image.html>
pub trait KhrSharedPresentableImageExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetSwapchainStatusKHR.html>
    #[inline]
    unsafe fn get_swapchain_status_khr(
        &self,
        swapchain: SwapchainKHR,
    ) -> crate::VkResult<SuccessCode> {
        let __result = (self.commands().get_swapchain_status_khr)(self.handle(), swapchain);

        if __result >= Result::SUCCESS {
            Ok(__result.into())
        } else {
            Err(__result.into())
        }
    }
}

impl KhrSharedPresentableImageExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_spirv_1_4.html>
pub trait KhrSpirv14Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_SPIRV_1_4_EXTENSION;
}

impl KhrSpirv14Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_storage_buffer_storage_class.html>
pub trait KhrStorageBufferStorageClassExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION;
}

impl KhrStorageBufferStorageClassExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_surface.html>
pub trait KhrSurfaceExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_SURFACE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySurfaceKHR.html>
    #[inline]
    unsafe fn destroy_surface_khr(
        &self,
        surface: SurfaceKHR,
        allocator: Option<&AllocationCallbacks>,
    ) {
        let __result = (self.commands().destroy_surface_khr)(
            self.handle(),
            surface,
            allocator.map_or(ptr::null(), |v| v),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceCapabilitiesKHR.html>
    #[inline]
    unsafe fn get_physical_device_surface_capabilities_khr(
        &self,
        physical_device: PhysicalDevice,
        surface: SurfaceKHR,
    ) -> crate::VkResult<SurfaceCapabilitiesKHR> {
        let mut surface_capabilities = MaybeUninit::<SurfaceCapabilitiesKHR>::uninit();

        let __result = (self.commands().get_physical_device_surface_capabilities_khr)(
            physical_device,
            surface,
            surface_capabilities.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(surface_capabilities.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceFormatsKHR.html>
    #[inline]
    unsafe fn get_physical_device_surface_formats_khr(
        &self,
        physical_device: PhysicalDevice,
        surface: SurfaceKHR,
    ) -> crate::VkResult<Vec<SurfaceFormatKHR>> {
        let mut surface_format_count = 0;

        (self.commands().get_physical_device_surface_formats_khr)(
            physical_device,
            surface,
            &mut surface_format_count,
            ptr::null_mut(),
        );

        let mut surface_formats = Vec::with_capacity(surface_format_count as usize);

        let __result = (self.commands().get_physical_device_surface_formats_khr)(
            physical_device,
            surface,
            &mut surface_format_count,
            surface_formats.as_mut_ptr(),
        );

        debug_assert!(surface_formats.capacity() == surface_format_count as usize);
        surface_formats.set_len(surface_format_count as usize);

        if __result == Result::SUCCESS {
            Ok(surface_formats)
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfacePresentModesKHR.html>
    #[inline]
    unsafe fn get_physical_device_surface_present_modes_khr(
        &self,
        physical_device: PhysicalDevice,
        surface: SurfaceKHR,
    ) -> crate::VkResult<Vec<PresentModeKHR>> {
        let mut present_mode_count = 0;

        (self
            .commands()
            .get_physical_device_surface_present_modes_khr)(
            physical_device,
            surface,
            &mut present_mode_count,
            ptr::null_mut(),
        );

        let mut present_modes = Vec::with_capacity(present_mode_count as usize);

        let __result = (self
            .commands()
            .get_physical_device_surface_present_modes_khr)(
            physical_device,
            surface,
            &mut present_mode_count,
            present_modes.as_mut_ptr(),
        );

        debug_assert!(present_modes.capacity() == present_mode_count as usize);
        present_modes.set_len(present_mode_count as usize);

        if __result == Result::SUCCESS {
            Ok(present_modes)
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceSupportKHR.html>
    #[inline]
    unsafe fn get_physical_device_surface_support_khr(
        &self,
        physical_device: PhysicalDevice,
        queue_family_index: u32,
        surface: SurfaceKHR,
    ) -> crate::VkResult<bool> {
        let mut supported = MaybeUninit::<Bool32>::uninit();

        let __result = (self.commands().get_physical_device_surface_support_khr)(
            physical_device,
            queue_family_index,
            surface,
            supported.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(supported.assume_init() == TRUE)
        } else {
            Err(__result.into())
        }
    }
}

impl KhrSurfaceExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_surface_protected_capabilities.html>
pub trait KhrSurfaceProtectedCapabilitiesExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION;
}

impl KhrSurfaceProtectedCapabilitiesExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_swapchain.html>
pub trait KhrSwapchainExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_SWAPCHAIN_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAcquireNextImage2KHR.html>
    #[inline]
    unsafe fn acquire_next_image2_khr(
        &self,
        acquire_info: &AcquireNextImageInfoKHR,
    ) -> crate::VkSuccessResult<u32> {
        let mut image_index = MaybeUninit::<u32>::uninit();

        let __result = (self.commands().acquire_next_image2_khr)(
            self.handle(),
            acquire_info,
            image_index.as_mut_ptr(),
        );

        if __result >= Result::SUCCESS {
            Ok((image_index.assume_init(), __result.into()))
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAcquireNextImageKHR.html>
    #[inline]
    unsafe fn acquire_next_image_khr(
        &self,
        swapchain: SwapchainKHR,
        timeout: u64,
        semaphore: Semaphore,
        fence: Fence,
    ) -> crate::VkSuccessResult<u32> {
        let mut image_index = MaybeUninit::<u32>::uninit();

        let __result = (self.commands().acquire_next_image_khr)(
            self.handle(),
            swapchain,
            timeout,
            semaphore,
            fence,
            image_index.as_mut_ptr(),
        );

        if __result >= Result::SUCCESS {
            Ok((image_index.assume_init(), __result.into()))
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateSwapchainKHR.html>
    #[inline]
    unsafe fn create_swapchain_khr(
        &self,
        create_info: &SwapchainCreateInfoKHR,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<SwapchainKHR> {
        let mut swapchain = MaybeUninit::<SwapchainKHR>::uninit();

        let __result = (self.commands().create_swapchain_khr)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            swapchain.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(swapchain.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySwapchainKHR.html>
    #[inline]
    unsafe fn destroy_swapchain_khr(
        &self,
        swapchain: SwapchainKHR,
        allocator: Option<&AllocationCallbacks>,
    ) {
        let __result = (self.commands().destroy_swapchain_khr)(
            self.handle(),
            swapchain,
            allocator.map_or(ptr::null(), |v| v),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceGroupPresentCapabilitiesKHR.html>
    #[inline]
    unsafe fn get_device_group_present_capabilities_khr(
        &self,
        device_group_present_capabilities: &mut DeviceGroupPresentCapabilitiesKHR,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().get_device_group_present_capabilities_khr)(
            self.handle(),
            device_group_present_capabilities,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceGroupSurfacePresentModesKHR.html>
    #[inline]
    unsafe fn get_device_group_surface_present_modes_khr(
        &self,
        surface: SurfaceKHR,
    ) -> crate::VkResult<DeviceGroupPresentModeFlagsKHR> {
        let mut modes = MaybeUninit::<DeviceGroupPresentModeFlagsKHR>::uninit();

        let __result = (self.commands().get_device_group_surface_present_modes_khr)(
            self.handle(),
            surface,
            modes.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(modes.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDevicePresentRectanglesKHR.html>
    #[inline]
    unsafe fn get_physical_device_present_rectangles_khr(
        &self,
        physical_device: PhysicalDevice,
        surface: SurfaceKHR,
    ) -> crate::VkResult<Vec<Rect2D>> {
        let mut rect_count = 0;

        (self.commands().get_physical_device_present_rectangles_khr)(
            physical_device,
            surface,
            &mut rect_count,
            ptr::null_mut(),
        );

        let mut rects = Vec::with_capacity(rect_count as usize);

        let __result = (self.commands().get_physical_device_present_rectangles_khr)(
            physical_device,
            surface,
            &mut rect_count,
            rects.as_mut_ptr(),
        );

        debug_assert!(rects.capacity() == rect_count as usize);
        rects.set_len(rect_count as usize);

        if __result == Result::SUCCESS {
            Ok(rects)
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetSwapchainImagesKHR.html>
    #[inline]
    unsafe fn get_swapchain_images_khr(
        &self,
        swapchain: SwapchainKHR,
    ) -> crate::VkResult<Vec<Image>> {
        let mut swapchain_image_count = 0;

        (self.commands().get_swapchain_images_khr)(
            self.handle(),
            swapchain,
            &mut swapchain_image_count,
            ptr::null_mut(),
        );

        let mut swapchain_images = Vec::with_capacity(swapchain_image_count as usize);

        let __result = (self.commands().get_swapchain_images_khr)(
            self.handle(),
            swapchain,
            &mut swapchain_image_count,
            swapchain_images.as_mut_ptr(),
        );

        debug_assert!(swapchain_images.capacity() == swapchain_image_count as usize);
        swapchain_images.set_len(swapchain_image_count as usize);

        if __result == Result::SUCCESS {
            Ok(swapchain_images)
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueuePresentKHR.html>
    #[inline]
    unsafe fn queue_present_khr(
        &self,
        queue: Queue,
        present_info: &PresentInfoKHR,
    ) -> crate::VkResult<SuccessCode> {
        let __result = (self.commands().queue_present_khr)(queue, present_info);

        if __result >= Result::SUCCESS {
            Ok(__result.into())
        } else {
            Err(__result.into())
        }
    }
}

impl KhrSwapchainExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_swapchain_mutable_format.html>
pub trait KhrSwapchainMutableFormatExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION;
}

impl KhrSwapchainMutableFormatExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_synchronization2.html>
pub trait KhrSynchronization2Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_SYNCHRONIZATION2_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPipelineBarrier2KHR.html>
    #[inline]
    unsafe fn cmd_pipeline_barrier2_khr(
        &self,
        command_buffer: CommandBuffer,
        dependency_info: &DependencyInfo,
    ) {
        let __result = (self.commands().cmd_pipeline_barrier2_khr)(command_buffer, dependency_info);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResetEvent2KHR.html>
    #[inline]
    unsafe fn cmd_reset_event2_khr(
        &self,
        command_buffer: CommandBuffer,
        event: Event,
        stage_mask: PipelineStageFlags2,
    ) {
        let __result = (self.commands().cmd_reset_event2_khr)(command_buffer, event, stage_mask);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetEvent2KHR.html>
    #[inline]
    unsafe fn cmd_set_event2_khr(
        &self,
        command_buffer: CommandBuffer,
        event: Event,
        dependency_info: &DependencyInfo,
    ) {
        let __result = (self.commands().cmd_set_event2_khr)(command_buffer, event, dependency_info);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWaitEvents2KHR.html>
    #[inline]
    unsafe fn cmd_wait_events2_khr(
        &self,
        command_buffer: CommandBuffer,
        events: &[Event],
        dependency_infos: &[impl Cast<Target = DependencyInfo>],
    ) {
        let __result = (self.commands().cmd_wait_events2_khr)(
            command_buffer,
            events.len() as u32,
            events.as_ptr(),
            dependency_infos.as_ptr().cast(),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWriteBufferMarker2AMD.html>
    #[inline]
    unsafe fn cmd_write_buffer_marker2_amd(
        &self,
        command_buffer: CommandBuffer,
        stage: PipelineStageFlags2,
        dst_buffer: Buffer,
        dst_offset: DeviceSize,
        marker: u32,
    ) {
        let __result = (self.commands().cmd_write_buffer_marker2_amd)(
            command_buffer,
            stage,
            dst_buffer,
            dst_offset,
            marker,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWriteTimestamp2KHR.html>
    #[inline]
    unsafe fn cmd_write_timestamp2_khr(
        &self,
        command_buffer: CommandBuffer,
        stage: PipelineStageFlags2,
        query_pool: QueryPool,
        query: u32,
    ) {
        let __result =
            (self.commands().cmd_write_timestamp2_khr)(command_buffer, stage, query_pool, query);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetQueueCheckpointData2NV.html>
    #[inline]
    unsafe fn get_queue_checkpoint_data2_nv(&self, queue: Queue) -> Vec<CheckpointData2NV> {
        let mut checkpoint_data_count = 0;

        (self.commands().get_queue_checkpoint_data2_nv)(
            queue,
            &mut checkpoint_data_count,
            ptr::null_mut(),
        );

        let mut checkpoint_data = Vec::with_capacity(checkpoint_data_count as usize);

        let __result = (self.commands().get_queue_checkpoint_data2_nv)(
            queue,
            &mut checkpoint_data_count,
            checkpoint_data.as_mut_ptr(),
        );

        debug_assert!(checkpoint_data.capacity() == checkpoint_data_count as usize);
        checkpoint_data.set_len(checkpoint_data_count as usize);

        checkpoint_data
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueSubmit2KHR.html>
    #[inline]
    unsafe fn queue_submit2_khr(
        &self,
        queue: Queue,
        submits: &[impl Cast<Target = SubmitInfo2>],
        fence: Fence,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().queue_submit2_khr)(
            queue,
            submits.len() as u32,
            submits.as_ptr().cast(),
            fence,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

impl KhrSynchronization2Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_timeline_semaphore.html>
pub trait KhrTimelineSemaphoreExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_TIMELINE_SEMAPHORE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetSemaphoreCounterValueKHR.html>
    #[inline]
    unsafe fn get_semaphore_counter_value_khr(&self, semaphore: Semaphore) -> crate::VkResult<u64> {
        let mut value = MaybeUninit::<u64>::uninit();

        let __result = (self.commands().get_semaphore_counter_value_khr)(
            self.handle(),
            semaphore,
            value.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(value.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSignalSemaphoreKHR.html>
    #[inline]
    unsafe fn signal_semaphore_khr(
        &self,
        signal_info: &SemaphoreSignalInfo,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().signal_semaphore_khr)(self.handle(), signal_info);

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkWaitSemaphoresKHR.html>
    #[inline]
    unsafe fn wait_semaphores_khr(
        &self,
        wait_info: &SemaphoreWaitInfo,
        timeout: u64,
    ) -> crate::VkResult<SuccessCode> {
        let __result = (self.commands().wait_semaphores_khr)(self.handle(), wait_info, timeout);

        if __result >= Result::SUCCESS {
            Ok(__result.into())
        } else {
            Err(__result.into())
        }
    }
}

impl KhrTimelineSemaphoreExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_uniform_buffer_standard_layout.html>
pub trait KhrUniformBufferStandardLayoutExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION;
}

impl KhrUniformBufferStandardLayoutExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_variable_pointers.html>
pub trait KhrVariablePointersExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_VARIABLE_POINTERS_EXTENSION;
}

impl KhrVariablePointersExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_vertex_attribute_divisor.html>
pub trait KhrVertexAttributeDivisorExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION;
}

impl KhrVertexAttributeDivisorExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_video_decode_av1.html>
pub trait KhrVideoDecodeAv1Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_VIDEO_DECODE_AV1_EXTENSION;
}

impl KhrVideoDecodeAv1Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_video_decode_h264.html>
pub trait KhrVideoDecodeH264Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_VIDEO_DECODE_H264_EXTENSION;
}

impl KhrVideoDecodeH264Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_video_decode_h265.html>
pub trait KhrVideoDecodeH265Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_VIDEO_DECODE_H265_EXTENSION;
}

impl KhrVideoDecodeH265Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_video_decode_queue.html>
pub trait KhrVideoDecodeQueueExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_VIDEO_DECODE_QUEUE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDecodeVideoKHR.html>
    #[inline]
    unsafe fn cmd_decode_video_khr(
        &self,
        command_buffer: CommandBuffer,
        decode_info: &VideoDecodeInfoKHR,
    ) {
        let __result = (self.commands().cmd_decode_video_khr)(command_buffer, decode_info);
    }
}

impl KhrVideoDecodeQueueExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_video_encode_h264.html>
pub trait KhrVideoEncodeH264Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_VIDEO_ENCODE_H264_EXTENSION;
}

impl KhrVideoEncodeH264Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_video_encode_h265.html>
pub trait KhrVideoEncodeH265Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_VIDEO_ENCODE_H265_EXTENSION;
}

impl KhrVideoEncodeH265Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_video_encode_queue.html>
pub trait KhrVideoEncodeQueueExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_VIDEO_ENCODE_QUEUE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEncodeVideoKHR.html>
    #[inline]
    unsafe fn cmd_encode_video_khr(
        &self,
        command_buffer: CommandBuffer,
        encode_info: &VideoEncodeInfoKHR,
    ) {
        let __result = (self.commands().cmd_encode_video_khr)(command_buffer, encode_info);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetEncodedVideoSessionParametersKHR.html>
    #[inline]
    unsafe fn get_encoded_video_session_parameters_khr(
        &self,
        video_session_parameters_info: &VideoEncodeSessionParametersGetInfoKHR,
        feedback_info: Option<&mut VideoEncodeSessionParametersFeedbackInfoKHR>,
    ) -> crate::VkResult<Vec<u8>> {
        let mut data_size = 0;

        (self.commands().get_encoded_video_session_parameters_khr)(
            self.handle(),
            video_session_parameters_info,
            ptr::null_mut(),
            &mut data_size,
            ptr::null_mut(),
        );

        let mut data = Vec::with_capacity(data_size as usize);

        let __result = (self.commands().get_encoded_video_session_parameters_khr)(
            self.handle(),
            video_session_parameters_info,
            feedback_info.map_or(ptr::null_mut(), |v| v),
            &mut data_size,
            data.as_mut_ptr() as *mut c_void,
        );

        debug_assert!(data.capacity() == data_size as usize);
        data.set_len(data_size as usize);

        if __result == Result::SUCCESS {
            Ok(data)
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR.html>
    #[inline]
    unsafe fn get_physical_device_video_encode_quality_level_properties_khr(
        &self,
        physical_device: PhysicalDevice,
        quality_level_info: &PhysicalDeviceVideoEncodeQualityLevelInfoKHR,
        quality_level_properties: &mut VideoEncodeQualityLevelPropertiesKHR,
    ) -> crate::VkResult<()> {
        let __result = (self
            .commands()
            .get_physical_device_video_encode_quality_level_properties_khr)(
            physical_device,
            quality_level_info,
            quality_level_properties,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

impl KhrVideoEncodeQueueExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_video_maintenance1.html>
pub trait KhrVideoMaintenance1Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_VIDEO_MAINTENANCE1_EXTENSION;
}

impl KhrVideoMaintenance1Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_video_queue.html>
pub trait KhrVideoQueueExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_VIDEO_QUEUE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindVideoSessionMemoryKHR.html>
    #[inline]
    unsafe fn bind_video_session_memory_khr(
        &self,
        video_session: VideoSessionKHR,
        bind_session_memory_infos: &[impl Cast<Target = BindVideoSessionMemoryInfoKHR>],
    ) -> crate::VkResult<()> {
        let __result = (self.commands().bind_video_session_memory_khr)(
            self.handle(),
            video_session,
            bind_session_memory_infos.len() as u32,
            bind_session_memory_infos.as_ptr().cast(),
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginVideoCodingKHR.html>
    #[inline]
    unsafe fn cmd_begin_video_coding_khr(
        &self,
        command_buffer: CommandBuffer,
        begin_info: &VideoBeginCodingInfoKHR,
    ) {
        let __result = (self.commands().cmd_begin_video_coding_khr)(command_buffer, begin_info);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdControlVideoCodingKHR.html>
    #[inline]
    unsafe fn cmd_control_video_coding_khr(
        &self,
        command_buffer: CommandBuffer,
        coding_control_info: &VideoCodingControlInfoKHR,
    ) {
        let __result =
            (self.commands().cmd_control_video_coding_khr)(command_buffer, coding_control_info);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndVideoCodingKHR.html>
    #[inline]
    unsafe fn cmd_end_video_coding_khr(
        &self,
        command_buffer: CommandBuffer,
        end_coding_info: &VideoEndCodingInfoKHR,
    ) {
        let __result = (self.commands().cmd_end_video_coding_khr)(command_buffer, end_coding_info);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateVideoSessionKHR.html>
    #[inline]
    unsafe fn create_video_session_khr(
        &self,
        create_info: &VideoSessionCreateInfoKHR,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<VideoSessionKHR> {
        let mut video_session = MaybeUninit::<VideoSessionKHR>::uninit();

        let __result = (self.commands().create_video_session_khr)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            video_session.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(video_session.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateVideoSessionParametersKHR.html>
    #[inline]
    unsafe fn create_video_session_parameters_khr(
        &self,
        create_info: &VideoSessionParametersCreateInfoKHR,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<VideoSessionParametersKHR> {
        let mut video_session_parameters = MaybeUninit::<VideoSessionParametersKHR>::uninit();

        let __result = (self.commands().create_video_session_parameters_khr)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            video_session_parameters.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(video_session_parameters.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyVideoSessionKHR.html>
    #[inline]
    unsafe fn destroy_video_session_khr(
        &self,
        video_session: VideoSessionKHR,
        allocator: Option<&AllocationCallbacks>,
    ) {
        let __result = (self.commands().destroy_video_session_khr)(
            self.handle(),
            video_session,
            allocator.map_or(ptr::null(), |v| v),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyVideoSessionParametersKHR.html>
    #[inline]
    unsafe fn destroy_video_session_parameters_khr(
        &self,
        video_session_parameters: VideoSessionParametersKHR,
        allocator: Option<&AllocationCallbacks>,
    ) {
        let __result = (self.commands().destroy_video_session_parameters_khr)(
            self.handle(),
            video_session_parameters,
            allocator.map_or(ptr::null(), |v| v),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceVideoCapabilitiesKHR.html>
    #[inline]
    unsafe fn get_physical_device_video_capabilities_khr(
        &self,
        physical_device: PhysicalDevice,
        video_profile: &VideoProfileInfoKHR,
        capabilities: &mut VideoCapabilitiesKHR,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().get_physical_device_video_capabilities_khr)(
            physical_device,
            video_profile,
            capabilities,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceVideoFormatPropertiesKHR.html>
    #[inline]
    unsafe fn get_physical_device_video_format_properties_khr(
        &self,
        physical_device: PhysicalDevice,
        video_format_info: &PhysicalDeviceVideoFormatInfoKHR,
    ) -> crate::VkResult<Vec<VideoFormatPropertiesKHR>> {
        let mut video_format_property_count = 0;

        (self
            .commands()
            .get_physical_device_video_format_properties_khr)(
            physical_device,
            video_format_info,
            &mut video_format_property_count,
            ptr::null_mut(),
        );

        let mut video_format_properties = Vec::with_capacity(video_format_property_count as usize);

        let __result = (self
            .commands()
            .get_physical_device_video_format_properties_khr)(
            physical_device,
            video_format_info,
            &mut video_format_property_count,
            video_format_properties.as_mut_ptr(),
        );

        debug_assert!(video_format_properties.capacity() == video_format_property_count as usize);
        video_format_properties.set_len(video_format_property_count as usize);

        if __result == Result::SUCCESS {
            Ok(video_format_properties)
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetVideoSessionMemoryRequirementsKHR.html>
    #[inline]
    unsafe fn get_video_session_memory_requirements_khr(
        &self,
        video_session: VideoSessionKHR,
    ) -> crate::VkResult<Vec<VideoSessionMemoryRequirementsKHR>> {
        let mut memory_requirements_count = 0;

        (self.commands().get_video_session_memory_requirements_khr)(
            self.handle(),
            video_session,
            &mut memory_requirements_count,
            ptr::null_mut(),
        );

        let mut memory_requirements = Vec::with_capacity(memory_requirements_count as usize);

        let __result = (self.commands().get_video_session_memory_requirements_khr)(
            self.handle(),
            video_session,
            &mut memory_requirements_count,
            memory_requirements.as_mut_ptr(),
        );

        debug_assert!(memory_requirements.capacity() == memory_requirements_count as usize);
        memory_requirements.set_len(memory_requirements_count as usize);

        if __result == Result::SUCCESS {
            Ok(memory_requirements)
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkUpdateVideoSessionParametersKHR.html>
    #[inline]
    unsafe fn update_video_session_parameters_khr(
        &self,
        video_session_parameters: VideoSessionParametersKHR,
        update_info: &VideoSessionParametersUpdateInfoKHR,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().update_video_session_parameters_khr)(
            self.handle(),
            video_session_parameters,
            update_info,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

impl KhrVideoQueueExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_vulkan_memory_model.html>
pub trait KhrVulkanMemoryModelExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_VULKAN_MEMORY_MODEL_EXTENSION;
}

impl KhrVulkanMemoryModelExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_wayland_surface.html>
pub trait KhrWaylandSurfaceExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_WAYLAND_SURFACE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateWaylandSurfaceKHR.html>
    #[inline]
    unsafe fn create_wayland_surface_khr(
        &self,
        create_info: &WaylandSurfaceCreateInfoKHR,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<SurfaceKHR> {
        let mut surface = MaybeUninit::<SurfaceKHR>::uninit();

        let __result = (self.commands().create_wayland_surface_khr)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            surface.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(surface.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceWaylandPresentationSupportKHR.html>
    #[inline]
    unsafe fn get_physical_device_wayland_presentation_support_khr(
        &self,
        physical_device: PhysicalDevice,
        queue_family_index: u32,
        display: *mut wl_display,
    ) -> Bool32 {
        let __result = (self
            .commands()
            .get_physical_device_wayland_presentation_support_khr)(
            physical_device,
            queue_family_index,
            display,
        );

        __result
    }
}

impl KhrWaylandSurfaceExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_win32_keyed_mutex.html>
pub trait KhrWin32KeyedMutexExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_WIN32_KEYED_MUTEX_EXTENSION;
}

impl KhrWin32KeyedMutexExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_win32_surface.html>
pub trait KhrWin32SurfaceExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_WIN32_SURFACE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateWin32SurfaceKHR.html>
    #[inline]
    unsafe fn create_win32_surface_khr(
        &self,
        create_info: &Win32SurfaceCreateInfoKHR,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<SurfaceKHR> {
        let mut surface = MaybeUninit::<SurfaceKHR>::uninit();

        let __result = (self.commands().create_win32_surface_khr)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            surface.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(surface.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceWin32PresentationSupportKHR.html>
    #[inline]
    unsafe fn get_physical_device_win32_presentation_support_khr(
        &self,
        physical_device: PhysicalDevice,
        queue_family_index: u32,
    ) -> Bool32 {
        let __result = (self
            .commands()
            .get_physical_device_win32_presentation_support_khr)(
            physical_device,
            queue_family_index,
        );

        __result
    }
}

impl KhrWin32SurfaceExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_workgroup_memory_explicit_layout.html>
pub trait KhrWorkgroupMemoryExplicitLayoutExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_EXTENSION;
}

impl KhrWorkgroupMemoryExplicitLayoutExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_xcb_surface.html>
pub trait KhrXcbSurfaceExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_XCB_SURFACE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateXcbSurfaceKHR.html>
    #[inline]
    unsafe fn create_xcb_surface_khr(
        &self,
        create_info: &XcbSurfaceCreateInfoKHR,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<SurfaceKHR> {
        let mut surface = MaybeUninit::<SurfaceKHR>::uninit();

        let __result = (self.commands().create_xcb_surface_khr)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            surface.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(surface.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceXcbPresentationSupportKHR.html>
    #[inline]
    unsafe fn get_physical_device_xcb_presentation_support_khr(
        &self,
        physical_device: PhysicalDevice,
        queue_family_index: u32,
        connection: *mut xcb_connection_t,
        visual_id: xcb_visualid_t,
    ) -> Bool32 {
        let __result = (self
            .commands()
            .get_physical_device_xcb_presentation_support_khr)(
            physical_device,
            queue_family_index,
            connection,
            visual_id,
        );

        __result
    }
}

impl KhrXcbSurfaceExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_xlib_surface.html>
pub trait KhrXlibSurfaceExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_XLIB_SURFACE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateXlibSurfaceKHR.html>
    #[inline]
    unsafe fn create_xlib_surface_khr(
        &self,
        create_info: &XlibSurfaceCreateInfoKHR,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<SurfaceKHR> {
        let mut surface = MaybeUninit::<SurfaceKHR>::uninit();

        let __result = (self.commands().create_xlib_surface_khr)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            surface.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(surface.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceXlibPresentationSupportKHR.html>
    #[inline]
    unsafe fn get_physical_device_xlib_presentation_support_khr(
        &self,
        physical_device: PhysicalDevice,
        queue_family_index: u32,
        visual_id: VisualID,
    ) -> (Bool32, Display) {
        let mut dpy = MaybeUninit::<Display>::uninit();

        let __result = (self
            .commands()
            .get_physical_device_xlib_presentation_support_khr)(
            physical_device,
            queue_family_index,
            dpy.as_mut_ptr(),
            visual_id,
        );

        (__result, dpy.assume_init())
    }
}

impl KhrXlibSurfaceExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_KHR_zero_initialize_workgroup_memory.html>
pub trait KhrZeroInitializeWorkgroupMemoryExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_EXTENSION;
}

impl KhrZeroInitializeWorkgroupMemoryExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_LUNARG_direct_driver_loading.html>
pub trait LunargDirectDriverLoadingExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = LUNARG_DIRECT_DRIVER_LOADING_EXTENSION;
}

impl LunargDirectDriverLoadingExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_MESA_image_alignment_control.html>
pub trait MesaImageAlignmentControlExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = MESA_IMAGE_ALIGNMENT_CONTROL_EXTENSION;
}

impl MesaImageAlignmentControlExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_MSFT_layered_driver.html>
pub trait MsftLayeredDriverExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = MSFT_LAYERED_DRIVER_EXTENSION;
}

impl MsftLayeredDriverExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_MVK_ios_surface.html>
#[deprecated(note = "deprecated in favor of `VK_EXT_metal_surface`")]
pub trait MvkIosSurfaceExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = MVK_IOS_SURFACE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateIOSSurfaceMVK.html>
    #[inline]
    unsafe fn create_ios_surface_mvk(
        &self,
        create_info: &IOSSurfaceCreateInfoMVK,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<SurfaceKHR> {
        let mut surface = MaybeUninit::<SurfaceKHR>::uninit();

        let __result = (self.commands().create_ios_surface_mvk)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            surface.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(surface.assume_init())
        } else {
            Err(__result.into())
        }
    }
}

#[allow(deprecated)]
impl MvkIosSurfaceExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_MVK_macos_surface.html>
#[deprecated(note = "deprecated in favor of `VK_EXT_metal_surface`")]
pub trait MvkMacosSurfaceExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = MVK_MACOS_SURFACE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateMacOSSurfaceMVK.html>
    #[inline]
    unsafe fn create_mac_os_surface_mvk(
        &self,
        create_info: &MacOSSurfaceCreateInfoMVK,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<SurfaceKHR> {
        let mut surface = MaybeUninit::<SurfaceKHR>::uninit();

        let __result = (self.commands().create_mac_os_surface_mvk)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            surface.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(surface.assume_init())
        } else {
            Err(__result.into())
        }
    }
}

#[allow(deprecated)]
impl MvkMacosSurfaceExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NN_vi_surface.html>
pub trait NnViSurfaceExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NN_VI_SURFACE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateViSurfaceNN.html>
    #[inline]
    unsafe fn create_vi_surface_nn(
        &self,
        create_info: &ViSurfaceCreateInfoNN,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<SurfaceKHR> {
        let mut surface = MaybeUninit::<SurfaceKHR>::uninit();

        let __result = (self.commands().create_vi_surface_nn)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            surface.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(surface.assume_init())
        } else {
            Err(__result.into())
        }
    }
}

impl NnViSurfaceExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NVX_binary_import.html>
pub trait NvxBinaryImportExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NVX_BINARY_IMPORT_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCuLaunchKernelNVX.html>
    #[inline]
    unsafe fn cmd_cu_launch_kernel_nvx(
        &self,
        command_buffer: CommandBuffer,
        launch_info: &CuLaunchInfoNVX,
    ) {
        let __result = (self.commands().cmd_cu_launch_kernel_nvx)(command_buffer, launch_info);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateCuFunctionNVX.html>
    #[inline]
    unsafe fn create_cu_function_nvx(
        &self,
        create_info: &CuFunctionCreateInfoNVX,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<CuFunctionNVX> {
        let mut function = MaybeUninit::<CuFunctionNVX>::uninit();

        let __result = (self.commands().create_cu_function_nvx)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            function.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(function.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateCuModuleNVX.html>
    #[inline]
    unsafe fn create_cu_module_nvx(
        &self,
        create_info: &CuModuleCreateInfoNVX,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<CuModuleNVX> {
        let mut module = MaybeUninit::<CuModuleNVX>::uninit();

        let __result = (self.commands().create_cu_module_nvx)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            module.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(module.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyCuFunctionNVX.html>
    #[inline]
    unsafe fn destroy_cu_function_nvx(
        &self,
        function: CuFunctionNVX,
        allocator: Option<&AllocationCallbacks>,
    ) {
        let __result = (self.commands().destroy_cu_function_nvx)(
            self.handle(),
            function,
            allocator.map_or(ptr::null(), |v| v),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyCuModuleNVX.html>
    #[inline]
    unsafe fn destroy_cu_module_nvx(
        &self,
        module: CuModuleNVX,
        allocator: Option<&AllocationCallbacks>,
    ) {
        let __result = (self.commands().destroy_cu_module_nvx)(
            self.handle(),
            module,
            allocator.map_or(ptr::null(), |v| v),
        );
    }
}

impl NvxBinaryImportExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NVX_image_view_handle.html>
pub trait NvxImageViewHandleExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NVX_IMAGE_VIEW_HANDLE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageViewAddressNVX.html>
    #[inline]
    unsafe fn get_image_view_address_nvx(
        &self,
        image_view: ImageView,
        properties: &mut ImageViewAddressPropertiesNVX,
    ) -> crate::VkResult<()> {
        let __result =
            (self.commands().get_image_view_address_nvx)(self.handle(), image_view, properties);

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageViewHandleNVX.html>
    #[inline]
    unsafe fn get_image_view_handle_nvx(&self, info: &ImageViewHandleInfoNVX) -> u32 {
        let __result = (self.commands().get_image_view_handle_nvx)(self.handle(), info);

        __result
    }
}

impl NvxImageViewHandleExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NVX_multiview_per_view_attributes.html>
pub trait NvxMultiviewPerViewAttributesExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION;
}

impl NvxMultiviewPerViewAttributesExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_acquire_winrt_display.html>
pub trait NvAcquireWinrtDisplayExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_ACQUIRE_WINRT_DISPLAY_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAcquireWinrtDisplayNV.html>
    #[inline]
    unsafe fn acquire_winrt_display_nv(
        &self,
        physical_device: PhysicalDevice,
        display: DisplayKHR,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().acquire_winrt_display_nv)(physical_device, display);

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetWinrtDisplayNV.html>
    #[inline]
    unsafe fn get_winrt_display_nv(
        &self,
        physical_device: PhysicalDevice,
        device_relative_id: u32,
    ) -> crate::VkResult<DisplayKHR> {
        let mut display = MaybeUninit::<DisplayKHR>::uninit();

        let __result = (self.commands().get_winrt_display_nv)(
            physical_device,
            device_relative_id,
            display.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(display.assume_init())
        } else {
            Err(__result.into())
        }
    }
}

impl NvAcquireWinrtDisplayExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_clip_space_w_scaling.html>
pub trait NvClipSpaceWScalingExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_CLIP_SPACE_W_SCALING_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewportWScalingNV.html>
    #[inline]
    unsafe fn cmd_set_viewport_w_scaling_nv(
        &self,
        command_buffer: CommandBuffer,
        first_viewport: u32,
        viewport_w_scalings: &[impl Cast<Target = ViewportWScalingNV>],
    ) {
        let __result = (self.commands().cmd_set_viewport_w_scaling_nv)(
            command_buffer,
            first_viewport,
            viewport_w_scalings.len() as u32,
            viewport_w_scalings.as_ptr().cast(),
        );
    }
}

impl NvClipSpaceWScalingExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_command_buffer_inheritance.html>
pub trait NvCommandBufferInheritanceExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_COMMAND_BUFFER_INHERITANCE_EXTENSION;
}

impl NvCommandBufferInheritanceExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_compute_shader_derivatives.html>
pub trait NvComputeShaderDerivativesExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION;
}

impl NvComputeShaderDerivativesExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_cooperative_matrix.html>
pub trait NvCooperativeMatrixExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_COOPERATIVE_MATRIX_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceCooperativeMatrixPropertiesNV.html>
    #[inline]
    unsafe fn get_physical_device_cooperative_matrix_properties_nv(
        &self,
        physical_device: PhysicalDevice,
    ) -> crate::VkResult<Vec<CooperativeMatrixPropertiesNV>> {
        let mut property_count = 0;

        (self
            .commands()
            .get_physical_device_cooperative_matrix_properties_nv)(
            physical_device,
            &mut property_count,
            ptr::null_mut(),
        );

        let mut properties = Vec::with_capacity(property_count as usize);

        let __result = (self
            .commands()
            .get_physical_device_cooperative_matrix_properties_nv)(
            physical_device,
            &mut property_count,
            properties.as_mut_ptr(),
        );

        debug_assert!(properties.capacity() == property_count as usize);
        properties.set_len(property_count as usize);

        if __result == Result::SUCCESS {
            Ok(properties)
        } else {
            Err(__result.into())
        }
    }
}

impl NvCooperativeMatrixExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_copy_memory_indirect.html>
pub trait NvCopyMemoryIndirectExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_COPY_MEMORY_INDIRECT_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyMemoryIndirectNV.html>
    #[inline]
    unsafe fn cmd_copy_memory_indirect_nv(
        &self,
        command_buffer: CommandBuffer,
        copy_buffer_address: DeviceAddress,
        copy_count: u32,
        stride: u32,
    ) {
        let __result = (self.commands().cmd_copy_memory_indirect_nv)(
            command_buffer,
            copy_buffer_address,
            copy_count,
            stride,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyMemoryToImageIndirectNV.html>
    #[inline]
    unsafe fn cmd_copy_memory_to_image_indirect_nv(
        &self,
        command_buffer: CommandBuffer,
        copy_buffer_address: DeviceAddress,
        copy_count: u32,
        stride: u32,
        dst_image: Image,
        dst_image_layout: ImageLayout,
        image_subresources: &[impl Cast<Target = ImageSubresourceLayers>],
    ) {
        let __result = (self.commands().cmd_copy_memory_to_image_indirect_nv)(
            command_buffer,
            copy_buffer_address,
            copy_count,
            stride,
            dst_image,
            dst_image_layout,
            image_subresources.as_ptr().cast(),
        );
    }
}

impl NvCopyMemoryIndirectExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_corner_sampled_image.html>
pub trait NvCornerSampledImageExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_CORNER_SAMPLED_IMAGE_EXTENSION;
}

impl NvCornerSampledImageExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_coverage_reduction_mode.html>
pub trait NvCoverageReductionModeExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_COVERAGE_REDUCTION_MODE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV.html>
    #[inline]
    unsafe fn get_physical_device_supported_framebuffer_mixed_samples_combinations_nv(
        &self,
        physical_device: PhysicalDevice,
    ) -> crate::VkResult<Vec<FramebufferMixedSamplesCombinationNV>> {
        let mut combination_count = 0;

        (self
            .commands()
            .get_physical_device_supported_framebuffer_mixed_samples_combinations_nv)(
            physical_device,
            &mut combination_count,
            ptr::null_mut(),
        );

        let mut combinations = Vec::with_capacity(combination_count as usize);

        let __result = (self
            .commands()
            .get_physical_device_supported_framebuffer_mixed_samples_combinations_nv)(
            physical_device,
            &mut combination_count,
            combinations.as_mut_ptr(),
        );

        debug_assert!(combinations.capacity() == combination_count as usize);
        combinations.set_len(combination_count as usize);

        if __result == Result::SUCCESS {
            Ok(combinations)
        } else {
            Err(__result.into())
        }
    }
}

impl NvCoverageReductionModeExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_cuda_kernel_launch.html>
///
/// ## WARNING
///
/// This is a
/// [provisional extension](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/provisional-headers.html).
/// Provisional extensions are not guaranteed to be backwards compatible and are
/// not intended to be used in production applications.
#[cfg(feature = "provisional")]
pub trait NvCudaKernelLaunchExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_CUDA_KERNEL_LAUNCH_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCudaLaunchKernelNV.html>
    #[inline]
    unsafe fn cmd_cuda_launch_kernel_nv(
        &self,
        command_buffer: CommandBuffer,
        launch_info: &CudaLaunchInfoNV,
    ) {
        let __result = (self.commands().cmd_cuda_launch_kernel_nv)(command_buffer, launch_info);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateCudaFunctionNV.html>
    #[inline]
    unsafe fn create_cuda_function_nv(
        &self,
        create_info: &CudaFunctionCreateInfoNV,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<CudaFunctionNV> {
        let mut function = MaybeUninit::<CudaFunctionNV>::uninit();

        let __result = (self.commands().create_cuda_function_nv)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            function.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(function.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateCudaModuleNV.html>
    #[inline]
    unsafe fn create_cuda_module_nv(
        &self,
        create_info: &CudaModuleCreateInfoNV,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<CudaModuleNV> {
        let mut module = MaybeUninit::<CudaModuleNV>::uninit();

        let __result = (self.commands().create_cuda_module_nv)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            module.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(module.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyCudaFunctionNV.html>
    #[inline]
    unsafe fn destroy_cuda_function_nv(
        &self,
        function: CudaFunctionNV,
        allocator: Option<&AllocationCallbacks>,
    ) {
        let __result = (self.commands().destroy_cuda_function_nv)(
            self.handle(),
            function,
            allocator.map_or(ptr::null(), |v| v),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyCudaModuleNV.html>
    #[inline]
    unsafe fn destroy_cuda_module_nv(
        &self,
        module: CudaModuleNV,
        allocator: Option<&AllocationCallbacks>,
    ) {
        let __result = (self.commands().destroy_cuda_module_nv)(
            self.handle(),
            module,
            allocator.map_or(ptr::null(), |v| v),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetCudaModuleCacheNV.html>
    #[inline]
    unsafe fn get_cuda_module_cache_nv(&self, module: CudaModuleNV) -> crate::VkResult<Vec<u8>> {
        let mut cache_size = 0;

        (self.commands().get_cuda_module_cache_nv)(
            self.handle(),
            module,
            &mut cache_size,
            ptr::null_mut(),
        );

        let mut cache_data = Vec::with_capacity(cache_size as usize);

        let __result = (self.commands().get_cuda_module_cache_nv)(
            self.handle(),
            module,
            &mut cache_size,
            cache_data.as_mut_ptr() as *mut c_void,
        );

        debug_assert!(cache_data.capacity() == cache_size as usize);
        cache_data.set_len(cache_size as usize);

        if __result == Result::SUCCESS {
            Ok(cache_data)
        } else {
            Err(__result.into())
        }
    }
}

#[cfg(feature = "provisional")]
impl NvCudaKernelLaunchExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_dedicated_allocation.html>
#[deprecated(note = "deprecated in favor of `VK_KHR_dedicated_allocation`")]
pub trait NvDedicatedAllocationExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_DEDICATED_ALLOCATION_EXTENSION;
}

#[allow(deprecated)]
impl NvDedicatedAllocationExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_dedicated_allocation_image_aliasing.html>
pub trait NvDedicatedAllocationImageAliasingExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION;
}

impl NvDedicatedAllocationImageAliasingExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_descriptor_pool_overallocation.html>
pub trait NvDescriptorPoolOverallocationExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_DESCRIPTOR_POOL_OVERALLOCATION_EXTENSION;
}

impl NvDescriptorPoolOverallocationExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_device_diagnostic_checkpoints.html>
pub trait NvDeviceDiagnosticCheckpointsExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCheckpointNV.html>
    #[inline]
    unsafe fn cmd_set_checkpoint_nv(
        &self,
        command_buffer: CommandBuffer,
        checkpoint_marker: &c_void,
    ) {
        let __result = (self.commands().cmd_set_checkpoint_nv)(command_buffer, checkpoint_marker);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetQueueCheckpointDataNV.html>
    #[inline]
    unsafe fn get_queue_checkpoint_data_nv(&self, queue: Queue) -> Vec<CheckpointDataNV> {
        let mut checkpoint_data_count = 0;

        (self.commands().get_queue_checkpoint_data_nv)(
            queue,
            &mut checkpoint_data_count,
            ptr::null_mut(),
        );

        let mut checkpoint_data = Vec::with_capacity(checkpoint_data_count as usize);

        let __result = (self.commands().get_queue_checkpoint_data_nv)(
            queue,
            &mut checkpoint_data_count,
            checkpoint_data.as_mut_ptr(),
        );

        debug_assert!(checkpoint_data.capacity() == checkpoint_data_count as usize);
        checkpoint_data.set_len(checkpoint_data_count as usize);

        checkpoint_data
    }
}

impl NvDeviceDiagnosticCheckpointsExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_device_diagnostics_config.html>
pub trait NvDeviceDiagnosticsConfigExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_DEVICE_DIAGNOSTICS_CONFIG_EXTENSION;
}

impl NvDeviceDiagnosticsConfigExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_device_generated_commands.html>
pub trait NvDeviceGeneratedCommandsExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_DEVICE_GENERATED_COMMANDS_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindPipelineShaderGroupNV.html>
    #[inline]
    unsafe fn cmd_bind_pipeline_shader_group_nv(
        &self,
        command_buffer: CommandBuffer,
        pipeline_bind_point: PipelineBindPoint,
        pipeline: Pipeline,
        group_index: u32,
    ) {
        let __result = (self.commands().cmd_bind_pipeline_shader_group_nv)(
            command_buffer,
            pipeline_bind_point,
            pipeline,
            group_index,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdExecuteGeneratedCommandsNV.html>
    #[inline]
    unsafe fn cmd_execute_generated_commands_nv(
        &self,
        command_buffer: CommandBuffer,
        is_preprocessed: bool,
        generated_commands_info: &GeneratedCommandsInfoNV,
    ) {
        let __result = (self.commands().cmd_execute_generated_commands_nv)(
            command_buffer,
            is_preprocessed as Bool32,
            generated_commands_info,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPreprocessGeneratedCommandsNV.html>
    #[inline]
    unsafe fn cmd_preprocess_generated_commands_nv(
        &self,
        command_buffer: CommandBuffer,
        generated_commands_info: &GeneratedCommandsInfoNV,
    ) {
        let __result = (self.commands().cmd_preprocess_generated_commands_nv)(
            command_buffer,
            generated_commands_info,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateIndirectCommandsLayoutNV.html>
    #[inline]
    unsafe fn create_indirect_commands_layout_nv(
        &self,
        create_info: &IndirectCommandsLayoutCreateInfoNV,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<IndirectCommandsLayoutNV> {
        let mut indirect_commands_layout = MaybeUninit::<IndirectCommandsLayoutNV>::uninit();

        let __result = (self.commands().create_indirect_commands_layout_nv)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            indirect_commands_layout.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(indirect_commands_layout.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyIndirectCommandsLayoutNV.html>
    #[inline]
    unsafe fn destroy_indirect_commands_layout_nv(
        &self,
        indirect_commands_layout: IndirectCommandsLayoutNV,
        allocator: Option<&AllocationCallbacks>,
    ) {
        let __result = (self.commands().destroy_indirect_commands_layout_nv)(
            self.handle(),
            indirect_commands_layout,
            allocator.map_or(ptr::null(), |v| v),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetGeneratedCommandsMemoryRequirementsNV.html>
    #[inline]
    unsafe fn get_generated_commands_memory_requirements_nv(
        &self,
        info: &GeneratedCommandsMemoryRequirementsInfoNV,
        memory_requirements: &mut MemoryRequirements2,
    ) {
        let __result = (self
            .commands()
            .get_generated_commands_memory_requirements_nv)(
            self.handle(),
            info,
            memory_requirements,
        );
    }
}

impl NvDeviceGeneratedCommandsExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_device_generated_commands_compute.html>
pub trait NvDeviceGeneratedCommandsComputeExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_DEVICE_GENERATED_COMMANDS_COMPUTE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdUpdatePipelineIndirectBufferNV.html>
    #[inline]
    unsafe fn cmd_update_pipeline_indirect_buffer_nv(
        &self,
        command_buffer: CommandBuffer,
        pipeline_bind_point: PipelineBindPoint,
        pipeline: Pipeline,
    ) {
        let __result = (self.commands().cmd_update_pipeline_indirect_buffer_nv)(
            command_buffer,
            pipeline_bind_point,
            pipeline,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPipelineIndirectDeviceAddressNV.html>
    #[inline]
    unsafe fn get_pipeline_indirect_device_address_nv(
        &self,
        info: &PipelineIndirectDeviceAddressInfoNV,
    ) -> DeviceAddress {
        let __result =
            (self.commands().get_pipeline_indirect_device_address_nv)(self.handle(), info);

        __result
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPipelineIndirectMemoryRequirementsNV.html>
    #[inline]
    unsafe fn get_pipeline_indirect_memory_requirements_nv(
        &self,
        create_info: &ComputePipelineCreateInfo,
        memory_requirements: &mut MemoryRequirements2,
    ) {
        let __result = (self.commands().get_pipeline_indirect_memory_requirements_nv)(
            self.handle(),
            create_info,
            memory_requirements,
        );
    }
}

impl NvDeviceGeneratedCommandsComputeExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_displacement_micromap.html>
///
/// ## WARNING
///
/// This is a
/// [provisional extension](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/provisional-headers.html).
/// Provisional extensions are not guaranteed to be backwards compatible and are
/// not intended to be used in production applications.
#[cfg(feature = "provisional")]
pub trait NvDisplacementMicromapExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_DISPLACEMENT_MICROMAP_EXTENSION;
}

#[cfg(feature = "provisional")]
impl NvDisplacementMicromapExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_extended_sparse_address_space.html>
pub trait NvExtendedSparseAddressSpaceExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_EXTENDED_SPARSE_ADDRESS_SPACE_EXTENSION;
}

impl NvExtendedSparseAddressSpaceExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_external_memory.html>
#[deprecated(note = "deprecated in favor of `VK_KHR_external_memory`")]
pub trait NvExternalMemoryExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_EXTERNAL_MEMORY_EXTENSION;
}

#[allow(deprecated)]
impl NvExternalMemoryExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_external_memory_capabilities.html>
#[deprecated(note = "deprecated in favor of `VK_KHR_external_memory_capabilities`")]
pub trait NvExternalMemoryCapabilitiesExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceExternalImageFormatPropertiesNV.html>
    #[inline]
    unsafe fn get_physical_device_external_image_format_properties_nv(
        &self,
        physical_device: PhysicalDevice,
        format: Format,
        type_: ImageType,
        tiling: ImageTiling,
        usage: ImageUsageFlags,
        flags: ImageCreateFlags,
        external_handle_type: ExternalMemoryHandleTypeFlagsNV,
    ) -> crate::VkResult<ExternalImageFormatPropertiesNV> {
        let mut external_image_format_properties =
            MaybeUninit::<ExternalImageFormatPropertiesNV>::uninit();

        let __result = (self
            .commands()
            .get_physical_device_external_image_format_properties_nv)(
            physical_device,
            format,
            type_,
            tiling,
            usage,
            flags,
            external_handle_type,
            external_image_format_properties.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(external_image_format_properties.assume_init())
        } else {
            Err(__result.into())
        }
    }
}

#[allow(deprecated)]
impl NvExternalMemoryCapabilitiesExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_external_memory_rdma.html>
pub trait NvExternalMemoryRdmaExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_EXTERNAL_MEMORY_RDMA_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetMemoryRemoteAddressNV.html>
    #[inline]
    unsafe fn get_memory_remote_address_nv(
        &self,
        memory_get_remote_address_info: &MemoryGetRemoteAddressInfoNV,
    ) -> crate::VkResult<RemoteAddressNV> {
        let mut address = MaybeUninit::<RemoteAddressNV>::uninit();

        let __result = (self.commands().get_memory_remote_address_nv)(
            self.handle(),
            memory_get_remote_address_info,
            address.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(address.assume_init())
        } else {
            Err(__result.into())
        }
    }
}

impl NvExternalMemoryRdmaExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_external_memory_sci_buf.html>
pub trait NvExternalMemorySciBufExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_EXTERNAL_MEMORY_SCI_BUF_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetMemorySciBufNV.html>
    #[inline]
    unsafe fn get_memory_sci_buf_nv(
        &self,
        get_sci_buf_info: &MemoryGetSciBufInfoNV,
    ) -> crate::VkResult<NvSciBufObj> {
        let mut handle = MaybeUninit::<NvSciBufObj>::uninit();

        let __result = (self.commands().get_memory_sci_buf_nv)(
            self.handle(),
            get_sci_buf_info,
            handle.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(handle.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV.html>
    #[inline]
    unsafe fn get_physical_device_external_memory_sci_buf_properties_nv(
        &self,
        physical_device: PhysicalDevice,
        handle_type: ExternalMemoryHandleTypeFlags,
        handle: NvSciBufObj,
        memory_sci_buf_properties: &mut MemorySciBufPropertiesNV,
    ) -> crate::VkResult<()> {
        let __result = (self
            .commands()
            .get_physical_device_external_memory_sci_buf_properties_nv)(
            physical_device,
            handle_type,
            handle,
            memory_sci_buf_properties,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSciBufAttributesNV.html>
    #[inline]
    unsafe fn get_physical_device_sci_buf_attributes_nv(
        &self,
        physical_device: PhysicalDevice,
        attributes: NvSciBufAttrList,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().get_physical_device_sci_buf_attributes_nv)(
            physical_device,
            attributes,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

impl NvExternalMemorySciBufExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_external_memory_win32.html>
#[deprecated(note = "deprecated in favor of `VK_KHR_external_memory_win32`")]
pub trait NvExternalMemoryWin32Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_EXTERNAL_MEMORY_WIN32_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetMemoryWin32HandleNV.html>
    #[inline]
    unsafe fn get_memory_win32_handle_nv(
        &self,
        memory: DeviceMemory,
        handle_type: ExternalMemoryHandleTypeFlagsNV,
    ) -> crate::VkResult<HANDLE> {
        let mut handle = MaybeUninit::<HANDLE>::uninit();

        let __result = (self.commands().get_memory_win32_handle_nv)(
            self.handle(),
            memory,
            handle_type,
            handle.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(handle.assume_init())
        } else {
            Err(__result.into())
        }
    }
}

#[allow(deprecated)]
impl NvExternalMemoryWin32Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_external_sci_sync.html>
#[deprecated(note = "deprecated in favor of `VK_NV_external_sci_sync2`")]
pub trait NvExternalSciSyncExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_EXTERNAL_SCI_SYNC_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetFenceSciSyncFenceNV.html>
    #[inline]
    unsafe fn get_fence_sci_sync_fence_nv(
        &self,
        get_sci_sync_handle_info: &FenceGetSciSyncInfoNV,
    ) -> crate::VkResult<c_void> {
        let mut handle = MaybeUninit::<c_void>::uninit();

        let __result = (self.commands().get_fence_sci_sync_fence_nv)(
            self.handle(),
            get_sci_sync_handle_info,
            handle.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(handle.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetFenceSciSyncObjNV.html>
    #[inline]
    unsafe fn get_fence_sci_sync_obj_nv(
        &self,
        get_sci_sync_handle_info: &FenceGetSciSyncInfoNV,
    ) -> crate::VkResult<c_void> {
        let mut handle = MaybeUninit::<c_void>::uninit();

        let __result = (self.commands().get_fence_sci_sync_obj_nv)(
            self.handle(),
            get_sci_sync_handle_info,
            handle.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(handle.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSciSyncAttributesNV.html>
    #[inline]
    unsafe fn get_physical_device_sci_sync_attributes_nv(
        &self,
        physical_device: PhysicalDevice,
        sci_sync_attributes_info: &SciSyncAttributesInfoNV,
        attributes: NvSciSyncAttrList,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().get_physical_device_sci_sync_attributes_nv)(
            physical_device,
            sci_sync_attributes_info,
            attributes,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetSemaphoreSciSyncObjNV.html>
    #[inline]
    unsafe fn get_semaphore_sci_sync_obj_nv(
        &self,
        get_sci_sync_info: &SemaphoreGetSciSyncInfoNV,
    ) -> crate::VkResult<c_void> {
        let mut handle = MaybeUninit::<c_void>::uninit();

        let __result = (self.commands().get_semaphore_sci_sync_obj_nv)(
            self.handle(),
            get_sci_sync_info,
            handle.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(handle.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkImportFenceSciSyncFenceNV.html>
    #[inline]
    unsafe fn import_fence_sci_sync_fence_nv(
        &self,
        import_fence_sci_sync_info: &ImportFenceSciSyncInfoNV,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().import_fence_sci_sync_fence_nv)(
            self.handle(),
            import_fence_sci_sync_info,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkImportFenceSciSyncObjNV.html>
    #[inline]
    unsafe fn import_fence_sci_sync_obj_nv(
        &self,
        import_fence_sci_sync_info: &ImportFenceSciSyncInfoNV,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().import_fence_sci_sync_obj_nv)(
            self.handle(),
            import_fence_sci_sync_info,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkImportSemaphoreSciSyncObjNV.html>
    #[inline]
    unsafe fn import_semaphore_sci_sync_obj_nv(
        &self,
        import_semaphore_sci_sync_info: &ImportSemaphoreSciSyncInfoNV,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().import_semaphore_sci_sync_obj_nv)(
            self.handle(),
            import_semaphore_sci_sync_info,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

#[allow(deprecated)]
impl NvExternalSciSyncExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_external_sci_sync2.html>
pub trait NvExternalSciSync2Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_EXTERNAL_SCI_SYNC2_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateSemaphoreSciSyncPoolNV.html>
    #[inline]
    unsafe fn create_semaphore_sci_sync_pool_nv(
        &self,
        create_info: &SemaphoreSciSyncPoolCreateInfoNV,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<SemaphoreSciSyncPoolNV> {
        let mut semaphore_pool = MaybeUninit::<SemaphoreSciSyncPoolNV>::uninit();

        let __result = (self.commands().create_semaphore_sci_sync_pool_nv)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            semaphore_pool.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(semaphore_pool.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySemaphoreSciSyncPoolNV.html>
    #[inline]
    unsafe fn destroy_semaphore_sci_sync_pool_nv(
        &self,
        semaphore_pool: SemaphoreSciSyncPoolNV,
        allocator: Option<&AllocationCallbacks>,
    ) {
        let __result = (self.commands().destroy_semaphore_sci_sync_pool_nv)(
            self.handle(),
            semaphore_pool,
            allocator.map_or(ptr::null(), |v| v),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetFenceSciSyncFenceNV.html>
    #[inline]
    unsafe fn get_fence_sci_sync_fence_nv(
        &self,
        get_sci_sync_handle_info: &FenceGetSciSyncInfoNV,
    ) -> crate::VkResult<c_void> {
        let mut handle = MaybeUninit::<c_void>::uninit();

        let __result = (self.commands().get_fence_sci_sync_fence_nv)(
            self.handle(),
            get_sci_sync_handle_info,
            handle.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(handle.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetFenceSciSyncObjNV.html>
    #[inline]
    unsafe fn get_fence_sci_sync_obj_nv(
        &self,
        get_sci_sync_handle_info: &FenceGetSciSyncInfoNV,
    ) -> crate::VkResult<c_void> {
        let mut handle = MaybeUninit::<c_void>::uninit();

        let __result = (self.commands().get_fence_sci_sync_obj_nv)(
            self.handle(),
            get_sci_sync_handle_info,
            handle.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(handle.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSciSyncAttributesNV.html>
    #[inline]
    unsafe fn get_physical_device_sci_sync_attributes_nv(
        &self,
        physical_device: PhysicalDevice,
        sci_sync_attributes_info: &SciSyncAttributesInfoNV,
        attributes: NvSciSyncAttrList,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().get_physical_device_sci_sync_attributes_nv)(
            physical_device,
            sci_sync_attributes_info,
            attributes,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkImportFenceSciSyncFenceNV.html>
    #[inline]
    unsafe fn import_fence_sci_sync_fence_nv(
        &self,
        import_fence_sci_sync_info: &ImportFenceSciSyncInfoNV,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().import_fence_sci_sync_fence_nv)(
            self.handle(),
            import_fence_sci_sync_info,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkImportFenceSciSyncObjNV.html>
    #[inline]
    unsafe fn import_fence_sci_sync_obj_nv(
        &self,
        import_fence_sci_sync_info: &ImportFenceSciSyncInfoNV,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().import_fence_sci_sync_obj_nv)(
            self.handle(),
            import_fence_sci_sync_info,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

impl NvExternalSciSync2Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_fill_rectangle.html>
pub trait NvFillRectangleExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_FILL_RECTANGLE_EXTENSION;
}

impl NvFillRectangleExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_fragment_coverage_to_color.html>
pub trait NvFragmentCoverageToColorExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION;
}

impl NvFragmentCoverageToColorExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_fragment_shader_barycentric.html>
pub trait NvFragmentShaderBarycentricExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION;
}

impl NvFragmentShaderBarycentricExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_fragment_shading_rate_enums.html>
pub trait NvFragmentShadingRateEnumsExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_FRAGMENT_SHADING_RATE_ENUMS_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetFragmentShadingRateEnumNV.html>
    #[inline]
    unsafe fn cmd_set_fragment_shading_rate_enum_nv(
        &self,
        command_buffer: CommandBuffer,
        shading_rate: FragmentShadingRateNV,
        combiner_ops: [FragmentShadingRateCombinerOpKHR; 2],
    ) {
        let __result = (self.commands().cmd_set_fragment_shading_rate_enum_nv)(
            command_buffer,
            shading_rate,
            combiner_ops.as_ptr(),
        );
    }
}

impl NvFragmentShadingRateEnumsExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_framebuffer_mixed_samples.html>
pub trait NvFramebufferMixedSamplesExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION;
}

impl NvFramebufferMixedSamplesExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_geometry_shader_passthrough.html>
pub trait NvGeometryShaderPassthroughExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION;
}

impl NvGeometryShaderPassthroughExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_glsl_shader.html>
#[deprecated]
pub trait NvGlslShaderExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_GLSL_SHADER_EXTENSION;
}

#[allow(deprecated)]
impl NvGlslShaderExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_inherited_viewport_scissor.html>
pub trait NvInheritedViewportScissorExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_INHERITED_VIEWPORT_SCISSOR_EXTENSION;
}

impl NvInheritedViewportScissorExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_linear_color_attachment.html>
pub trait NvLinearColorAttachmentExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_LINEAR_COLOR_ATTACHMENT_EXTENSION;
}

impl NvLinearColorAttachmentExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_low_latency.html>
pub trait NvLowLatencyExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_LOW_LATENCY_EXTENSION;
}

impl NvLowLatencyExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_low_latency2.html>
pub trait NvLowLatency2Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_LOW_LATENCY2_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetLatencyTimingsNV.html>
    #[inline]
    unsafe fn get_latency_timings_nv(
        &self,
        swapchain: SwapchainKHR,
        latency_marker_info: &mut GetLatencyMarkerInfoNV,
    ) {
        let __result =
            (self.commands().get_latency_timings_nv)(self.handle(), swapchain, latency_marker_info);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkLatencySleepNV.html>
    #[inline]
    unsafe fn latency_sleep_nv(
        &self,
        swapchain: SwapchainKHR,
        sleep_info: &LatencySleepInfoNV,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().latency_sleep_nv)(self.handle(), swapchain, sleep_info);

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueNotifyOutOfBandNV.html>
    #[inline]
    unsafe fn queue_notify_out_of_band_nv(
        &self,
        queue: Queue,
        queue_type_info: &OutOfBandQueueTypeInfoNV,
    ) {
        let __result = (self.commands().queue_notify_out_of_band_nv)(queue, queue_type_info);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetLatencyMarkerNV.html>
    #[inline]
    unsafe fn set_latency_marker_nv(
        &self,
        swapchain: SwapchainKHR,
        latency_marker_info: &SetLatencyMarkerInfoNV,
    ) {
        let __result =
            (self.commands().set_latency_marker_nv)(self.handle(), swapchain, latency_marker_info);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetLatencySleepModeNV.html>
    #[inline]
    unsafe fn set_latency_sleep_mode_nv(
        &self,
        swapchain: SwapchainKHR,
        sleep_mode_info: &LatencySleepModeInfoNV,
    ) -> crate::VkResult<()> {
        let __result =
            (self.commands().set_latency_sleep_mode_nv)(self.handle(), swapchain, sleep_mode_info);

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

impl NvLowLatency2Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_memory_decompression.html>
pub trait NvMemoryDecompressionExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_MEMORY_DECOMPRESSION_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDecompressMemoryIndirectCountNV.html>
    #[inline]
    unsafe fn cmd_decompress_memory_indirect_count_nv(
        &self,
        command_buffer: CommandBuffer,
        indirect_commands_address: DeviceAddress,
        indirect_commands_count_address: DeviceAddress,
        stride: u32,
    ) {
        let __result = (self.commands().cmd_decompress_memory_indirect_count_nv)(
            command_buffer,
            indirect_commands_address,
            indirect_commands_count_address,
            stride,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDecompressMemoryNV.html>
    #[inline]
    unsafe fn cmd_decompress_memory_nv(
        &self,
        command_buffer: CommandBuffer,
        decompress_memory_regions: &[impl Cast<Target = DecompressMemoryRegionNV>],
    ) {
        let __result = (self.commands().cmd_decompress_memory_nv)(
            command_buffer,
            decompress_memory_regions.len() as u32,
            decompress_memory_regions.as_ptr().cast(),
        );
    }
}

impl NvMemoryDecompressionExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_mesh_shader.html>
pub trait NvMeshShaderExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_MESH_SHADER_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMeshTasksIndirectCountNV.html>
    #[inline]
    unsafe fn cmd_draw_mesh_tasks_indirect_count_nv(
        &self,
        command_buffer: CommandBuffer,
        buffer: Buffer,
        offset: DeviceSize,
        count_buffer: Buffer,
        count_buffer_offset: DeviceSize,
        max_draw_count: u32,
        stride: u32,
    ) {
        let __result = (self.commands().cmd_draw_mesh_tasks_indirect_count_nv)(
            command_buffer,
            buffer,
            offset,
            count_buffer,
            count_buffer_offset,
            max_draw_count,
            stride,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMeshTasksIndirectNV.html>
    #[inline]
    unsafe fn cmd_draw_mesh_tasks_indirect_nv(
        &self,
        command_buffer: CommandBuffer,
        buffer: Buffer,
        offset: DeviceSize,
        draw_count: u32,
        stride: u32,
    ) {
        let __result = (self.commands().cmd_draw_mesh_tasks_indirect_nv)(
            command_buffer,
            buffer,
            offset,
            draw_count,
            stride,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMeshTasksNV.html>
    #[inline]
    unsafe fn cmd_draw_mesh_tasks_nv(
        &self,
        command_buffer: CommandBuffer,
        task_count: u32,
        first_task: u32,
    ) {
        let __result =
            (self.commands().cmd_draw_mesh_tasks_nv)(command_buffer, task_count, first_task);
    }
}

impl NvMeshShaderExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_optical_flow.html>
pub trait NvOpticalFlowExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_OPTICAL_FLOW_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindOpticalFlowSessionImageNV.html>
    #[inline]
    unsafe fn bind_optical_flow_session_image_nv(
        &self,
        session: OpticalFlowSessionNV,
        binding_point: OpticalFlowSessionBindingPointNV,
        view: ImageView,
        layout: ImageLayout,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().bind_optical_flow_session_image_nv)(
            self.handle(),
            session,
            binding_point,
            view,
            layout,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdOpticalFlowExecuteNV.html>
    #[inline]
    unsafe fn cmd_optical_flow_execute_nv(
        &self,
        command_buffer: CommandBuffer,
        session: OpticalFlowSessionNV,
        execute_info: &OpticalFlowExecuteInfoNV,
    ) {
        let __result =
            (self.commands().cmd_optical_flow_execute_nv)(command_buffer, session, execute_info);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateOpticalFlowSessionNV.html>
    #[inline]
    unsafe fn create_optical_flow_session_nv(
        &self,
        create_info: &OpticalFlowSessionCreateInfoNV,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<OpticalFlowSessionNV> {
        let mut session = MaybeUninit::<OpticalFlowSessionNV>::uninit();

        let __result = (self.commands().create_optical_flow_session_nv)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            session.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(session.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyOpticalFlowSessionNV.html>
    #[inline]
    unsafe fn destroy_optical_flow_session_nv(
        &self,
        session: OpticalFlowSessionNV,
        allocator: Option<&AllocationCallbacks>,
    ) {
        let __result = (self.commands().destroy_optical_flow_session_nv)(
            self.handle(),
            session,
            allocator.map_or(ptr::null(), |v| v),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceOpticalFlowImageFormatsNV.html>
    #[inline]
    unsafe fn get_physical_device_optical_flow_image_formats_nv(
        &self,
        physical_device: PhysicalDevice,
        optical_flow_image_format_info: &OpticalFlowImageFormatInfoNV,
    ) -> crate::VkResult<Vec<OpticalFlowImageFormatPropertiesNV>> {
        let mut format_count = 0;

        (self
            .commands()
            .get_physical_device_optical_flow_image_formats_nv)(
            physical_device,
            optical_flow_image_format_info,
            &mut format_count,
            ptr::null_mut(),
        );

        let mut image_format_properties = Vec::with_capacity(format_count as usize);

        let __result = (self
            .commands()
            .get_physical_device_optical_flow_image_formats_nv)(
            physical_device,
            optical_flow_image_format_info,
            &mut format_count,
            image_format_properties.as_mut_ptr(),
        );

        debug_assert!(image_format_properties.capacity() == format_count as usize);
        image_format_properties.set_len(format_count as usize);

        if __result == Result::SUCCESS {
            Ok(image_format_properties)
        } else {
            Err(__result.into())
        }
    }
}

impl NvOpticalFlowExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_per_stage_descriptor_set.html>
pub trait NvPerStageDescriptorSetExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_PER_STAGE_DESCRIPTOR_SET_EXTENSION;
}

impl NvPerStageDescriptorSetExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_present_barrier.html>
pub trait NvPresentBarrierExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_PRESENT_BARRIER_EXTENSION;
}

impl NvPresentBarrierExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_private_vendor_info.html>
pub trait NvPrivateVendorInfoExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_PRIVATE_VENDOR_INFO_EXTENSION;
}

impl NvPrivateVendorInfoExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_raw_access_chains.html>
pub trait NvRawAccessChainsExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_RAW_ACCESS_CHAINS_EXTENSION;
}

impl NvRawAccessChainsExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_ray_tracing.html>
#[deprecated(note = "deprecated in favor of `VK_KHR_ray_tracing_pipeline`")]
pub trait NvRayTracingExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_RAY_TRACING_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindAccelerationStructureMemoryNV.html>
    #[inline]
    unsafe fn bind_acceleration_structure_memory_nv(
        &self,
        bind_infos: &[impl Cast<Target = BindAccelerationStructureMemoryInfoNV>],
    ) -> crate::VkResult<()> {
        let __result = (self.commands().bind_acceleration_structure_memory_nv)(
            self.handle(),
            bind_infos.len() as u32,
            bind_infos.as_ptr().cast(),
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBuildAccelerationStructureNV.html>
    #[inline]
    unsafe fn cmd_build_acceleration_structure_nv(
        &self,
        command_buffer: CommandBuffer,
        info: &AccelerationStructureInfoNV,
        instance_data: Buffer,
        instance_offset: DeviceSize,
        update: bool,
        dst: AccelerationStructureNV,
        src: AccelerationStructureNV,
        scratch: Buffer,
        scratch_offset: DeviceSize,
    ) {
        let __result = (self.commands().cmd_build_acceleration_structure_nv)(
            command_buffer,
            info,
            instance_data,
            instance_offset,
            update as Bool32,
            dst,
            src,
            scratch,
            scratch_offset,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyAccelerationStructureNV.html>
    #[inline]
    unsafe fn cmd_copy_acceleration_structure_nv(
        &self,
        command_buffer: CommandBuffer,
        dst: AccelerationStructureNV,
        src: AccelerationStructureNV,
        mode: CopyAccelerationStructureModeKHR,
    ) {
        let __result =
            (self.commands().cmd_copy_acceleration_structure_nv)(command_buffer, dst, src, mode);
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdTraceRaysNV.html>
    #[inline]
    unsafe fn cmd_trace_rays_nv(
        &self,
        command_buffer: CommandBuffer,
        raygen_shader_binding_table_buffer: Buffer,
        raygen_shader_binding_offset: DeviceSize,
        miss_shader_binding_table_buffer: Buffer,
        miss_shader_binding_offset: DeviceSize,
        miss_shader_binding_stride: DeviceSize,
        hit_shader_binding_table_buffer: Buffer,
        hit_shader_binding_offset: DeviceSize,
        hit_shader_binding_stride: DeviceSize,
        callable_shader_binding_table_buffer: Buffer,
        callable_shader_binding_offset: DeviceSize,
        callable_shader_binding_stride: DeviceSize,
        width: u32,
        height: u32,
        depth: u32,
    ) {
        let __result = (self.commands().cmd_trace_rays_nv)(
            command_buffer,
            raygen_shader_binding_table_buffer,
            raygen_shader_binding_offset,
            miss_shader_binding_table_buffer,
            miss_shader_binding_offset,
            miss_shader_binding_stride,
            hit_shader_binding_table_buffer,
            hit_shader_binding_offset,
            hit_shader_binding_stride,
            callable_shader_binding_table_buffer,
            callable_shader_binding_offset,
            callable_shader_binding_stride,
            width,
            height,
            depth,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWriteAccelerationStructuresPropertiesNV.html>
    #[inline]
    unsafe fn cmd_write_acceleration_structures_properties_nv(
        &self,
        command_buffer: CommandBuffer,
        acceleration_structures: &[AccelerationStructureNV],
        query_type: QueryType,
        query_pool: QueryPool,
        first_query: u32,
    ) {
        let __result = (self
            .commands()
            .cmd_write_acceleration_structures_properties_nv)(
            command_buffer,
            acceleration_structures.len() as u32,
            acceleration_structures.as_ptr(),
            query_type,
            query_pool,
            first_query,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCompileDeferredNV.html>
    #[inline]
    unsafe fn compile_deferred_nv(&self, pipeline: Pipeline, shader: u32) -> crate::VkResult<()> {
        let __result = (self.commands().compile_deferred_nv)(self.handle(), pipeline, shader);

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateAccelerationStructureNV.html>
    #[inline]
    unsafe fn create_acceleration_structure_nv(
        &self,
        create_info: &AccelerationStructureCreateInfoNV,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<AccelerationStructureNV> {
        let mut acceleration_structure = MaybeUninit::<AccelerationStructureNV>::uninit();

        let __result = (self.commands().create_acceleration_structure_nv)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            acceleration_structure.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(acceleration_structure.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateRayTracingPipelinesNV.html>
    #[inline]
    unsafe fn create_ray_tracing_pipelines_nv(
        &self,
        pipeline_cache: PipelineCache,
        create_infos: &[impl Cast<Target = RayTracingPipelineCreateInfoNV>],
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkSuccessResult<Vec<Pipeline>> {
        let mut pipelines = Vec::with_capacity(create_infos.len() as usize);

        let __result = (self.commands().create_ray_tracing_pipelines_nv)(
            self.handle(),
            pipeline_cache,
            create_infos.len() as u32,
            create_infos.as_ptr().cast(),
            allocator.map_or(ptr::null(), |v| v),
            pipelines.as_mut_ptr(),
        );

        pipelines.set_len(create_infos.len() as usize);

        if __result >= Result::SUCCESS {
            Ok((pipelines, __result.into()))
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyAccelerationStructureNV.html>
    #[inline]
    unsafe fn destroy_acceleration_structure_nv(
        &self,
        acceleration_structure: AccelerationStructureNV,
        allocator: Option<&AllocationCallbacks>,
    ) {
        let __result = (self.commands().destroy_acceleration_structure_nv)(
            self.handle(),
            acceleration_structure,
            allocator.map_or(ptr::null(), |v| v),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetAccelerationStructureHandleNV.html>
    #[inline]
    unsafe fn get_acceleration_structure_handle_nv(
        &self,
        acceleration_structure: AccelerationStructureNV,
        data: &mut [u8],
    ) -> crate::VkResult<()> {
        let __result = (self.commands().get_acceleration_structure_handle_nv)(
            self.handle(),
            acceleration_structure,
            data.len() as usize,
            data.as_ptr() as *mut c_void,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetAccelerationStructureMemoryRequirementsNV.html>
    #[inline]
    unsafe fn get_acceleration_structure_memory_requirements_nv(
        &self,
        info: &AccelerationStructureMemoryRequirementsInfoNV,
    ) -> MemoryRequirements2KHR {
        let mut memory_requirements = MaybeUninit::<MemoryRequirements2KHR>::uninit();

        let __result = (self
            .commands()
            .get_acceleration_structure_memory_requirements_nv)(
            self.handle(),
            info,
            memory_requirements.as_mut_ptr(),
        );

        memory_requirements.assume_init()
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetRayTracingShaderGroupHandlesNV.html>
    #[inline]
    unsafe fn get_ray_tracing_shader_group_handles_nv(
        &self,
        pipeline: Pipeline,
        first_group: u32,
        group_count: u32,
        data: &mut [u8],
    ) -> crate::VkResult<()> {
        let __result = (self.commands().get_ray_tracing_shader_group_handles_nv)(
            self.handle(),
            pipeline,
            first_group,
            group_count,
            data.len() as usize,
            data.as_ptr() as *mut c_void,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

#[allow(deprecated)]
impl NvRayTracingExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_ray_tracing_invocation_reorder.html>
pub trait NvRayTracingInvocationReorderExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_RAY_TRACING_INVOCATION_REORDER_EXTENSION;
}

impl NvRayTracingInvocationReorderExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_ray_tracing_motion_blur.html>
pub trait NvRayTracingMotionBlurExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_RAY_TRACING_MOTION_BLUR_EXTENSION;
}

impl NvRayTracingMotionBlurExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_ray_tracing_validation.html>
pub trait NvRayTracingValidationExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_RAY_TRACING_VALIDATION_EXTENSION;
}

impl NvRayTracingValidationExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_representative_fragment_test.html>
pub trait NvRepresentativeFragmentTestExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION;
}

impl NvRepresentativeFragmentTestExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_sample_mask_override_coverage.html>
pub trait NvSampleMaskOverrideCoverageExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION;
}

impl NvSampleMaskOverrideCoverageExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_scissor_exclusive.html>
pub trait NvScissorExclusiveExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_SCISSOR_EXCLUSIVE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetExclusiveScissorEnableNV.html>
    #[inline]
    unsafe fn cmd_set_exclusive_scissor_enable_nv(
        &self,
        command_buffer: CommandBuffer,
        first_exclusive_scissor: u32,
        exclusive_scissor_enables: &[Bool32],
    ) {
        let __result = (self.commands().cmd_set_exclusive_scissor_enable_nv)(
            command_buffer,
            first_exclusive_scissor,
            exclusive_scissor_enables.len() as u32,
            exclusive_scissor_enables.as_ptr(),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetExclusiveScissorNV.html>
    #[inline]
    unsafe fn cmd_set_exclusive_scissor_nv(
        &self,
        command_buffer: CommandBuffer,
        first_exclusive_scissor: u32,
        exclusive_scissors: &[impl Cast<Target = Rect2D>],
    ) {
        let __result = (self.commands().cmd_set_exclusive_scissor_nv)(
            command_buffer,
            first_exclusive_scissor,
            exclusive_scissors.len() as u32,
            exclusive_scissors.as_ptr().cast(),
        );
    }
}

impl NvScissorExclusiveExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_shader_atomic_float16_vector.html>
pub trait NvShaderAtomicFloat16VectorExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_SHADER_ATOMIC_FLOAT16_VECTOR_EXTENSION;
}

impl NvShaderAtomicFloat16VectorExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_shader_image_footprint.html>
pub trait NvShaderImageFootprintExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_SHADER_IMAGE_FOOTPRINT_EXTENSION;
}

impl NvShaderImageFootprintExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_shader_sm_builtins.html>
pub trait NvShaderSmBuiltinsExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_SHADER_SM_BUILTINS_EXTENSION;
}

impl NvShaderSmBuiltinsExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_shader_subgroup_partitioned.html>
pub trait NvShaderSubgroupPartitionedExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION;
}

impl NvShaderSubgroupPartitionedExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_shading_rate_image.html>
pub trait NvShadingRateImageExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_SHADING_RATE_IMAGE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindShadingRateImageNV.html>
    #[inline]
    unsafe fn cmd_bind_shading_rate_image_nv(
        &self,
        command_buffer: CommandBuffer,
        image_view: ImageView,
        image_layout: ImageLayout,
    ) {
        let __result = (self.commands().cmd_bind_shading_rate_image_nv)(
            command_buffer,
            image_view,
            image_layout,
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoarseSampleOrderNV.html>
    #[inline]
    unsafe fn cmd_set_coarse_sample_order_nv(
        &self,
        command_buffer: CommandBuffer,
        sample_order_type: CoarseSampleOrderTypeNV,
        custom_sample_orders: &[impl Cast<Target = CoarseSampleOrderCustomNV>],
    ) {
        let __result = (self.commands().cmd_set_coarse_sample_order_nv)(
            command_buffer,
            sample_order_type,
            custom_sample_orders.len() as u32,
            custom_sample_orders.as_ptr().cast(),
        );
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewportShadingRatePaletteNV.html>
    #[inline]
    unsafe fn cmd_set_viewport_shading_rate_palette_nv(
        &self,
        command_buffer: CommandBuffer,
        first_viewport: u32,
        shading_rate_palettes: &[impl Cast<Target = ShadingRatePaletteNV>],
    ) {
        let __result = (self.commands().cmd_set_viewport_shading_rate_palette_nv)(
            command_buffer,
            first_viewport,
            shading_rate_palettes.len() as u32,
            shading_rate_palettes.as_ptr().cast(),
        );
    }
}

impl NvShadingRateImageExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_viewport_array2.html>
pub trait NvViewportArray2Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_VIEWPORT_ARRAY2_EXTENSION;
}

impl NvViewportArray2Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_viewport_swizzle.html>
pub trait NvViewportSwizzleExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_VIEWPORT_SWIZZLE_EXTENSION;
}

impl NvViewportSwizzleExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_NV_win32_keyed_mutex.html>
pub trait NvWin32KeyedMutexExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = NV_WIN32_KEYED_MUTEX_EXTENSION;
}

impl NvWin32KeyedMutexExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_QCOM_filter_cubic_clamp.html>
pub trait QcomFilterCubicClampExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = QCOM_FILTER_CUBIC_CLAMP_EXTENSION;
}

impl QcomFilterCubicClampExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_QCOM_filter_cubic_weights.html>
pub trait QcomFilterCubicWeightsExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = QCOM_FILTER_CUBIC_WEIGHTS_EXTENSION;
}

impl QcomFilterCubicWeightsExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_QCOM_fragment_density_map_offset.html>
pub trait QcomFragmentDensityMapOffsetExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = QCOM_FRAGMENT_DENSITY_MAP_OFFSET_EXTENSION;
}

impl QcomFragmentDensityMapOffsetExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_QCOM_image_processing.html>
pub trait QcomImageProcessingExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = QCOM_IMAGE_PROCESSING_EXTENSION;
}

impl QcomImageProcessingExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_QCOM_image_processing2.html>
pub trait QcomImageProcessing2Extension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = QCOM_IMAGE_PROCESSING2_EXTENSION;
}

impl QcomImageProcessing2Extension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_QCOM_multiview_per_view_render_areas.html>
pub trait QcomMultiviewPerViewRenderAreasExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = QCOM_MULTIVIEW_PER_VIEW_RENDER_AREAS_EXTENSION;
}

impl QcomMultiviewPerViewRenderAreasExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_QCOM_multiview_per_view_viewports.html>
pub trait QcomMultiviewPerViewViewportsExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = QCOM_MULTIVIEW_PER_VIEW_VIEWPORTS_EXTENSION;
}

impl QcomMultiviewPerViewViewportsExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_QCOM_render_pass_shader_resolve.html>
pub trait QcomRenderPassShaderResolveExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = QCOM_RENDER_PASS_SHADER_RESOLVE_EXTENSION;
}

impl QcomRenderPassShaderResolveExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_QCOM_render_pass_store_ops.html>
pub trait QcomRenderPassStoreOpsExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = QCOM_RENDER_PASS_STORE_OPS_EXTENSION;
}

impl QcomRenderPassStoreOpsExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_QCOM_render_pass_transform.html>
pub trait QcomRenderPassTransformExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = QCOM_RENDER_PASS_TRANSFORM_EXTENSION;
}

impl QcomRenderPassTransformExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_QCOM_rotated_copy_commands.html>
pub trait QcomRotatedCopyCommandsExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = QCOM_ROTATED_COPY_COMMANDS_EXTENSION;
}

impl QcomRotatedCopyCommandsExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_QCOM_tile_properties.html>
pub trait QcomTilePropertiesExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = QCOM_TILE_PROPERTIES_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDynamicRenderingTilePropertiesQCOM.html>
    #[inline]
    unsafe fn get_dynamic_rendering_tile_properties_qcom(
        &self,
        rendering_info: &RenderingInfo,
        properties: &mut TilePropertiesQCOM,
    ) -> crate::VkResult<()> {
        let __result = (self.commands().get_dynamic_rendering_tile_properties_qcom)(
            self.handle(),
            rendering_info,
            properties,
        );

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetFramebufferTilePropertiesQCOM.html>
    #[inline]
    unsafe fn get_framebuffer_tile_properties_qcom(
        &self,
        framebuffer: Framebuffer,
    ) -> crate::VkResult<Vec<TilePropertiesQCOM>> {
        let mut properties_count = 0;

        (self.commands().get_framebuffer_tile_properties_qcom)(
            self.handle(),
            framebuffer,
            &mut properties_count,
            ptr::null_mut(),
        );

        let mut properties = Vec::with_capacity(properties_count as usize);

        let __result = (self.commands().get_framebuffer_tile_properties_qcom)(
            self.handle(),
            framebuffer,
            &mut properties_count,
            properties.as_mut_ptr(),
        );

        debug_assert!(properties.capacity() == properties_count as usize);
        properties.set_len(properties_count as usize);

        if __result == Result::SUCCESS {
            Ok(properties)
        } else {
            Err(__result.into())
        }
    }
}

impl QcomTilePropertiesExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_QCOM_ycbcr_degamma.html>
pub trait QcomYcbcrDegammaExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = QCOM_YCBCR_DEGAMMA_EXTENSION;
}

impl QcomYcbcrDegammaExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_QNX_external_memory_screen_buffer.html>
pub trait QnxExternalMemoryScreenBufferExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = QNX_EXTERNAL_MEMORY_SCREEN_BUFFER_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetScreenBufferPropertiesQNX.html>
    #[inline]
    unsafe fn get_screen_buffer_properties_qnx(
        &self,
        buffer: &_screen_buffer,
        properties: &mut ScreenBufferPropertiesQNX,
    ) -> crate::VkResult<()> {
        let __result =
            (self.commands().get_screen_buffer_properties_qnx)(self.handle(), buffer, properties);

        if __result == Result::SUCCESS {
            Ok(())
        } else {
            Err(__result.into())
        }
    }
}

impl QnxExternalMemoryScreenBufferExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_QNX_screen_surface.html>
pub trait QnxScreenSurfaceExtension: InstanceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = QNX_SCREEN_SURFACE_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateScreenSurfaceQNX.html>
    #[inline]
    unsafe fn create_screen_surface_qnx(
        &self,
        create_info: &ScreenSurfaceCreateInfoQNX,
        allocator: Option<&AllocationCallbacks>,
    ) -> crate::VkResult<SurfaceKHR> {
        let mut surface = MaybeUninit::<SurfaceKHR>::uninit();

        let __result = (self.commands().create_screen_surface_qnx)(
            self.handle(),
            create_info,
            allocator.map_or(ptr::null(), |v| v),
            surface.as_mut_ptr(),
        );

        if __result == Result::SUCCESS {
            Ok(surface.assume_init())
        } else {
            Err(__result.into())
        }
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceScreenPresentationSupportQNX.html>
    #[inline]
    unsafe fn get_physical_device_screen_presentation_support_qnx(
        &self,
        physical_device: PhysicalDevice,
        queue_family_index: u32,
        window: *mut _screen_window,
    ) -> Bool32 {
        let __result = (self
            .commands()
            .get_physical_device_screen_presentation_support_qnx)(
            physical_device,
            queue_family_index,
            window,
        );

        __result
    }
}

impl QnxScreenSurfaceExtension for crate::Instance {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_SEC_amigo_profiling.html>
pub trait SecAmigoProfilingExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = SEC_AMIGO_PROFILING_EXTENSION;
}

impl SecAmigoProfilingExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_VALVE_descriptor_set_host_mapping.html>
pub trait ValveDescriptorSetHostMappingExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = VALVE_DESCRIPTOR_SET_HOST_MAPPING_EXTENSION;

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDescriptorSetHostMappingVALVE.html>
    #[inline]
    unsafe fn get_descriptor_set_host_mapping_valve(
        &self,
        descriptor_set: DescriptorSet,
    ) -> *mut c_void {
        let mut data = MaybeUninit::<*mut c_void>::uninit();

        let __result = (self.commands().get_descriptor_set_host_mapping_valve)(
            self.handle(),
            descriptor_set,
            data.as_mut_ptr(),
        );

        data.assume_init()
    }

    /// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDescriptorSetLayoutHostMappingInfoVALVE.html>
    #[inline]
    unsafe fn get_descriptor_set_layout_host_mapping_info_valve(
        &self,
        binding_reference: &DescriptorSetBindingReferenceVALVE,
        host_mapping: &mut DescriptorSetLayoutHostMappingInfoVALVE,
    ) {
        let __result = (self
            .commands()
            .get_descriptor_set_layout_host_mapping_info_valve)(
            self.handle(),
            binding_reference,
            host_mapping,
        );
    }
}

impl ValveDescriptorSetHostMappingExtension for crate::Device {}

/// <https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VK_VALVE_mutable_descriptor_type.html>
pub trait ValveMutableDescriptorTypeExtension: DeviceV1_0 {
    /// The metadata for this extension.
    #[allow(deprecated)]
    const METADATA: Extension = VALVE_MUTABLE_DESCRIPTOR_TYPE_EXTENSION;
}

impl ValveMutableDescriptorTypeExtension for crate::Device {}
